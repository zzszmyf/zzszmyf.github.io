{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u897f\u5c71\u4e0b,\u95fb\u6eaa\u8bed,\u4e66\u5fc3\u5883 \u00b6 E = MC^2 E = MC^2 E = MC \\sum A E = MC \\sum A","title":"\u9996\u9875"},{"location":"#_1","text":"E = MC^2 E = MC^2 E = MC \\sum A E = MC \\sum A","title":"\u897f\u5c71\u4e0b,\u95fb\u6eaa\u8bed,\u4e66\u5fc3\u5883"},{"location":"about/","text":"\u672c\u4eba \u00b6 \u5165\u95e8\u673a\u5668\u5b66\u4e60\u548c\u6df1\u5ea6\u5b66\u4e60\u4e2d \u5728\u67d0\u5c0f\u516c\u53f8\u5e7f\u544a\u7b97\u6cd5\u56e2\u961f\u4e2d\u6253\u6742 \u70ed\u7231\u6280\u672f\u7814\u7a76\u548c\u843d\u5730 \u90ae\u7bb1: zzszmyf@outlook.com","title":"About"},{"location":"about/#_1","text":"\u5165\u95e8\u673a\u5668\u5b66\u4e60\u548c\u6df1\u5ea6\u5b66\u4e60\u4e2d \u5728\u67d0\u5c0f\u516c\u53f8\u5e7f\u544a\u7b97\u6cd5\u56e2\u961f\u4e2d\u6253\u6742 \u70ed\u7231\u6280\u672f\u7814\u7a76\u548c\u843d\u5730 \u90ae\u7bb1: zzszmyf@outlook.com","title":"\u672c\u4eba"},{"location":"crypto/ctf-wiki/introduction-zh/","text":"EN | ZH \u5bc6\u7801\u5b66\uff08Cryptography\uff09\u4e00\u822c\u53ef\u5206\u4e3a\u53e4\u5178\u5bc6\u7801\u5b66\u548c\u73b0\u4ee3\u5bc6\u7801\u5b66\u3002 \u5176\u4e2d\uff0c\u53e4\u5178\u5bc6\u7801\u5b66\uff0c\u4f5c\u4e3a\u4e00\u79cd\u5b9e\u7528\u6027\u827a\u672f\u5b58\u5728\uff0c\u5176\u7f16\u7801\u548c\u7834\u8bd1\u901a\u5e38\u4f9d\u8d56\u4e8e\u8bbe\u8ba1\u8005\u548c\u654c\u624b\u7684\u521b\u9020\u529b\u4e0e\u6280\u5de7\uff0c\u5e76\u6ca1\u6709\u5bf9\u5bc6\u7801\u5b66\u539f\u4ef6\u8fdb\u884c\u6e05\u6670\u7684\u5b9a\u4e49\u3002\u53e4\u5178\u5bc6\u7801\u5b66\u4e3b\u8981\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u65b9\u9762\uff1a \u5355\u8868\u66ff\u6362\u52a0\u5bc6\uff08Monoalphabetic Cipher\uff09 \u591a\u8868\u66ff\u6362\u52a0\u5bc6\uff08Polyalphabetic Cipher\uff09 \u5947\u5947\u602a\u602a\u7684\u52a0\u5bc6\u65b9\u5f0f \u800c\u73b0\u4ee3\u5bc6\u7801\u5b66\u5219\u8d77\u6e90\u4e8e 20 \u4e16\u7eaa\u4e2d\u540e\u671f\u51fa\u73b0\u7684\u5927\u91cf\u76f8\u5173\u7406\u8bba\uff0c1949 \u5e74\u9999\u519c\uff08C. E. Shannon\uff09\u53d1\u8868\u4e86\u9898\u4e3a\u300a\u4fdd\u5bc6\u7cfb\u7edf\u7684\u901a\u4fe1\u7406\u8bba\u300b\u7684\u7ecf\u5178\u8bba\u6587\u6807\u5fd7\u7740\u73b0\u4ee3\u5bc6\u7801\u5b66\u7684\u5f00\u59cb\u3002\u73b0\u4ee3\u5bc6\u7801\u5b66\u4e3b\u8981\u5305\u542b\u4ee5\u4e0b\u51e0\u4e2a\u65b9\u9762\uff1a \u5bf9\u79f0\u52a0\u5bc6\uff08Symmetric Cryptography\uff09\uff0c\u4ee5 DES\uff0cAES\uff0cRC4 \u4e3a\u4ee3\u8868\u3002 \u975e\u5bf9\u79f0\u52a0\u5bc6\uff08Asymmetric Cryptography\uff09\uff0c\u4ee5 RSA\uff0cElGamal\uff0c\u692d\u5706\u66f2\u7ebf\u52a0\u5bc6\u4e3a\u4ee3\u8868\u3002 \u54c8\u5e0c\u51fd\u6570\uff08Hash Function\uff09\uff0c\u4ee5 MD5\uff0cSHA-1\uff0cSHA-512 \u7b49\u4e3a\u4ee3\u8868\u3002 \u6570\u5b57\u7b7e\u540d\uff08Digital Signature\uff09\uff0c\u4ee5 RSA \u7b7e\u540d\uff0cElGamal \u7b7e\u540d\uff0cDSA \u7b7e\u540d\u4e3a\u4ee3\u8868\u3002 \u5176\u4e2d\uff0c\u5bf9\u79f0\u52a0\u5bc6\u4f53\u5236\u4e3b\u8981\u5206\u4e3a\u4e24\u79cd\u65b9\u5f0f\uff1a \u5206\u7ec4\u5bc6\u7801\uff08Block Cipher\uff09\uff0c\u53c8\u79f0\u4e3a\u5757\u5bc6\u7801\u3002 \u5e8f\u5217\u5bc6\u7801\uff08Stream Cipher\uff09\uff0c\u53c8\u79f0\u4e3a\u6d41\u5bc6\u7801\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u5bc6\u7801\u8bbe\u8ba1\u8005\u7684\u6839\u672c\u76ee\u6807\u662f\u4fdd\u969c\u4fe1\u606f\u53ca\u4fe1\u606f\u7cfb\u7edf\u7684 \u673a\u5bc6\u6027\uff08Confidentiality\uff09 \u5b8c\u6574\u6027\uff08Integrity\uff09 \u53ef\u7528\u6027\uff08Availability\uff09 \u8ba4\u8bc1\u6027\uff08Authentication\uff09 \u4e0d\u53ef\u5426\u8ba4\u6027\uff08Non-repudiation\uff09 \u5176\u4e2d\uff0c\u524d\u4e09\u8005\u88ab\u79f0\u4e3a\u4fe1\u606f\u5b89\u5168\u7684 CIA \u4e09\u8981\u7d20 \u3002 \u800c\u5bf9\u4e8e\u5bc6\u7801\u7834\u89e3\u8005\u6765\u8bf4\uff0c\u4e00\u822c\u662f\u8981\u60f3\u529e\u6cd5\u8bc6\u522b\u51fa\u5bc6\u7801\u7b97\u6cd5\uff0c\u7136\u540e\u8fdb\u884c\u66b4\u529b\u7834\u89e3\uff0c\u6216\u8005\u5229\u7528\u5bc6\u7801\u4f53\u5236\u7684\u6f0f\u6d1e\u8fdb\u884c\u7834\u89e3\u3002\u5f53\u7136\uff0c\u4e5f\u6709\u53ef\u80fd\u901a\u8fc7\u6784\u9020\u865a\u5047\u7684\u54c8\u5e0c\u503c\u6216\u8005\u6570\u5b57\u7b7e\u540d\u6765\u7ed5\u8fc7\u76f8\u5e94\u7684\u68c0\u6d4b\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u90fd\u4f1a\u5047\u8bbe\u653b\u51fb\u8005\u5df2\u77e5\u5f85\u7834\u89e3\u7684\u5bc6\u7801\u4f53\u5236\uff0c\u800c\u653b\u51fb\u7c7b\u578b\u901a\u5e38\u5206\u4e3a\u4ee5\u4e0b\u56db\u79cd\uff1a \u653b\u51fb\u7c7b\u578b \u8bf4\u660e \u552f\u5bc6\u6587\u653b\u51fb \u53ea\u62e5\u6709\u5bc6\u6587 \u5df2\u77e5\u660e\u6587\u653b\u51fb \u62e5\u6709\u5bc6\u6587\u4e0e\u5bf9\u5e94\u7684\u660e\u6587 \u9009\u62e9\u660e\u6587\u653b\u51fb \u62e5\u6709\u52a0\u5bc6\u6743\u9650\uff0c\u80fd\u591f\u5bf9\u660e\u6587\u52a0\u5bc6\u540e\u83b7\u5f97\u76f8\u5e94\u5bc6\u6587 \u9009\u62e9\u5bc6\u6587\u653b\u51fb \u62e5\u6709\u89e3\u5bc6\u6743\u9650\uff0c\u80fd\u591f\u5bf9\u5bc6\u6587\u89e3\u5bc6\u540e\u83b7\u5f97\u76f8\u5e94\u660e\u6587 Note \u6ce8\uff1a\u4e4b\u524d\u5728\u8fd9\u91cc\u66fe\u5199\u8fc7\u8fd9\u4e9b\u653b\u51fb\u5e38\u89c1\u7684\u573a\u666f\uff0c\u968f\u7740\u4e0d\u65ad\u5730\u5b66\u4e60\uff0c\u6e10\u6e10\u610f\u8bc6\u5230\u8fd9\u4e9b\u653b\u51fb\u7c7b\u578b\u4fa7\u91cd\u63cf\u8ff0\u653b\u51fb\u8005\u7684\u80fd\u529b\uff0c\u6709\u53ef\u80fd\u9002\u7528\u4e8e\u5404\u79cd\u5404\u6837\u7684\u573a\u666f\u3002\u6545\u8fdb\u884c\u4fee\u6b63\u3002 \u8fd9\u91cc\u63a8\u8350\u4e00\u4e9b\u8d44\u6599 \u53ef\u6c57\u5b66\u9662\u516c\u5f00\u8bfe \u6df1\u5165\u6d45\u51fa\u5bc6\u7801\u5b66\u2014\u2014\u5e38\u7528\u52a0\u5bc6\u6280\u672f\u539f\u7406\u4e0e\u5e94\u7528 https://cryptopals.com/ \uff0c\u4e00\u5806\u5bc6\u7801\u5b66\u7684\u7ec3\u4e60\u9898\u76ee\u3002 Note \u63a8\u8350\u5728\u770b\u5b8c\u516c\u5f00\u8bfe\u7684\u60c5\u51b5\u4e0b\uff0c\u4ee5\u53ca\u7b80\u5355\u770b\u770b\u7535\u5b50\u4e66\u7684\u60c5\u51b5\u4e0b\u5728\u8003\u8651\u662f\u5426\u8981\u8d2d\u4e70\u4e66\uff0c\u56e0\u4e3a\u4e66\u4e70\u56de\u6765\u4e00\u822c\u90fd\u88ab\u95f2\u7f6e\u8d77\u6765\u4e86\u3002 \u53c2\u8003 \u00b6 \u7ef4\u57fa\u767e\u79d1-\u5bc6\u7801\u5b66 Info \u672c\u8282\u5927\u90e8\u5206\u5b9a\u4e49\u4e0e\u4f8b\u5b50\u53c2\u8003\u4e86\u7ef4\u57fa\u767e\u79d1\u3002","title":"Introduction zh"},{"location":"crypto/ctf-wiki/introduction-zh/#_1","text":"\u7ef4\u57fa\u767e\u79d1-\u5bc6\u7801\u5b66 Info \u672c\u8282\u5927\u90e8\u5206\u5b9a\u4e49\u4e0e\u4f8b\u5b50\u53c2\u8003\u4e86\u7ef4\u57fa\u767e\u79d1\u3002","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/introduction/","text":"EN | ZH Cryptography can generally be divided into classical cryptography and modern cryptography. Among them, classical cryptography, as a practical art, its coding and deciphering usually depends on the creativity and skill of designers and adversaries, and does not clearly define the original cryptography. Classical cryptography mainly includes the following aspects: Monoalphabetic Cipher Polyalphabetic Cipher Strange encryption Modern cryptography originated from a large number of related theories in the middle and late 20 th century. In 1949, Shan Shan published a classic paper entitled \"Communication Theory of Security Systems\", marking the beginning of modern cryptography. Modern cryptography mainly includes the following aspects: Symmetric Cryptography, represented by DES, AES, and RC4. Asymmetric Cryptography, represented by RSA, ElGamal, elliptic curve encryption. Hash function, represented by MD5, SHA-1, SHA-512, etc. Digital Signature, represented by RSA signature, ElGamal signature, and DSA signature. Among them, the symmetric encryption system is mainly divided into two ways: Block Cipher, also known as block cipher. Stream Cipher, also known as stream cipher. In general, the fundamental goal of password designers is to protect information and information systems. Confidentiality (Confidentiality) Integrity Availability Authentication Non-repudiation Among them, the first three are called the three elements of CIA for information security. For password crackers, it is generally necessary to find a way to identify the cryptographic algorithm, and then brute force, or use the cryptosystem vulnerability to crack. Of course, it is also possible to bypass the corresponding detection by constructing a false hash value or a digital signature. In general, we will assume that the attacker knows the cryptosystem to be cracked, and the attack types are usually divided into the following four types: Attack Type Description | ciphertext attack | only has ciphertext | | Known plaintext attack | Have ciphertext and corresponding plaintext | | Select plaintext attack | Have encryption permission, can encrypt the plaintext and get the corresponding ciphertext| | Select ciphertext attack | Have decryption permission, can decrypt the ciphertext and get the corresponding plaintext | Note Note: I have previously written about the common scenarios of these attacks. As I continue to learn, I gradually realize that these types of attacks focus on describing the capabilities of attackers and may be applicable to a wide variety of scenarios. Therefore, the amendment was made. Recommend some information here [Khan Academy Open Class] ( http://open.163.com/special/Khan/moderncryptography.html ) [In-depth cryptography - Principles and Applications of Common Encryption Technologies] ( https://github.com/yuankeyang/python/blob/master/%E3%80%8A%E6%B7%B1%E5%85%A5 % E6%B5%85%E5%87%BA%E5%AF%86%E7%A0%81%E5%AD%A6%E2%80%94%E2%80%94%E5%B8%B8%E7% 94%A8%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA% 94%E7%94%A8%E3%80%8B.pdf) https://cryptopals.com/ , a bunch of cryptography exercises. Note It is recommended to consider whether to buy a book in the case of reading the open class and simply looking at the e-book, because the book is usually left unused. Reference \u00b6 [Wikipedia-Cryptography] ( https://en.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6 ) Info Most of the definitions and examples in this section refer to Wikipedia.","title":"\u5bc6\u7801\u5b66\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/introduction/#reference","text":"[Wikipedia-Cryptography] ( https://en.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6 ) Info Most of the definitions and examples in this section refer to Wikipedia.","title":"Reference"},{"location":"crypto/ctf-wiki/asymmetric/introduction-zh/","text":"EN | ZH \u4ecb\u7ecd \u00b6 \u5728\u975e\u5bf9\u79f0\u5bc6\u7801\u4e2d\uff0c\u52a0\u5bc6\u8005\u4e0e\u89e3\u5bc6\u8005\u6240\u4f7f\u7528\u7684\u5bc6\u94a5\u5e76\u4e0d\u4e00\u6837\uff0c\u5178\u578b\u7684\u6709 RSA \u52a0\u5bc6\uff0c\u80cc\u5305\u52a0\u5bc6\uff0c\u692d\u5706\u66f2\u7ebf\u52a0\u5bc6\u3002","title":"Introduction zh"},{"location":"crypto/ctf-wiki/asymmetric/introduction-zh/#_1","text":"\u5728\u975e\u5bf9\u79f0\u5bc6\u7801\u4e2d\uff0c\u52a0\u5bc6\u8005\u4e0e\u89e3\u5bc6\u8005\u6240\u4f7f\u7528\u7684\u5bc6\u94a5\u5e76\u4e0d\u4e00\u6837\uff0c\u5178\u578b\u7684\u6709 RSA \u52a0\u5bc6\uff0c\u80cc\u5305\u52a0\u5bc6\uff0c\u692d\u5706\u66f2\u7ebf\u52a0\u5bc6\u3002","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/asymmetric/introduction/","text":"EN | ZH Introduction \u00b6 In asymmetric cryptography, the keys used by the encryptor and the decrypter are different. Typical examples are RSA encryption, knapsack encryption, and elliptic curve encryption.","title":"\u975e\u5bf9\u79f0\u52a0\u5bc6\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/asymmetric/introduction/#introduction","text":"In asymmetric cryptography, the keys used by the encryptor and the decrypter are different. Typical examples are RSA encryption, knapsack encryption, and elliptic curve encryption.","title":"Introduction"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/","text":"EN | ZH \u79bb\u6563\u5bf9\u6570 \u00b6 \u57fa\u672c\u5b9a\u4e49 \u00b6 \u5728\u4e86\u89e3\u79bb\u6563\u5bf9\u6570\u65f6\uff0c\u6211\u4eec\u5148\u6765\u4e86\u89e3\u51e0\u4e2a\u57fa\u672c\u5b9a\u4e49\u3002 \u5b9a\u4e491 \u5728\u7fa4 G \u4e2d\uff0cg \u4e3a G \u7684\u751f\u6210\u5143\uff0c\u4e5f\u5c31\u662f\u8bf4\u7fa4 G \u4e2d\u6bcf\u4e00\u4e2a\u5143\u7d20\u90fd\u53ef\u4ee5\u5199\u6210 y=g^k y=g^k \uff0c\u6211\u4eec\u79f0 k \u4e3a y \u5728\u7fa4 G \u4e2d\u7684\u5bf9\u6570\u3002 \u5b9a\u4e492 \u8bbe m\\geq 1 m\\geq 1 \uff0c (a,m)=1 (a,m)=1 \uff0c\u4f7f\u5f97 a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m \u6210\u7acb\u7684\u6700\u5c0f\u6b63\u6574\u6570 d \u79f0\u4e3a a \u5bf9\u6a21 m \u7684\u6307\u6570\u6216\u8005\u9636\uff0c\u6211\u4eec\u4e00\u822c\u5c06\u5176\u8bb0\u4e3a \\delta_m(a) \\delta_m(a) \u3002 \u5b9a\u4e493 \u5f53 \\delta_m(a)=\\varphi(m) \\delta_m(a)=\\varphi(m) \u65f6\uff0c\u79f0 a \u662f\u6a21 m \u7684\u539f\u6839\uff0c\u7b80\u79f0 m \u7684\u539f\u6839\u3002 \u4e00\u4e9b\u6027\u8d28 \u00b6 \u6027\u8d281 \u4f7f\u5f97 a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m \u6210\u7acb\u7684\u6700\u5c0f\u6b63\u6574\u6570 d d \uff0c\u5fc5\u6709 d\\mid\\varphi(m) d\\mid\\varphi(m) \u3002 \u6027\u8d282 \u6a21 m m \u5269\u4f59\u7cfb\u5b58\u5728\u539f\u6839\u7684\u5145\u8981\u6761\u4ef6\u662f m=2,4,p^{\\alpha},2p^{\\alpha} m=2,4,p^{\\alpha},2p^{\\alpha} \uff0c\u5176\u4e2d p p \u4e3a\u5947\u7d20\u6570\uff0c \\alpha \\alpha \u4e3a\u6b63\u6574\u6570\u3002 \u79bb\u6563\u5bf9\u6570\u95ee\u9898 \u00b6 \u5df2\u77e5 g,p,y g,p,y \uff0c\u5bf9\u4e8e\u65b9\u7a0b y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p \uff0c\u6c42\u89e3 x x \u662f\u4e00\u4e2a\u96be\u89e3\u95ee\u9898\u3002\u4f46\u662f\u5f53 p p \u5177\u6709\u4e00\u5b9a\u7684\u7279\u6027\u65f6\u5c31\u53ef\u80fd\u53ef\u4ee5\u6c42\u89e3\uff0c\u6bd4\u5982\uff0c\u8fd9\u4e2a\u7fa4\u7684\u9636\u662f\u4e00\u4e2a\u5149\u6ed1\u6570\u3002 \u6b63\u662f\u4e0a\u8ff0\u8fd9\u4e2a\u95ee\u9898\u6784\u6210\u4e86\u76ee\u524d\u5f88\u5927\u4e00\u90e8\u5206\u73b0\u4ee3\u5bc6\u7801\u5b66\uff0c\u5305\u62ec Diffie\u2013Hellman \u5bc6\u94a5\u4ea4\u6362\uff0c ElGamal \u7b97\u6cd5\uff0cECC \u7b49\u3002 \u79bb\u6563\u5bf9\u6570\u6c42\u89e3\u65b9\u5f0f \u00b6 \u66b4\u529b\u7834\u89e3 \u00b6 \u7ed9\u5b9a y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p \uff0c\u6211\u4eec\u53ef\u4ee5\u66b4\u529b\u679a\u4e3e x x \u4ece\u800c\u5f97\u5230\u771f\u6b63\u7684 x x \u7684\u503c\u3002 Baby-step giant-step \u00b6 \u8fd9\u4e00\u65b9\u6cd5\u901a\u5e38\u88ab\u79f0\u4e3a\u5c0f\u6b65\u5927\u6b65\u6cd5\uff0c\u8fd9\u4e00\u65b9\u6cd5\u4f7f\u7528\u4e86\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\u7684\u601d\u60f3\u3002 \u6211\u4eec\u53ef\u4ee5\u4ee4 x=im+j x=im+j \uff0c\u5176\u4e2d m= \\lceil \\sqrt n\\rceil m= \\lceil \\sqrt n\\rceil \uff0c\u90a3\u4e48\u6574\u6570 i \u548c j \u90fd\u5728 0 \u5230 m \u7684\u8303\u56f4\u5185\u3002 \u56e0\u6b64 y=g^x=g^{im+j} y=g^x=g^{im+j} \u4e5f\u5c31\u662f y(g^{-m})^i=g^j y(g^{-m})^i=g^j \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u7684 j \u5e76\u8fdb\u884c\u8ba1\u7b97\uff0c\u5e76\u5c06\u5176\u5b58\u50a8\u5230\u4e00\u4e2a\u96c6\u5408 S \u4e2d\uff0c\u7136\u540e\u6211\u4eec\u518d\u6b21\u679a\u4e3e i\uff0c\u8ba1\u7b97 y(g^{-m})^i y(g^{-m})^i \uff0c\u4e00\u65e6\u6211\u4eec\u53d1\u73b0\u8ba1\u7b97\u7684\u7ed3\u679c\u5728\u96c6\u5408 S \u4e2d\uff0c\u5219\u8bf4\u660e\u6211\u4eec\u5f97\u5230\u4e86\u4e00\u4e2a\u78b0\u649e\uff0c\u8fdb\u800c\u5f97\u5230\u4e86 i \u548c j\u3002 \u8fd9\u663e\u7136\u662f\u4e00\u4e2a\u65f6\u95f4\u4e0e\u7a7a\u95f4\u7684\u6298\u4e2d\u7684\u65b9\u5f0f\uff0c\u6211\u4eec\u5c06\u4e00\u4e2a O(n) O(n) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c O(1) O(1) \u7a7a\u95f4\u590d\u6742\u5ea6\u7684\u7b97\u6cd5\u8f6c\u6362\u4e3a\u4e86\u4e00\u4e2a O(\\sqrt n) O(\\sqrt n) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u548c O(\\sqrt n) O(\\sqrt n) \u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u7684\u7b97\u6cd5\u3002 \u5176\u4e2d \u6bcf\u4e00\u6b21 j \u7684\u589e\u52a0\u8868\u793a\u201cbaby-step\u201d\uff0c\u4e00\u6b21\u4e58\u4e0a g g \u3002 \u6bcf\u4e00\u6b21 i \u7684\u589e\u52a0\u8868\u793a\u201cgiant-step\u201d\uff0c\u4e00\u6b21\u4e58\u4e0a g^{-m} g^{-m} \u3002 def bsgs ( g , y , p ): m = int ( ceil ( sqrt ( p - 1 ))) S = { pow ( g , j , p ): j for j in range ( m )} gs = pow ( g , p - 1 - m , p ) for i in range ( m ): if y in S : return i * m + S [ y ] y = y * gs % p return None Pollard\u2019s \u03c1 algorithm \u00b6 \u6211\u4eec\u53ef\u4ee5\u4ee5 O(\\sqrt n) O(\\sqrt n) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u548c O(1) O(1) \u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u6765\u89e3\u51b3\u4e0a\u8ff0\u95ee\u9898\u3002\u5177\u4f53\u539f\u7406\u8bf7\u81ea\u884c\u8c37\u6b4c\u3002 Pollard\u2019s kangaroo algorithm \u00b6 \u5982\u679c\u6211\u4eec\u77e5\u9053 x \u7684\u8303\u56f4\u4e3a a \\leq x \\leq b a \\leq x \\leq b \uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u4ee5 O(\\sqrt{b-a}) O(\\sqrt{b-a}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u89e3\u51b3\u4e0a\u8ff0\u95ee\u9898\u3002\u5177\u4f53\u539f\u7406\u8bf7\u81ea\u884c\u8c37\u6b4c\u3002 Pohlig-Hellman algorithm \u00b6 \u4e0d\u59a8\u5047\u8bbe\u4e0a\u8ff0\u6240\u63d0\u5230\u7684\u7fa4\u5173\u4e8e\u5143\u7d20 g g \u7684\u9636\u4e3a n n \uff0c n n \u4e3a\u4e00\u4e2a\u5149\u6ed1\u6570\uff1a n=\\prod\\limits_{i=1}^r p_i^{e_i} n=\\prod\\limits_{i=1}^r p_i^{e_i} \u3002 \u5bf9\u4e8e\u6bcf\u4e2a i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} \uff1a \u8ba1\u7b97 g_i \\equiv g^{n/p_i^{e_i}} \\pmod m g_i \\equiv g^{n/p_i^{e_i}} \\pmod m \u3002\u6839\u636e\u62c9\u683c\u6717\u65e5\u5b9a\u7406\uff0c g_i g_i \u5728\u7fa4\u4e2d\u7684\u9636\u4e3a p_i^{e_i} p_i^{e_i} \u3002 \u8ba1\u7b97 y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i}} \\equiv g_i^{x_i} \\pmod m y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i}} \\equiv g_i^{x_i} \\pmod m \uff0c\u8fd9\u91cc\u6211\u4eec\u77e5\u9053 y_i,m,g_i y_i,m,g_i \uff0c\u800c x_i x_i \u7684\u8303\u56f4\u4e3a [0,p_i^{e_i}) [0,p_i^{e_i}) \uff0c\u7531 n n \u662f\u4e00\u4e2a\u5149\u6ed1\u6570\uff0c\u53ef\u77e5\u5176\u8303\u56f4\u8f83\u5c0f\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Pollard\u2019s kangaroo algorithm \u7b49\u65b9\u6cd5\u5feb\u901f\u6c42\u5f97 x_i x_i \u3002 \u6839\u636e\u4e0a\u8ff0\u7684\u63a8\u5bfc\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u5bf9\u4e8e i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} \uff0c x \\equiv x_i \\pmod{p_i^{e_i}} x \\equiv x_i \\pmod{p_i^{e_i}} \uff0c\u8be5\u5f0f\u53ef\u7528\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u6c42\u89e3\u3002 \u4e0a\u8ff0\u8fc7\u7a0b\u53ef\u7528\u4e0b\u56fe\u7b80\u5355\u63cf\u8ff0\uff1a \u5176\u590d\u6742\u5ea6\u4e3a O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) \uff0c\u53ef\u4ee5\u770b\u51fa\u590d\u6742\u5ea6\u8fd8\u662f\u5f88\u4f4e\u7684\u3002 \u4f46\u5f53 n n \u4e3a\u7d20\u6570\uff0c m=2n+1 m=2n+1 \uff0c\u90a3\u4e48\u590d\u6742\u5ea6\u548c O(\\sqrt m) O(\\sqrt m) \u662f\u51e0\u4e4e\u6ca1\u6709\u5dee\u522b\u7684\u3002 2018 \u56fd\u8d5b crackme java \u00b6 \u4ee3\u7801\u5982\u4e0b import java.math.BigInteger ; import java.util.Random ; public class Test1 { static BigInteger two = new BigInteger ( \"2\" ); static BigInteger p = new BigInteger ( \"11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\" ); static BigInteger h = new BigInteger ( \"7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\" ); /* Alice write the below algorithm for encryption. The public key {p, h} is broadcasted to everyone. @param val: The plaintext to encrypt. We suppose val only contains lowercase letter {a-z} and numeric charactors, and is at most 256 charactors in length. */ public static String pkEnc ( String val ){ BigInteger [] ret = new BigInteger [ 2 ] ; BigInteger bVal = new BigInteger ( val . toLowerCase (), 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); ret [ 0 ]= two . modPow ( r , p ); ret [ 1 ]= h . modPow ( r , p ). multiply ( bVal ); return ret [ 0 ] . toString ( 36 ) + \"==\" + ret [ 1 ] . toString ( 36 ); } /* Alice write the below algorithm for decryption. x is her private key, which she will never let you know. public static String skDec(String val,BigInteger x){ if(!val.contains(\"==\")){ return null; } else { BigInteger val0=new BigInteger(val.split(\"==\")[0],36); BigInteger val1=new BigInteger(val.split(\"==\")[1],36); BigInteger s=val0.modPow(x,p).modInverse(p); return val1.multiply(s).mod(p).toString(36); } } */ public static void main ( String [] args ) throws Exception { System . out . println ( \"You intercepted the following message, which is sent from Bob to Alice:\" ); BigInteger bVal1 = new BigInteger ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco\" , 36 ); BigInteger bVal2 = new BigInteger ( \"2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" , 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); System . out . println ( r ); System . out . println ( bVal1 ); System . out . println ( bVal2 ); System . out . println ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco==2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" ); System . out . println ( \"Please figure out the plaintext!\" ); } } \u57fa\u672c\u529f\u80fd\u4e3a\u8ba1\u7b97 r_0=2^r \\bmod p r_0=2^r \\bmod p r_1 =b*h^r \\bmod p r_1 =b*h^r \\bmod p \u53ef\u4ee5\u53d1\u73b0\uff0cr \u7684\u8303\u56f4\u4e3a [0,2^{32}) [0,2^{32}) \uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 BSGS \u7b97\u6cd5\uff0c\u5982\u4e0b from sage.all import * c1 = int ( 'a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco' , 36 ) c2 = int ( '2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc' , 36 ) print c1 , c2 p = 11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711 h = 7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916 # generate the group const2 = 2 const2 = Mod ( const2 , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) h = Mod ( h , p ) print '2' , bsgs ( const2 , c1 , bounds = ( 1 , 2 ^ 32 )) r = 152351913 num = long ( c2 / ( h ** r )) print num \u53c2\u8003 \u00b6 \u521d\u7b49\u6570\u8bba\uff0c\u6f58\u627f\u6d1e\uff0c\u6f58\u627f\u5f6a https://ee.stanford.edu/~hellman/publications/28.pdf https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm#cite_note-Menezes97p108-2 https://fortenf.org/e/crypto/2017/12/03/survey-of-discrete-log-algos.html","title":"Discrete log zh"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#_1","text":"","title":"\u79bb\u6563\u5bf9\u6570"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#_2","text":"\u5728\u4e86\u89e3\u79bb\u6563\u5bf9\u6570\u65f6\uff0c\u6211\u4eec\u5148\u6765\u4e86\u89e3\u51e0\u4e2a\u57fa\u672c\u5b9a\u4e49\u3002 \u5b9a\u4e491 \u5728\u7fa4 G \u4e2d\uff0cg \u4e3a G \u7684\u751f\u6210\u5143\uff0c\u4e5f\u5c31\u662f\u8bf4\u7fa4 G \u4e2d\u6bcf\u4e00\u4e2a\u5143\u7d20\u90fd\u53ef\u4ee5\u5199\u6210 y=g^k y=g^k \uff0c\u6211\u4eec\u79f0 k \u4e3a y \u5728\u7fa4 G \u4e2d\u7684\u5bf9\u6570\u3002 \u5b9a\u4e492 \u8bbe m\\geq 1 m\\geq 1 \uff0c (a,m)=1 (a,m)=1 \uff0c\u4f7f\u5f97 a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m \u6210\u7acb\u7684\u6700\u5c0f\u6b63\u6574\u6570 d \u79f0\u4e3a a \u5bf9\u6a21 m \u7684\u6307\u6570\u6216\u8005\u9636\uff0c\u6211\u4eec\u4e00\u822c\u5c06\u5176\u8bb0\u4e3a \\delta_m(a) \\delta_m(a) \u3002 \u5b9a\u4e493 \u5f53 \\delta_m(a)=\\varphi(m) \\delta_m(a)=\\varphi(m) \u65f6\uff0c\u79f0 a \u662f\u6a21 m \u7684\u539f\u6839\uff0c\u7b80\u79f0 m \u7684\u539f\u6839\u3002","title":"\u57fa\u672c\u5b9a\u4e49"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#_3","text":"\u6027\u8d281 \u4f7f\u5f97 a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m \u6210\u7acb\u7684\u6700\u5c0f\u6b63\u6574\u6570 d d \uff0c\u5fc5\u6709 d\\mid\\varphi(m) d\\mid\\varphi(m) \u3002 \u6027\u8d282 \u6a21 m m \u5269\u4f59\u7cfb\u5b58\u5728\u539f\u6839\u7684\u5145\u8981\u6761\u4ef6\u662f m=2,4,p^{\\alpha},2p^{\\alpha} m=2,4,p^{\\alpha},2p^{\\alpha} \uff0c\u5176\u4e2d p p \u4e3a\u5947\u7d20\u6570\uff0c \\alpha \\alpha \u4e3a\u6b63\u6574\u6570\u3002","title":"\u4e00\u4e9b\u6027\u8d28"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#_4","text":"\u5df2\u77e5 g,p,y g,p,y \uff0c\u5bf9\u4e8e\u65b9\u7a0b y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p \uff0c\u6c42\u89e3 x x \u662f\u4e00\u4e2a\u96be\u89e3\u95ee\u9898\u3002\u4f46\u662f\u5f53 p p \u5177\u6709\u4e00\u5b9a\u7684\u7279\u6027\u65f6\u5c31\u53ef\u80fd\u53ef\u4ee5\u6c42\u89e3\uff0c\u6bd4\u5982\uff0c\u8fd9\u4e2a\u7fa4\u7684\u9636\u662f\u4e00\u4e2a\u5149\u6ed1\u6570\u3002 \u6b63\u662f\u4e0a\u8ff0\u8fd9\u4e2a\u95ee\u9898\u6784\u6210\u4e86\u76ee\u524d\u5f88\u5927\u4e00\u90e8\u5206\u73b0\u4ee3\u5bc6\u7801\u5b66\uff0c\u5305\u62ec Diffie\u2013Hellman \u5bc6\u94a5\u4ea4\u6362\uff0c ElGamal \u7b97\u6cd5\uff0cECC \u7b49\u3002","title":"\u79bb\u6563\u5bf9\u6570\u95ee\u9898"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#_5","text":"","title":"\u79bb\u6563\u5bf9\u6570\u6c42\u89e3\u65b9\u5f0f"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#_6","text":"\u7ed9\u5b9a y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p \uff0c\u6211\u4eec\u53ef\u4ee5\u66b4\u529b\u679a\u4e3e x x \u4ece\u800c\u5f97\u5230\u771f\u6b63\u7684 x x \u7684\u503c\u3002","title":"\u66b4\u529b\u7834\u89e3"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#baby-step-giant-step","text":"\u8fd9\u4e00\u65b9\u6cd5\u901a\u5e38\u88ab\u79f0\u4e3a\u5c0f\u6b65\u5927\u6b65\u6cd5\uff0c\u8fd9\u4e00\u65b9\u6cd5\u4f7f\u7528\u4e86\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\u7684\u601d\u60f3\u3002 \u6211\u4eec\u53ef\u4ee5\u4ee4 x=im+j x=im+j \uff0c\u5176\u4e2d m= \\lceil \\sqrt n\\rceil m= \\lceil \\sqrt n\\rceil \uff0c\u90a3\u4e48\u6574\u6570 i \u548c j \u90fd\u5728 0 \u5230 m \u7684\u8303\u56f4\u5185\u3002 \u56e0\u6b64 y=g^x=g^{im+j} y=g^x=g^{im+j} \u4e5f\u5c31\u662f y(g^{-m})^i=g^j y(g^{-m})^i=g^j \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u7684 j \u5e76\u8fdb\u884c\u8ba1\u7b97\uff0c\u5e76\u5c06\u5176\u5b58\u50a8\u5230\u4e00\u4e2a\u96c6\u5408 S \u4e2d\uff0c\u7136\u540e\u6211\u4eec\u518d\u6b21\u679a\u4e3e i\uff0c\u8ba1\u7b97 y(g^{-m})^i y(g^{-m})^i \uff0c\u4e00\u65e6\u6211\u4eec\u53d1\u73b0\u8ba1\u7b97\u7684\u7ed3\u679c\u5728\u96c6\u5408 S \u4e2d\uff0c\u5219\u8bf4\u660e\u6211\u4eec\u5f97\u5230\u4e86\u4e00\u4e2a\u78b0\u649e\uff0c\u8fdb\u800c\u5f97\u5230\u4e86 i \u548c j\u3002 \u8fd9\u663e\u7136\u662f\u4e00\u4e2a\u65f6\u95f4\u4e0e\u7a7a\u95f4\u7684\u6298\u4e2d\u7684\u65b9\u5f0f\uff0c\u6211\u4eec\u5c06\u4e00\u4e2a O(n) O(n) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c O(1) O(1) \u7a7a\u95f4\u590d\u6742\u5ea6\u7684\u7b97\u6cd5\u8f6c\u6362\u4e3a\u4e86\u4e00\u4e2a O(\\sqrt n) O(\\sqrt n) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u548c O(\\sqrt n) O(\\sqrt n) \u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u7684\u7b97\u6cd5\u3002 \u5176\u4e2d \u6bcf\u4e00\u6b21 j \u7684\u589e\u52a0\u8868\u793a\u201cbaby-step\u201d\uff0c\u4e00\u6b21\u4e58\u4e0a g g \u3002 \u6bcf\u4e00\u6b21 i \u7684\u589e\u52a0\u8868\u793a\u201cgiant-step\u201d\uff0c\u4e00\u6b21\u4e58\u4e0a g^{-m} g^{-m} \u3002 def bsgs ( g , y , p ): m = int ( ceil ( sqrt ( p - 1 ))) S = { pow ( g , j , p ): j for j in range ( m )} gs = pow ( g , p - 1 - m , p ) for i in range ( m ): if y in S : return i * m + S [ y ] y = y * gs % p return None","title":"Baby-step giant-step"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#pollards-algorithm","text":"\u6211\u4eec\u53ef\u4ee5\u4ee5 O(\\sqrt n) O(\\sqrt n) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u548c O(1) O(1) \u7684\u7a7a\u95f4\u590d\u6742\u5ea6\u6765\u89e3\u51b3\u4e0a\u8ff0\u95ee\u9898\u3002\u5177\u4f53\u539f\u7406\u8bf7\u81ea\u884c\u8c37\u6b4c\u3002","title":"Pollard\u2019s \u03c1 algorithm"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#pollards-kangaroo-algorithm","text":"\u5982\u679c\u6211\u4eec\u77e5\u9053 x \u7684\u8303\u56f4\u4e3a a \\leq x \\leq b a \\leq x \\leq b \uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u4ee5 O(\\sqrt{b-a}) O(\\sqrt{b-a}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u89e3\u51b3\u4e0a\u8ff0\u95ee\u9898\u3002\u5177\u4f53\u539f\u7406\u8bf7\u81ea\u884c\u8c37\u6b4c\u3002","title":"Pollard\u2019s kangaroo algorithm"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#pohlig-hellman-algorithm","text":"\u4e0d\u59a8\u5047\u8bbe\u4e0a\u8ff0\u6240\u63d0\u5230\u7684\u7fa4\u5173\u4e8e\u5143\u7d20 g g \u7684\u9636\u4e3a n n \uff0c n n \u4e3a\u4e00\u4e2a\u5149\u6ed1\u6570\uff1a n=\\prod\\limits_{i=1}^r p_i^{e_i} n=\\prod\\limits_{i=1}^r p_i^{e_i} \u3002 \u5bf9\u4e8e\u6bcf\u4e2a i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} \uff1a \u8ba1\u7b97 g_i \\equiv g^{n/p_i^{e_i}} \\pmod m g_i \\equiv g^{n/p_i^{e_i}} \\pmod m \u3002\u6839\u636e\u62c9\u683c\u6717\u65e5\u5b9a\u7406\uff0c g_i g_i \u5728\u7fa4\u4e2d\u7684\u9636\u4e3a p_i^{e_i} p_i^{e_i} \u3002 \u8ba1\u7b97 y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i}} \\equiv g_i^{x_i} \\pmod m y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i}} \\equiv g_i^{x_i} \\pmod m \uff0c\u8fd9\u91cc\u6211\u4eec\u77e5\u9053 y_i,m,g_i y_i,m,g_i \uff0c\u800c x_i x_i \u7684\u8303\u56f4\u4e3a [0,p_i^{e_i}) [0,p_i^{e_i}) \uff0c\u7531 n n \u662f\u4e00\u4e2a\u5149\u6ed1\u6570\uff0c\u53ef\u77e5\u5176\u8303\u56f4\u8f83\u5c0f\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Pollard\u2019s kangaroo algorithm \u7b49\u65b9\u6cd5\u5feb\u901f\u6c42\u5f97 x_i x_i \u3002 \u6839\u636e\u4e0a\u8ff0\u7684\u63a8\u5bfc\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u5bf9\u4e8e i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} \uff0c x \\equiv x_i \\pmod{p_i^{e_i}} x \\equiv x_i \\pmod{p_i^{e_i}} \uff0c\u8be5\u5f0f\u53ef\u7528\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u6c42\u89e3\u3002 \u4e0a\u8ff0\u8fc7\u7a0b\u53ef\u7528\u4e0b\u56fe\u7b80\u5355\u63cf\u8ff0\uff1a \u5176\u590d\u6742\u5ea6\u4e3a O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) \uff0c\u53ef\u4ee5\u770b\u51fa\u590d\u6742\u5ea6\u8fd8\u662f\u5f88\u4f4e\u7684\u3002 \u4f46\u5f53 n n \u4e3a\u7d20\u6570\uff0c m=2n+1 m=2n+1 \uff0c\u90a3\u4e48\u590d\u6742\u5ea6\u548c O(\\sqrt m) O(\\sqrt m) \u662f\u51e0\u4e4e\u6ca1\u6709\u5dee\u522b\u7684\u3002","title":"Pohlig-Hellman algorithm"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#2018-crackme-java","text":"\u4ee3\u7801\u5982\u4e0b import java.math.BigInteger ; import java.util.Random ; public class Test1 { static BigInteger two = new BigInteger ( \"2\" ); static BigInteger p = new BigInteger ( \"11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\" ); static BigInteger h = new BigInteger ( \"7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\" ); /* Alice write the below algorithm for encryption. The public key {p, h} is broadcasted to everyone. @param val: The plaintext to encrypt. We suppose val only contains lowercase letter {a-z} and numeric charactors, and is at most 256 charactors in length. */ public static String pkEnc ( String val ){ BigInteger [] ret = new BigInteger [ 2 ] ; BigInteger bVal = new BigInteger ( val . toLowerCase (), 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); ret [ 0 ]= two . modPow ( r , p ); ret [ 1 ]= h . modPow ( r , p ). multiply ( bVal ); return ret [ 0 ] . toString ( 36 ) + \"==\" + ret [ 1 ] . toString ( 36 ); } /* Alice write the below algorithm for decryption. x is her private key, which she will never let you know. public static String skDec(String val,BigInteger x){ if(!val.contains(\"==\")){ return null; } else { BigInteger val0=new BigInteger(val.split(\"==\")[0],36); BigInteger val1=new BigInteger(val.split(\"==\")[1],36); BigInteger s=val0.modPow(x,p).modInverse(p); return val1.multiply(s).mod(p).toString(36); } } */ public static void main ( String [] args ) throws Exception { System . out . println ( \"You intercepted the following message, which is sent from Bob to Alice:\" ); BigInteger bVal1 = new BigInteger ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco\" , 36 ); BigInteger bVal2 = new BigInteger ( \"2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" , 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); System . out . println ( r ); System . out . println ( bVal1 ); System . out . println ( bVal2 ); System . out . println ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco==2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" ); System . out . println ( \"Please figure out the plaintext!\" ); } } \u57fa\u672c\u529f\u80fd\u4e3a\u8ba1\u7b97 r_0=2^r \\bmod p r_0=2^r \\bmod p r_1 =b*h^r \\bmod p r_1 =b*h^r \\bmod p \u53ef\u4ee5\u53d1\u73b0\uff0cr \u7684\u8303\u56f4\u4e3a [0,2^{32}) [0,2^{32}) \uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 BSGS \u7b97\u6cd5\uff0c\u5982\u4e0b from sage.all import * c1 = int ( 'a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco' , 36 ) c2 = int ( '2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc' , 36 ) print c1 , c2 p = 11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711 h = 7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916 # generate the group const2 = 2 const2 = Mod ( const2 , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) h = Mod ( h , p ) print '2' , bsgs ( const2 , c1 , bounds = ( 1 , 2 ^ 32 )) r = 152351913 num = long ( c2 / ( h ** r )) print num","title":"2018 \u56fd\u8d5b crackme java"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log-zh/#_7","text":"\u521d\u7b49\u6570\u8bba\uff0c\u6f58\u627f\u6d1e\uff0c\u6f58\u627f\u5f6a https://ee.stanford.edu/~hellman/publications/28.pdf https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm#cite_note-Menezes97p108-2 https://fortenf.org/e/crypto/2017/12/03/survey-of-discrete-log-algos.html","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/","text":"EN | ZH discrete logarithm \u00b6 Basic definition \u00b6 When we understand discrete logarithms, let's first look at a few basic definitions. Definition 1 In group G, g is the generator of G, that is, each element in group G can be written as y=g^k y=g^k , which we call k is the logarithm of y in group G. Definition 2 Let m\\geq 1 m\\geq 1 , (a,m)=1 (a,m)=1 , let a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m be the smallest positive integer d called a to the exponent or order of modulo m, we will generally It is recorded as \\delta_m(a) \\delta_m(a) . Definition 3 When \\delta_m(a)=\\varphi(m) \\delta_m(a)=\\varphi(m) , a is called the original root of modulo m, which is called the original root of m. Some properties \u00b6 Nature 1 The smallest positive integer d d that makes a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m true must have d\\mid\\varphi(m) d\\mid\\varphi(m) . Property 2 The necessary and sufficient condition for the existence of the original root of the modulo m m is m=2,4,p^{\\alpha}, 2p^{\\alpha} m=2,4,p^{\\alpha}, 2p^{\\alpha} , where p p is an odd prime, \\alpha \\alpha is positive Integer. Discrete logarithm problem \u00b6 Knowing g,p,y g,p,y , for the equation y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p , solving x x is a difficult problem. But when p p has certain characteristics, it can be solved. For example, the order of this group is a smooth number. It is this problem that constitutes a large part of modern cryptography, including Diffie\u2013Hellman key exchange, ElGamal algorithm, ECC, etc. Discrete logarithm solution \u00b6 \u66b4\u66b4 \u00b6 Given y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p , we can violently enumerate x x to get the true value of x x . Baby-step giant-step \u00b6 This method is often referred to as a small step, which uses the idea of an intermediate encounter attack. We can make x=im+j x=im+j , where m= \\lceil \\sqrt n\\rceil m= \\lceil \\sqrt n\\rceil , then the integers i and j are all in the range 0 to m. therefore y = g ^ x = g ^ {im + j} y = g ^ x = g ^ {im + j} That is y(g^{-m})^i=g^j y(g^{-m})^i=g^j Then we can enumerate all the j and calculate it and store it in a set S, then we enumerate i again, calculate y(g^{-m})^i y(g^{-m})^i , once we find the calculation The result in the set S shows that we got a collision and got i and j. This is obviously a way of compromise between time and space. We convert a O(n) O(n) time complexity, O(1) O(1) space complexity algorithm to a O(\\sqrt n) O(\\sqrt n) The algorithm of time complexity and space complexity of O(\\sqrt n) O(\\sqrt n) . among them Each increment of j means \"baby-step\", multiplied by g g at a time. Each increment of i means \"giant-step\", multiplied by g^{-m} g^{-m} at a time. def bsgs ( g , y , p ): m = int ( ceil ( sqrt ( p - 1 ))) S = { pow ( g , j , p ): j for j in range ( m )} gs = pow ( g , p - 1 - m , p ) for i in range ( m ): if y in S : return i * m + S [ y ] y = y * gs % p return None Pollard's \u03c1 algorithm \u00b6 We can solve the above problem with the time complexity of O(\\sqrt n) O(\\sqrt n) and the space complexity of O(1) O(1) . Please use Google for your specific principles. Pollard\u2019s kangaroo algorithm \u00b6 If we know that the range of x is a \\leq x \\leq b a \\leq x \\leq b , then we can solve the above problem with the time complexity of O(\\sqrt{ba}) O(\\sqrt{ba}) . Please use Google for your specific principles. Pohlig-Hellman algorithm \u00b6 Let's assume that the above mentioned group has a rank of n n for the element g g , and n n is a smooth number: n=\\prod\\limits_{i=1}^r p_i^{e_i} n=\\prod\\limits_{i=1}^r p_i^{e_i} . For each i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} : Calculate g_i \\equiv g^{n/p_i^{e_i}} \\pmod m g_i \\equiv g^{n/p_i^{e_i}} \\pmod m . According to the Lagrange theorem, the order of g_i g_i in the group is p_i^{e_i} p_i^{e_i} . Calculate y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m , here we know y_i,m,g_i y_i,m,g_i , and x_i x_i ranges from [0,p_i^{e_i}) [0,p_i^{e_i}) , by n n is a Smooth numbers, the range is small, so we can quickly find x_i x_i using methods such as Pollard's kangaroo algorithm . According to the above derivation, we can get for i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} , x \\equiv x_i \\pmod{p_i^{e_i}} x \\equiv x_i \\pmod{p_i^{e_i}} , which can be solved by Chinese remainder theorem . The above process can be briefly described in the following figure: The complexity is O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) , and it can be seen that the complexity is still very low. But when n n is prime, m=2n+1 m=2n+1 , then the complexity and O(\\sqrt m) O(\\sqrt m) are almost indistinguishable. 2018 \u56fd\u8d5bcrackme java \u00b6 code show as below import java.math.BigInteger ; import java.util.Random ; public class Test1 { static BigInteger two = new BigInteger ( \"2\" ); static BigInteger p = new BigInteger ( \"11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\" ); static BigInteger h = new BigInteger ( \"7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\" ); /* Alice write the below algorithm for encryption. The public key {p, h} is broadcasted to everyone. @param val: The plaintext to encrypt. We suppose val only contains lowercase letter {a-z} and numeric charactors, and is at most 256 charactors in length. */ public static String pkEnc ( String val ){ BigInteger [] ret = new BigInteger [ 2 ] ; BigInteger bVal = new BigInteger ( val . toLowerCase (), 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); ret [ 0 ] = two . modPow ( r , p ); entitled [ 1 ] = h . modPow ( r , p ) . multiply ( bVal ); return right [ 0 ] . toString ( 36 ) + & quot ; ==& quot ; + ret [ 1 ] . toString ( 36 ); } /* Alice write the below algorithm for decryption. x is her private key, which she will never let you know. public static String skDec(String val,BigInteger x){ if(!val.contains(\"==\")){ return null; } else { BigInteger val0=new BigInteger(val.split(\"==\")[0],36); BigInteger val1=new BigInteger(val.split(\"==\")[1],36); BigInteger s=val0.modPow(x,p).modInverse(p); return val1.multiply(s).mod(p).toString(36); } } */ public static void main ( String [] args ) throws Exception { System . out . println ( \"You intercepted the following message, which is sent from Bob to Alice:\" ); BigInteger bVal1 = new BigInteger ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco\" , 36 ); BigInteger bVal2 = new BigInteger ( \"2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" , 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); System . out . println ( r ); System . out . println ( bVal1 ); System . out . println ( bVal2 ); System . out . println ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco==2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" ); System . out . println ( \"Please figure out the plaintext!\" ); } } Basic function is calculation $ R_0 = 2 ^ r way $ p $ R_1 = b * h ^ r way $ p It can be found that the range of r is [0,2^{32}) [0,2^{32}) , so we can use the BSGS algorithm as follows from sage.all import * c1 = int ( 'a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco' , 36 ) c2 = int ( '2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc' , 36 ) print c1 , c2 p = 11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711 h = 7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916 # generate the group const2 = 2 const2 = Mod ( const2 , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) h = Mod ( h , p ) print '2' , bsgs ( const2 , c1 , bounds = ( 1 , 2 ^ 32 )) r = 152351913 num = long ( c2 / ( h ** r )) Surely Print Reference \u00b6 Elementary number theory, Pan Chengdong, Pan Chengyu https://ee.stanford.edu/~hellman/publications/28.pdf https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm#cite_note-Menezes97p108-2 https://fortenf.org/e/crypto/2017/12/03/survey-of-discrete-log-algos.html","title":"\u79bb\u6563\u5bf9\u6570"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#discrete-logarithm","text":"","title":"discrete logarithm"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#basic-definition","text":"When we understand discrete logarithms, let's first look at a few basic definitions. Definition 1 In group G, g is the generator of G, that is, each element in group G can be written as y=g^k y=g^k , which we call k is the logarithm of y in group G. Definition 2 Let m\\geq 1 m\\geq 1 , (a,m)=1 (a,m)=1 , let a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m be the smallest positive integer d called a to the exponent or order of modulo m, we will generally It is recorded as \\delta_m(a) \\delta_m(a) . Definition 3 When \\delta_m(a)=\\varphi(m) \\delta_m(a)=\\varphi(m) , a is called the original root of modulo m, which is called the original root of m.","title":"Basic definition"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#some-properties","text":"Nature 1 The smallest positive integer d d that makes a^d \\equiv 1\\pmod m a^d \\equiv 1\\pmod m true must have d\\mid\\varphi(m) d\\mid\\varphi(m) . Property 2 The necessary and sufficient condition for the existence of the original root of the modulo m m is m=2,4,p^{\\alpha}, 2p^{\\alpha} m=2,4,p^{\\alpha}, 2p^{\\alpha} , where p p is an odd prime, \\alpha \\alpha is positive Integer.","title":"Some properties"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#discrete-logarithm-problem","text":"Knowing g,p,y g,p,y , for the equation y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p , solving x x is a difficult problem. But when p p has certain characteristics, it can be solved. For example, the order of this group is a smooth number. It is this problem that constitutes a large part of modern cryptography, including Diffie\u2013Hellman key exchange, ElGamal algorithm, ECC, etc.","title":"Discrete logarithm problem"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#discrete-logarithm-solution","text":"","title":"Discrete logarithm solution"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#_1","text":"Given y\\equiv g^x \\pmod p y\\equiv g^x \\pmod p , we can violently enumerate x x to get the true value of x x .","title":"\u66b4\u66b4"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#baby-step-giant-step","text":"This method is often referred to as a small step, which uses the idea of an intermediate encounter attack. We can make x=im+j x=im+j , where m= \\lceil \\sqrt n\\rceil m= \\lceil \\sqrt n\\rceil , then the integers i and j are all in the range 0 to m. therefore y = g ^ x = g ^ {im + j} y = g ^ x = g ^ {im + j} That is y(g^{-m})^i=g^j y(g^{-m})^i=g^j Then we can enumerate all the j and calculate it and store it in a set S, then we enumerate i again, calculate y(g^{-m})^i y(g^{-m})^i , once we find the calculation The result in the set S shows that we got a collision and got i and j. This is obviously a way of compromise between time and space. We convert a O(n) O(n) time complexity, O(1) O(1) space complexity algorithm to a O(\\sqrt n) O(\\sqrt n) The algorithm of time complexity and space complexity of O(\\sqrt n) O(\\sqrt n) . among them Each increment of j means \"baby-step\", multiplied by g g at a time. Each increment of i means \"giant-step\", multiplied by g^{-m} g^{-m} at a time. def bsgs ( g , y , p ): m = int ( ceil ( sqrt ( p - 1 ))) S = { pow ( g , j , p ): j for j in range ( m )} gs = pow ( g , p - 1 - m , p ) for i in range ( m ): if y in S : return i * m + S [ y ] y = y * gs % p return None","title":"Baby-step giant-step"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#pollards-algorithm","text":"We can solve the above problem with the time complexity of O(\\sqrt n) O(\\sqrt n) and the space complexity of O(1) O(1) . Please use Google for your specific principles.","title":"Pollard&#39;s \u03c1 algorithm"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#pollards-kangaroo-algorithm","text":"If we know that the range of x is a \\leq x \\leq b a \\leq x \\leq b , then we can solve the above problem with the time complexity of O(\\sqrt{ba}) O(\\sqrt{ba}) . Please use Google for your specific principles.","title":"Pollard\u2019s kangaroo algorithm"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#pohlig-hellman-algorithm","text":"Let's assume that the above mentioned group has a rank of n n for the element g g , and n n is a smooth number: n=\\prod\\limits_{i=1}^r p_i^{e_i} n=\\prod\\limits_{i=1}^r p_i^{e_i} . For each i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} : Calculate g_i \\equiv g^{n/p_i^{e_i}} \\pmod m g_i \\equiv g^{n/p_i^{e_i}} \\pmod m . According to the Lagrange theorem, the order of g_i g_i in the group is p_i^{e_i} p_i^{e_i} . Calculate y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m y_i \\equiv y^{n/p_i^{e_i}} \\equiv g^{xn/p_i^{e_i}} \\equiv g_i^{x} \\equiv g_i^{x \\bmod p_i^{e_i }} \\equiv g_i^{x_i} \\pmod m , here we know y_i,m,g_i y_i,m,g_i , and x_i x_i ranges from [0,p_i^{e_i}) [0,p_i^{e_i}) , by n n is a Smooth numbers, the range is small, so we can quickly find x_i x_i using methods such as Pollard's kangaroo algorithm . According to the above derivation, we can get for i \\in \\{1,\\ldots,r\\} i \\in \\{1,\\ldots,r\\} , x \\equiv x_i \\pmod{p_i^{e_i}} x \\equiv x_i \\pmod{p_i^{e_i}} , which can be solved by Chinese remainder theorem . The above process can be briefly described in the following figure: The complexity is O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) O\\left(\\sum\\limits _i e_i\\left(\\log n+\\sqrt{p_i}\\right)\\right) , and it can be seen that the complexity is still very low. But when n n is prime, m=2n+1 m=2n+1 , then the complexity and O(\\sqrt m) O(\\sqrt m) are almost indistinguishable.","title":"Pohlig-Hellman algorithm"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#2018-crackme-java","text":"code show as below import java.math.BigInteger ; import java.util.Random ; public class Test1 { static BigInteger two = new BigInteger ( \"2\" ); static BigInteger p = new BigInteger ( \"11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711\" ); static BigInteger h = new BigInteger ( \"7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916\" ); /* Alice write the below algorithm for encryption. The public key {p, h} is broadcasted to everyone. @param val: The plaintext to encrypt. We suppose val only contains lowercase letter {a-z} and numeric charactors, and is at most 256 charactors in length. */ public static String pkEnc ( String val ){ BigInteger [] ret = new BigInteger [ 2 ] ; BigInteger bVal = new BigInteger ( val . toLowerCase (), 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); ret [ 0 ] = two . modPow ( r , p ); entitled [ 1 ] = h . modPow ( r , p ) . multiply ( bVal ); return right [ 0 ] . toString ( 36 ) + & quot ; ==& quot ; + ret [ 1 ] . toString ( 36 ); } /* Alice write the below algorithm for decryption. x is her private key, which she will never let you know. public static String skDec(String val,BigInteger x){ if(!val.contains(\"==\")){ return null; } else { BigInteger val0=new BigInteger(val.split(\"==\")[0],36); BigInteger val1=new BigInteger(val.split(\"==\")[1],36); BigInteger s=val0.modPow(x,p).modInverse(p); return val1.multiply(s).mod(p).toString(36); } } */ public static void main ( String [] args ) throws Exception { System . out . println ( \"You intercepted the following message, which is sent from Bob to Alice:\" ); BigInteger bVal1 = new BigInteger ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco\" , 36 ); BigInteger bVal2 = new BigInteger ( \"2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" , 36 ); BigInteger r = new BigInteger ( new Random (). nextInt () + \"\" ); System . out . println ( r ); System . out . println ( bVal1 ); System . out . println ( bVal2 ); System . out . println ( \"a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco==2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc\" ); System . out . println ( \"Please figure out the plaintext!\" ); } } Basic function is calculation $ R_0 = 2 ^ r way $ p $ R_1 = b * h ^ r way $ p It can be found that the range of r is [0,2^{32}) [0,2^{32}) , so we can use the BSGS algorithm as follows from sage.all import * c1 = int ( 'a9hgrei38ez78hl2kkd6nvookaodyidgti7d9mbvctx3jjniezhlxs1b1xz9m0dzcexwiyhi4nhvazhhj8dwb91e7lbbxa4ieco' , 36 ) c2 = int ( '2q17m8ajs7509yl9iy39g4znf08bw3b33vibipaa1xt5b8lcmgmk6i5w4830yd3fdqfbqaf82386z5odwssyo3t93y91xqd5jb0zbgvkb00fcmo53sa8eblgw6vahl80ykxeylpr4bpv32p7flvhdtwl4cxqzc' , 36 ) print c1 , c2 p = 11360738295177002998495384057893129964980131806509572927886675899422214174408333932150813939357279703161556767193621832795605708456628733877084015367497711 h = 7854998893567208831270627233155763658947405610938106998083991389307363085837028364154809577816577515021560985491707606165788274218742692875308216243966916 # generate the group const2 = 2 const2 = Mod ( const2 , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) h = Mod ( h , p ) print '2' , bsgs ( const2 , c1 , bounds = ( 1 , 2 ^ 32 )) r = 152351913 num = long ( c2 / ( h ** r )) Surely Print","title":"2018 \u56fd\u8d5bcrackme java"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/discrete-log/#reference","text":"Elementary number theory, Pan Chengdong, Pan Chengyu https://ee.stanford.edu/~hellman/publications/28.pdf https://en.wikipedia.org/wiki/Pohlig%E2%80%93Hellman_algorithm#cite_note-Menezes97p108-2 https://fortenf.org/e/crypto/2017/12/03/survey-of-discrete-log-algos.html","title":"Reference"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/","text":"EN | ZH ECC \u00b6 \u6982\u8ff0 \u00b6 ECC \u5168\u79f0\u4e3a\u692d\u5706\u66f2\u7ebf\u52a0\u5bc6\uff0cEllipseCurve Cryptography\uff0c\u662f\u4e00\u79cd\u57fa\u4e8e\u692d\u5706\u66f2\u7ebf\u6570\u5b66\u7684\u516c\u94a5\u5bc6\u7801\u3002\u4e0e\u4f20\u7edf\u7684\u57fa\u4e8e\u5927\u8d28\u6570\u56e0\u5b50\u5206\u89e3\u56f0\u96be\u6027\u7684\u52a0\u5bc6\u65b9\u6cd5\u4e0d\u540c\uff0cECC\u4f9d\u8d56\u4e8e\u89e3\u51b3\u692d\u5706\u66f2\u7ebf\u79bb\u6563\u5bf9\u6570\u95ee\u9898\u7684\u56f0\u96be\u6027\u3002\u5b83\u7684\u4f18\u52bf\u4e3b\u8981\u5728\u4e8e\u76f8\u5bf9\u4e8e\u5176\u5b83\u65b9\u6cd5\uff0c\u5b83\u53ef\u4ee5\u5728\u4f7f\u7528\u8f83\u77ed\u5bc6\u94a5\u957f\u5ea6\u7684\u540c\u65f6\u4fdd\u6301\u76f8\u540c\u7684\u5bc6\u7801\u5f3a\u5ea6\u3002\u76ee\u524d\u692d\u5706\u66f2\u7ebf\u4e3b\u8981\u91c7\u7528\u7684\u6709\u9650\u57df\u6709 \u4ee5\u7d20\u6570\u4e3a\u6a21\u7684\u6574\u6570\u57dfGF(p)\uff0c\u901a\u5e38\u5728\u901a\u7528\u5904\u7406\u5668\u4e0a\u66f4\u4e3a\u6709\u6548\u3002 \u7279\u5f81\u4e3a 2 \u7684\u4f3d\u7f57\u534e\u57dfGF\uff082^m\uff09\uff0c\u53ef\u4ee5\u8bbe\u8ba1\u4e13\u95e8\u7684\u786c\u4ef6\u3002 \u57fa\u672c\u77e5\u8bc6 \u00b6 \u6211\u4eec\u9996\u5148\u6765\u4e86\u89e3\u4e00\u4e0b\u6709\u9650\u57df\u4e0a\u7684\u692d\u5706\u66f2\u7ebf\uff0c\u6709\u9650\u57df\u4e0a\u7684\u692d\u5706\u66f2\u7ebf\u662f\u6307\u5728\u692d\u5706\u66f2\u7ebf\u7684\u5b9a\u4e49\u5f0f y^2+axy+by=x^3+cx^2+dx+e y^2+axy+by=x^3+cx^2+dx+e \u4e2d\u6240\u6709\u7684\u7cfb\u6570\u90fd\u662f\u5728\u67d0\u4e2a\u6709\u9650\u57dfGF(p)\u4e2d\u7684\u5143\u7d20\uff0c\u5176\u4e2dp\u4e3a\u4e00\u4e2a\u5927\u7d20\u6570\u3002 \u5f53\u7136\uff0c\u5e76\u4e0d\u662f\u6240\u6709\u7684\u692d\u5706\u66f2\u7ebf\u90fd\u9002\u5408\u4e8e\u52a0\u5bc6\uff0c\u6700\u4e3a\u5e38\u7528\u7684\u65b9\u7a0b\u5982\u4e0b y^2=x^3+ax+b y^2=x^3+ax+b \u5176\u4e2d 4a^3+27b^2 \\bmod p \\neq 0 4a^3+27b^2 \\bmod p \\neq 0 \u6211\u4eec\u79f0\u8be5\u65b9\u7a0b\u7684\u6240\u6709\u89e3(x,y)\uff0c( x\\in Fp , y \\in Fp x\\in Fp , y \\in Fp )\uff0c\u4ee5\u53ca\u4e00\u4e2a\u79f0\u4e3a\u201c\u65e0\u7a77\u8fdc\u70b9\u201d(O)\u7ec4\u6210\u7684\u96c6\u5408\u4e3a\u5b9a\u4e49\u5728Fp\u4e0a\u7684\u4e00\u4e2a\u692d\u5706\u66f2\u7ebf\uff0c\u8bb0\u4e3aE(Fp)\u3002 \u4e00\u822c\u5b9a\u4e49\u692d\u5706\u66f2\u7ebf\u5bc6\u7801\u9700\u8981\u4ee5\u4e0b\u6761\u4ef6 \u5047\u8bbeE(Fp)\u5bf9\u4e8e\u70b9\u7684\u8fd0\u7b97 \\oplus \\oplus \u5f62\u6210\u4e00\u4e2aable\u7fa4\uff08\u4ea4\u6362\u7fa4\uff0c\u9006\u5143\u5b58\u5728\uff0c\u5c01\u95ed\u6027\u7b49\uff09\uff0c\u8bbe p\\in E(Fq) p\\in E(Fq) \uff0c\u4e14\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\u7684t\u5f88\u5927 p \\oplus p \\oplus ... \\oplus p=O p \\oplus p \\oplus ... \\oplus p=O \u5176\u4e2d\u5171\u6709t\u4e2ap\u53c2\u4e0e\u8fd0\u7b97\u3002\u8fd9\u91cc\u6211\u4eec\u79f0t\u4e3ap\u7684\u5468\u671f\u3002\u6b64\u5916\uff0c\u5bf9\u4e8e Q\\in E(Fq) Q\\in E(Fq) \uff0c\u5b9a\u6709\u67d0\u4e2a\u6b63\u6574\u6570m\u4f7f\u5f97\u4e0b\u5217\u5f0f\u5b50\u6210\u7acb\uff0c\u5b9a\u4e49 m=log_pq m=log_pq Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p \uff08m\u4e2ap\u53c2\u4e0e\u8fd0\u7b97\uff09 \u6b64\u5916\uff0c\u5047\u8bbeG\u662f\u8be5 E_q (a,b) E_q (a,b) \u7684\u751f\u6210\u5143\uff0c\u5373\u53ef\u4ee5\u751f\u6210\u5176\u4e2d\u7684\u6240\u6709\u5143\u7d20\uff0c\u5176\u9636\u4e3a\u6ee1\u8db3 nG=O nG=O \u7684\u6700\u5c0f\u6b63\u6574\u6570n\u3002 ECC\u4e2d\u7684ElGamal \u00b6 \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u7528\u6237B\u8981\u628a\u6d88\u606f\u52a0\u5bc6\u540e\u4f20\u7ed9\u7528\u6237A\u3002 \u5bc6\u94a5\u751f\u6210 \u00b6 \u7528\u6237A\u5148\u9009\u62e9\u4e00\u6761\u692d\u5706\u66f2\u7ebf E_q (a,b) E_q (a,b) \uff0c\u7136\u540e\u9009\u62e9\u5176\u4e0a\u7684\u4e00\u4e2a\u751f\u6210\u5143G\uff0c\u5047\u8bbe\u5176\u9636\u4e3an\uff0c\u4e4b\u540e\u518d\u9009\u62e9\u4e00\u4e2a\u6b63\u6574\u6570 n_a n_a \u4f5c\u4e3a\u5bc6\u94a5\uff0c\u8ba1\u7b97 P_a=n_aG P_a=n_aG \u3002 \u5176\u4e2d\uff0c E_q(a,b), q,G E_q(a,b), q,G \u90fd\u4f1a\u88ab\u516c\u5f00\u3002 \u516c\u94a5\u4e3a P_a P_a \uff0c\u79c1\u94a5\u4e3a$n_a $\u3002 \u52a0\u5bc6 \u00b6 \u7528\u6237B\u5728\u5411\u7528\u6237A\u53d1\u9001\u6d88\u606fm\uff0c\u8fd9\u91cc\u5047\u8bbe\u6d88\u606fm\u5df2\u7ecf\u88ab\u7f16\u7801\u4e3a\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u70b9\uff0c\u5176\u52a0\u5bc6\u6b65\u9aa4\u5982\u4e0b \u67e5\u8be2\u7528\u6237A\u7684\u516c\u94a5 E_q(a,b), q, P_a,G E_q(a,b), q, P_a,G \u3002 \u5728(1,q-1) \u7684\u533a\u95f4\u5185\u9009\u62e9\u968f\u673a\u6570k \u3002 \u6839\u636eA\u7684\u516c\u94a5\u8ba1\u7b97\u70b9 (x_1,y_1)=kG (x_1,y_1)=kG \u3002 \u8ba1\u7b97\u70b9 (x_2,y_2)=kP_a (x_2,y_2)=kP_a \uff0c\u5982\u679c\u4e3aO\uff0c\u5219\u4ece\u7b2c\u4e8c\u6b65\u91cd\u65b0\u5f00\u59cb\u3002 \u8ba1\u7b97 C=m+(x_2,y_2) C=m+(x_2,y_2) \u5c06 ((x_1,y_1),C) ((x_1,y_1),C) \u53d1\u9001\u7ed9A\u3002 \u89e3\u5bc6 \u00b6 \u89e3\u5bc6\u6b65\u9aa4\u5982\u4e0b \u5229\u7528\u79c1\u94a5\u8ba1\u7b97\u70b9 n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) \u3002 \u8ba1\u7b97\u6d88\u606f m=C-(x_2,y_2) m=C-(x_2,y_2) \u3002 \u5173\u952e\u70b9 \u00b6 \u8fd9\u91cc\u7684\u5173\u952e\u70b9\u5728\u4e8e\u6211\u4eec\u5373\u4f7f\u77e5\u9053\u4e86 (x_1,y_1) (x_1,y_1) \u4e5f\u96be\u4ee5\u77e5\u9053k\uff0c\u8fd9\u662f\u7531\u79bb\u6563\u5bf9\u6570\u7684\u95ee\u9898\u7684\u96be\u5ea6\u51b3\u5b9a\u7684\u3002 2013 SECCON CTF quals Cryptanalysis \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee52013\u5e74SECCON CTF quals \u4e2d\u7684 Cryptanalysis \u4e3a\u4f8b\uff0c\u9898\u76ee\u5982\u4e0b \u8fd9\u91cc\uff0c\u6211\u4eec\u5df2\u77e5\u692d\u5706\u66f2\u7ebf\u65b9\u7a0b\u4ee5\u53ca\u5bf9\u5e94\u7684\u751f\u6210\u5143 base\uff0c\u8fd8\u77e5\u9053\u76f8\u5e94\u7684\u6a21\u6570\u4ee5\u53ca\u516c\u94a5\u4ee5\u53ca\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u3002 \u4f46\u662f\u53ef\u4ee5\u770b\u51fa\u7684\u6211\u4eec\u7684\u6a21\u6570\u592a\u5c0f\uff0c\u6211\u4eec\u66b4\u529b\u679a\u4e3e\u83b7\u53d6\u7ed3\u679c\u3002 \u8fd9\u91cc\u76f4\u63a5\u53c2\u8003 github\u4e0a\u7684 sage \u7a0b\u5e8f\uff0c\u66b4\u529b\u8dd1\u51fa secret key\u3002\u4e4b\u540e\u4fbf\u53ef\u4ee5\u89e3\u5bc6\u4e86\u3002 a = 1234577 b = 3213242 n = 7654319 E = EllipticCurve ( GF ( n ), [ 0 , 0 , 0 , a , b ]) base = E ([ 5234568 , 2287747 ]) pub = E ([ 2366653 , 1424308 ]) c1 = E ([ 5081741 , 6744615 ]) c2 = E ([ 610619 , 6218 ]) X = base for i in range ( 1 , n ): if X == pub : secret = i print \"[+] secret:\" , i break else : X = X + base print i m = c2 - ( c1 * secret ) print \"[+] x:\" , m [ 0 ] print \"[+] y:\" , m [ 1 ] print \"[+] x+y:\" , m [ 0 ] + m [ 1 ] \u66b4\u529b\u8dd1\u51fa\u7ed3\u679c [ + ] secret: 1584718 [ + ] x: 2171002 [ + ] y: 3549912 [ + ] x+y: 5720914 \u53c2\u8003 \u00b6 https://github.com/sonickun/ctf-crypto-writeups/tree/master/2013/seccon-ctf-quals/cryptanalysis","title":"Ecc zh"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#ecc","text":"","title":"ECC"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#_1","text":"ECC \u5168\u79f0\u4e3a\u692d\u5706\u66f2\u7ebf\u52a0\u5bc6\uff0cEllipseCurve Cryptography\uff0c\u662f\u4e00\u79cd\u57fa\u4e8e\u692d\u5706\u66f2\u7ebf\u6570\u5b66\u7684\u516c\u94a5\u5bc6\u7801\u3002\u4e0e\u4f20\u7edf\u7684\u57fa\u4e8e\u5927\u8d28\u6570\u56e0\u5b50\u5206\u89e3\u56f0\u96be\u6027\u7684\u52a0\u5bc6\u65b9\u6cd5\u4e0d\u540c\uff0cECC\u4f9d\u8d56\u4e8e\u89e3\u51b3\u692d\u5706\u66f2\u7ebf\u79bb\u6563\u5bf9\u6570\u95ee\u9898\u7684\u56f0\u96be\u6027\u3002\u5b83\u7684\u4f18\u52bf\u4e3b\u8981\u5728\u4e8e\u76f8\u5bf9\u4e8e\u5176\u5b83\u65b9\u6cd5\uff0c\u5b83\u53ef\u4ee5\u5728\u4f7f\u7528\u8f83\u77ed\u5bc6\u94a5\u957f\u5ea6\u7684\u540c\u65f6\u4fdd\u6301\u76f8\u540c\u7684\u5bc6\u7801\u5f3a\u5ea6\u3002\u76ee\u524d\u692d\u5706\u66f2\u7ebf\u4e3b\u8981\u91c7\u7528\u7684\u6709\u9650\u57df\u6709 \u4ee5\u7d20\u6570\u4e3a\u6a21\u7684\u6574\u6570\u57dfGF(p)\uff0c\u901a\u5e38\u5728\u901a\u7528\u5904\u7406\u5668\u4e0a\u66f4\u4e3a\u6709\u6548\u3002 \u7279\u5f81\u4e3a 2 \u7684\u4f3d\u7f57\u534e\u57dfGF\uff082^m\uff09\uff0c\u53ef\u4ee5\u8bbe\u8ba1\u4e13\u95e8\u7684\u786c\u4ef6\u3002","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#_2","text":"\u6211\u4eec\u9996\u5148\u6765\u4e86\u89e3\u4e00\u4e0b\u6709\u9650\u57df\u4e0a\u7684\u692d\u5706\u66f2\u7ebf\uff0c\u6709\u9650\u57df\u4e0a\u7684\u692d\u5706\u66f2\u7ebf\u662f\u6307\u5728\u692d\u5706\u66f2\u7ebf\u7684\u5b9a\u4e49\u5f0f y^2+axy+by=x^3+cx^2+dx+e y^2+axy+by=x^3+cx^2+dx+e \u4e2d\u6240\u6709\u7684\u7cfb\u6570\u90fd\u662f\u5728\u67d0\u4e2a\u6709\u9650\u57dfGF(p)\u4e2d\u7684\u5143\u7d20\uff0c\u5176\u4e2dp\u4e3a\u4e00\u4e2a\u5927\u7d20\u6570\u3002 \u5f53\u7136\uff0c\u5e76\u4e0d\u662f\u6240\u6709\u7684\u692d\u5706\u66f2\u7ebf\u90fd\u9002\u5408\u4e8e\u52a0\u5bc6\uff0c\u6700\u4e3a\u5e38\u7528\u7684\u65b9\u7a0b\u5982\u4e0b y^2=x^3+ax+b y^2=x^3+ax+b \u5176\u4e2d 4a^3+27b^2 \\bmod p \\neq 0 4a^3+27b^2 \\bmod p \\neq 0 \u6211\u4eec\u79f0\u8be5\u65b9\u7a0b\u7684\u6240\u6709\u89e3(x,y)\uff0c( x\\in Fp , y \\in Fp x\\in Fp , y \\in Fp )\uff0c\u4ee5\u53ca\u4e00\u4e2a\u79f0\u4e3a\u201c\u65e0\u7a77\u8fdc\u70b9\u201d(O)\u7ec4\u6210\u7684\u96c6\u5408\u4e3a\u5b9a\u4e49\u5728Fp\u4e0a\u7684\u4e00\u4e2a\u692d\u5706\u66f2\u7ebf\uff0c\u8bb0\u4e3aE(Fp)\u3002 \u4e00\u822c\u5b9a\u4e49\u692d\u5706\u66f2\u7ebf\u5bc6\u7801\u9700\u8981\u4ee5\u4e0b\u6761\u4ef6 \u5047\u8bbeE(Fp)\u5bf9\u4e8e\u70b9\u7684\u8fd0\u7b97 \\oplus \\oplus \u5f62\u6210\u4e00\u4e2aable\u7fa4\uff08\u4ea4\u6362\u7fa4\uff0c\u9006\u5143\u5b58\u5728\uff0c\u5c01\u95ed\u6027\u7b49\uff09\uff0c\u8bbe p\\in E(Fq) p\\in E(Fq) \uff0c\u4e14\u6ee1\u8db3\u4e0b\u5217\u6761\u4ef6\u7684t\u5f88\u5927 p \\oplus p \\oplus ... \\oplus p=O p \\oplus p \\oplus ... \\oplus p=O \u5176\u4e2d\u5171\u6709t\u4e2ap\u53c2\u4e0e\u8fd0\u7b97\u3002\u8fd9\u91cc\u6211\u4eec\u79f0t\u4e3ap\u7684\u5468\u671f\u3002\u6b64\u5916\uff0c\u5bf9\u4e8e Q\\in E(Fq) Q\\in E(Fq) \uff0c\u5b9a\u6709\u67d0\u4e2a\u6b63\u6574\u6570m\u4f7f\u5f97\u4e0b\u5217\u5f0f\u5b50\u6210\u7acb\uff0c\u5b9a\u4e49 m=log_pq m=log_pq Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p \uff08m\u4e2ap\u53c2\u4e0e\u8fd0\u7b97\uff09 \u6b64\u5916\uff0c\u5047\u8bbeG\u662f\u8be5 E_q (a,b) E_q (a,b) \u7684\u751f\u6210\u5143\uff0c\u5373\u53ef\u4ee5\u751f\u6210\u5176\u4e2d\u7684\u6240\u6709\u5143\u7d20\uff0c\u5176\u9636\u4e3a\u6ee1\u8db3 nG=O nG=O \u7684\u6700\u5c0f\u6b63\u6574\u6570n\u3002","title":"\u57fa\u672c\u77e5\u8bc6"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#eccelgamal","text":"\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u7528\u6237B\u8981\u628a\u6d88\u606f\u52a0\u5bc6\u540e\u4f20\u7ed9\u7528\u6237A\u3002","title":"ECC\u4e2d\u7684ElGamal"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#_3","text":"\u7528\u6237A\u5148\u9009\u62e9\u4e00\u6761\u692d\u5706\u66f2\u7ebf E_q (a,b) E_q (a,b) \uff0c\u7136\u540e\u9009\u62e9\u5176\u4e0a\u7684\u4e00\u4e2a\u751f\u6210\u5143G\uff0c\u5047\u8bbe\u5176\u9636\u4e3an\uff0c\u4e4b\u540e\u518d\u9009\u62e9\u4e00\u4e2a\u6b63\u6574\u6570 n_a n_a \u4f5c\u4e3a\u5bc6\u94a5\uff0c\u8ba1\u7b97 P_a=n_aG P_a=n_aG \u3002 \u5176\u4e2d\uff0c E_q(a,b), q,G E_q(a,b), q,G \u90fd\u4f1a\u88ab\u516c\u5f00\u3002 \u516c\u94a5\u4e3a P_a P_a \uff0c\u79c1\u94a5\u4e3a$n_a $\u3002","title":"\u5bc6\u94a5\u751f\u6210"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#_4","text":"\u7528\u6237B\u5728\u5411\u7528\u6237A\u53d1\u9001\u6d88\u606fm\uff0c\u8fd9\u91cc\u5047\u8bbe\u6d88\u606fm\u5df2\u7ecf\u88ab\u7f16\u7801\u4e3a\u692d\u5706\u66f2\u7ebf\u4e0a\u7684\u70b9\uff0c\u5176\u52a0\u5bc6\u6b65\u9aa4\u5982\u4e0b \u67e5\u8be2\u7528\u6237A\u7684\u516c\u94a5 E_q(a,b), q, P_a,G E_q(a,b), q, P_a,G \u3002 \u5728(1,q-1) \u7684\u533a\u95f4\u5185\u9009\u62e9\u968f\u673a\u6570k \u3002 \u6839\u636eA\u7684\u516c\u94a5\u8ba1\u7b97\u70b9 (x_1,y_1)=kG (x_1,y_1)=kG \u3002 \u8ba1\u7b97\u70b9 (x_2,y_2)=kP_a (x_2,y_2)=kP_a \uff0c\u5982\u679c\u4e3aO\uff0c\u5219\u4ece\u7b2c\u4e8c\u6b65\u91cd\u65b0\u5f00\u59cb\u3002 \u8ba1\u7b97 C=m+(x_2,y_2) C=m+(x_2,y_2) \u5c06 ((x_1,y_1),C) ((x_1,y_1),C) \u53d1\u9001\u7ed9A\u3002","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#_5","text":"\u89e3\u5bc6\u6b65\u9aa4\u5982\u4e0b \u5229\u7528\u79c1\u94a5\u8ba1\u7b97\u70b9 n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) \u3002 \u8ba1\u7b97\u6d88\u606f m=C-(x_2,y_2) m=C-(x_2,y_2) \u3002","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#_6","text":"\u8fd9\u91cc\u7684\u5173\u952e\u70b9\u5728\u4e8e\u6211\u4eec\u5373\u4f7f\u77e5\u9053\u4e86 (x_1,y_1) (x_1,y_1) \u4e5f\u96be\u4ee5\u77e5\u9053k\uff0c\u8fd9\u662f\u7531\u79bb\u6563\u5bf9\u6570\u7684\u95ee\u9898\u7684\u96be\u5ea6\u51b3\u5b9a\u7684\u3002","title":"\u5173\u952e\u70b9"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#2013-seccon-ctf-quals-cryptanalysis","text":"\u8fd9\u91cc\u6211\u4eec\u4ee52013\u5e74SECCON CTF quals \u4e2d\u7684 Cryptanalysis \u4e3a\u4f8b\uff0c\u9898\u76ee\u5982\u4e0b \u8fd9\u91cc\uff0c\u6211\u4eec\u5df2\u77e5\u692d\u5706\u66f2\u7ebf\u65b9\u7a0b\u4ee5\u53ca\u5bf9\u5e94\u7684\u751f\u6210\u5143 base\uff0c\u8fd8\u77e5\u9053\u76f8\u5e94\u7684\u6a21\u6570\u4ee5\u53ca\u516c\u94a5\u4ee5\u53ca\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u3002 \u4f46\u662f\u53ef\u4ee5\u770b\u51fa\u7684\u6211\u4eec\u7684\u6a21\u6570\u592a\u5c0f\uff0c\u6211\u4eec\u66b4\u529b\u679a\u4e3e\u83b7\u53d6\u7ed3\u679c\u3002 \u8fd9\u91cc\u76f4\u63a5\u53c2\u8003 github\u4e0a\u7684 sage \u7a0b\u5e8f\uff0c\u66b4\u529b\u8dd1\u51fa secret key\u3002\u4e4b\u540e\u4fbf\u53ef\u4ee5\u89e3\u5bc6\u4e86\u3002 a = 1234577 b = 3213242 n = 7654319 E = EllipticCurve ( GF ( n ), [ 0 , 0 , 0 , a , b ]) base = E ([ 5234568 , 2287747 ]) pub = E ([ 2366653 , 1424308 ]) c1 = E ([ 5081741 , 6744615 ]) c2 = E ([ 610619 , 6218 ]) X = base for i in range ( 1 , n ): if X == pub : secret = i print \"[+] secret:\" , i break else : X = X + base print i m = c2 - ( c1 * secret ) print \"[+] x:\" , m [ 0 ] print \"[+] y:\" , m [ 1 ] print \"[+] x+y:\" , m [ 0 ] + m [ 1 ] \u66b4\u529b\u8dd1\u51fa\u7ed3\u679c [ + ] secret: 1584718 [ + ] x: 2171002 [ + ] y: 3549912 [ + ] x+y: 5720914","title":"2013 SECCON CTF quals Cryptanalysis"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc-zh/#_7","text":"https://github.com/sonickun/ctf-crypto-writeups/tree/master/2013/seccon-ctf-quals/cryptanalysis","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/","text":"EN | ZH ECC \u00b6 Overview \u00b6 ECC is called elliptic curve encryption, EllipseCurve Cryptography, which is a public key cryptography based on elliptic curve mathematics. Unlike traditional encryption methods based on the difficulty of large-scale factorization, ECC relies on the difficulty of solving the discrete logarithm problem of elliptic curves. Its main advantage is that it can maintain the same password strength while using a shorter key length than other methods. Currently, the finite field mainly used in the elliptic curve has The integer field GF(p), which is modulo prime, is usually more efficient on general purpose processors. The Galois Field GF (2^m) with a feature of 2 can be designed with dedicated hardware. basic knowledge \u00b6 Let us first look at the elliptic curve on the finite field. The elliptic curve on the finite field is the definition of the elliptic curve. y^2+axy+by=x^3+cx^2+dx+e y^2+axy+by=x^3+cx^2+dx+e All coefficients in the finite element GF(p) are elements, where p is a large prime number. Of course, not all elliptic curves are suitable for encryption. The most common equations are as follows y^2=x^3+ax+b y^2=x^3+ax+b Where 4a^3+27b^2 \\bmod p \\neq 0 4a^3+27b^2 \\bmod p \\neq 0 We call all the solutions (x, y), ( x\\in Fp, y \\in Fp x\\in Fp, y \\in Fp ) of the equation, and a set called \"infinity point\" (O) as an ellipse defined on Fp. The curve is denoted as E(Fp). Generally defining elliptic curve passwords requires the following conditions Suppose E(Fp) for the point operation \\oplus \\oplus forms a possible group (commutative group, inverse element existence, closure, etc.), set p\\in E(Fq) p\\in E(Fq) , and the t satisfying the following conditions is very large $ p oplus p oplus ... oplus p = O $ There are a total of t p participating in the operation. Here we call t the period of p. In addition, for Q\\in E(Fq) Q\\in E(Fq) , there is a positive integer m such that the following formula holds, defining m=log_pq m=log_pq Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p (m p participating in the operation) In addition, suppose G is the generator of the E_q (a,b) E_q (a,b) , that is, all the elements in it can be generated, and the order is the smallest positive integer n satisfying nG=O nG=O . ElGamal in ECC \u00b6 Here we assume that User B wants to encrypt the message and pass it to User A. Key Generation \u00b6 User A first selects an elliptic curve E_q (a,b) E_q (a,b) and then selects a generator G on it, assuming its order is n, and then selects a positive integer n_a n_a as the key, and calculates $P_a=n_aG $. Among them, E_q(a,b), q,G E_q(a,b), q,G will be made public. The public key is P_a P_a and the private key is $n_a $. Encryption \u00b6 User B is sending a message m to User A, assuming that message m has been encoded as a point on the elliptic curve, the encryption steps are as follows Query user A's public key E_q(a,b), q, P_a,G E_q(a,b), q, P_a,G . Select the random number k in the interval of (1, q-1). Calculate the point (x_1,y_1)=kG (x_1,y_1)=kG based on A's public key. Calculate the point (x_2,y_2)=kP_a (x_2,y_2)=kP_a . If it is O, restart from the second step. Calculate C=m+(x_2,y_2) C=m+(x_2,y_2) Send ((x_1,y_1),C) ((x_1,y_1),C) to A. Decryption \u00b6 The decryption steps are as follows Calculate the point n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) using the private key. Calculate the message m=C-(x_2,y_2) m=C-(x_2,y_2) . key point \u00b6 The key point here is that even if we know (x_1,y_1) (x_1,y_1) , it is difficult to know k, which is determined by the difficulty of the discrete logarithm problem. 2013 SECCON CTF quals Cryptanalysis \u00b6 Here we take Cryptanalysis in SECCON CTF quals in 2013 as an example. The topics are as follows: Here, we know the elliptic curve equation and the corresponding generator element base, and also know the corresponding modulus and public key and the encrypted result. But we can see that our modulus is too small, we violently enumerate the results. Here directly refer to the sage program on github, violently ran out of the secret key. Then you can decrypt it. a = 1234577 b = 3213242 n = 7654319 E = EllipticCurve ( GF ( n ), [ 0 , 0 , 0 , a , b ]) base = E ([ 5234568 , 2287747 ]) pub = E ([ 2366653 , 1424308 ]) c1 = E ([ 5081741 , 6744615 ]) c2 = E ([ 610619 , 6218 ]) X = base for i in range ( 1 , n ): if X == pub : secret = i print \"[+] secret:\" , i break else : X = X + base print i m = c2 - ( c1 * secret ) print \"[+] x:\" , m [ 0 ] print & quot ;[ + ] y : & quot ;, m [ 1 ] print \"[+] x+y:\" , m [ 0 ] + m [ 1 ] Violence ran out of results [ + ] secret: 1584718 [ + ] x: 2171002 [ + ] and: 3549912 [ + ] x+y: 5720914 Reference \u00b6 https://github.com/sonickun/ctf-crypto-writeups/tree/master/2013/seccon-ctf-quals/cryptanalysis","title":"ECC"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#ecc","text":"","title":"ECC"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#overview","text":"ECC is called elliptic curve encryption, EllipseCurve Cryptography, which is a public key cryptography based on elliptic curve mathematics. Unlike traditional encryption methods based on the difficulty of large-scale factorization, ECC relies on the difficulty of solving the discrete logarithm problem of elliptic curves. Its main advantage is that it can maintain the same password strength while using a shorter key length than other methods. Currently, the finite field mainly used in the elliptic curve has The integer field GF(p), which is modulo prime, is usually more efficient on general purpose processors. The Galois Field GF (2^m) with a feature of 2 can be designed with dedicated hardware.","title":"Overview"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#basic-knowledge","text":"Let us first look at the elliptic curve on the finite field. The elliptic curve on the finite field is the definition of the elliptic curve. y^2+axy+by=x^3+cx^2+dx+e y^2+axy+by=x^3+cx^2+dx+e All coefficients in the finite element GF(p) are elements, where p is a large prime number. Of course, not all elliptic curves are suitable for encryption. The most common equations are as follows y^2=x^3+ax+b y^2=x^3+ax+b Where 4a^3+27b^2 \\bmod p \\neq 0 4a^3+27b^2 \\bmod p \\neq 0 We call all the solutions (x, y), ( x\\in Fp, y \\in Fp x\\in Fp, y \\in Fp ) of the equation, and a set called \"infinity point\" (O) as an ellipse defined on Fp. The curve is denoted as E(Fp). Generally defining elliptic curve passwords requires the following conditions Suppose E(Fp) for the point operation \\oplus \\oplus forms a possible group (commutative group, inverse element existence, closure, etc.), set p\\in E(Fq) p\\in E(Fq) , and the t satisfying the following conditions is very large $ p oplus p oplus ... oplus p = O $ There are a total of t p participating in the operation. Here we call t the period of p. In addition, for Q\\in E(Fq) Q\\in E(Fq) , there is a positive integer m such that the following formula holds, defining m=log_pq m=log_pq Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p Q=m\\cdot p =p \\oplus p \\oplus ... \\oplus p (m p participating in the operation) In addition, suppose G is the generator of the E_q (a,b) E_q (a,b) , that is, all the elements in it can be generated, and the order is the smallest positive integer n satisfying nG=O nG=O .","title":"basic knowledge"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#elgamal-in-ecc","text":"Here we assume that User B wants to encrypt the message and pass it to User A.","title":"ElGamal in ECC"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#key-generation","text":"User A first selects an elliptic curve E_q (a,b) E_q (a,b) and then selects a generator G on it, assuming its order is n, and then selects a positive integer n_a n_a as the key, and calculates $P_a=n_aG $. Among them, E_q(a,b), q,G E_q(a,b), q,G will be made public. The public key is P_a P_a and the private key is $n_a $.","title":"Key Generation"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#encryption","text":"User B is sending a message m to User A, assuming that message m has been encoded as a point on the elliptic curve, the encryption steps are as follows Query user A's public key E_q(a,b), q, P_a,G E_q(a,b), q, P_a,G . Select the random number k in the interval of (1, q-1). Calculate the point (x_1,y_1)=kG (x_1,y_1)=kG based on A's public key. Calculate the point (x_2,y_2)=kP_a (x_2,y_2)=kP_a . If it is O, restart from the second step. Calculate C=m+(x_2,y_2) C=m+(x_2,y_2) Send ((x_1,y_1),C) ((x_1,y_1),C) to A.","title":"Encryption"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#decryption","text":"The decryption steps are as follows Calculate the point n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) n_a(x_1,y_1)=n_akG=kP_a=(x_2,y_2) using the private key. Calculate the message m=C-(x_2,y_2) m=C-(x_2,y_2) .","title":"Decryption"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#key-point","text":"The key point here is that even if we know (x_1,y_1) (x_1,y_1) , it is difficult to know k, which is determined by the difficulty of the discrete logarithm problem.","title":"key point"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#2013-seccon-ctf-quals-cryptanalysis","text":"Here we take Cryptanalysis in SECCON CTF quals in 2013 as an example. The topics are as follows: Here, we know the elliptic curve equation and the corresponding generator element base, and also know the corresponding modulus and public key and the encrypted result. But we can see that our modulus is too small, we violently enumerate the results. Here directly refer to the sage program on github, violently ran out of the secret key. Then you can decrypt it. a = 1234577 b = 3213242 n = 7654319 E = EllipticCurve ( GF ( n ), [ 0 , 0 , 0 , a , b ]) base = E ([ 5234568 , 2287747 ]) pub = E ([ 2366653 , 1424308 ]) c1 = E ([ 5081741 , 6744615 ]) c2 = E ([ 610619 , 6218 ]) X = base for i in range ( 1 , n ): if X == pub : secret = i print \"[+] secret:\" , i break else : X = X + base print i m = c2 - ( c1 * secret ) print \"[+] x:\" , m [ 0 ] print & quot ;[ + ] y : & quot ;, m [ 1 ] print \"[+] x+y:\" , m [ 0 ] + m [ 1 ] Violence ran out of results [ + ] secret: 1584718 [ + ] x: 2171002 [ + ] and: 3549912 [ + ] x+y: 5720914","title":"2013 SECCON CTF quals Cryptanalysis"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/ecc/#reference","text":"https://github.com/sonickun/ctf-crypto-writeups/tree/master/2013/seccon-ctf-quals/cryptanalysis","title":"Reference"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/","text":"EN | ZH ElGamal \u00b6 \u6982\u8ff0 \u00b6 ElGamal\u7b97\u6cd5\u7684\u5b89\u5168\u6027\u662f\u57fa\u4e8e\u6c42\u89e3\u79bb\u6563\u5bf9\u6570\u95ee\u9898\u7684\u56f0\u96be\u6027\uff0c\u4e8e1984\u5e74\u63d0\u51fa\uff0c\u4e5f\u662f\u4e00\u79cd\u53cc\u94a5\u5bc6\u7801\u4f53\u5236\uff0c\u65e2\u53ef\u4ee5\u7528\u4e8e\u52a0\u5bc6\u53c8\u53ef\u7528\u4e8e\u6570\u5b57\u7b7e\u540d\u3002 \u5982\u679c\u6211\u4eec\u5047\u8bbep\u662f\u81f3\u5c11\u662f160\u4f4d\u7684\u5341\u8fdb\u5236\u7d20\u6570\uff0c \u5e76\u4e14p-1\u6709\u5927\u7d20\u56e0\u5b50 \uff0c\u6b64\u5916g\u662f Z_p^* Z_p^* \u7684\u751f\u6210\u5143\uff0c\u5e76\u4e14 y \\in Z_p^* y \\in Z_p^* \u3002\u90a3\u4e48\u5982\u4f55\u627e\u5230\u4e00\u4e2a\u552f\u4e00\u7684\u6574\u6570x( 0\\leq x \\leq p-2 0\\leq x \\leq p-2 ) \uff0c\u6ee1\u8db3 g^x \\equiv y \\bmod p g^x \\equiv y \\bmod p \u5728\u7b97\u6cd5\u4e0a\u662f\u56f0\u96be\u7684\uff0c\u8fd9\u91cc\u5c06x\u8bb0\u4e3a x=log_gy x=log_gy \u3002 \u57fa\u672c\u539f\u7406 \u00b6 \u8fd9\u91cc\u6211\u4eec\u5047\u8bbeA\u8981\u7ed9B\u53d1\u9001\u6d88\u606fm\u3002 \u5bc6\u94a5\u751f\u6210 \u00b6 \u57fa\u672c\u6b65\u9aa4\u5982\u4e0b \u9009\u53d6\u4e00\u4e2a\u8db3\u591f\u5927\u7684\u7d20\u6570p\uff0c\u4ee5\u4fbf\u4e8e\u5728 Z_p Z_p \u4e0a\u6c42\u89e3\u79bb\u6563\u5bf9\u6570\u95ee\u9898\u662f\u56f0\u96be\u7684\u3002 \u9009\u53d6 Z_p^* Z_p^* \u7684\u751f\u6210\u5143g\u3002 \u968f\u673a\u9009\u53d6\u6574\u6570k, 0\\leq k \\leq p-2 0\\leq k \\leq p-2 \uff0c\u5e76\u8ba1\u7b97 g^k \\equiv y \\bmod p g^k \\equiv y \\bmod p \u3002 \u5176\u4e2d\u79c1\u94a5\u4e3a{k}\uff0c\u516c\u94a5\u4e3a{p,g,y} \u3002 \u52a0\u5bc6 \u00b6 A\u9009\u53d6\u968f\u673a\u6570 r \\in Z_{p-1} r \\in Z_{p-1} \uff0c\u5bf9\u660e\u6587\u52a0\u5bc6 E_k(m,r)=(y_1,y_2) E_k(m,r)=(y_1,y_2) \u3002\u5176\u4e2d y_1 \\equiv g^r \\bmod p y_1 \\equiv g^r \\bmod p \uff0c y_2 \\equiv my^r \\bmod p y_2 \\equiv my^r \\bmod p \u3002 \u89e3\u5bc6 \u00b6 D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p \u3002 \u96be\u70b9 \u00b6 \u867d\u7136\u6211\u4eec\u77e5\u9053\u4e86y1,\u4f46\u662f\u6211\u4eec\u5374\u6ca1\u6709\u529e\u6cd5\u77e5\u9053\u5176\u5bf9\u5e94\u7684r\u3002 2015 MMA CTF Alicegame \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee52015\u5e74 MMA-CTF-2015 \u4e2d\u7684 Alicegame \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002\u8fd9\u9898\u6700\u521d\u5728\u6ca1\u6709\u7ed9\u51fa\u6e90\u7801\u7684\u65f6\u5019\u5374\u662f\u6bd4\u8f83\u96be\u505a\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u7ed9\u4e00\u4e2a m\uff0c\u7ed9\u4e00\u4e2a r \u5c31\u5f97\u5230\u52a0\u5bc6\u7ed3\u679c\uff0c\uff0c\u8fd9\u592a\u96be\u60f3\u3002 \u6211\u4eec\u6765\u7b80\u5355\u5206\u6790\u4e00\u4e0b\u6e90\u7801\uff0c\u9996\u5148\u7a0b\u5e8f\u6700\u521d\u751f\u6210\u4e86 pk \u4e0e sk ( pk , sk ) = genkey ( PBITS ) \u5176\u4e2dgenkey\u51fd\u6570\u5982\u4e0b def genkey ( k ): p = getPrime ( k ) g = random . randrange ( 2 , p ) x = random . randrange ( 1 , p - 1 ) h = pow ( g , x , p ) pk = ( p , g , h ) sk = ( p , x ) return ( pk , sk ) p\u4e3ak\u4f4d\u7684\u7d20\u6570\uff0cg\u4e3a(2,p)\u8303\u56f4\u5185\u7684\u4e66\uff0cx\u5728(1,p-1)\u8303\u56f4\u5185\u3002\u5e76\u4e14\u8ba1\u7b97\u4e86 h \\equiv g^x \\bmod p h \\equiv g^x \\bmod p \u3002\u770b\u5230\u8fd9\u91cc\uff0c\u5dee\u4e0d\u591a\u5c31\u77e5\u9053\uff0c\u8fd9\u5e94\u8be5\u662f\u4e00\u4e2a\u6570\u57df\u4e0a\u7684ElGamal\u52a0\u5bc6\u4e86\u3002\u5176\u4e2dpk\u4e3a\u516c\u94a5\uff0csk\u4e3a\u79c1\u94a5\u3002 \u63a5\u4e0b\u6765 \u7a0b\u5e8f\u8f93\u51fa\u4e8610\u6b21m\u548cr\u3002\u5e76\u4e14\uff0c\u5229\u7528\u5982\u4e0b\u51fd\u6570\u52a0\u5bc6 def encrypt ( pk , m , r = None ): ( p , g , h ) = pk if r is None : r = random . randrange ( 1 , p - 1 ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) \u5176\u52a0\u5bc6\u65b9\u6cd5\u786e\u5b9e\u662fElGamal\u65b9\u5f0f\u7684\u52a0\u5bc6\u3002 \u6700\u540e\u7a0b\u5e8f\u5bf9flag\u8fdb\u884c\u4e86\u52a0\u5bc6\u3002\u6b64\u65f6\u7684r\u662f\u7531\u7a0b\u5e8f\u81ea\u5df1random\u7684\u3002 \u5206\u6790\u4e00\u4e0b\uff0c\u8fd9\u91cc\u6211\u4eec\u5728\u5341\u8f6e\u5faa\u73af\u4e2d\u53ef\u4ee5\u63a7\u5236m\u548cr\uff0c\u5e76\u4e14 c_1 \\equiv g^r \\bmod p c_1 \\equiv g^r \\bmod p c_2 \\equiv m * h^{r} \\bmod p c_2 \\equiv m * h^{r} \\bmod p \u5982\u679c\u6211\u4eec\u8bbe\u7f6e r=1\uff0cm=1\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u83b7\u5f97 c_1=g,c_2=h c_1=g,c_2=h \u3002 r=1\uff0cm=-1\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u83b7\u5f97 c_1=g, c_2 = p-h c_1=g, c_2 = p-h \u3002\u8fdb\u800c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230\u7d20\u6570p\u3002 \u6211\u4eec\u5f97\u5230\u7d20\u6570p\u6709\u4ec0\u4e48\u7528\u5462?p\u7684\u4f4d\u6570\u5728201\u4f4d\u5de6\u53f3\uff0c\u5f88\u5927\u554a\u3002 \u4f46\u662f\u554a\uff0c\u5b83\u751f\u6210\u7d20\u6570p\u4e4b\u540e\uff0c\u6ca1\u6709\u8fdb\u884c\u68c0\u67e5\u554a\u3002\u6211\u4eec\u5728\u4e4b\u524d\u8bf4\u8fc7p-1\u5fc5\u987b\u6709\u5927\u7d20\u56e0\u5b50\uff0c\u5982\u679c\u6709\u5c0f\u7684\u7d20\u56e0\u5b50\u7684\u8bdd\uff0c\u90a3\u6211\u4eec\u5c31\u53ef\u4ee5\u653b\u51fb\u4e86\u3002\u5176\u653b\u51fb\u4e3b\u8981\u662f\u4f7f\u7528\u5230\u4e86baby step-giant step \u4e0e Pohlig-Hellman algorithm \u7b97\u6cd5\uff0c\u6709\u5174\u8da3\u7684\u53ef\u4ee5\u770b\u770b\uff0c\u8fd9\u91ccsage\u672c\u8eab\u81ea\u5e26\u7684\u8ba1\u7b97\u79bb\u6563\u5bf9\u6570\u7684\u51fd\u6570\u5df2\u7ecf\u53ef\u4ee5\u5904\u7406\u8fd9\u6837\u7684\u60c5\u51b5\u4e86\uff0c\u53c2\u89c1 discrete_log \u3002 \u5177\u4f53\u4ee3\u7801\u5982\u4e0b\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\uff0c\u8fd9\u4e2a\u6d88\u8017\u5185\u5b58\u6bd4\u8f83\u5927\uff0c\uff0c\u4e0d\u8981\u968f\u4fbf\u62ff\u865a\u62df\u673a\u8dd1\u3002\u3002\u3002\u8fd8\u6709\u5c31\u662f\u8fd9\u5c3c\u739b\u4ea4\u4e92\u8ba9\u6211\u5934\u75bc\u554a\uff0c\uff0c\uff0c import socket from Crypto.Util.number import * from sage.all import * def get_maxfactor ( N ): f = factor ( N ) print 'factor done' return f [ - 1 ][ 0 ] maxnumber = 1 << 70 i = 0 while 1 : print 'cycle: ' , i sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"localhost\" , 9999 )) sock . recv ( 17 ) # get g,h sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 1024 ) ( g , h ) = eval ( data ) # get g,p sock . sendall ( \"-1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 512 ) ( g , tmp ) = eval ( data ) p = tmp + h tmp = get_maxfactor ( p - 1 ) if tmp < maxnumber : print 'may be success' # skip the for cycle sock . sendall ( 'quit \\n ' ); data = sock . recv ( 1024 ) print 'receive data: ' , data data = data [ data . index ( \":\" ) + 1 :] ( c1 , c2 ) = eval ( data ) # generate the group g = Mod ( g , p ) h = Mod ( h , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) x = discrete_log ( h , g ) print \"x = \" , x print \"Flag: \" , long_to_bytes ( long ( c2 / ( c1 ** x ))) sock . sendall ( 'quit \\n ' ) sock . recv ( 1024 ) sock . close () i += 1 \u6700\u540e\u8feb\u4e8e\u8ba1\u7b97\u673a\u5185\u5b58\u4e0d\u591f\uff0c\uff0c\u6ca1\u8ba1\u7b97\u51fa\u6765\uff0c\uff0c\uff0c\u6709\u65f6\u5019\u4f1a\u5d29\uff0c\u591a\u8fd0\u884c\u51e0\u6b21\u3002\u3002 2018 Code Blue lagalem \u00b6 \u9898\u76ee\u63cf\u8ff0\u5982\u4e0b from Crypto.Util.number import * from key import FLAG size = 2048 rand_state = getRandomInteger ( size // 2 ) def keygen ( size ): q = getPrime ( size ) k = 2 while True : p = q * k + 1 if isPrime ( p ): break k += 1 g = 2 while True : if pow ( g , q , p ) == 1 : break g += 1 A = getRandomInteger ( size ) % q B = getRandomInteger ( size ) % q x = getRandomInteger ( size ) % q h = pow ( g , x , p ) return ( g , h , A , B , p , q ), ( x ,) def rand ( A , B , M ): global rand_state rand_state , ret = ( A * rand_state + B ) % M , rand_state return ret def encrypt ( pubkey , m ): g , h , A , B , p , q = pubkey assert 0 < m <= p r = rand ( A , B , q ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) # pubkey, privkey = keygen(size) m = bytes_to_long ( FLAG ) c1 , c2 = encrypt ( pubkey , m ) c1_ , c2_ = encrypt ( pubkey , m ) print pubkey print ( c1 , c2 ) print ( c1_ , c2_ ) \u53ef\u4ee5\u770b\u51fa\uff0c\u8be5\u7b97\u6cd5\u5c31\u662f\u4e00\u4e2a ElGamal \u52a0\u5bc6\uff0c\u7ed9\u4e86\u540c\u4e00\u4e2a\u660e\u6587\u4e24\u7ec4\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\uff0c\u5176\u7279\u70b9\u5728\u4e8e\u4f7f\u7528\u7684\u968f\u673a\u6570 r \u662f\u901a\u8fc7\u7ebf\u6027\u540c\u4f59\u751f\u6210\u5668\u751f\u6210\u7684\uff0c\u5219\u6211\u4eec\u77e5\u9053 c2 \\equiv m * h^{r} \\bmod p c2 \\equiv m * h^{r} \\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p \u5219 c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p \u5176\u4e2d\uff0cc2\uff0cc2_\uff0cA\uff0cB\uff0ch \u5747\u77e5\u9053\u3002\u5219\u6211\u4eec\u77e5\u9053 m^{A-1} \\equiv t \\bmod p m^{A-1} \\equiv t \\bmod p \u6211\u4eec\u5047\u8bbe\u5df2\u77e5 p \u7684\u4e00\u4e2a\u539f\u6839 g\uff0c\u5219\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe g^x \\equiv t g^x \\equiv t g^y \\equiv m g^y \\equiv m \u5219 g^{y(A-1)}\\equiv g^x \\bmod p g^{y(A-1)}\\equiv g^x \\bmod p \u5219 y(A-1) \\equiv x \\bmod p-1 y(A-1) \\equiv x \\bmod p-1 \u8fdb\u800c\u6211\u4eec\u77e5\u9053 y(A-1)-k(p-1)=x y(A-1)-k(p-1)=x \u8fd9\u91cc\u6211\u4eec\u77e5\u9053 A\uff0cp\uff0cx\uff0c\u5219\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406\u6c42\u5f97 s(A-1)+w(p-1)=gcd(A-1,t-1) s(A-1)+w(p-1)=gcd(A-1,t-1) \u5982\u679cgcd(A-1,t-1)=d\uff0c\u5219\u6211\u4eec\u76f4\u63a5\u8ba1\u7b97 t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p \u5982\u679c d=1\uff0c\u5219\u76f4\u63a5\u77e5\u9053 m\u3002 \u5982\u679c d \u4e0d\u4e3a1\uff0c\u5219\u5c31\u6709\u70b9\u9ebb\u70e6\u4e86\u3002\u3002 \u8fd9\u91cc\u8fd9\u9053\u9898\u76ee\u4e2d\u6070\u597d d=1\uff0c\u56e0\u6b64\u53ef\u4ee5\u5f88\u5bb9\u6613\u8fdb\u884c\u6c42\u89e3\u3002 import gmpy2 data = open ( './transcript.txt' ) . read () . split ( ' \\n ' ) g , h , A , B , p , q = eval ( data [ 0 ]) c1 , c2 = eval ( data [ 1 ]) c1_ , c2_ = eval ( data [ 2 ]) tmp = gmpy2 . powmod ( c2 , A , p ) * gmpy2 . powmod ( h , B , p ) * gmpy2 . invert ( c2_ , p ) tmp = tmp % p print 't=' , tmp print 'A=' , A print 'p=' , p gg , x , y = gmpy2 . gcdext ( A - 1 , p - 1 ) print gg m = gmpy2 . powmod ( tmp , x , p ) print hex ( m )[ 2 :] . decode ( 'hex' ) flag \u279c 2018 -CodeBlue-lagalem git: ( master ) \u2717 python exp.py t = 24200833701856688878756977616650401715079183425722900529883514170904572086655826119242478732147288453761668954561939121426507899982627823151671207325781939341536650446260662452251070281875998376892857074363464032471952373518723746478141532996553854860936891133020681787570469383635252298945995672350873354628222982549233490189069478253457618473798487302495173105238289131448773538891748786125439847903309001198270694350004806890056215413633506973762313723658679532448729713653832387018928329243004507575710557548103815480626921755313420592693751934239155279580621162244859702224854316335659710333994740615748525806865323 A = 22171697832053348372915156043907956018090374461486719823366788630982715459384574553995928805167650346479356982401578161672693725423656918877111472214422442822321625228790031176477006387102261114291881317978365738605597034007565240733234828473235498045060301370063576730214239276663597216959028938702407690674202957249530224200656409763758677312265502252459474165905940522616924153211785956678275565280913390459395819438405830015823251969534345394385537526648860230429494250071276556746938056133344210445379647457181241674557283446678737258648530017213913802458974971453566678233726954727138234790969492546826523537158 p = 36416598149204678746613774367335394418818540686081178949292703167146103769686977098311936910892255381505012076996538695563763728453722792393508239790798417928810924208352785963037070885776153765280985533615624550198273407375650747001758391126814998498088382510133441013074771543464269812056636761840445695357746189203973350947418017496096468209755162029601945293367109584953080901393887040618021500119075628542529750701055865457182596931680189830763274025951607252183893164091069436120579097006203008253591406223666572333518943654621052210438476603030156263623221155480270748529488292790643952121391019941280923396132717 1 CBCTF { 183a3ce8ed93df613b002252dfc741b2 } \u53c2\u8003 \u00b6 https://www.math.auckland.ac.nz/~sgal018/crypto-book/solns.pdf \uff0c20.4.1","title":"Elgamal zh"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#elgamal","text":"","title":"ElGamal"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#_1","text":"ElGamal\u7b97\u6cd5\u7684\u5b89\u5168\u6027\u662f\u57fa\u4e8e\u6c42\u89e3\u79bb\u6563\u5bf9\u6570\u95ee\u9898\u7684\u56f0\u96be\u6027\uff0c\u4e8e1984\u5e74\u63d0\u51fa\uff0c\u4e5f\u662f\u4e00\u79cd\u53cc\u94a5\u5bc6\u7801\u4f53\u5236\uff0c\u65e2\u53ef\u4ee5\u7528\u4e8e\u52a0\u5bc6\u53c8\u53ef\u7528\u4e8e\u6570\u5b57\u7b7e\u540d\u3002 \u5982\u679c\u6211\u4eec\u5047\u8bbep\u662f\u81f3\u5c11\u662f160\u4f4d\u7684\u5341\u8fdb\u5236\u7d20\u6570\uff0c \u5e76\u4e14p-1\u6709\u5927\u7d20\u56e0\u5b50 \uff0c\u6b64\u5916g\u662f Z_p^* Z_p^* \u7684\u751f\u6210\u5143\uff0c\u5e76\u4e14 y \\in Z_p^* y \\in Z_p^* \u3002\u90a3\u4e48\u5982\u4f55\u627e\u5230\u4e00\u4e2a\u552f\u4e00\u7684\u6574\u6570x( 0\\leq x \\leq p-2 0\\leq x \\leq p-2 ) \uff0c\u6ee1\u8db3 g^x \\equiv y \\bmod p g^x \\equiv y \\bmod p \u5728\u7b97\u6cd5\u4e0a\u662f\u56f0\u96be\u7684\uff0c\u8fd9\u91cc\u5c06x\u8bb0\u4e3a x=log_gy x=log_gy \u3002","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#_2","text":"\u8fd9\u91cc\u6211\u4eec\u5047\u8bbeA\u8981\u7ed9B\u53d1\u9001\u6d88\u606fm\u3002","title":"\u57fa\u672c\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#_3","text":"\u57fa\u672c\u6b65\u9aa4\u5982\u4e0b \u9009\u53d6\u4e00\u4e2a\u8db3\u591f\u5927\u7684\u7d20\u6570p\uff0c\u4ee5\u4fbf\u4e8e\u5728 Z_p Z_p \u4e0a\u6c42\u89e3\u79bb\u6563\u5bf9\u6570\u95ee\u9898\u662f\u56f0\u96be\u7684\u3002 \u9009\u53d6 Z_p^* Z_p^* \u7684\u751f\u6210\u5143g\u3002 \u968f\u673a\u9009\u53d6\u6574\u6570k, 0\\leq k \\leq p-2 0\\leq k \\leq p-2 \uff0c\u5e76\u8ba1\u7b97 g^k \\equiv y \\bmod p g^k \\equiv y \\bmod p \u3002 \u5176\u4e2d\u79c1\u94a5\u4e3a{k}\uff0c\u516c\u94a5\u4e3a{p,g,y} \u3002","title":"\u5bc6\u94a5\u751f\u6210"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#_4","text":"A\u9009\u53d6\u968f\u673a\u6570 r \\in Z_{p-1} r \\in Z_{p-1} \uff0c\u5bf9\u660e\u6587\u52a0\u5bc6 E_k(m,r)=(y_1,y_2) E_k(m,r)=(y_1,y_2) \u3002\u5176\u4e2d y_1 \\equiv g^r \\bmod p y_1 \\equiv g^r \\bmod p \uff0c y_2 \\equiv my^r \\bmod p y_2 \\equiv my^r \\bmod p \u3002","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#_5","text":"D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p \u3002","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#_6","text":"\u867d\u7136\u6211\u4eec\u77e5\u9053\u4e86y1,\u4f46\u662f\u6211\u4eec\u5374\u6ca1\u6709\u529e\u6cd5\u77e5\u9053\u5176\u5bf9\u5e94\u7684r\u3002","title":"\u96be\u70b9"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#2015-mma-ctf-alicegame","text":"\u8fd9\u91cc\u6211\u4eec\u4ee52015\u5e74 MMA-CTF-2015 \u4e2d\u7684 Alicegame \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002\u8fd9\u9898\u6700\u521d\u5728\u6ca1\u6709\u7ed9\u51fa\u6e90\u7801\u7684\u65f6\u5019\u5374\u662f\u6bd4\u8f83\u96be\u505a\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u7ed9\u4e00\u4e2a m\uff0c\u7ed9\u4e00\u4e2a r \u5c31\u5f97\u5230\u52a0\u5bc6\u7ed3\u679c\uff0c\uff0c\u8fd9\u592a\u96be\u60f3\u3002 \u6211\u4eec\u6765\u7b80\u5355\u5206\u6790\u4e00\u4e0b\u6e90\u7801\uff0c\u9996\u5148\u7a0b\u5e8f\u6700\u521d\u751f\u6210\u4e86 pk \u4e0e sk ( pk , sk ) = genkey ( PBITS ) \u5176\u4e2dgenkey\u51fd\u6570\u5982\u4e0b def genkey ( k ): p = getPrime ( k ) g = random . randrange ( 2 , p ) x = random . randrange ( 1 , p - 1 ) h = pow ( g , x , p ) pk = ( p , g , h ) sk = ( p , x ) return ( pk , sk ) p\u4e3ak\u4f4d\u7684\u7d20\u6570\uff0cg\u4e3a(2,p)\u8303\u56f4\u5185\u7684\u4e66\uff0cx\u5728(1,p-1)\u8303\u56f4\u5185\u3002\u5e76\u4e14\u8ba1\u7b97\u4e86 h \\equiv g^x \\bmod p h \\equiv g^x \\bmod p \u3002\u770b\u5230\u8fd9\u91cc\uff0c\u5dee\u4e0d\u591a\u5c31\u77e5\u9053\uff0c\u8fd9\u5e94\u8be5\u662f\u4e00\u4e2a\u6570\u57df\u4e0a\u7684ElGamal\u52a0\u5bc6\u4e86\u3002\u5176\u4e2dpk\u4e3a\u516c\u94a5\uff0csk\u4e3a\u79c1\u94a5\u3002 \u63a5\u4e0b\u6765 \u7a0b\u5e8f\u8f93\u51fa\u4e8610\u6b21m\u548cr\u3002\u5e76\u4e14\uff0c\u5229\u7528\u5982\u4e0b\u51fd\u6570\u52a0\u5bc6 def encrypt ( pk , m , r = None ): ( p , g , h ) = pk if r is None : r = random . randrange ( 1 , p - 1 ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) \u5176\u52a0\u5bc6\u65b9\u6cd5\u786e\u5b9e\u662fElGamal\u65b9\u5f0f\u7684\u52a0\u5bc6\u3002 \u6700\u540e\u7a0b\u5e8f\u5bf9flag\u8fdb\u884c\u4e86\u52a0\u5bc6\u3002\u6b64\u65f6\u7684r\u662f\u7531\u7a0b\u5e8f\u81ea\u5df1random\u7684\u3002 \u5206\u6790\u4e00\u4e0b\uff0c\u8fd9\u91cc\u6211\u4eec\u5728\u5341\u8f6e\u5faa\u73af\u4e2d\u53ef\u4ee5\u63a7\u5236m\u548cr\uff0c\u5e76\u4e14 c_1 \\equiv g^r \\bmod p c_1 \\equiv g^r \\bmod p c_2 \\equiv m * h^{r} \\bmod p c_2 \\equiv m * h^{r} \\bmod p \u5982\u679c\u6211\u4eec\u8bbe\u7f6e r=1\uff0cm=1\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u83b7\u5f97 c_1=g,c_2=h c_1=g,c_2=h \u3002 r=1\uff0cm=-1\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u83b7\u5f97 c_1=g, c_2 = p-h c_1=g, c_2 = p-h \u3002\u8fdb\u800c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230\u7d20\u6570p\u3002 \u6211\u4eec\u5f97\u5230\u7d20\u6570p\u6709\u4ec0\u4e48\u7528\u5462?p\u7684\u4f4d\u6570\u5728201\u4f4d\u5de6\u53f3\uff0c\u5f88\u5927\u554a\u3002 \u4f46\u662f\u554a\uff0c\u5b83\u751f\u6210\u7d20\u6570p\u4e4b\u540e\uff0c\u6ca1\u6709\u8fdb\u884c\u68c0\u67e5\u554a\u3002\u6211\u4eec\u5728\u4e4b\u524d\u8bf4\u8fc7p-1\u5fc5\u987b\u6709\u5927\u7d20\u56e0\u5b50\uff0c\u5982\u679c\u6709\u5c0f\u7684\u7d20\u56e0\u5b50\u7684\u8bdd\uff0c\u90a3\u6211\u4eec\u5c31\u53ef\u4ee5\u653b\u51fb\u4e86\u3002\u5176\u653b\u51fb\u4e3b\u8981\u662f\u4f7f\u7528\u5230\u4e86baby step-giant step \u4e0e Pohlig-Hellman algorithm \u7b97\u6cd5\uff0c\u6709\u5174\u8da3\u7684\u53ef\u4ee5\u770b\u770b\uff0c\u8fd9\u91ccsage\u672c\u8eab\u81ea\u5e26\u7684\u8ba1\u7b97\u79bb\u6563\u5bf9\u6570\u7684\u51fd\u6570\u5df2\u7ecf\u53ef\u4ee5\u5904\u7406\u8fd9\u6837\u7684\u60c5\u51b5\u4e86\uff0c\u53c2\u89c1 discrete_log \u3002 \u5177\u4f53\u4ee3\u7801\u5982\u4e0b\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\uff0c\u8fd9\u4e2a\u6d88\u8017\u5185\u5b58\u6bd4\u8f83\u5927\uff0c\uff0c\u4e0d\u8981\u968f\u4fbf\u62ff\u865a\u62df\u673a\u8dd1\u3002\u3002\u3002\u8fd8\u6709\u5c31\u662f\u8fd9\u5c3c\u739b\u4ea4\u4e92\u8ba9\u6211\u5934\u75bc\u554a\uff0c\uff0c\uff0c import socket from Crypto.Util.number import * from sage.all import * def get_maxfactor ( N ): f = factor ( N ) print 'factor done' return f [ - 1 ][ 0 ] maxnumber = 1 << 70 i = 0 while 1 : print 'cycle: ' , i sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"localhost\" , 9999 )) sock . recv ( 17 ) # get g,h sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 1024 ) ( g , h ) = eval ( data ) # get g,p sock . sendall ( \"-1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 512 ) ( g , tmp ) = eval ( data ) p = tmp + h tmp = get_maxfactor ( p - 1 ) if tmp < maxnumber : print 'may be success' # skip the for cycle sock . sendall ( 'quit \\n ' ); data = sock . recv ( 1024 ) print 'receive data: ' , data data = data [ data . index ( \":\" ) + 1 :] ( c1 , c2 ) = eval ( data ) # generate the group g = Mod ( g , p ) h = Mod ( h , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) x = discrete_log ( h , g ) print \"x = \" , x print \"Flag: \" , long_to_bytes ( long ( c2 / ( c1 ** x ))) sock . sendall ( 'quit \\n ' ) sock . recv ( 1024 ) sock . close () i += 1 \u6700\u540e\u8feb\u4e8e\u8ba1\u7b97\u673a\u5185\u5b58\u4e0d\u591f\uff0c\uff0c\u6ca1\u8ba1\u7b97\u51fa\u6765\uff0c\uff0c\uff0c\u6709\u65f6\u5019\u4f1a\u5d29\uff0c\u591a\u8fd0\u884c\u51e0\u6b21\u3002\u3002","title":"2015 MMA CTF Alicegame"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#2018-code-blue-lagalem","text":"\u9898\u76ee\u63cf\u8ff0\u5982\u4e0b from Crypto.Util.number import * from key import FLAG size = 2048 rand_state = getRandomInteger ( size // 2 ) def keygen ( size ): q = getPrime ( size ) k = 2 while True : p = q * k + 1 if isPrime ( p ): break k += 1 g = 2 while True : if pow ( g , q , p ) == 1 : break g += 1 A = getRandomInteger ( size ) % q B = getRandomInteger ( size ) % q x = getRandomInteger ( size ) % q h = pow ( g , x , p ) return ( g , h , A , B , p , q ), ( x ,) def rand ( A , B , M ): global rand_state rand_state , ret = ( A * rand_state + B ) % M , rand_state return ret def encrypt ( pubkey , m ): g , h , A , B , p , q = pubkey assert 0 < m <= p r = rand ( A , B , q ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) # pubkey, privkey = keygen(size) m = bytes_to_long ( FLAG ) c1 , c2 = encrypt ( pubkey , m ) c1_ , c2_ = encrypt ( pubkey , m ) print pubkey print ( c1 , c2 ) print ( c1_ , c2_ ) \u53ef\u4ee5\u770b\u51fa\uff0c\u8be5\u7b97\u6cd5\u5c31\u662f\u4e00\u4e2a ElGamal \u52a0\u5bc6\uff0c\u7ed9\u4e86\u540c\u4e00\u4e2a\u660e\u6587\u4e24\u7ec4\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\uff0c\u5176\u7279\u70b9\u5728\u4e8e\u4f7f\u7528\u7684\u968f\u673a\u6570 r \u662f\u901a\u8fc7\u7ebf\u6027\u540c\u4f59\u751f\u6210\u5668\u751f\u6210\u7684\uff0c\u5219\u6211\u4eec\u77e5\u9053 c2 \\equiv m * h^{r} \\bmod p c2 \\equiv m * h^{r} \\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p \u5219 c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p \u5176\u4e2d\uff0cc2\uff0cc2_\uff0cA\uff0cB\uff0ch \u5747\u77e5\u9053\u3002\u5219\u6211\u4eec\u77e5\u9053 m^{A-1} \\equiv t \\bmod p m^{A-1} \\equiv t \\bmod p \u6211\u4eec\u5047\u8bbe\u5df2\u77e5 p \u7684\u4e00\u4e2a\u539f\u6839 g\uff0c\u5219\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe g^x \\equiv t g^x \\equiv t g^y \\equiv m g^y \\equiv m \u5219 g^{y(A-1)}\\equiv g^x \\bmod p g^{y(A-1)}\\equiv g^x \\bmod p \u5219 y(A-1) \\equiv x \\bmod p-1 y(A-1) \\equiv x \\bmod p-1 \u8fdb\u800c\u6211\u4eec\u77e5\u9053 y(A-1)-k(p-1)=x y(A-1)-k(p-1)=x \u8fd9\u91cc\u6211\u4eec\u77e5\u9053 A\uff0cp\uff0cx\uff0c\u5219\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u5b9a\u7406\u6c42\u5f97 s(A-1)+w(p-1)=gcd(A-1,t-1) s(A-1)+w(p-1)=gcd(A-1,t-1) \u5982\u679cgcd(A-1,t-1)=d\uff0c\u5219\u6211\u4eec\u76f4\u63a5\u8ba1\u7b97 t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p \u5982\u679c d=1\uff0c\u5219\u76f4\u63a5\u77e5\u9053 m\u3002 \u5982\u679c d \u4e0d\u4e3a1\uff0c\u5219\u5c31\u6709\u70b9\u9ebb\u70e6\u4e86\u3002\u3002 \u8fd9\u91cc\u8fd9\u9053\u9898\u76ee\u4e2d\u6070\u597d d=1\uff0c\u56e0\u6b64\u53ef\u4ee5\u5f88\u5bb9\u6613\u8fdb\u884c\u6c42\u89e3\u3002 import gmpy2 data = open ( './transcript.txt' ) . read () . split ( ' \\n ' ) g , h , A , B , p , q = eval ( data [ 0 ]) c1 , c2 = eval ( data [ 1 ]) c1_ , c2_ = eval ( data [ 2 ]) tmp = gmpy2 . powmod ( c2 , A , p ) * gmpy2 . powmod ( h , B , p ) * gmpy2 . invert ( c2_ , p ) tmp = tmp % p print 't=' , tmp print 'A=' , A print 'p=' , p gg , x , y = gmpy2 . gcdext ( A - 1 , p - 1 ) print gg m = gmpy2 . powmod ( tmp , x , p ) print hex ( m )[ 2 :] . decode ( 'hex' ) flag \u279c 2018 -CodeBlue-lagalem git: ( master ) \u2717 python exp.py t = 24200833701856688878756977616650401715079183425722900529883514170904572086655826119242478732147288453761668954561939121426507899982627823151671207325781939341536650446260662452251070281875998376892857074363464032471952373518723746478141532996553854860936891133020681787570469383635252298945995672350873354628222982549233490189069478253457618473798487302495173105238289131448773538891748786125439847903309001198270694350004806890056215413633506973762313723658679532448729713653832387018928329243004507575710557548103815480626921755313420592693751934239155279580621162244859702224854316335659710333994740615748525806865323 A = 22171697832053348372915156043907956018090374461486719823366788630982715459384574553995928805167650346479356982401578161672693725423656918877111472214422442822321625228790031176477006387102261114291881317978365738605597034007565240733234828473235498045060301370063576730214239276663597216959028938702407690674202957249530224200656409763758677312265502252459474165905940522616924153211785956678275565280913390459395819438405830015823251969534345394385537526648860230429494250071276556746938056133344210445379647457181241674557283446678737258648530017213913802458974971453566678233726954727138234790969492546826523537158 p = 36416598149204678746613774367335394418818540686081178949292703167146103769686977098311936910892255381505012076996538695563763728453722792393508239790798417928810924208352785963037070885776153765280985533615624550198273407375650747001758391126814998498088382510133441013074771543464269812056636761840445695357746189203973350947418017496096468209755162029601945293367109584953080901393887040618021500119075628542529750701055865457182596931680189830763274025951607252183893164091069436120579097006203008253591406223666572333518943654621052210438476603030156263623221155480270748529488292790643952121391019941280923396132717 1 CBCTF { 183a3ce8ed93df613b002252dfc741b2 }","title":"2018 Code Blue lagalem"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal-zh/#_7","text":"https://www.math.auckland.ac.nz/~sgal018/crypto-book/solns.pdf \uff0c20.4.1","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/","text":"EN | ZH ElGamal \u00b6 Overview \u00b6 The security of the ElGamal algorithm is based on the difficulty of solving the discrete logarithm problem. It was proposed in 1984 and is also a double-key cryptosystem, which can be used for both encryption and digital signature. If we assume that p is a decimal prime of at least 160 bits, and p-1 has a large prime factor , and g is the generator of Z_p^* Z_p^* , and y \\in Z_p^* y \\in Z_p^* . So how to find a unique integer x ( 0\\leq x \\leq p-2 0\\leq x \\leq p-2 ) that satisfies g^x \\equiv y \\bmod p g^x \\equiv y \\bmod p is algorithmically difficult, here is x as x=log_gy x=log_gy . Fundamental \u00b6 Here we assume that A wants to send a message m to B. Key Generation \u00b6 The basic steps are as follows It is difficult to choose a prime p that is large enough to solve the discrete logarithm problem on Z_p Z_p . Select the generator g of Z_p^* Z_p^* . Randomly select the integer k, 0\\leq k \\leq p-2 0\\leq k \\leq p-2 , and calculate g^k \\equiv y \\bmod p g^k \\equiv y \\bmod p . The private key is {k} and the public key is {p,g,y}. Encryption \u00b6 A selects the random number r \\in Z_{p-1} r \\in Z_{p-1} and encrypts the plaintext E_k(m,r)=(y_1,y_2) E_k(m,r)=(y_1,y_2) . Where y_1 \\equiv g^r \\bmod p y_1 \\equiv g^r \\bmod p , y_2 \\equiv my^r \\bmod p y_2 \\equiv my^r \\bmod p . Decryption \u00b6 D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p \u3002 Difficult \u00b6 Although we know y1, we have no way of knowing the corresponding r. 2015 MMA CTF Alicegame \u00b6 Here we take Alicegame in MMA-CTF-2015 in 2015 as an example. This question was originally difficult to do when the source code was not given, because this gives an m, and gives an r to get the encrypted result, which is too difficult to think about. Let's analyze the source code briefly. First, the program originally generated pk and sk. ( pk , sk ) = genkey ( PBITS ) Where the genkey function is as follows def genkey ( k ): p = getPrime ( k ) g = random . randrange ( 2 , p ) x = random . randrange ( 1 , p - 1 ) h = pow ( g , x , p ) pk = ( p , g , h ) sk = ( p , x ) return ( pk , sk ) p is the prime number of the k position, g is the book in the range of (2, p), and x is in the range of (1, p-1). And calculated h \\equiv g^x \\bmod p h \\equiv g^x \\bmod p . Seeing this, I almost know that this should be an ElGamal encryption on a number field. Where pk is the public key and sk is the private key. The program then outputs 10 times m and r. And, use the following function to encrypt def encrypt ( pk , m , r = None ): ( p , g , h ) = pk if r is None : r = random . randrange ( 1 , p - 1 ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) Its encryption method is indeed ElGamal encryption. Finally the program encrypts the flag. At this time r is by the program itself random. Analysis, here we can control m and r in ten rounds, and c_1 \\equiv g^r \\bmod p c_1 \\equiv g^r \\bmod p c_2 \\equiv m * h^{r} \\bmod p c_2 \\equiv m * h^{r} \\bmod p If we set r=1, m=1, then we can get c_1=g, c_2=h c_1=g, c_2=h . r=1, m=-1, then we can get c_1=g, c_2 = ph c_1=g, c_2 = ph . Then we can get the prime number p. What is the use of prime p? The number of bits in p is around 201, which is very big. But ah, after it generated the prime number p, it was not checked. We have said before that p-1 must have a large factor, and if there is a small prime factor, then we can attack. The attack mainly uses the baby step-giant step and Pohlig-Hellman algorithm algorithm. If you are interested, you can look at it. Here, the sage itself has a function to calculate the discrete logarithm, which can handle such a situation. See discrete_log . The specific code is as follows, it should be noted that this memory consumption is relatively large, do not just take the virtual machine to run. . . There is also this Nima interaction that makes me a headache,,,, import socket from Crypto.Util.number import * from sage.all import * def get_maxfactor ( N ): f = factor ( N ) print 'factor done' return f [ - 1 ][ 0 ] maxnumber = 1 << 70 i = 0 while 1 : print 'cycle: ' , i sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"localhost\" , 9999 )) sock . recv ( 17 ) # get g,h sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 1024 ) ( g , h ) = eval ( data ) # get g,p sock . sendall ( \"-1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 512 ) ( g , tmp ) = eval ( data ) p = tmp + h tmp = get_maxfactor ( p - 1 ) if tmp < maxnumber : print 'may be success' # skip the for cycle sock . sendall ( 'quit \\n ' ); data = sock . recv ( 1024 ) print 'receive data: ' , data data = data [ data . index ( \":\" ) + 1 :] ( c1 , c2 ) = eval ( data ) # generate the group g = Mod ( g , p ) h = Mod ( h , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) x = discrete_log ( h , g ) print \"x = \" , x print \"Flag: \" , long_to_bytes ( long ( c2 / ( c1 ** x ))) sock . sendall ( 'quit \\n ' ) sock . recv ( 1024 ) sock . close () i += 1 In the end, the computer is not enough memory, it is not calculated, and sometimes it will collapse and run a few times. . 2018 Code Blue lagalem \u00b6 The title is described below from Crypto.Util.number import * from key import FLAG size = 2048 rand_state = getRandomInteger ( size // 2 ) def keygen ( size ): q = getPrime ( size ) k = 2 while True : p = q * k + 1 if isPrime ( p ): break k + = 1 g = 2 while True : if pow ( g , q , p ) == 1 : break g += 1 A = getRandomInteger ( size ) % q B = getRandomInteger ( size ) % q x = getRandomInteger ( size ) % q h = pow ( g , x , p ) return ( g , h , A , B , p , q ), ( x ,) def rand ( A , B , M ): global rand_state rand_state , ret = ( A * rand_state + B ) % M , rand_state return right def encrypt ( pubkey , m ): g , h , A , B , p , q = pubkey assert 0 < m <= p r = rand ( A , B , q ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) # pubkey, privkey = keygen(size) m = bytes_to_long ( FLAG ) c1 , c2 = encrypt ( pubkey , m ) c1_ , c2_ = encrypt ( pubkey , m ) print pubkey print ( c1 , c2 ) print ( c1_ , c2_ ) It can be seen that the algorithm is an ElGamal encryption, which gives the same plaintext two sets of encrypted results. The characteristic is that the random number r used is generated by the linear congruential generator, then we know c2 \\equiv m * h^{r} \\bmod p c2 \\equiv m * h^{r} \\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p then c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p Among them, c2, c2_, A, B, h are known. Then we know m^{A-1} \\equiv t \\bmod p m^{A-1} \\equiv t \\bmod p We assume that we know a primitive root g of p, then we can assume g^x \\equiv t g^x \\equiv t g^y \\equiv m g^y \\equiv m then g^{y(A-1)}\\equiv g^x \\bmod p g^{y(A-1)}\\equiv g^x \\bmod p then y(A-1) \\equiv x \\bmod p-1 y(A-1) \\equiv x \\bmod p-1 Then we know y(A-1)-k(p-1)=x y(A-1)-k(p-1)=x Here we know A, p, x, then we can use the extended Euclidean theorem to find s(A-1)+w(p-1)=gcd(A-1,t-1) s(A-1)+w(p-1)=gcd(A-1,t-1) If gcd(A-1, t-1)=d, then we calculate directly t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p If d=1, then m is directly known. If d is not 1, then it is a bit of a hassle. . This problem is exactly d=1, so it can be solved easily. import gmpy2 data = open ( './transcript.txt' ) . read () . split ( ' \\n ' ) g , h , A , B , p , q = eval ( data [ 0 ]) c1 , c2 = eval ( data [ 1 ]) c1_ , c2_ = eval ( data [ 2 ]) tmp = gmpy2 . powmod ( c2 , A , p ) * gmpy2 . powmod ( h , B , p ) * gmpy2 . invert ( c2_ , p ) tmp = tmp % p print 't=' , tmp print 'A=' , A Print & #39;= p, p gg , x , y = gmpy2 . gcdext ( A - 1 , p - 1 ) print gg m = gmpy2 . powmod ( tmp , x , p ) print hex ( m )[ 2 :] . decode ( 'hex' ) flag \u279c 2018 -CodeBlue-lagalem git: ( master ) \u2717 python exp.py t = 24200833701856688878756977616650401715079183425722900529883514170904572086655826119242478732147288453761668954561939121426507899982627823151671207325781939341536650446260662452251070281875998376892857074363464032471952373518723746478141532996553854860936891133020681787570469383635252298945995672350873354628222982549233490189069478253457618473798487302495173105238289131448773538891748786125439847903309001198270694350004806890056215413633506973762313723658679532448729713653832387018928329243004507575710557548103815480626921755313420592693751934239155279580621162244859702224854316335659710333994740615748525806865323 A = 22171697832053348372915156043907956018090374461486719823366788630982715459384574553995928805167650346479356982401578161672693725423656918877111472214422442822321625228790031176477006387102261114291881317978365738605597034007565240733234828473235498045060301370063576730214239276663597216959028938702407690674202957249530224200656409763758677312265502252459474165905940522616924153211785956678275565280913390459395819438405830015823251969534345394385537526648860230429494250071276556746938056133344210445379647457181241674557283446678737258648530017213913802458974971453566678233726954727138234790969492546826523537158 p = 36416598149204678746613774367335394418818540686081178949292703167146103769686977098311936910892255381505012076996538695563763728453722792393508239790798417928810924208352785963037070885776153765280985533615624550198273407375650747001758391126814998498088382510133441013074771543464269812056636761840445695357746189203973350947418017496096468209755162029601945293367109584953080901393887040618021500119075628542529750701055865457182596931680189830763274025951607252183893164091069436120579097006203008253591406223666572333518943654621052210438476603030156263623221155480270748529488292790643952121391019941280923396132717 1 CBCTF { 183a3ce8ed93df613b002252dfc741b2 } Reference \u00b6 https://www.math.auckland.ac.nz/~sgal018/crypto-book/solns.pdf \uff0c20.4.1","title":"Elgamal"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#elgamal","text":"","title":"ElGamal"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#overview","text":"The security of the ElGamal algorithm is based on the difficulty of solving the discrete logarithm problem. It was proposed in 1984 and is also a double-key cryptosystem, which can be used for both encryption and digital signature. If we assume that p is a decimal prime of at least 160 bits, and p-1 has a large prime factor , and g is the generator of Z_p^* Z_p^* , and y \\in Z_p^* y \\in Z_p^* . So how to find a unique integer x ( 0\\leq x \\leq p-2 0\\leq x \\leq p-2 ) that satisfies g^x \\equiv y \\bmod p g^x \\equiv y \\bmod p is algorithmically difficult, here is x as x=log_gy x=log_gy .","title":"Overview"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#fundamental","text":"Here we assume that A wants to send a message m to B.","title":"Fundamental"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#key-generation","text":"The basic steps are as follows It is difficult to choose a prime p that is large enough to solve the discrete logarithm problem on Z_p Z_p . Select the generator g of Z_p^* Z_p^* . Randomly select the integer k, 0\\leq k \\leq p-2 0\\leq k \\leq p-2 , and calculate g^k \\equiv y \\bmod p g^k \\equiv y \\bmod p . The private key is {k} and the public key is {p,g,y}.","title":"Key Generation"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#encryption","text":"A selects the random number r \\in Z_{p-1} r \\in Z_{p-1} and encrypts the plaintext E_k(m,r)=(y_1,y_2) E_k(m,r)=(y_1,y_2) . Where y_1 \\equiv g^r \\bmod p y_1 \\equiv g^r \\bmod p , y_2 \\equiv my^r \\bmod p y_2 \\equiv my^r \\bmod p .","title":"Encryption"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#decryption","text":"D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p D_k(y_1,y_2)=y_2(y_1^k)^-1 \\bmod p \\equiv m(g^k)^r(g^{rk})^{-1} \\equiv m \\bmod p \u3002","title":"Decryption"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#difficult","text":"Although we know y1, we have no way of knowing the corresponding r.","title":"Difficult"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#2015-mma-ctf-alicegame","text":"Here we take Alicegame in MMA-CTF-2015 in 2015 as an example. This question was originally difficult to do when the source code was not given, because this gives an m, and gives an r to get the encrypted result, which is too difficult to think about. Let's analyze the source code briefly. First, the program originally generated pk and sk. ( pk , sk ) = genkey ( PBITS ) Where the genkey function is as follows def genkey ( k ): p = getPrime ( k ) g = random . randrange ( 2 , p ) x = random . randrange ( 1 , p - 1 ) h = pow ( g , x , p ) pk = ( p , g , h ) sk = ( p , x ) return ( pk , sk ) p is the prime number of the k position, g is the book in the range of (2, p), and x is in the range of (1, p-1). And calculated h \\equiv g^x \\bmod p h \\equiv g^x \\bmod p . Seeing this, I almost know that this should be an ElGamal encryption on a number field. Where pk is the public key and sk is the private key. The program then outputs 10 times m and r. And, use the following function to encrypt def encrypt ( pk , m , r = None ): ( p , g , h ) = pk if r is None : r = random . randrange ( 1 , p - 1 ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) Its encryption method is indeed ElGamal encryption. Finally the program encrypts the flag. At this time r is by the program itself random. Analysis, here we can control m and r in ten rounds, and c_1 \\equiv g^r \\bmod p c_1 \\equiv g^r \\bmod p c_2 \\equiv m * h^{r} \\bmod p c_2 \\equiv m * h^{r} \\bmod p If we set r=1, m=1, then we can get c_1=g, c_2=h c_1=g, c_2=h . r=1, m=-1, then we can get c_1=g, c_2 = ph c_1=g, c_2 = ph . Then we can get the prime number p. What is the use of prime p? The number of bits in p is around 201, which is very big. But ah, after it generated the prime number p, it was not checked. We have said before that p-1 must have a large factor, and if there is a small prime factor, then we can attack. The attack mainly uses the baby step-giant step and Pohlig-Hellman algorithm algorithm. If you are interested, you can look at it. Here, the sage itself has a function to calculate the discrete logarithm, which can handle such a situation. See discrete_log . The specific code is as follows, it should be noted that this memory consumption is relatively large, do not just take the virtual machine to run. . . There is also this Nima interaction that makes me a headache,,,, import socket from Crypto.Util.number import * from sage.all import * def get_maxfactor ( N ): f = factor ( N ) print 'factor done' return f [ - 1 ][ 0 ] maxnumber = 1 << 70 i = 0 while 1 : print 'cycle: ' , i sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"localhost\" , 9999 )) sock . recv ( 17 ) # get g,h sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 1024 ) ( g , h ) = eval ( data ) # get g,p sock . sendall ( \"-1 \\n \" ) sock . recv ( 512 ) sock . sendall ( \"1 \\n \" ) data = sock . recv ( 1024 ) print data if ' \\n ' in data : data = data [: data . index ( ' \\n ' )] else : # receive m= sock . recv ( 512 ) ( g , tmp ) = eval ( data ) p = tmp + h tmp = get_maxfactor ( p - 1 ) if tmp < maxnumber : print 'may be success' # skip the for cycle sock . sendall ( 'quit \\n ' ); data = sock . recv ( 1024 ) print 'receive data: ' , data data = data [ data . index ( \":\" ) + 1 :] ( c1 , c2 ) = eval ( data ) # generate the group g = Mod ( g , p ) h = Mod ( h , p ) c1 = Mod ( c1 , p ) c2 = Mod ( c2 , p ) x = discrete_log ( h , g ) print \"x = \" , x print \"Flag: \" , long_to_bytes ( long ( c2 / ( c1 ** x ))) sock . sendall ( 'quit \\n ' ) sock . recv ( 1024 ) sock . close () i += 1 In the end, the computer is not enough memory, it is not calculated, and sometimes it will collapse and run a few times. .","title":"2015 MMA CTF Alicegame"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#2018-code-blue-lagalem","text":"The title is described below from Crypto.Util.number import * from key import FLAG size = 2048 rand_state = getRandomInteger ( size // 2 ) def keygen ( size ): q = getPrime ( size ) k = 2 while True : p = q * k + 1 if isPrime ( p ): break k + = 1 g = 2 while True : if pow ( g , q , p ) == 1 : break g += 1 A = getRandomInteger ( size ) % q B = getRandomInteger ( size ) % q x = getRandomInteger ( size ) % q h = pow ( g , x , p ) return ( g , h , A , B , p , q ), ( x ,) def rand ( A , B , M ): global rand_state rand_state , ret = ( A * rand_state + B ) % M , rand_state return right def encrypt ( pubkey , m ): g , h , A , B , p , q = pubkey assert 0 < m <= p r = rand ( A , B , q ) c1 = pow ( g , r , p ) c2 = ( m * pow ( h , r , p )) % p return ( c1 , c2 ) # pubkey, privkey = keygen(size) m = bytes_to_long ( FLAG ) c1 , c2 = encrypt ( pubkey , m ) c1_ , c2_ = encrypt ( pubkey , m ) print pubkey print ( c1 , c2 ) print ( c1_ , c2_ ) It can be seen that the algorithm is an ElGamal encryption, which gives the same plaintext two sets of encrypted results. The characteristic is that the random number r used is generated by the linear congruential generator, then we know c2 \\equiv m * h^{r} \\bmod p c2 \\equiv m * h^{r} \\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p c2\\_ \\equiv m*h^{(Ar+B) \\bmod q} \\equiv m*h^{Ar+B}\\bmod p then c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p c2^A*h^B/c2\\_ \\equiv m^{A-1}\\bmod p Among them, c2, c2_, A, B, h are known. Then we know m^{A-1} \\equiv t \\bmod p m^{A-1} \\equiv t \\bmod p We assume that we know a primitive root g of p, then we can assume g^x \\equiv t g^x \\equiv t g^y \\equiv m g^y \\equiv m then g^{y(A-1)}\\equiv g^x \\bmod p g^{y(A-1)}\\equiv g^x \\bmod p then y(A-1) \\equiv x \\bmod p-1 y(A-1) \\equiv x \\bmod p-1 Then we know y(A-1)-k(p-1)=x y(A-1)-k(p-1)=x Here we know A, p, x, then we can use the extended Euclidean theorem to find s(A-1)+w(p-1)=gcd(A-1,t-1) s(A-1)+w(p-1)=gcd(A-1,t-1) If gcd(A-1, t-1)=d, then we calculate directly t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p t^s \\equiv m^{s(A-1)} \\equiv m^d \\bmod p If d=1, then m is directly known. If d is not 1, then it is a bit of a hassle. . This problem is exactly d=1, so it can be solved easily. import gmpy2 data = open ( './transcript.txt' ) . read () . split ( ' \\n ' ) g , h , A , B , p , q = eval ( data [ 0 ]) c1 , c2 = eval ( data [ 1 ]) c1_ , c2_ = eval ( data [ 2 ]) tmp = gmpy2 . powmod ( c2 , A , p ) * gmpy2 . powmod ( h , B , p ) * gmpy2 . invert ( c2_ , p ) tmp = tmp % p print 't=' , tmp print 'A=' , A Print & #39;= p, p gg , x , y = gmpy2 . gcdext ( A - 1 , p - 1 ) print gg m = gmpy2 . powmod ( tmp , x , p ) print hex ( m )[ 2 :] . decode ( 'hex' ) flag \u279c 2018 -CodeBlue-lagalem git: ( master ) \u2717 python exp.py t = 24200833701856688878756977616650401715079183425722900529883514170904572086655826119242478732147288453761668954561939121426507899982627823151671207325781939341536650446260662452251070281875998376892857074363464032471952373518723746478141532996553854860936891133020681787570469383635252298945995672350873354628222982549233490189069478253457618473798487302495173105238289131448773538891748786125439847903309001198270694350004806890056215413633506973762313723658679532448729713653832387018928329243004507575710557548103815480626921755313420592693751934239155279580621162244859702224854316335659710333994740615748525806865323 A = 22171697832053348372915156043907956018090374461486719823366788630982715459384574553995928805167650346479356982401578161672693725423656918877111472214422442822321625228790031176477006387102261114291881317978365738605597034007565240733234828473235498045060301370063576730214239276663597216959028938702407690674202957249530224200656409763758677312265502252459474165905940522616924153211785956678275565280913390459395819438405830015823251969534345394385537526648860230429494250071276556746938056133344210445379647457181241674557283446678737258648530017213913802458974971453566678233726954727138234790969492546826523537158 p = 36416598149204678746613774367335394418818540686081178949292703167146103769686977098311936910892255381505012076996538695563763728453722792393508239790798417928810924208352785963037070885776153765280985533615624550198273407375650747001758391126814998498088382510133441013074771543464269812056636761840445695357746189203973350947418017496096468209755162029601945293367109584953080901393887040618021500119075628542529750701055865457182596931680189830763274025951607252183893164091069436120579097006203008253591406223666572333518943654621052210438476603030156263623221155480270748529488292790643952121391019941280923396132717 1 CBCTF { 183a3ce8ed93df613b002252dfc741b2 }","title":"2018 Code Blue lagalem"},{"location":"crypto/ctf-wiki/asymmetric/discrete-log/elgamal/#reference","text":"https://www.math.auckland.ac.nz/~sgal018/crypto-book/solns.pdf \uff0c20.4.1","title":"Reference"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/","text":"EN | ZH \u80cc\u5305\u95ee\u9898 \u00b6 \u9996\u5148\uff0c\u6211\u4eec\u5148\u6765\u4ecb\u7ecd\u4e00\u4e0b\u80cc\u5305\u95ee\u9898\uff0c\u5047\u5b9a\u4e00\u4e2a\u80cc\u5305\u53ef\u4ee5\u79f0\u91cd W\uff0c\u73b0\u5728\u6709 n \u4e2a\u7269\u54c1\uff0c\u5176\u91cd\u91cf\u5206\u522b\u4e3a a_1, a_2,...,a_n a_1, a_2,...,a_n \u6211\u4eec\u60f3\u95ee\u4e00\u4e0b\u88c5\u54ea\u4e9b\u7269\u54c1\u53ef\u4ee5\u6070\u597d\u4f7f\u5f97\u80cc\u5305\u88c5\u6ee1\uff0c\u5e76\u4e14\u6bcf\u4e2a\u7269\u54c1\u53ea\u80fd\u88ab\u88c5\u4e00\u6b21\u3002\u8fd9\u5176\u5b9e\u5c31\u662f\u5728\u89e3\u8fd9\u6837\u7684\u4e00\u4e2a\u95ee\u9898 x_1a_1+x_2a_2+,...,+x_na_n=W x_1a_1+x_2a_2+,...,+x_na_n=W \u5176\u4e2d\u6240\u6709\u7684 x_i x_i \u53ea\u80fd\u4e3a 0 \u548c 1\u3002\u663e\u7136\u6211\u4eec\u5fc5\u987b\u679a\u4e3e\u6240\u6709\u7684 n \u4e2a\u7269\u54c1\u7684\u7ec4\u5408\u624d\u80fd\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u800c\u590d\u6742\u5ea6\u4e5f\u5c31\u662f 2^n 2^n \uff0c\u8fd9\u4e5f\u5c31\u662f\u80cc\u5305\u52a0\u5bc6\u7684\u5999\u5904\u6240\u5728\u3002 \u5728\u52a0\u5bc6\u65f6\uff0c\u5982\u679c\u6211\u4eec\u60f3\u8981\u52a0\u5bc6\u7684\u660e\u6587\u4e3a x\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u8868\u793a\u4e3a n \u4f4d\u4e8c\u8fdb\u5236\u6570\uff0c\u7136\u540e\u5206\u522b\u4e58\u4e0a a_i a_i \u5373\u53ef\u5f97\u5230\u52a0\u5bc6\u7ed3\u679c\u3002 \u4f46\u662f\u89e3\u5bc6\u7684\u65f6\u5019\uff0c\u8be5\u600e\u4e48\u529e\u5462\uff1f\u6211\u4eec\u786e\u5b9e\u8ba9\u5176\u4ed6\u4eba\u96be\u4ee5\u89e3\u5bc6\u5bc6\u6587\uff0c\u4f46\u662f\u6211\u4eec\u81ea\u5df1\u4e5f\u786e\u5b9e\u6ca1\u6709\u529e\u6cd5\u89e3\u5bc6\u5bc6\u6587\u3002 \u4f46\u662f\u5f53 a_i a_i \u662f\u8d85\u9012\u589e\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u6709\u529e\u6cd5\u89e3\u4e86\uff0c\u6240\u8c13\u8d85\u9012\u589e\u662f\u6307\u5e8f\u5217\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6 a_i>\\sum_{k=1}^{i-1}a_k a_i>\\sum_{k=1}^{i-1}a_k \u5373\u7b2c i \u4e2a\u6570\u5927\u4e8e\u524d\u9762\u6240\u6709\u6570\u7684\u548c\u3002 \u4e3a\u4ec0\u4e48\u6ee1\u8db3\u8fd9\u6837\u7684\u6761\u4ef6\u5c31\u53ef\u4ee5\u89e3\u5bc6\u4e86\u5462\uff1f\u8fd9\u662f\u56e0\u4e3a\u5982\u679c\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u5927\u4e8e a_n a_n \u7684\u8bdd\uff0c\u5176\u524d\u9762\u7684\u7cfb\u6570\u4e3a\u5fc5\u987b 1 \u7684\u3002\u53cd\u4e4b\uff0c\u65e0\u8bba\u5982\u4f55\u4e5f\u65e0\u6cd5\u4f7f\u5f97\u7b49\u5f0f\u6210\u7acb\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7acb\u9a6c\u5f97\u5230\u5bf9\u5e94\u7684\u660e\u6587\u3002 \u4f46\u662f\uff0c\u8fd9\u6837\u53c8\u51fa\u73b0\u4e86\u4e00\u4e2a\u95ee\u9898\uff0c\u7531\u4e8e a_i a_i \u662f\u516c\u5f00\u7684\uff0c\u5982\u679c\u653b\u51fb\u8005\u622a\u83b7\u4e86\u5bc6\u6587\uff0c\u90a3\u4e48\u5b83\u4e5f\u5c31\u5f88\u5bb9\u6613\u53bb\u7834\u89e3\u8fd9\u6837\u7684\u5bc6\u7801\u3002\u4e3a\u4e86\u5f25\u8865\u8fd9\u6837\u7684\u95ee\u9898\uff0c\u5c31\u51fa\u73b0\u4e86 Merkle\u2013Hellman \u8fd9\u6837\u7684\u52a0\u5bc6\u7b97\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u521d\u59cb\u7684\u80cc\u5305\u96c6\u4f5c\u4e3a\u79c1\u94a5\uff0c\u53d8\u6362\u540e\u7684\u80cc\u5305\u96c6\u4f5c\u4e3a\u516c\u94a5\uff0c\u518d\u7a0d\u5fae\u6539\u52a8\u52a0\u5bc6\u8fc7\u7a0b\uff0c\u5373\u53ef\u3002 \u8fd9\u91cc\u867d\u7136\u8bf4\u4e86\u8d85\u9012\u589e\u5e8f\u5217\uff0c\u4f46\u662f\u5374\u6ca1\u6709\u8bf4\u662f\u5982\u4f55\u751f\u6210\u7684\u3002 Merkle\u2013Hellman \u00b6 \u516c\u79c1\u94a5\u751f\u6210 \u00b6 \u751f\u6210\u79c1\u94a5 \u00b6 \u79c1\u94a5\u5c31\u662f\u6211\u4eec\u7684\u521d\u59cb\u7684\u80cc\u5305\u96c6\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u8d85\u9012\u589e\u5e8f\u5217\uff0c\u600e\u4e48\u751f\u6210\u5462\uff1f\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe a_1=1 a_1=1 \uff0c\u90a3\u4e48 a_2 a_2 \u5927\u4e8e 1 \u5373\u53ef\uff0c\u7c7b\u4f3c\u7684\u53ef\u4ee5\u4f9d\u6b21\u751f\u6210\u540e\u9762\u7684\u503c\u3002 \u751f\u6210\u516c\u94a5 \u00b6 \u5728\u751f\u6210\u516c\u94a5\u7684\u8fc7\u7a0b\u4e2d\u4e3b\u8981\u4f7f\u7528\u4e86\u6a21\u4e58\u7684\u8fd0\u7b97\u3002 \u9996\u5148\uff0c\u6211\u4eec\u751f\u6210\u6a21\u4e58\u7684\u6a21\u6570 m\uff0c\u8fd9\u91cc\u8981\u786e\u4fdd m>\\sum_{i=1}^{i=n}a_i m>\\sum_{i=1}^{i=n}a_i \u5176\u6b21\uff0c\u6211\u4eec\u9009\u62e9\u6a21\u4e58\u7684\u4e58\u6570 w\uff0c\u4f5c\u4e3a\u79c1\u94a5\u5e76\u4e14\u786e\u4fdd gcd(w,m)=1 gcd(w,m)=1 \u4e4b\u540e\uff0c\u6211\u4eec\u4fbf\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u516c\u5f0f\u751f\u6210\u516c\u94a5 b_i \\equiv w a_i \\bmod m b_i \\equiv w a_i \\bmod m \u5e76\u5c06\u8fd9\u4e2a\u65b0\u7684\u80cc\u5305\u96c6 b_i b_i \u548c m \u4f5c\u4e3a\u516c\u94a5\u3002 \u52a0\u89e3\u5bc6 \u00b6 \u52a0\u5bc6 \u00b6 \u5047\u8bbe\u6211\u4eec\u8981\u52a0\u5bc6\u7684\u660e\u6587\u4e3a v\uff0c\u5176\u6bcf\u4e00\u4e2a\u6bd4\u7279\u4f4d\u4e3a v_i v_i \uff0c\u90a3\u4e48\u6211\u4eec\u52a0\u5bc6\u7684\u7ed3\u679c\u4e3a \\sum_{i=1}^{i=n}b_iv_i \\bmod m \\sum_{i=1}^{i=n}b_iv_i \\bmod m \u89e3\u5bc6 \u00b6 \u5bf9\u4e8e\u89e3\u5bc6\u65b9\uff0c\u9996\u5148\u53ef\u4ee5\u6c42\u7684 w \u5173\u4e8e m \u7684\u9006\u5143 w^{-1} w^{-1} \u3002 \u7136\u540e\u6211\u4eec\u53ef\u4ee5\u5c06\u5f97\u5230\u7684\u5bc6\u6587\u4e58\u4ee5 w^{-1} w^{-1} \u5373\u53ef\u5f97\u5230\u660e\u6587\uff0c\u8fd9\u662f\u56e0\u4e3a \\sum_{i=1}^{i=n}w^{-1}b_iv_i \\bmod m=\\sum_{i=1}^{i=n}a_iv_i \\bmod m \\sum_{i=1}^{i=n}w^{-1}b_iv_i \\bmod m=\\sum_{i=1}^{i=n}a_iv_i \\bmod m \u8fd9\u91cc\u6709 b_i \\equiv w a_i \\bmod m b_i \\equiv w a_i \\bmod m \u5bf9\u4e8e\u6bcf\u4e00\u5757\u7684\u52a0\u5bc6\u7684\u6d88\u606f\u90fd\u662f\u5c0f\u4e8e m \u7684\uff0c\u6240\u4ee5\u6c42\u5f97\u7ed3\u679c\u81ea\u7136\u4e5f\u5c31\u662f\u660e\u6587\u4e86\u3002 \u7834\u89e3 \u00b6 \u8be5\u52a0\u5bc6\u4f53\u5236\u5728\u63d0\u51fa\u540e\u4e24\u5e74\u540e\u8be5\u4f53\u5236\u5373\u88ab\u7834\u8bd1\uff0c\u7834\u8bd1\u7684\u57fa\u672c\u601d\u60f3\u662f\u6211\u4eec\u4e0d\u4e00\u5b9a\u8981\u627e\u51fa\u6b63\u786e\u7684\u4e58\u6570 w\uff08\u5373\u9677\u95e8\u4fe1\u606f\uff09\uff0c\u53ea\u9700\u627e\u51fa\u4efb\u610f\u6a21\u6570 m\u2032 \u548c\u4e58\u6570 w\u2032 \uff0c\u53ea\u8981\u4f7f\u7528 w\u2032 \u53bb\u4e58\u516c\u5f00\u7684\u80cc\u5305\u5411\u91cf B \u65f6\uff0c\u80fd\u591f\u4ea7\u751f\u8d85\u9012\u589e\u7684\u80cc\u5305\u5411\u91cf\u5373\u53ef\u3002 \u4f8b\u5b50 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 2014 \u5e74 ASIS Cyber Security Contest Quals \u4e2d\u7684 Archaic \u4e3a\u4f8b\uff0c \u9898\u76ee\u94fe\u63a5 \u3002 \u9996\u5148\u67e5\u770b\u6e90\u7a0b\u5e8f secret = 'CENSORED' msg_bit = bin ( int ( secret . encode ( 'hex' ), 16 ))[ 2 :] \u9996\u5148\u5f97\u5230\u4e86 secret \u7684\u6240\u6709\u4e8c\u8fdb\u5236\u4f4d\u3002 \u5176\u6b21\uff0c\u5229\u7528\u5982\u4e0b\u51fd\u6570\u5f97\u5230 keypair\uff0c\u5305\u542b\u516c\u94a5\u4e0e\u79c1\u94a5\u3002 keyPair = makeKey ( len ( msg_bit )) \u4ed4\u7ec6\u5206\u6790 makekey \u51fd\u6570\uff0c\u5982\u4e0b def makeKey ( n ): privKey = [ random . randint ( 1 , 4 ** n )] s = privKey [ 0 ] for i in range ( 1 , n ): privKey . append ( random . randint ( s + 1 , 4 ** ( n + i ))) s += privKey [ i ] q = random . randint ( privKey [ n - 1 ] + 1 , 2 * privKey [ n - 1 ]) r = random . randint ( 1 , q ) while gmpy2 . gcd ( r , q ) != 1 : r = random . randint ( 1 , q ) pubKey = [ r * w % q for w in privKey ] return privKey , q , r , pubKey \u53ef\u4ee5\u770b\u51fa prikey \u662f\u4e00\u4e2a\u8d85\u9012\u589e\u5e8f\u5217\uff0c\u5e76\u4e14\u5f97\u5230\u7684 q \u6bd4 prikey \u4e2d\u6240\u6709\u6570\u7684\u548c\u8fd8\u8981\u5927\uff0c\u6b64\u5916\u6211\u4eec\u5f97\u5230\u7684 r\uff0c\u6070\u597d\u4e0e q \u4e92\u7d20\uff0c\u8fd9\u4e00\u5207\u90fd\u8868\u660e\u4e86\u8be5\u52a0\u5bc6\u662f\u4e00\u4e2a\u80cc\u5305\u52a0\u5bc6\u3002 \u679c\u7136\u52a0\u5bc6\u51fd\u6570\u5c31\u662f\u5bf9\u4e8e\u6d88\u606f\u7684\u6bcf\u4e00\u4f4d\u4e58\u4ee5\u5bf9\u5e94\u7684\u516c\u94a5\u5e76\u6c42\u548c\u3002 def encrypt ( msg , pubKey ): msg_bit = msg n = len ( pubKey ) cipher = 0 i = 0 for bit in msg_bit : cipher += int ( bit ) * pubKey [ i ] i += 1 return bin ( cipher )[ 2 :] \u5bf9\u4e8e\u7834\u89e3\u7684\u811a\u672c\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 GitHub \u4e0a\u7684\u811a\u672c\u3002\u8fdb\u884c\u4e00\u4e9b\u7b80\u5355\u7684\u4fee\u6539\u3002 import binascii # open the public key and strip the spaces so we have a decent array fileKey = open ( \"pub.Key\" , 'rb' ) pubKey = fileKey . read () . replace ( ' ' , '' ) . replace ( 'L' , '' ) . strip ( '[]' ) . split ( ',' ) nbit = len ( pubKey ) # open the encoded message fileEnc = open ( \"enc.txt\" , 'rb' ) encoded = fileEnc . read () . replace ( 'L' , '' ) print \"start\" # create a large matrix of 0's (dimensions are public key length +1) A = Matrix ( ZZ , nbit + 1 , nbit + 1 ) # fill in the identity matrix for i in xrange ( nbit ): A [ i , i ] = 1 # replace the bottom row with your public key for i in xrange ( nbit ): A [ i , nbit ] = pubKey [ i ] # last element is the encoded message A [ nbit , nbit ] = - int ( encoded ) res = A . LLL () for i in range ( 0 , nbit + 1 ): # print solution M = res . row ( i ) . list () flag = True for m in M : if m != 0 and m != 1 : flag = False break if flag : print i , M M = '' . join ( str ( j ) for j in M ) # remove the last bit M = M [: - 1 ] M = hex ( int ( M , 2 ))[ 2 : - 1 ] print M \u8f93\u51fa\u4e4b\u540e\u518d\u89e3\u7801\u4e0b 295 [ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] 415349535 f3962643364356664323432323638326331393536383830366130373036316365 >>> import binascii >>> binascii . unhexlify ( '415349535f3962643364356664323432323638326331393536383830366130373036316365' ) 'ASIS_9bd3d5fd2422682c19568806a07061ce' \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6211\u4eec\u5f97\u5230\u7684 LLL \u653b\u51fb\u5f97\u5230\u7684\u77e9\u9635 res \u7684\u53ea\u5305\u542b 01 \u503c\u7684\u884c\u624d\u662f\u6211\u4eec\u60f3\u8981\u7684\u7ed3\u679c\uff0c\u56e0\u4e3a\u6211\u4eec\u5bf9\u4e8e\u660e\u6587\u52a0\u5bc6\u65f6\uff0c\u4f1a\u5c06\u5176\u5206\u89e3\u4e3a\u4e8c\u8fdb\u5236\u6bd4\u7279\u4e32\u3002\u6b64\u5916\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u53bb\u6389\u5bf9\u5e94\u54ea\u4e00\u884c\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u3002 flag \u662f ASIS_9bd3d5fd2422682c19568806a07061ce \u3002 \u9898\u76ee \u00b6 2017 \u56fd\u8d5b classic","title":"Knapsack zh"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_1","text":"\u9996\u5148\uff0c\u6211\u4eec\u5148\u6765\u4ecb\u7ecd\u4e00\u4e0b\u80cc\u5305\u95ee\u9898\uff0c\u5047\u5b9a\u4e00\u4e2a\u80cc\u5305\u53ef\u4ee5\u79f0\u91cd W\uff0c\u73b0\u5728\u6709 n \u4e2a\u7269\u54c1\uff0c\u5176\u91cd\u91cf\u5206\u522b\u4e3a a_1, a_2,...,a_n a_1, a_2,...,a_n \u6211\u4eec\u60f3\u95ee\u4e00\u4e0b\u88c5\u54ea\u4e9b\u7269\u54c1\u53ef\u4ee5\u6070\u597d\u4f7f\u5f97\u80cc\u5305\u88c5\u6ee1\uff0c\u5e76\u4e14\u6bcf\u4e2a\u7269\u54c1\u53ea\u80fd\u88ab\u88c5\u4e00\u6b21\u3002\u8fd9\u5176\u5b9e\u5c31\u662f\u5728\u89e3\u8fd9\u6837\u7684\u4e00\u4e2a\u95ee\u9898 x_1a_1+x_2a_2+,...,+x_na_n=W x_1a_1+x_2a_2+,...,+x_na_n=W \u5176\u4e2d\u6240\u6709\u7684 x_i x_i \u53ea\u80fd\u4e3a 0 \u548c 1\u3002\u663e\u7136\u6211\u4eec\u5fc5\u987b\u679a\u4e3e\u6240\u6709\u7684 n \u4e2a\u7269\u54c1\u7684\u7ec4\u5408\u624d\u80fd\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u800c\u590d\u6742\u5ea6\u4e5f\u5c31\u662f 2^n 2^n \uff0c\u8fd9\u4e5f\u5c31\u662f\u80cc\u5305\u52a0\u5bc6\u7684\u5999\u5904\u6240\u5728\u3002 \u5728\u52a0\u5bc6\u65f6\uff0c\u5982\u679c\u6211\u4eec\u60f3\u8981\u52a0\u5bc6\u7684\u660e\u6587\u4e3a x\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u8868\u793a\u4e3a n \u4f4d\u4e8c\u8fdb\u5236\u6570\uff0c\u7136\u540e\u5206\u522b\u4e58\u4e0a a_i a_i \u5373\u53ef\u5f97\u5230\u52a0\u5bc6\u7ed3\u679c\u3002 \u4f46\u662f\u89e3\u5bc6\u7684\u65f6\u5019\uff0c\u8be5\u600e\u4e48\u529e\u5462\uff1f\u6211\u4eec\u786e\u5b9e\u8ba9\u5176\u4ed6\u4eba\u96be\u4ee5\u89e3\u5bc6\u5bc6\u6587\uff0c\u4f46\u662f\u6211\u4eec\u81ea\u5df1\u4e5f\u786e\u5b9e\u6ca1\u6709\u529e\u6cd5\u89e3\u5bc6\u5bc6\u6587\u3002 \u4f46\u662f\u5f53 a_i a_i \u662f\u8d85\u9012\u589e\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u6709\u529e\u6cd5\u89e3\u4e86\uff0c\u6240\u8c13\u8d85\u9012\u589e\u662f\u6307\u5e8f\u5217\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6 a_i>\\sum_{k=1}^{i-1}a_k a_i>\\sum_{k=1}^{i-1}a_k \u5373\u7b2c i \u4e2a\u6570\u5927\u4e8e\u524d\u9762\u6240\u6709\u6570\u7684\u548c\u3002 \u4e3a\u4ec0\u4e48\u6ee1\u8db3\u8fd9\u6837\u7684\u6761\u4ef6\u5c31\u53ef\u4ee5\u89e3\u5bc6\u4e86\u5462\uff1f\u8fd9\u662f\u56e0\u4e3a\u5982\u679c\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u5927\u4e8e a_n a_n \u7684\u8bdd\uff0c\u5176\u524d\u9762\u7684\u7cfb\u6570\u4e3a\u5fc5\u987b 1 \u7684\u3002\u53cd\u4e4b\uff0c\u65e0\u8bba\u5982\u4f55\u4e5f\u65e0\u6cd5\u4f7f\u5f97\u7b49\u5f0f\u6210\u7acb\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7acb\u9a6c\u5f97\u5230\u5bf9\u5e94\u7684\u660e\u6587\u3002 \u4f46\u662f\uff0c\u8fd9\u6837\u53c8\u51fa\u73b0\u4e86\u4e00\u4e2a\u95ee\u9898\uff0c\u7531\u4e8e a_i a_i \u662f\u516c\u5f00\u7684\uff0c\u5982\u679c\u653b\u51fb\u8005\u622a\u83b7\u4e86\u5bc6\u6587\uff0c\u90a3\u4e48\u5b83\u4e5f\u5c31\u5f88\u5bb9\u6613\u53bb\u7834\u89e3\u8fd9\u6837\u7684\u5bc6\u7801\u3002\u4e3a\u4e86\u5f25\u8865\u8fd9\u6837\u7684\u95ee\u9898\uff0c\u5c31\u51fa\u73b0\u4e86 Merkle\u2013Hellman \u8fd9\u6837\u7684\u52a0\u5bc6\u7b97\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u521d\u59cb\u7684\u80cc\u5305\u96c6\u4f5c\u4e3a\u79c1\u94a5\uff0c\u53d8\u6362\u540e\u7684\u80cc\u5305\u96c6\u4f5c\u4e3a\u516c\u94a5\uff0c\u518d\u7a0d\u5fae\u6539\u52a8\u52a0\u5bc6\u8fc7\u7a0b\uff0c\u5373\u53ef\u3002 \u8fd9\u91cc\u867d\u7136\u8bf4\u4e86\u8d85\u9012\u589e\u5e8f\u5217\uff0c\u4f46\u662f\u5374\u6ca1\u6709\u8bf4\u662f\u5982\u4f55\u751f\u6210\u7684\u3002","title":"\u80cc\u5305\u95ee\u9898"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#merklehellman","text":"","title":"Merkle\u2013Hellman"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_2","text":"","title":"\u516c\u79c1\u94a5\u751f\u6210"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_3","text":"\u79c1\u94a5\u5c31\u662f\u6211\u4eec\u7684\u521d\u59cb\u7684\u80cc\u5305\u96c6\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u8d85\u9012\u589e\u5e8f\u5217\uff0c\u600e\u4e48\u751f\u6210\u5462\uff1f\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe a_1=1 a_1=1 \uff0c\u90a3\u4e48 a_2 a_2 \u5927\u4e8e 1 \u5373\u53ef\uff0c\u7c7b\u4f3c\u7684\u53ef\u4ee5\u4f9d\u6b21\u751f\u6210\u540e\u9762\u7684\u503c\u3002","title":"\u751f\u6210\u79c1\u94a5"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_4","text":"\u5728\u751f\u6210\u516c\u94a5\u7684\u8fc7\u7a0b\u4e2d\u4e3b\u8981\u4f7f\u7528\u4e86\u6a21\u4e58\u7684\u8fd0\u7b97\u3002 \u9996\u5148\uff0c\u6211\u4eec\u751f\u6210\u6a21\u4e58\u7684\u6a21\u6570 m\uff0c\u8fd9\u91cc\u8981\u786e\u4fdd m>\\sum_{i=1}^{i=n}a_i m>\\sum_{i=1}^{i=n}a_i \u5176\u6b21\uff0c\u6211\u4eec\u9009\u62e9\u6a21\u4e58\u7684\u4e58\u6570 w\uff0c\u4f5c\u4e3a\u79c1\u94a5\u5e76\u4e14\u786e\u4fdd gcd(w,m)=1 gcd(w,m)=1 \u4e4b\u540e\uff0c\u6211\u4eec\u4fbf\u53ef\u4ee5\u901a\u8fc7\u5982\u4e0b\u516c\u5f0f\u751f\u6210\u516c\u94a5 b_i \\equiv w a_i \\bmod m b_i \\equiv w a_i \\bmod m \u5e76\u5c06\u8fd9\u4e2a\u65b0\u7684\u80cc\u5305\u96c6 b_i b_i \u548c m \u4f5c\u4e3a\u516c\u94a5\u3002","title":"\u751f\u6210\u516c\u94a5"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_5","text":"","title":"\u52a0\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_6","text":"\u5047\u8bbe\u6211\u4eec\u8981\u52a0\u5bc6\u7684\u660e\u6587\u4e3a v\uff0c\u5176\u6bcf\u4e00\u4e2a\u6bd4\u7279\u4f4d\u4e3a v_i v_i \uff0c\u90a3\u4e48\u6211\u4eec\u52a0\u5bc6\u7684\u7ed3\u679c\u4e3a \\sum_{i=1}^{i=n}b_iv_i \\bmod m \\sum_{i=1}^{i=n}b_iv_i \\bmod m","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_7","text":"\u5bf9\u4e8e\u89e3\u5bc6\u65b9\uff0c\u9996\u5148\u53ef\u4ee5\u6c42\u7684 w \u5173\u4e8e m \u7684\u9006\u5143 w^{-1} w^{-1} \u3002 \u7136\u540e\u6211\u4eec\u53ef\u4ee5\u5c06\u5f97\u5230\u7684\u5bc6\u6587\u4e58\u4ee5 w^{-1} w^{-1} \u5373\u53ef\u5f97\u5230\u660e\u6587\uff0c\u8fd9\u662f\u56e0\u4e3a \\sum_{i=1}^{i=n}w^{-1}b_iv_i \\bmod m=\\sum_{i=1}^{i=n}a_iv_i \\bmod m \\sum_{i=1}^{i=n}w^{-1}b_iv_i \\bmod m=\\sum_{i=1}^{i=n}a_iv_i \\bmod m \u8fd9\u91cc\u6709 b_i \\equiv w a_i \\bmod m b_i \\equiv w a_i \\bmod m \u5bf9\u4e8e\u6bcf\u4e00\u5757\u7684\u52a0\u5bc6\u7684\u6d88\u606f\u90fd\u662f\u5c0f\u4e8e m \u7684\uff0c\u6240\u4ee5\u6c42\u5f97\u7ed3\u679c\u81ea\u7136\u4e5f\u5c31\u662f\u660e\u6587\u4e86\u3002","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_8","text":"\u8be5\u52a0\u5bc6\u4f53\u5236\u5728\u63d0\u51fa\u540e\u4e24\u5e74\u540e\u8be5\u4f53\u5236\u5373\u88ab\u7834\u8bd1\uff0c\u7834\u8bd1\u7684\u57fa\u672c\u601d\u60f3\u662f\u6211\u4eec\u4e0d\u4e00\u5b9a\u8981\u627e\u51fa\u6b63\u786e\u7684\u4e58\u6570 w\uff08\u5373\u9677\u95e8\u4fe1\u606f\uff09\uff0c\u53ea\u9700\u627e\u51fa\u4efb\u610f\u6a21\u6570 m\u2032 \u548c\u4e58\u6570 w\u2032 \uff0c\u53ea\u8981\u4f7f\u7528 w\u2032 \u53bb\u4e58\u516c\u5f00\u7684\u80cc\u5305\u5411\u91cf B \u65f6\uff0c\u80fd\u591f\u4ea7\u751f\u8d85\u9012\u589e\u7684\u80cc\u5305\u5411\u91cf\u5373\u53ef\u3002","title":"\u7834\u89e3"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_9","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 2014 \u5e74 ASIS Cyber Security Contest Quals \u4e2d\u7684 Archaic \u4e3a\u4f8b\uff0c \u9898\u76ee\u94fe\u63a5 \u3002 \u9996\u5148\u67e5\u770b\u6e90\u7a0b\u5e8f secret = 'CENSORED' msg_bit = bin ( int ( secret . encode ( 'hex' ), 16 ))[ 2 :] \u9996\u5148\u5f97\u5230\u4e86 secret \u7684\u6240\u6709\u4e8c\u8fdb\u5236\u4f4d\u3002 \u5176\u6b21\uff0c\u5229\u7528\u5982\u4e0b\u51fd\u6570\u5f97\u5230 keypair\uff0c\u5305\u542b\u516c\u94a5\u4e0e\u79c1\u94a5\u3002 keyPair = makeKey ( len ( msg_bit )) \u4ed4\u7ec6\u5206\u6790 makekey \u51fd\u6570\uff0c\u5982\u4e0b def makeKey ( n ): privKey = [ random . randint ( 1 , 4 ** n )] s = privKey [ 0 ] for i in range ( 1 , n ): privKey . append ( random . randint ( s + 1 , 4 ** ( n + i ))) s += privKey [ i ] q = random . randint ( privKey [ n - 1 ] + 1 , 2 * privKey [ n - 1 ]) r = random . randint ( 1 , q ) while gmpy2 . gcd ( r , q ) != 1 : r = random . randint ( 1 , q ) pubKey = [ r * w % q for w in privKey ] return privKey , q , r , pubKey \u53ef\u4ee5\u770b\u51fa prikey \u662f\u4e00\u4e2a\u8d85\u9012\u589e\u5e8f\u5217\uff0c\u5e76\u4e14\u5f97\u5230\u7684 q \u6bd4 prikey \u4e2d\u6240\u6709\u6570\u7684\u548c\u8fd8\u8981\u5927\uff0c\u6b64\u5916\u6211\u4eec\u5f97\u5230\u7684 r\uff0c\u6070\u597d\u4e0e q \u4e92\u7d20\uff0c\u8fd9\u4e00\u5207\u90fd\u8868\u660e\u4e86\u8be5\u52a0\u5bc6\u662f\u4e00\u4e2a\u80cc\u5305\u52a0\u5bc6\u3002 \u679c\u7136\u52a0\u5bc6\u51fd\u6570\u5c31\u662f\u5bf9\u4e8e\u6d88\u606f\u7684\u6bcf\u4e00\u4f4d\u4e58\u4ee5\u5bf9\u5e94\u7684\u516c\u94a5\u5e76\u6c42\u548c\u3002 def encrypt ( msg , pubKey ): msg_bit = msg n = len ( pubKey ) cipher = 0 i = 0 for bit in msg_bit : cipher += int ( bit ) * pubKey [ i ] i += 1 return bin ( cipher )[ 2 :] \u5bf9\u4e8e\u7834\u89e3\u7684\u811a\u672c\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 GitHub \u4e0a\u7684\u811a\u672c\u3002\u8fdb\u884c\u4e00\u4e9b\u7b80\u5355\u7684\u4fee\u6539\u3002 import binascii # open the public key and strip the spaces so we have a decent array fileKey = open ( \"pub.Key\" , 'rb' ) pubKey = fileKey . read () . replace ( ' ' , '' ) . replace ( 'L' , '' ) . strip ( '[]' ) . split ( ',' ) nbit = len ( pubKey ) # open the encoded message fileEnc = open ( \"enc.txt\" , 'rb' ) encoded = fileEnc . read () . replace ( 'L' , '' ) print \"start\" # create a large matrix of 0's (dimensions are public key length +1) A = Matrix ( ZZ , nbit + 1 , nbit + 1 ) # fill in the identity matrix for i in xrange ( nbit ): A [ i , i ] = 1 # replace the bottom row with your public key for i in xrange ( nbit ): A [ i , nbit ] = pubKey [ i ] # last element is the encoded message A [ nbit , nbit ] = - int ( encoded ) res = A . LLL () for i in range ( 0 , nbit + 1 ): # print solution M = res . row ( i ) . list () flag = True for m in M : if m != 0 and m != 1 : flag = False break if flag : print i , M M = '' . join ( str ( j ) for j in M ) # remove the last bit M = M [: - 1 ] M = hex ( int ( M , 2 ))[ 2 : - 1 ] print M \u8f93\u51fa\u4e4b\u540e\u518d\u89e3\u7801\u4e0b 295 [ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] 415349535 f3962643364356664323432323638326331393536383830366130373036316365 >>> import binascii >>> binascii . unhexlify ( '415349535f3962643364356664323432323638326331393536383830366130373036316365' ) 'ASIS_9bd3d5fd2422682c19568806a07061ce' \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6211\u4eec\u5f97\u5230\u7684 LLL \u653b\u51fb\u5f97\u5230\u7684\u77e9\u9635 res \u7684\u53ea\u5305\u542b 01 \u503c\u7684\u884c\u624d\u662f\u6211\u4eec\u60f3\u8981\u7684\u7ed3\u679c\uff0c\u56e0\u4e3a\u6211\u4eec\u5bf9\u4e8e\u660e\u6587\u52a0\u5bc6\u65f6\uff0c\u4f1a\u5c06\u5176\u5206\u89e3\u4e3a\u4e8c\u8fdb\u5236\u6bd4\u7279\u4e32\u3002\u6b64\u5916\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u53bb\u6389\u5bf9\u5e94\u54ea\u4e00\u884c\u7684\u6700\u540e\u4e00\u4e2a\u6570\u5b57\u3002 flag \u662f ASIS_9bd3d5fd2422682c19568806a07061ce \u3002","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack-zh/#_10","text":"2017 \u56fd\u8d5b classic","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/","text":"EN | ZH Backpack problem \u00b6 First, let's introduce the backpack problem. Suppose a backpack can weigh W. Now there are n items with weights of a_1, a_2,..., a_n a_1, a_2,..., a_n . We want to ask which items can fit the backpack. Filled up and each item can only be loaded once. This is actually solving such a problem. $$ x_1a_1 + x_2a_2 +, ..., + x_na_n = W $$ All of these x_i x_i can only be 0 and 1. Obviously we have to enumerate all the combinations of n items to solve this problem, and the complexity is 2^n 2^n , which is the beauty of backpack encryption. When encrypting, if we want to encrypt the plaintext as x, then we can represent it as an n-bit binary number and then multiply it by a_i a_i to get the encrypted result. But what should I do when decrypting? We did make it difficult for others to decrypt the ciphertext, but we really have no way to decrypt the ciphertext. But when a_i a_i is super-incremental, we have a solution. The so-called super-increment means that the sequence satisfies the following conditions. $$ a_i>\\sum_{k=1}^{i-1}a_k $$ That is, the ith number is greater than the sum of all the previous numbers. Why can you decrypt it if you meet such a condition? This is because if the encrypted result is greater than a_n a_n , the preceding coefficient must be 1. On the contrary, the equation cannot be established anyway. Therefore, we can get the corresponding plaintext immediately. However, this has another problem. Since a_i a_i is public, if the attacker intercepts the ciphertext, it is easy to crack such a password. In order to make up for this problem, an encryption algorithm such as Merkle\u2013Hellman appears. We can use the initial backpack set as the private key, the transformed backpack set as the public key, and then slightly change the encryption process. Although the super-increment sequence is mentioned here, it is not said how it is generated. Merkle\u2013Hellman \u00b6 Public private key generation \u00b6 Generating a private key \u00b6 The private key is our initial backpack set. Here we use the super-increment sequence, how to generate it? We can assume that a_1=1 a_1=1 , then a_2 a_2 is greater than 1, and similarly can generate subsequent values in turn. Generating a public key \u00b6 In the process of generating a public key, the operation of modular multiplication is mainly used. First, we generate the modulus m of the modular multiplication, here we want to make sure $$ m>\\sum_{i=1}^{i=n}a_i $$ Second, we choose the multiplier w of the modular multiplication as the private key and ensure $$ gcd(w,m)=1 $$ After that, we can generate the public key by the following formula. $$ b_i \\equiv w a_i \\bmod m $$ And this new backpack set b_i b_i and m as the public key. encryption and decryption \u00b6 Encryption \u00b6 Suppose we want to encrypt the plaintext as v, each bit is v_i v_i , then the result of our encryption is $$ Sum_ {i = 1} ^ {n} i = b_iv_i m way $$ Decryption \u00b6 For the decryption side, we can first ask for the inverse of m^{-1} m^{-1} for m. Then we can multiply the obtained ciphertext by w^{-1} w^{-1} to get the plaintext, because $$ Sum_ {i = 1} ^ {w} i = n ^ {- 1} b_iv_i way m = sum_ {i = 1} ^ {n} i = a_iv_i m way $$ here has $$ b_i \\equiv w a_i \\bmod m $$ The encrypted message for each block is less than m, so the result is naturally plaintext. \u7834 \u00b6 The system was deciphered two years after the proposed encryption system. The basic idea of deciphering is that we do not necessarily need to find the correct multiplier w (ie trapdoor information), just find the arbitrary modulus m&#39; and The multiplier w&#39; can be used to generate a super-incrementing backpack vector by using w&#39; to multiply the public backpack vector B. Examples \u00b6 Here we take Archaic in 2014 ASIS Cyber Security Contest Quals as an example, [topic link] ( https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ). First look at the source program secret = 'CENSORED' msg_bit = bin ( int ( secret . encode ( 'hex' ), 16 ))[ 2 :] First we get all the bits of secret. Second, use the following function to get the keypair, including the public and private keys. keyPair = makeKey ( curtain ( msg_bit )) Carefully analyze the makekey function as follows def makeKey ( n ): privKey = [ random . randint ( 1 , 4 ** n )] s = privKey [ 0 ] for i in range ( 1 , n ): privKey . append ( random . randint ( s + 1 , 4 ** ( n + i ))) s + = privKey [ i ] q = random . randint ( privKey [ n - 1 ] + 1 , 2 * privKey [ n - 1 ]) r = random . randint ( 1 , q ) while gmpy2 . gcd ( r , q ) != 1 : r = random . randint ( 1 , q ) pubKey = [ r * w % q for w in privKey ] return privKey , q , r , pubKey It can be seen that prikey is a super-incremental sequence, and the obtained q is larger than the sum of all the numbers in prikey. In addition, we get r, which is exactly the same as q, which indicates that the encryption is a backpack encryption. Sure enough, the encryption function is to multiply each bit of the message by the corresponding public key and sum. def encrypt ( msg , pubKey ): msg_bit = msg n = only ( pubKey ) cipher = 0 i = 0 for bit in msg_bit : cipher += int ( bit ) * pubKey [ i ] i += 1 return bin ( cipher )[ 2 :] For the cracked script we use the script on [GitHub] ( https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ). Make some simple modifications. import binascii # open the public key and strip the spaces so we have a decent array fileKey = open ( & quot ; pub . Key & quot ;, & #39;rb&#39;) pubKey = fileKey . read () . replace ( ' ' , '' ) . replace ( 'L' , '' ) . strip ( '[]' ) . split ( ',' ) nbit = only ( pubKey ) # open the encoded message fileEnc = open ( & quot ; enc . txt & quot ;, & #39;rb&#39;) encoded = fileEnc . read () . replace ( 'L' , '' ) print \"start\" # create a large matrix of 0's (dimensions are public key length +1) A = Matrix ( ZZ , nbit + 1 , nbit + 1 ) # fill in the identity matrix for i in xrange ( nbit ): A [ i , i ] = 1 # replace the bottom row with your public key for i in xrange ( nbit ): A [ i , nbit ] = pubKey [ i ] # last element is the encoded message A [ nbit , nbit ] = - int ( encoded ) res = A . LLL () for i in range ( 0 , nbit + 1 ): # print solution M = res . row ( i ) . list () flag = True for m in M : if m != 0 and m != 1 : flag = False break if flag : print i , M M = '' . join ( str ( j ) for j in M ) # remove the last bit M = M [: - 1 ] M = hex ( int ( M , 2 ))[ 2 : - 1 ] print M Decoded after output 295 [ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] 415349535 f3962643364356664323432323638326331393536383830366130373036316365 & gt ; & gt ; & gt ; import binascii >>> binascii . unhexlify ( '415349535f3962643364356664323432323638326331393536383830366130373036316365' ) & #39;ASIS_9bd3d5fd2422682c19568806a07061ce&#39; It should be noted that the matrix of res obtained by the LLL attack we only contains the 01 value is the result we want, because when we encrypt the plaintext, it will be decomposed into binary bit strings. In addition, we need to remove the last number of the corresponding row. flag \u662f ASIS_9bd3d5fd2422682c19568806a07061ce \u3002 Title \u00b6 2017 national classic","title":"\u80cc\u5305\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#backpack-problem","text":"First, let's introduce the backpack problem. Suppose a backpack can weigh W. Now there are n items with weights of a_1, a_2,..., a_n a_1, a_2,..., a_n . We want to ask which items can fit the backpack. Filled up and each item can only be loaded once. This is actually solving such a problem. $$ x_1a_1 + x_2a_2 +, ..., + x_na_n = W $$ All of these x_i x_i can only be 0 and 1. Obviously we have to enumerate all the combinations of n items to solve this problem, and the complexity is 2^n 2^n , which is the beauty of backpack encryption. When encrypting, if we want to encrypt the plaintext as x, then we can represent it as an n-bit binary number and then multiply it by a_i a_i to get the encrypted result. But what should I do when decrypting? We did make it difficult for others to decrypt the ciphertext, but we really have no way to decrypt the ciphertext. But when a_i a_i is super-incremental, we have a solution. The so-called super-increment means that the sequence satisfies the following conditions. $$ a_i>\\sum_{k=1}^{i-1}a_k $$ That is, the ith number is greater than the sum of all the previous numbers. Why can you decrypt it if you meet such a condition? This is because if the encrypted result is greater than a_n a_n , the preceding coefficient must be 1. On the contrary, the equation cannot be established anyway. Therefore, we can get the corresponding plaintext immediately. However, this has another problem. Since a_i a_i is public, if the attacker intercepts the ciphertext, it is easy to crack such a password. In order to make up for this problem, an encryption algorithm such as Merkle\u2013Hellman appears. We can use the initial backpack set as the private key, the transformed backpack set as the public key, and then slightly change the encryption process. Although the super-increment sequence is mentioned here, it is not said how it is generated.","title":"Backpack problem"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#merklehellman","text":"","title":"Merkle\u2013Hellman"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#public-private-key-generation","text":"","title":"Public private key generation"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#generating-a-private-key","text":"The private key is our initial backpack set. Here we use the super-increment sequence, how to generate it? We can assume that a_1=1 a_1=1 , then a_2 a_2 is greater than 1, and similarly can generate subsequent values in turn.","title":"Generating a private key"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#generating-a-public-key","text":"In the process of generating a public key, the operation of modular multiplication is mainly used. First, we generate the modulus m of the modular multiplication, here we want to make sure $$ m>\\sum_{i=1}^{i=n}a_i $$ Second, we choose the multiplier w of the modular multiplication as the private key and ensure $$ gcd(w,m)=1 $$ After that, we can generate the public key by the following formula. $$ b_i \\equiv w a_i \\bmod m $$ And this new backpack set b_i b_i and m as the public key.","title":"Generating a public key"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#encryption-and-decryption","text":"","title":"encryption and decryption"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#encryption","text":"Suppose we want to encrypt the plaintext as v, each bit is v_i v_i , then the result of our encryption is $$ Sum_ {i = 1} ^ {n} i = b_iv_i m way $$","title":"Encryption"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#decryption","text":"For the decryption side, we can first ask for the inverse of m^{-1} m^{-1} for m. Then we can multiply the obtained ciphertext by w^{-1} w^{-1} to get the plaintext, because $$ Sum_ {i = 1} ^ {w} i = n ^ {- 1} b_iv_i way m = sum_ {i = 1} ^ {n} i = a_iv_i m way $$ here has $$ b_i \\equiv w a_i \\bmod m $$ The encrypted message for each block is less than m, so the result is naturally plaintext.","title":"Decryption"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#_1","text":"The system was deciphered two years after the proposed encryption system. The basic idea of deciphering is that we do not necessarily need to find the correct multiplier w (ie trapdoor information), just find the arbitrary modulus m&#39; and The multiplier w&#39; can be used to generate a super-incrementing backpack vector by using w&#39; to multiply the public backpack vector B.","title":"\u7834"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#examples","text":"Here we take Archaic in 2014 ASIS Cyber Security Contest Quals as an example, [topic link] ( https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ). First look at the source program secret = 'CENSORED' msg_bit = bin ( int ( secret . encode ( 'hex' ), 16 ))[ 2 :] First we get all the bits of secret. Second, use the following function to get the keypair, including the public and private keys. keyPair = makeKey ( curtain ( msg_bit )) Carefully analyze the makekey function as follows def makeKey ( n ): privKey = [ random . randint ( 1 , 4 ** n )] s = privKey [ 0 ] for i in range ( 1 , n ): privKey . append ( random . randint ( s + 1 , 4 ** ( n + i ))) s + = privKey [ i ] q = random . randint ( privKey [ n - 1 ] + 1 , 2 * privKey [ n - 1 ]) r = random . randint ( 1 , q ) while gmpy2 . gcd ( r , q ) != 1 : r = random . randint ( 1 , q ) pubKey = [ r * w % q for w in privKey ] return privKey , q , r , pubKey It can be seen that prikey is a super-incremental sequence, and the obtained q is larger than the sum of all the numbers in prikey. In addition, we get r, which is exactly the same as q, which indicates that the encryption is a backpack encryption. Sure enough, the encryption function is to multiply each bit of the message by the corresponding public key and sum. def encrypt ( msg , pubKey ): msg_bit = msg n = only ( pubKey ) cipher = 0 i = 0 for bit in msg_bit : cipher += int ( bit ) * pubKey [ i ] i += 1 return bin ( cipher )[ 2 :] For the cracked script we use the script on [GitHub] ( https://github.com/ctfs/write-ups-2014/tree/b02bcbb2737907dd0aa39c5d4df1d1e270958f54/asis-ctf-quals-2014/archaic ). Make some simple modifications. import binascii # open the public key and strip the spaces so we have a decent array fileKey = open ( & quot ; pub . Key & quot ;, & #39;rb&#39;) pubKey = fileKey . read () . replace ( ' ' , '' ) . replace ( 'L' , '' ) . strip ( '[]' ) . split ( ',' ) nbit = only ( pubKey ) # open the encoded message fileEnc = open ( & quot ; enc . txt & quot ;, & #39;rb&#39;) encoded = fileEnc . read () . replace ( 'L' , '' ) print \"start\" # create a large matrix of 0's (dimensions are public key length +1) A = Matrix ( ZZ , nbit + 1 , nbit + 1 ) # fill in the identity matrix for i in xrange ( nbit ): A [ i , i ] = 1 # replace the bottom row with your public key for i in xrange ( nbit ): A [ i , nbit ] = pubKey [ i ] # last element is the encoded message A [ nbit , nbit ] = - int ( encoded ) res = A . LLL () for i in range ( 0 , nbit + 1 ): # print solution M = res . row ( i ) . list () flag = True for m in M : if m != 0 and m != 1 : flag = False break if flag : print i , M M = '' . join ( str ( j ) for j in M ) # remove the last bit M = M [: - 1 ] M = hex ( int ( M , 2 ))[ 2 : - 1 ] print M Decoded after output 295 [ 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ] 415349535 f3962643364356664323432323638326331393536383830366130373036316365 & gt ; & gt ; & gt ; import binascii >>> binascii . unhexlify ( '415349535f3962643364356664323432323638326331393536383830366130373036316365' ) & #39;ASIS_9bd3d5fd2422682c19568806a07061ce&#39; It should be noted that the matrix of res obtained by the LLL attack we only contains the 01 value is the result we want, because when we encrypt the plaintext, it will be decomposed into binary bit strings. In addition, we need to remove the last number of the corresponding row. flag \u662f ASIS_9bd3d5fd2422682c19568806a07061ce \u3002","title":"Examples"},{"location":"crypto/ctf-wiki/asymmetric/knapsack/knapsack/#title","text":"2017 national classic","title":"Title"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/","text":"EN | ZH CVP \u00b6 CVP\u662fLattice-based cryptography\u4e2d\u5c24\u4e3a\u91cd\u8981\u7684\u4e00\u4e2a\u95ee\u9898\u3002 \u95ee\u9898\u7684\u57fa\u672c\u5b9a\u4e49\u5982\u4e0b\uff1a\u7ed9\u5b9a\u683c L L \u7684\u4e00\u7ec4\u57fa\u4e0e\u5411\u91cf \\mathbf{v} \\mathbf{v} \uff0c\u627e\u5230\u5728 L L \u4e0a\u79bb \\mathbf{v} \\mathbf{v} \u6700\u8fd1\u7684\u4e00\u4e2a\u5411\u91cf\u3002 Algorithms \u00b6 Babai's nearest plane algorithm \u00b6 \u8be5\u7b97\u6cd5\u8f93\u5165\u4e00\u7ec4\u683c L L (\u79e9\u4e3a n n )\u7684\u57fa B B \u548c\u4e00\u4e2a\u76ee\u6807\u5411\u91cf \\mathbf{t} \\mathbf{t} \uff0c\u8f93\u51faCVP\u95ee\u9898\u7684\u8fd1\u4f3c\u89e3\u3002 \u8fd1\u4f3c\u56e0\u5b50\u4e3a \\gamma = 2^{\\frac{n}{2}} \\gamma = 2^{\\frac{n}{2}} \u5177\u4f53\u7b97\u6cd5\uff1a \u5176\u4e2d c_j c_j \u4e3aGram-schmidt\u6b63\u4ea4\u5316\u4e2d\u7684\u7cfb\u6570\u53d6\u6574\uff0c\u4e5f\u5373 proj_{b_{j}}(b) proj_{b_{j}}(b) \u7684\u53d6\u6574\u3002 \u5bf9\u4e8e\u8be5\u7b97\u6cd5\u7b2c\u4e8c\u6b65\u7684\u4e2a\u4eba\u7406\u89e3\uff1a\u5728\u683c\u57fa\u89c4\u7ea6\u548c\u6b63\u4ea4\u5316\u8fc7\u540e\u7684\u57fa B B \u4e2d\u627e\u5230\u4e00\u4e2a\u6700\u9760\u8fd1 \\mathbf{t} \\mathbf{t} \u7684\u7ebf\u6027\u7ec4\u5408\u3002 Babai\u2019s Rounding Technique \u00b6 \u8be5\u7b97\u6cd5\u662f Babai's nearest plane algorithm \u7684\u4e00\u4e2a\u53d8\u79cd\u3002 \u6b65\u9aa4\u53ef\u4ee5\u8868\u793a\u4e3a\uff1a N = rank(B), w = target - B' = LLL(B) - Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b'_i). * (b'_i is the i-th vector in the LLL-reduced basis B') - Round each l_i to it's closest integer l'_i. - Result v = sum(l'_i * b'_i) \u76f8\u5173\u5185\u5bb9 \u00b6 Hidden number problem \u00b6 HNP\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a \u7ed9\u5b9a\u8d28\u6570 p p \u3001\u8bb8\u591a t \\in \\mathbb{F}_p t \\in \\mathbb{F}_p \u4ee5\u53ca\u6bcf\u4e00\u4e2a\u5bf9\u5e94\u7684 MSB_{l,p}(\\alpha t) MSB_{l,p}(\\alpha t) \uff0c\u627e\u51fa\u5bf9\u5e94\u7684 \\alpha \\alpha \u3002 MSB_{l,p}(x) MSB_{l,p}(x) \u8868\u793a\u4efb\u4e00\u6ee1\u8db3 \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} \u7684\u6574\u6570 u u \uff0c\u8fd1\u4f3c\u4e3a\u53d6 x \\mod p x \\mod p \u7684 l l \u4e2a\u6700\u9ad8\u6709\u6548\u4f4d\u3002 \u6839\u636e\u53c2\u80033\u4e2d\u7684\u63cf\u8ff0\uff0c\u5f53 l \\approx \\log^{\\frac{1}{2}}{p} l \\approx \\log^{\\frac{1}{2}}{p} \u65f6\uff0c\u6709\u5982\u4e0b\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51b3HNP\uff1a \u6211\u4eec\u53ef\u4ee5\u5c06\u6b64\u95ee\u9898\u8f6c\u5316\u4e3a\u4e00\u4e2a\u7531\u8be5\u77e9\u9635\u751f\u6210\u7684\u683c\u4e0a\u7684CVP\u95ee\u9898\uff1a \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] \u6211\u4eec\u9700\u8981\u627e\u5230\u5728\u683c\u4e0a\u79bb \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) \u6700\u8fd1\u7684\u5411\u91cf\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528 Babai's nearest plane algorithm \u3002\u6700\u7ec8\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u4e00\u7ec4\u5411\u91cf \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1}}) \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1}}) \uff0c\u4ece\u800c\u7b97\u51fa \\alpha \\alpha \u3002 BCTF 2018 - guess_number \u00b6 \u9898\u76ee\u63d0\u4f9b\u4e86\u670d\u52a1\u5668\u7aef\u7684\u4ee3\u7801\uff1a import random , sys from flag import FLAG import gmpy2 def msb ( k , x , p ): delta = p >> ( k + 1 ) ui = random . randint ( x - delta , x + delta ) return ui def main (): p = gmpy2 . next_prime ( 2 ** 160 ) for _ in range ( 5 ): alpha = random . randint ( 1 , p - 1 ) # print(alpha) t = [] u = [] k = 10 for i in range ( 22 ): t . append ( random . randint ( 1 , p - 1 )) u . append ( msb ( k , alpha * t [ i ] % p , p )) print ( str ( t )) print ( str ( u )) guess = raw_input ( 'Input your guess number: ' ) guess = int ( guess ) if guess != alpha : exit ( 0 ) if __name__ == \"__main__\" : main () print ( FLAG ) \u53ef\u4ee5\u770b\u5230\uff0c\u7a0b\u5e8f\u4e00\u5171\u6267\u884c5\u8f6e\u3002\u5728\u6bcf\u4e00\u8f6e\uff0c\u7a0b\u5e8f\u4f1a\u751f\u6210\u4e00\u4e2a\u968f\u673a\u7684 \\alpha \\alpha \u548c22\u4e2a\u968f\u673a\u7684 t_i t_i \u3002\u5bf9\u4e8e\u6bcf\u4e00\u4e2a t_i t_i \uff0c\u7a0b\u5e8f\u4f1a\u53d6 u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) \uff0c\u968f\u540e\u53d1\u9001\u7ed9\u5ba2\u6237\u7aef\u3002\u6211\u4eec\u9700\u8981\u6839\u636e\u63d0\u4f9b\u7684 t_i t_i \u548c u_i u_i \u8ba1\u7b97\u51fa\u5bf9\u5e94\u7684 \\alpha \\alpha \u3002\u53ef\u4ee5\u770b\u5230\uff0c\u8be5\u95ee\u9898\u662f\u4e00\u4e2a\u5178\u578b\u7684Hidden number problem\uff0c\u4e8e\u662f\u53ef\u4ee5\u4f7f\u7528\u4e0a\u8ff0\u7b97\u6cd5\u89e3\u51b3\uff1a import socket import ast import telnetlib #HOST, PORT = 'localhost', 9999 HOST , PORT = '60.205.223.220' , 9999 s = socket . socket () s . connect (( HOST , PORT )) f = s . makefile ( 'rw' , 0 ) def recv_until ( f , delim = ' \\n ' ): buf = '' while not buf . endswith ( delim ): buf += f . read ( 1 ) return buf p = 1461501637330902918203684832716283019655932542983 k = 10 def solve_hnp ( t , u ): # http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf M = Matrix ( RationalField (), 23 , 23 ) for i in xrange ( 22 ): M [ i , i ] = p M [ 22 , i ] = t [ i ] M [ 22 , 22 ] = 1 / ( 2 ** ( k + 1 )) def babai ( A , w ): A = A . LLL ( delta = 0.75 ) G = A . gram_schmidt ()[ 0 ] t = w for i in reversed ( range ( A . nrows ())): c = (( t * G [ i ]) / ( G [ i ] * G [ i ])) . round () t -= A [ i ] * c return w - t closest = babai ( M , vector ( u + [ 0 ])) return ( closest [ - 1 ] * ( 2 ** ( k + 1 ))) % p for i in xrange ( 5 ): t = ast . literal_eval ( f . readline () . strip ()) u = ast . literal_eval ( f . readline () . strip ()) alpha = solve_hnp ( t , u ) recv_until ( f , 'number: ' ) s . send ( str ( alpha ) + ' \\n ' ) t = telnetlib . Telnet () t . sock = s t . interact () \u53c2\u8003 \u00b6 Lecture 3 - CVP algorithm Wikipedia Playing \u201cHide-and-Seek\u201d in Finite Fields: Hidden Number Problem and Its Applications https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch18.pdf","title":"Cvp zh"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/#cvp","text":"CVP\u662fLattice-based cryptography\u4e2d\u5c24\u4e3a\u91cd\u8981\u7684\u4e00\u4e2a\u95ee\u9898\u3002 \u95ee\u9898\u7684\u57fa\u672c\u5b9a\u4e49\u5982\u4e0b\uff1a\u7ed9\u5b9a\u683c L L \u7684\u4e00\u7ec4\u57fa\u4e0e\u5411\u91cf \\mathbf{v} \\mathbf{v} \uff0c\u627e\u5230\u5728 L L \u4e0a\u79bb \\mathbf{v} \\mathbf{v} \u6700\u8fd1\u7684\u4e00\u4e2a\u5411\u91cf\u3002","title":"CVP"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/#algorithms","text":"","title":"Algorithms"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/#babais-nearest-plane-algorithm","text":"\u8be5\u7b97\u6cd5\u8f93\u5165\u4e00\u7ec4\u683c L L (\u79e9\u4e3a n n )\u7684\u57fa B B \u548c\u4e00\u4e2a\u76ee\u6807\u5411\u91cf \\mathbf{t} \\mathbf{t} \uff0c\u8f93\u51faCVP\u95ee\u9898\u7684\u8fd1\u4f3c\u89e3\u3002 \u8fd1\u4f3c\u56e0\u5b50\u4e3a \\gamma = 2^{\\frac{n}{2}} \\gamma = 2^{\\frac{n}{2}} \u5177\u4f53\u7b97\u6cd5\uff1a \u5176\u4e2d c_j c_j \u4e3aGram-schmidt\u6b63\u4ea4\u5316\u4e2d\u7684\u7cfb\u6570\u53d6\u6574\uff0c\u4e5f\u5373 proj_{b_{j}}(b) proj_{b_{j}}(b) \u7684\u53d6\u6574\u3002 \u5bf9\u4e8e\u8be5\u7b97\u6cd5\u7b2c\u4e8c\u6b65\u7684\u4e2a\u4eba\u7406\u89e3\uff1a\u5728\u683c\u57fa\u89c4\u7ea6\u548c\u6b63\u4ea4\u5316\u8fc7\u540e\u7684\u57fa B B \u4e2d\u627e\u5230\u4e00\u4e2a\u6700\u9760\u8fd1 \\mathbf{t} \\mathbf{t} \u7684\u7ebf\u6027\u7ec4\u5408\u3002","title":"Babai's nearest plane algorithm"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/#babais-rounding-technique","text":"\u8be5\u7b97\u6cd5\u662f Babai's nearest plane algorithm \u7684\u4e00\u4e2a\u53d8\u79cd\u3002 \u6b65\u9aa4\u53ef\u4ee5\u8868\u793a\u4e3a\uff1a N = rank(B), w = target - B' = LLL(B) - Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b'_i). * (b'_i is the i-th vector in the LLL-reduced basis B') - Round each l_i to it's closest integer l'_i. - Result v = sum(l'_i * b'_i)","title":"Babai\u2019s Rounding Technique"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/#_1","text":"","title":"\u76f8\u5173\u5185\u5bb9"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/#hidden-number-problem","text":"HNP\u7684\u5b9a\u4e49\u5982\u4e0b\uff1a \u7ed9\u5b9a\u8d28\u6570 p p \u3001\u8bb8\u591a t \\in \\mathbb{F}_p t \\in \\mathbb{F}_p \u4ee5\u53ca\u6bcf\u4e00\u4e2a\u5bf9\u5e94\u7684 MSB_{l,p}(\\alpha t) MSB_{l,p}(\\alpha t) \uff0c\u627e\u51fa\u5bf9\u5e94\u7684 \\alpha \\alpha \u3002 MSB_{l,p}(x) MSB_{l,p}(x) \u8868\u793a\u4efb\u4e00\u6ee1\u8db3 \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} \u7684\u6574\u6570 u u \uff0c\u8fd1\u4f3c\u4e3a\u53d6 x \\mod p x \\mod p \u7684 l l \u4e2a\u6700\u9ad8\u6709\u6548\u4f4d\u3002 \u6839\u636e\u53c2\u80033\u4e2d\u7684\u63cf\u8ff0\uff0c\u5f53 l \\approx \\log^{\\frac{1}{2}}{p} l \\approx \\log^{\\frac{1}{2}}{p} \u65f6\uff0c\u6709\u5982\u4e0b\u7b97\u6cd5\u53ef\u4ee5\u89e3\u51b3HNP\uff1a \u6211\u4eec\u53ef\u4ee5\u5c06\u6b64\u95ee\u9898\u8f6c\u5316\u4e3a\u4e00\u4e2a\u7531\u8be5\u77e9\u9635\u751f\u6210\u7684\u683c\u4e0a\u7684CVP\u95ee\u9898\uff1a \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] \u6211\u4eec\u9700\u8981\u627e\u5230\u5728\u683c\u4e0a\u79bb \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) \u6700\u8fd1\u7684\u5411\u91cf\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528 Babai's nearest plane algorithm \u3002\u6700\u7ec8\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u4e00\u7ec4\u5411\u91cf \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1}}) \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1}}) \uff0c\u4ece\u800c\u7b97\u51fa \\alpha \\alpha \u3002","title":"Hidden number problem"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/#bctf-2018-guess_number","text":"\u9898\u76ee\u63d0\u4f9b\u4e86\u670d\u52a1\u5668\u7aef\u7684\u4ee3\u7801\uff1a import random , sys from flag import FLAG import gmpy2 def msb ( k , x , p ): delta = p >> ( k + 1 ) ui = random . randint ( x - delta , x + delta ) return ui def main (): p = gmpy2 . next_prime ( 2 ** 160 ) for _ in range ( 5 ): alpha = random . randint ( 1 , p - 1 ) # print(alpha) t = [] u = [] k = 10 for i in range ( 22 ): t . append ( random . randint ( 1 , p - 1 )) u . append ( msb ( k , alpha * t [ i ] % p , p )) print ( str ( t )) print ( str ( u )) guess = raw_input ( 'Input your guess number: ' ) guess = int ( guess ) if guess != alpha : exit ( 0 ) if __name__ == \"__main__\" : main () print ( FLAG ) \u53ef\u4ee5\u770b\u5230\uff0c\u7a0b\u5e8f\u4e00\u5171\u6267\u884c5\u8f6e\u3002\u5728\u6bcf\u4e00\u8f6e\uff0c\u7a0b\u5e8f\u4f1a\u751f\u6210\u4e00\u4e2a\u968f\u673a\u7684 \\alpha \\alpha \u548c22\u4e2a\u968f\u673a\u7684 t_i t_i \u3002\u5bf9\u4e8e\u6bcf\u4e00\u4e2a t_i t_i \uff0c\u7a0b\u5e8f\u4f1a\u53d6 u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) \uff0c\u968f\u540e\u53d1\u9001\u7ed9\u5ba2\u6237\u7aef\u3002\u6211\u4eec\u9700\u8981\u6839\u636e\u63d0\u4f9b\u7684 t_i t_i \u548c u_i u_i \u8ba1\u7b97\u51fa\u5bf9\u5e94\u7684 \\alpha \\alpha \u3002\u53ef\u4ee5\u770b\u5230\uff0c\u8be5\u95ee\u9898\u662f\u4e00\u4e2a\u5178\u578b\u7684Hidden number problem\uff0c\u4e8e\u662f\u53ef\u4ee5\u4f7f\u7528\u4e0a\u8ff0\u7b97\u6cd5\u89e3\u51b3\uff1a import socket import ast import telnetlib #HOST, PORT = 'localhost', 9999 HOST , PORT = '60.205.223.220' , 9999 s = socket . socket () s . connect (( HOST , PORT )) f = s . makefile ( 'rw' , 0 ) def recv_until ( f , delim = ' \\n ' ): buf = '' while not buf . endswith ( delim ): buf += f . read ( 1 ) return buf p = 1461501637330902918203684832716283019655932542983 k = 10 def solve_hnp ( t , u ): # http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf M = Matrix ( RationalField (), 23 , 23 ) for i in xrange ( 22 ): M [ i , i ] = p M [ 22 , i ] = t [ i ] M [ 22 , 22 ] = 1 / ( 2 ** ( k + 1 )) def babai ( A , w ): A = A . LLL ( delta = 0.75 ) G = A . gram_schmidt ()[ 0 ] t = w for i in reversed ( range ( A . nrows ())): c = (( t * G [ i ]) / ( G [ i ] * G [ i ])) . round () t -= A [ i ] * c return w - t closest = babai ( M , vector ( u + [ 0 ])) return ( closest [ - 1 ] * ( 2 ** ( k + 1 ))) % p for i in xrange ( 5 ): t = ast . literal_eval ( f . readline () . strip ()) u = ast . literal_eval ( f . readline () . strip ()) alpha = solve_hnp ( t , u ) recv_until ( f , 'number: ' ) s . send ( str ( alpha ) + ' \\n ' ) t = telnetlib . Telnet () t . sock = s t . interact ()","title":"BCTF 2018 - guess_number"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp-zh/#_2","text":"Lecture 3 - CVP algorithm Wikipedia Playing \u201cHide-and-Seek\u201d in Finite Fields: Hidden Number Problem and Its Applications https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch18.pdf","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/","text":"EN | ZH CVP \u00b6 CVP is a particularly important issue in Lattice-based cryptography. The basic definition of the problem is as follows: Given a set of bases and vectors \\mathbf{v} \\mathbf{v} for L L , find the nearest vector to \\mathbf{v} \\mathbf{v} on L L . Algorithms \u00b6 Babai's nearest plane algorithm \u00b6 The algorithm inputs a set of lattice L L (rank is n n ) base B B and a target vector \\mathbf{t} \\mathbf{t} to output an approximate solution to the CVP problem. The approximation factor is \\gamma = 2^{\\frac{n}{2}} \\gamma = 2^{\\frac{n}{2}} Specific algorithm: where c_j c_j is the rounding of the coefficients in the Gram-schmidt orthogonalization, which is the rounding of proj_{b_{j}}(b) proj_{b_{j}}(b) . For the personal understanding of the second step of the algorithm: find a linear combination closest to \\mathbf{t} \\mathbf{t} in the base B B after the lattice basis and the orthogonalization. Babai\u2019s Rounding Technique \u00b6 This algorithm is a variant of Babai&#39;s nearest plane algorithm . The steps can be expressed as: N = rank(B), w = target - B' = LLL(B) - Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b'_i). * (b'_i is the i-th vector in the LLL-reduced basis B') - Round each l_i to it's closest integer l'_i. - Result v = sum(l'_i * b'_i) related information \u00b6 Hidden number problem \u00b6 The definition of HNP is as follows: Given the prime p p , many t \\in \\mathbb{F}_p t \\in \\mathbb{F}_p and each corresponding MSB_{l,p}(\\alpha t) MSB_{l,p}(\\alpha t) , find the corresponding \\alpha \\alpha . MSB_{l,p}(x) MSB_{l,p}(x) means any integer $u that satisfies \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} $, which is approximately l l most significant digits of x \\mod p x \\mod p . According to the description in Reference 3, when l \\approx \\log^{\\frac{1}{2}}{p} l \\approx \\log^{\\frac{1}{2}}{p} , the following algorithm can solve HNP: We can turn this problem into a CVP problem on the lattice generated by the matrix: \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] We need to find the nearest vector from \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) on the lattice, so here we can use Babai&#39;s nearest plane algorithm . Finally we can get a set of vectors \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }) \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }) , which calculates \\alpha \\alpha . BCTF 2018 - guess_number \u00b6 The topic provides server-side code: import random , sys from flag import FLAG import gmpy2 def msb ( k , x , p ): delta = p & gt ; & gt ; ( k + 1 ) ui = random . randint ( x - delta , x + delta ) return ui def main (): p = gmpy2 . next_prime ( 2 ** 160 ) for _ in range ( 5 ): alpha = random . randint ( 1 , p - 1 ) # print(alpha) t = [] u = [] k = 10 for i in range ( 22 ): t . append ( random . randint ( 1 , p - 1 )) u . append ( msb ( k , alpha * t [ i ] % p , p )) print ( str ( t )) print ( p ( u )) guess = raw_input ( 'Input your guess number: ' ) guess = int ( guess ) if guess != alpha : exit ( 0 ) if __name__ == \"__main__\" : main () print ( FLAG ) As you can see, the program performs a total of 5 rounds. In each round, the program generates a random \\alpha \\alpha and 22 random t_i t_i . For each t_i t_i , the program will take u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) and send it to the client. We need to calculate the corresponding \\alpha \\alpha based on the provided t_i t_i and u_i u_i . As you can see, the problem is a typical Hidden number problem, so you can use the above algorithm to solve: import socket import ast import telnetlib #HOST, PORT = 'localhost', 9999 HOST , PORT = '60.205.223.220' , 9999 s = socket . socket () s . connect (( HOST , PORT )) f = s . makefile ( 'rw' , 0 ) def recv_until ( f , delim = ' \\n ' ): buf = & #39;&#39; while not buf . endswith ( delim ): buf += f . read ( 1 ) return buf p = 1461501637330902918203684832716283019655932542983 k = 10 def solve_hnp ( t , u ): # http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf M = Matrix ( RationalField (), 23 , 23 ) for i in xrange ( 22 ): M [ i , i ] = p M [ 22 , i ] = t [ i ] M [ 22 , 22 ] = 1 / ( 2 ** ( k + 1 )) def babai ( A , w ): A = A . LLL ( delta = 0.75 ) G = A . gram_schmidt ()[ 0 ] t = w for i in reversed ( range ( A . nrows ())): c = (( t * G [ i ]) / ( G [ i ] * G [ i ])) . round () t -= A [ i ] * c return w - t closest = babai ( M , vector ( u + [ 0 ])) return ( closest [ - 1 ] * ( 2 ** ( k + 1 ))) % p for i in xrange ( 5 ): t = ast . literal_eval ( f . readline () . strip ()) u = ast . literal_eval ( f . readline () . strip ()) alpha = solve_hnp ( t , u ) recv_until ( f , 'number: ' ) s . send ( str ( alpha ) + ' \\n ' ) t = telnetlib . Telnet () t . sock = s t . interact () Reference \u00b6 Lecture 3 - CVP algorithm Wikipedia Playing \u201cHide-and-Seek\u201d in Finite Fields: Hidden Number Problem and Its Applications https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch18.pdf","title":"CVP"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/#cvp","text":"CVP is a particularly important issue in Lattice-based cryptography. The basic definition of the problem is as follows: Given a set of bases and vectors \\mathbf{v} \\mathbf{v} for L L , find the nearest vector to \\mathbf{v} \\mathbf{v} on L L .","title":"CVP"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/#algorithms","text":"","title":"Algorithms"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/#babais-nearest-plane-algorithm","text":"The algorithm inputs a set of lattice L L (rank is n n ) base B B and a target vector \\mathbf{t} \\mathbf{t} to output an approximate solution to the CVP problem. The approximation factor is \\gamma = 2^{\\frac{n}{2}} \\gamma = 2^{\\frac{n}{2}} Specific algorithm: where c_j c_j is the rounding of the coefficients in the Gram-schmidt orthogonalization, which is the rounding of proj_{b_{j}}(b) proj_{b_{j}}(b) . For the personal understanding of the second step of the algorithm: find a linear combination closest to \\mathbf{t} \\mathbf{t} in the base B B after the lattice basis and the orthogonalization.","title":"Babai's nearest plane algorithm"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/#babais-rounding-technique","text":"This algorithm is a variant of Babai&#39;s nearest plane algorithm . The steps can be expressed as: N = rank(B), w = target - B' = LLL(B) - Find a linear combination [l_0, ... l_N] such that w = sum(l_i * b'_i). * (b'_i is the i-th vector in the LLL-reduced basis B') - Round each l_i to it's closest integer l'_i. - Result v = sum(l'_i * b'_i)","title":"Babai\u2019s Rounding Technique"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/#related-information","text":"","title":"related information"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/#hidden-number-problem","text":"The definition of HNP is as follows: Given the prime p p , many t \\in \\mathbb{F}_p t \\in \\mathbb{F}_p and each corresponding MSB_{l,p}(\\alpha t) MSB_{l,p}(\\alpha t) , find the corresponding \\alpha \\alpha . MSB_{l,p}(x) MSB_{l,p}(x) means any integer $u that satisfies \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} \\lvert (x \\mod p) - u \\rvert \\le \\frac{p}{2^{l+1}} $, which is approximately l l most significant digits of x \\mod p x \\mod p . According to the description in Reference 3, when l \\approx \\log^{\\frac{1}{2}}{p} l \\approx \\log^{\\frac{1}{2}}{p} , the following algorithm can solve HNP: We can turn this problem into a CVP problem on the lattice generated by the matrix: \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] \\left[ \\begin{matrix} p & 0 & \\dots & 0 & 0 \\\\ 0 & p & \\ddots & \\vdots & \\vdots \\\\ \\vdots & \\ddots & \\ddots & 0 & \\vdots \\\\ 0 & 0 & \\dots & p & 0 \\\\ t_1 & t_2 & \\dots & t_{n} & \\frac{1}{2^{l+1}} \\end{matrix} \\right] We need to find the nearest vector from \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) \\mathbf{u}=(u_1, u_2, \\dots, u_{n}, 0) on the lattice, so here we can use Babai&#39;s nearest plane algorithm . Finally we can get a set of vectors \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }) \\mathbf{v}=(\\alpha \\cdot t_1 \\mod p, \\alpha \\cdot t_2 \\mod p, \\dots, \\frac{\\alpha}{2^{l+1} }) , which calculates \\alpha \\alpha .","title":"Hidden number problem"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/#bctf-2018-guess_number","text":"The topic provides server-side code: import random , sys from flag import FLAG import gmpy2 def msb ( k , x , p ): delta = p & gt ; & gt ; ( k + 1 ) ui = random . randint ( x - delta , x + delta ) return ui def main (): p = gmpy2 . next_prime ( 2 ** 160 ) for _ in range ( 5 ): alpha = random . randint ( 1 , p - 1 ) # print(alpha) t = [] u = [] k = 10 for i in range ( 22 ): t . append ( random . randint ( 1 , p - 1 )) u . append ( msb ( k , alpha * t [ i ] % p , p )) print ( str ( t )) print ( p ( u )) guess = raw_input ( 'Input your guess number: ' ) guess = int ( guess ) if guess != alpha : exit ( 0 ) if __name__ == \"__main__\" : main () print ( FLAG ) As you can see, the program performs a total of 5 rounds. In each round, the program generates a random \\alpha \\alpha and 22 random t_i t_i . For each t_i t_i , the program will take u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) u_i = MSB_{10,p}(\\alpha\\cdot{t_i\\mod{p}}) and send it to the client. We need to calculate the corresponding \\alpha \\alpha based on the provided t_i t_i and u_i u_i . As you can see, the problem is a typical Hidden number problem, so you can use the above algorithm to solve: import socket import ast import telnetlib #HOST, PORT = 'localhost', 9999 HOST , PORT = '60.205.223.220' , 9999 s = socket . socket () s . connect (( HOST , PORT )) f = s . makefile ( 'rw' , 0 ) def recv_until ( f , delim = ' \\n ' ): buf = & #39;&#39; while not buf . endswith ( delim ): buf += f . read ( 1 ) return buf p = 1461501637330902918203684832716283019655932542983 k = 10 def solve_hnp ( t , u ): # http://www.isg.rhul.ac.uk/~sdg/igor-slides.pdf M = Matrix ( RationalField (), 23 , 23 ) for i in xrange ( 22 ): M [ i , i ] = p M [ 22 , i ] = t [ i ] M [ 22 , 22 ] = 1 / ( 2 ** ( k + 1 )) def babai ( A , w ): A = A . LLL ( delta = 0.75 ) G = A . gram_schmidt ()[ 0 ] t = w for i in reversed ( range ( A . nrows ())): c = (( t * G [ i ]) / ( G [ i ] * G [ i ])) . round () t -= A [ i ] * c return w - t closest = babai ( M , vector ( u + [ 0 ])) return ( closest [ - 1 ] * ( 2 ** ( k + 1 ))) % p for i in xrange ( 5 ): t = ast . literal_eval ( f . readline () . strip ()) u = ast . literal_eval ( f . readline () . strip ()) alpha = solve_hnp ( t , u ) recv_until ( f , 'number: ' ) s . send ( str ( alpha ) + ' \\n ' ) t = telnetlib . Telnet () t . sock = s t . interact ()","title":"BCTF 2018 - guess_number"},{"location":"crypto/ctf-wiki/asymmetric/lattice/cvp/#reference","text":"Lecture 3 - CVP algorithm Wikipedia Playing \u201cHide-and-Seek\u201d in Finite Fields: Hidden Number Problem and Its Applications https://www.math.auckland.ac.nz/~sgal018/crypto-book/ch18.pdf","title":"Reference"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction-zh/","text":"EN | ZH \u57fa\u672c\u4ecb\u7ecd \u00b6 \u683c\u5b9a\u4e49 \u00b6 \u683c\u662f m \u7ef4\u6b27\u5f0f\u7a7a\u95f4 R^m R^m \u7684 n ( m\\geq n m\\geq n ) \u4e2a\u7ebf\u6027\u65e0\u5173\u5411\u91cf b_i(1\\leq i \\leq n) b_i(1\\leq i \\leq n) \u7684\u6240\u6709\u6574\u7cfb\u6570\u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u5373 L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} \u8fd9\u91cc B \u5c31\u662f n \u4e2a\u5411\u91cf\u7684\u96c6\u5408\uff0c\u6211\u4eec\u79f0 \u8fd9 n \u4e2a\u5411\u91cf\u662f\u683c L \u7684\u4e00\u7ec4\u57fa\u3002 \u683c L \u7684\u79e9\u4e3a n\u3002 \u683c L \u7684\u4f4d\u6570\u4e3a m\u3002 \u5982\u679c m=n\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u8fd9\u4e2a\u683c\u5f0f\u6ee1\u79e9\u7684\u3002 \u5f53\u7136\uff0c\u4e5f\u53ef\u4ee5\u662f\u5176\u5b83\u7fa4\uff0c\u4e0d\u662f R^m R^m \u3002 \u683c\u4e2d\u82e5\u5e72\u57fa\u672c\u5b9a\u4e49 \u00b6 successive minima \u00b6 \u683c\u662f m \u7ef4\u6b27\u5f0f\u7a7a\u95f4 R^m R^m \u7684\u79e9\u4e3a n \u7684\u683c\uff0c\u90a3\u4e48 L \u7684\u8fde\u7eed\u6700\u5c0f\u957f\u5ea6(successive minima)\u4e3a \\lambda_1,...,\\lambda_n \\in R \\lambda_1,...,\\lambda_n \\in R \uff0c\u6ee1\u8db3\u5bf9\u4e8e\u4efb\u610f\u7684 1\\leq i\\leq n 1\\leq i\\leq n \uff0c \\lambda_i \\lambda_i \u662f\u6ee1\u8db3\u683c\u4e2d i \u4e2a\u7ebf\u6027\u65e0\u5173\u7684\u5411\u91cf v_i v_i \uff0c ||v_j||\\leq \\lambda_i,1\\leq j\\leq i ||v_j||\\leq \\lambda_i,1\\leq j\\leq i \u7684\u6700\u5c0f\u503c\u3002 \u81ea\u7136\u7684 \\lambda_i \\leq \\lambda_j ,\\forall i <j \\lambda_i \\leq \\lambda_j ,\\forall i <j \u3002 \u683c\u4e2d\u8ba1\u7b97\u56f0\u96be\u6027\u95ee\u9898 \u00b6 \u6700\u77ed\u5411\u91cf\u95ee\u9898(Shortest Vector Problem\uff0cSVP) \uff1a\u7ed9\u5b9a\u683c L \u53ca\u5176\u57fa\u5411\u91cf B \uff0c\u627e\u5230\u683c L \u4e2d\u7684\u975e\u96f6\u5411\u91cf v \u4f7f\u5f97\u5bf9\u4e8e\u683c\u4e2d\u7684\u4efb\u610f\u5176\u5b83\u975e\u96f6\u5411\u91cf u\uff0c ||v|| \\leq ||u|| ||v|| \\leq ||u|| \u3002 \\gamma \\gamma -\u8fd1\u4f3c\u6700\u77ed\u5411\u91cf\u95ee\u9898(SVP- \\gamma \\gamma ) \uff1a\u7ed9\u5b9a\u683c L\uff0c\u627e\u5230\u683c L \u4e2d\u7684\u975e\u96f6\u5411\u91cf v \u4f7f\u5f97\u5bf9\u4e8e\u683c\u4e2d\u7684\u4efb\u610f\u5176\u5b83\u975e\u96f6\u5411\u91cf u\uff0c ||v|| \\leq \\gamma||u|| ||v|| \\leq \\gamma||u|| \u3002 \u8fde\u7eed\u6700\u5c0f\u957f\u5ea6\u95ee\u9898(Successive Minima Problem, SMP) :\u7ed9\u5b9a\u79e9\u4e3a n \u7684\u683c L\uff0c\u627e\u5230\u683c L \u4e2d n \u4e2a\u7ebf\u6027\u65e0\u5173\u5411\u91cf s_i s_i \uff0c\u6ee1\u8db3 \\lambda_i(L)=||s_i||, 1\\leq i \\leq n \\lambda_i(L)=||s_i||, 1\\leq i \\leq n \u3002 \u6700\u77ed\u7ebf\u6027\u65e0\u5173\u5411\u91cf\u95ee\u9898(Shortest Independent Vector Problem, SIVP) \uff1a\u7ed9\u5b9a\u4e00\u4e2a\u79e9\u4e3a n \u7684\u683c L\uff0c\u627e\u5230\u683c L \u4e2d n \u4e2a\u7ebf\u6027\u65e0\u5173\u5411\u91cf s_i s_i \uff0c\u6ee1\u8db3 ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n \u3002 \u552f\u4e00\u6700\u77ed\u5411\u91cf\u95ee\u9898(Unique Shortest Vector Problem, uSVP- \\gamma \\gamma ) \uff1a\u7ed9\u5b9a\u683c L\uff0c\u6ee1\u8db3 $ \\lambda_2(L) > \\gamma \\lambda_1(L)$\uff0c\u627e\u5230\u8be5\u683c\u7684\u6700\u77ed\u5411\u91cf\u3002 \u6700\u8fd1\u5411\u91cf\u95ee\u9898(Closest Vector Problem\uff0cCVP) \uff1a\u7ed9\u5b9a\u683c L\u548c\u76ee\u6807\u5411\u91cf t\\in R^m t\\in R^m \uff0c\u627e\u5230\u4e00\u4e2a\u683c\u4e2d\u7684\u975e\u96f6\u5411\u91cf v\uff0c\u4f7f\u5f97\u5bf9\u4e8e\u683c\u4e2d\u7684\u4efb\u610f\u975e\u96f6\u5411\u91cf u\uff0c\u6ee1\u8db3 ||v-t|| \\leq ||u-t|| ||v-t|| \\leq ||u-t|| \u3002","title":"Introduction zh"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction-zh/#_1","text":"","title":"\u57fa\u672c\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction-zh/#_2","text":"\u683c\u662f m \u7ef4\u6b27\u5f0f\u7a7a\u95f4 R^m R^m \u7684 n ( m\\geq n m\\geq n ) \u4e2a\u7ebf\u6027\u65e0\u5173\u5411\u91cf b_i(1\\leq i \\leq n) b_i(1\\leq i \\leq n) \u7684\u6240\u6709\u6574\u7cfb\u6570\u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u5373 L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} \u8fd9\u91cc B \u5c31\u662f n \u4e2a\u5411\u91cf\u7684\u96c6\u5408\uff0c\u6211\u4eec\u79f0 \u8fd9 n \u4e2a\u5411\u91cf\u662f\u683c L \u7684\u4e00\u7ec4\u57fa\u3002 \u683c L \u7684\u79e9\u4e3a n\u3002 \u683c L \u7684\u4f4d\u6570\u4e3a m\u3002 \u5982\u679c m=n\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u8fd9\u4e2a\u683c\u5f0f\u6ee1\u79e9\u7684\u3002 \u5f53\u7136\uff0c\u4e5f\u53ef\u4ee5\u662f\u5176\u5b83\u7fa4\uff0c\u4e0d\u662f R^m R^m \u3002","title":"\u683c\u5b9a\u4e49"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction-zh/#_3","text":"","title":"\u683c\u4e2d\u82e5\u5e72\u57fa\u672c\u5b9a\u4e49"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction-zh/#successive-minima","text":"\u683c\u662f m \u7ef4\u6b27\u5f0f\u7a7a\u95f4 R^m R^m \u7684\u79e9\u4e3a n \u7684\u683c\uff0c\u90a3\u4e48 L \u7684\u8fde\u7eed\u6700\u5c0f\u957f\u5ea6(successive minima)\u4e3a \\lambda_1,...,\\lambda_n \\in R \\lambda_1,...,\\lambda_n \\in R \uff0c\u6ee1\u8db3\u5bf9\u4e8e\u4efb\u610f\u7684 1\\leq i\\leq n 1\\leq i\\leq n \uff0c \\lambda_i \\lambda_i \u662f\u6ee1\u8db3\u683c\u4e2d i \u4e2a\u7ebf\u6027\u65e0\u5173\u7684\u5411\u91cf v_i v_i \uff0c ||v_j||\\leq \\lambda_i,1\\leq j\\leq i ||v_j||\\leq \\lambda_i,1\\leq j\\leq i \u7684\u6700\u5c0f\u503c\u3002 \u81ea\u7136\u7684 \\lambda_i \\leq \\lambda_j ,\\forall i <j \\lambda_i \\leq \\lambda_j ,\\forall i <j \u3002","title":"successive minima"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction-zh/#_4","text":"\u6700\u77ed\u5411\u91cf\u95ee\u9898(Shortest Vector Problem\uff0cSVP) \uff1a\u7ed9\u5b9a\u683c L \u53ca\u5176\u57fa\u5411\u91cf B \uff0c\u627e\u5230\u683c L \u4e2d\u7684\u975e\u96f6\u5411\u91cf v \u4f7f\u5f97\u5bf9\u4e8e\u683c\u4e2d\u7684\u4efb\u610f\u5176\u5b83\u975e\u96f6\u5411\u91cf u\uff0c ||v|| \\leq ||u|| ||v|| \\leq ||u|| \u3002 \\gamma \\gamma -\u8fd1\u4f3c\u6700\u77ed\u5411\u91cf\u95ee\u9898(SVP- \\gamma \\gamma ) \uff1a\u7ed9\u5b9a\u683c L\uff0c\u627e\u5230\u683c L \u4e2d\u7684\u975e\u96f6\u5411\u91cf v \u4f7f\u5f97\u5bf9\u4e8e\u683c\u4e2d\u7684\u4efb\u610f\u5176\u5b83\u975e\u96f6\u5411\u91cf u\uff0c ||v|| \\leq \\gamma||u|| ||v|| \\leq \\gamma||u|| \u3002 \u8fde\u7eed\u6700\u5c0f\u957f\u5ea6\u95ee\u9898(Successive Minima Problem, SMP) :\u7ed9\u5b9a\u79e9\u4e3a n \u7684\u683c L\uff0c\u627e\u5230\u683c L \u4e2d n \u4e2a\u7ebf\u6027\u65e0\u5173\u5411\u91cf s_i s_i \uff0c\u6ee1\u8db3 \\lambda_i(L)=||s_i||, 1\\leq i \\leq n \\lambda_i(L)=||s_i||, 1\\leq i \\leq n \u3002 \u6700\u77ed\u7ebf\u6027\u65e0\u5173\u5411\u91cf\u95ee\u9898(Shortest Independent Vector Problem, SIVP) \uff1a\u7ed9\u5b9a\u4e00\u4e2a\u79e9\u4e3a n \u7684\u683c L\uff0c\u627e\u5230\u683c L \u4e2d n \u4e2a\u7ebf\u6027\u65e0\u5173\u5411\u91cf s_i s_i \uff0c\u6ee1\u8db3 ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n \u3002 \u552f\u4e00\u6700\u77ed\u5411\u91cf\u95ee\u9898(Unique Shortest Vector Problem, uSVP- \\gamma \\gamma ) \uff1a\u7ed9\u5b9a\u683c L\uff0c\u6ee1\u8db3 $ \\lambda_2(L) > \\gamma \\lambda_1(L)$\uff0c\u627e\u5230\u8be5\u683c\u7684\u6700\u77ed\u5411\u91cf\u3002 \u6700\u8fd1\u5411\u91cf\u95ee\u9898(Closest Vector Problem\uff0cCVP) \uff1a\u7ed9\u5b9a\u683c L\u548c\u76ee\u6807\u5411\u91cf t\\in R^m t\\in R^m \uff0c\u627e\u5230\u4e00\u4e2a\u683c\u4e2d\u7684\u975e\u96f6\u5411\u91cf v\uff0c\u4f7f\u5f97\u5bf9\u4e8e\u683c\u4e2d\u7684\u4efb\u610f\u975e\u96f6\u5411\u91cf u\uff0c\u6ee1\u8db3 ||v-t|| \\leq ||u-t|| ||v-t|| \\leq ||u-t|| \u3002","title":"\u683c\u4e2d\u8ba1\u7b97\u56f0\u96be\u6027\u95ee\u9898"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction/","text":"EN | ZH Basic Introduction \u00b6 Lattice Definition \u00b6 The lattice is the linear combination of all integer coefficients of n ( m\\geq n m\\geq n ) linearly independent vectors b_i(1\\leq i \\leq n) b_i(1\\leq i \\leq n) of the m-dimensional Euclidean space R^m R^m , ie L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} Here B is a collection of n vectors, we call These n n vectors a set of bases of the lattice L L . The rank of the lattice L L is n n . The number of bits in L L is m m . If m = n m = n , then we call this format full rank. Of course, the space can be other groups instead of R^m R^m . Basic Definition in Lattices \u00b6 Successive Minimum \u00b6 Let lattice L L be a lattice in the m-dimensional Euclidean space R^m R^m with rank n n , then the continuous minimum length of L L (successive minima) is \\lambda_1,...,\\lambda_n \\in R \\lambda_1,...,\\lambda_n \\in R , where for any 1 \\leq i\\leq n 1 \\leq i\\leq n , \\lambda_i \\lambda_i is the minimum value to satisfy that for i i linearly independent vectors v_i v_i , ||v_j||\\leq \\lambda_i,1\\leq j\\leq i ||v_j||\\leq \\lambda_i,1\\leq j\\leq i . Obviously we have \\lambda_i \\leq \\lambda_j ,\\forall i <j \\lambda_i \\leq \\lambda_j ,\\forall i <j \u3002 Calculating Difficult Problems in the Lattice \u00b6 Shortest Vector Problem (SVP) : Given the lattice L and its base vector B, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, ||v| | \\leq ||u|| ||v| | \\leq ||u|| . \\gamma \\gamma -Approximate Shortest Vector Problem (SVP- \\gamma \\gamma ) : Given a fixed L, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, || v|| \\leq \\gamma||u|| || v|| \\leq \\gamma||u|| . Successive Minima Problem (SMP) : Given a lattice L of rank n, find n linearly independent vectors s_i s_i in lattice L, satisfying \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n . Shortest Independent Vector Problem (SIVP) : Given a lattice L of rank n, find n linear independent vectors s_i s_i in lattice L, satisfying ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n . Unique Shortest Vector Problem (uSVP- \\gamma \\gamma ) : Given a fixed L, satisfying $ \\lambda_2(L) > \\gamma \\lambda_1(L)$, find the shortest vector of the cell. Closest Vector Problem (CVP) : Given the lattice L and the target vector t\\in R^m t\\in R^m , find a non-zero vector v in a lattice such that for any non-zero vector u in the lattice , satisfy ||vt|| \\leq ||ut|| ||vt|| \\leq ||ut|| .","title":"\u683c\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction/#basic-introduction","text":"","title":"Basic Introduction"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction/#lattice-definition","text":"The lattice is the linear combination of all integer coefficients of n ( m\\geq n m\\geq n ) linearly independent vectors b_i(1\\leq i \\leq n) b_i(1\\leq i \\leq n) of the m-dimensional Euclidean space R^m R^m , ie L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} L(B)=\\{\\sum\\limits_{i=1}^{n}x_ib_i:x_i \\in Z,1\\leq i \\leq n\\} Here B is a collection of n vectors, we call These n n vectors a set of bases of the lattice L L . The rank of the lattice L L is n n . The number of bits in L L is m m . If m = n m = n , then we call this format full rank. Of course, the space can be other groups instead of R^m R^m .","title":"Lattice Definition"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction/#basic-definition-in-lattices","text":"","title":"Basic Definition in Lattices"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction/#successive-minimum","text":"Let lattice L L be a lattice in the m-dimensional Euclidean space R^m R^m with rank n n , then the continuous minimum length of L L (successive minima) is \\lambda_1,...,\\lambda_n \\in R \\lambda_1,...,\\lambda_n \\in R , where for any 1 \\leq i\\leq n 1 \\leq i\\leq n , \\lambda_i \\lambda_i is the minimum value to satisfy that for i i linearly independent vectors v_i v_i , ||v_j||\\leq \\lambda_i,1\\leq j\\leq i ||v_j||\\leq \\lambda_i,1\\leq j\\leq i . Obviously we have \\lambda_i \\leq \\lambda_j ,\\forall i <j \\lambda_i \\leq \\lambda_j ,\\forall i <j \u3002","title":"Successive Minimum"},{"location":"crypto/ctf-wiki/asymmetric/lattice/introduction/#calculating-difficult-problems-in-the-lattice","text":"Shortest Vector Problem (SVP) : Given the lattice L and its base vector B, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, ||v| | \\leq ||u|| ||v| | \\leq ||u|| . \\gamma \\gamma -Approximate Shortest Vector Problem (SVP- \\gamma \\gamma ) : Given a fixed L, find the non-zero vector v in the lattice L such that for any other non-zero vector u in the lattice, || v|| \\leq \\gamma||u|| || v|| \\leq \\gamma||u|| . Successive Minima Problem (SMP) : Given a lattice L of rank n, find n linearly independent vectors s_i s_i in lattice L, satisfying \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n \\lambda_i(L)=||s_i| |, 1\\leq i \\leq n . Shortest Independent Vector Problem (SIVP) : Given a lattice L of rank n, find n linear independent vectors s_i s_i in lattice L, satisfying ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n ||s_i|| \\leq \\lambda_n(L), 1\\leq i \\leq n . Unique Shortest Vector Problem (uSVP- \\gamma \\gamma ) : Given a fixed L, satisfying $ \\lambda_2(L) > \\gamma \\lambda_1(L)$, find the shortest vector of the cell. Closest Vector Problem (CVP) : Given the lattice L and the target vector t\\in R^m t\\in R^m , find a non-zero vector v in a lattice such that for any non-zero vector u in the lattice , satisfy ||vt|| \\leq ||ut|| ||vt|| \\leq ||ut|| .","title":"Calculating Difficult Problems in the Lattice"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction-zh/","text":"EN | ZH \u683c\u57fa\u89c4\u7ea6\u7b97\u6cd5 \u00b6 Lenstra\u2013Lenstra\u2013Lovasz \u00b6 \u57fa\u672c\u4ecb\u7ecd \u00b6 LLL \u7b97\u6cd5\u5c31\u662f\u5728\u683c\u4e0a\u627e\u5230\u4e00\u7ec4\u57fa\uff0c\u6ee1\u8db3\u5982\u4e0b\u6548\u679c \u800c\u4e14\uff0c\u8fd9\u79cd\u65b9\u6cd5\u751f\u6210\u7684\u57fa\u6240\u5177\u6709\u7684\u5982\u4e0b\u6027\u8d28\u662f\u975e\u5e38\u6709\u7528\u7684 \u7b80\u5355\u5e94\u7528 \u00b6 \u8fd9\u91cc\u6211\u4e3e\u4e00\u4e0b LLL paper \u4e2d\u7ed9\u7684\u7b2c\u4e8c\u4e2a\u4f8b\u5b50\u3002\u7ed9\u5b9a n \u4e2a\u5b9e\u6570 \\alpha_i,...,\\alpha_n \\alpha_i,...,\\alpha_n \uff0c\u627e\u5230\u8fd9 n \u4e2a\u6570\u7684\u6709\u7406\u7ebf\u6027\u903c\u8fd1\uff0c\u5373\u627e\u5230 n \u4e2a\u6570 m_i m_i \uff0c\u4f7f\u5f97 \\sum\\limits_{i=1}^{n}m_i\\alpha_i \\sum\\limits_{i=1}^{n}m_i\\alpha_i \u5c3d\u53ef\u80fd\u7b49\u4e8e 0\u3002 \u6211\u4eec\u53ef\u4ee5\u6784\u9020\u8fd9\u6837\u7684\u77e9\u9635\uff0c\u8fd9\u91cc a_i a_i \u4e3a \\alpha_i \\alpha_i \u7684\u6709\u7406\u903c\u8fd1\u3002 A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] \u77e9\u9635\u4e3a n*(n+1) \u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u683c\u6c42\u884c\u5217\u5f0f\u7684\u65b9\u6cd5\u6765\u6c42\u4e00\u4e0b\u8fd9\u4e2a\u683c\u5bf9\u5e94\u7684\u884c\u5217\u5f0f\u3002 det(L)=\\sqrt{AA^T} det(L)=\\sqrt{AA^T} \u6211\u4eec\u8fdb\u4e00\u6b65\u8003\u8651\u8fd9\u6837\u7684\u77e9\u9635 A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] \u90a3\u4e48 AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] \u8fdb\u4e00\u6b65\u6211\u4eec\u4ece\u4f4e\u7ef4\u5230\u9ad8\u7ef4\u5927\u6982\u8bd5\u4e00\u8bd5\uff08\u4e25\u683c\u8bc1\u660e\uff0c\u53ef\u4ee5\u8003\u8651\u6dfb\u52a0\u4e00\u884c\u548c\u4e00\u5217\uff0c\u5de6\u4e0a\u89d2\u4e3a1\uff09\uff0c\u5f97\u5230\u683c\u7684\u884c\u5217\u5f0f\u4e3a \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} \u53ef\u4ee5\u53c2\u89c1\u8003\u7814\u5b87\u54e5\u7684\u5982\u4e0b\u8bc1\u660e \u90a3\u4e48\u7ecf\u8fc7 LLL \u7b97\u6cd5\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u5f97 ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} \u4e00\u822c\u6765\u8bf4\u540e\u4e00\u9879\u5728\u5f00 n \u6b21\u65b9\u65f6\u8d8b\u5411\u4e8e1\uff0c\u56e0\u4e3a a_i a_i \u90fd\u662f\u5e38\u6570\uff0c\u4e00\u822c\u4e0d\u4f1a\u548c n \u76f8\u5173\uff0c\u6240\u4ee5 ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k k \u6bd4\u8f83\u5c0f\u3002\u6b64\u5916\uff0c b_1 b_1 \u53c8\u662f\u539f\u5411\u91cf\u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u90a3\u4e48 b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i \u663e\u7136\u5982\u679c c \u8db3\u591f\u5927\uff0c\u90a3\u4e48\u540e\u9762\u7684\u6c42\u548c\u5fc5\u987b\u8db3\u591f\u5c0f\uff0c\u624d\u53ef\u4ee5\u6ee1\u8db3\u4e0a\u9762\u7684\u7ea6\u675f\u3002 \u53c2\u8003 \u00b6 Survey: Lattice Reduction Attacks on RSA","title":"Lattice reduction zh"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction-zh/#_1","text":"","title":"\u683c\u57fa\u89c4\u7ea6\u7b97\u6cd5"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction-zh/#lenstralenstralovasz","text":"","title":"Lenstra\u2013Lenstra\u2013Lovasz"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction-zh/#_2","text":"LLL \u7b97\u6cd5\u5c31\u662f\u5728\u683c\u4e0a\u627e\u5230\u4e00\u7ec4\u57fa\uff0c\u6ee1\u8db3\u5982\u4e0b\u6548\u679c \u800c\u4e14\uff0c\u8fd9\u79cd\u65b9\u6cd5\u751f\u6210\u7684\u57fa\u6240\u5177\u6709\u7684\u5982\u4e0b\u6027\u8d28\u662f\u975e\u5e38\u6709\u7528\u7684","title":"\u57fa\u672c\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction-zh/#_3","text":"\u8fd9\u91cc\u6211\u4e3e\u4e00\u4e0b LLL paper \u4e2d\u7ed9\u7684\u7b2c\u4e8c\u4e2a\u4f8b\u5b50\u3002\u7ed9\u5b9a n \u4e2a\u5b9e\u6570 \\alpha_i,...,\\alpha_n \\alpha_i,...,\\alpha_n \uff0c\u627e\u5230\u8fd9 n \u4e2a\u6570\u7684\u6709\u7406\u7ebf\u6027\u903c\u8fd1\uff0c\u5373\u627e\u5230 n \u4e2a\u6570 m_i m_i \uff0c\u4f7f\u5f97 \\sum\\limits_{i=1}^{n}m_i\\alpha_i \\sum\\limits_{i=1}^{n}m_i\\alpha_i \u5c3d\u53ef\u80fd\u7b49\u4e8e 0\u3002 \u6211\u4eec\u53ef\u4ee5\u6784\u9020\u8fd9\u6837\u7684\u77e9\u9635\uff0c\u8fd9\u91cc a_i a_i \u4e3a \\alpha_i \\alpha_i \u7684\u6709\u7406\u903c\u8fd1\u3002 A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] \u77e9\u9635\u4e3a n*(n+1) \u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u683c\u6c42\u884c\u5217\u5f0f\u7684\u65b9\u6cd5\u6765\u6c42\u4e00\u4e0b\u8fd9\u4e2a\u683c\u5bf9\u5e94\u7684\u884c\u5217\u5f0f\u3002 det(L)=\\sqrt{AA^T} det(L)=\\sqrt{AA^T} \u6211\u4eec\u8fdb\u4e00\u6b65\u8003\u8651\u8fd9\u6837\u7684\u77e9\u9635 A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] \u90a3\u4e48 AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] \u8fdb\u4e00\u6b65\u6211\u4eec\u4ece\u4f4e\u7ef4\u5230\u9ad8\u7ef4\u5927\u6982\u8bd5\u4e00\u8bd5\uff08\u4e25\u683c\u8bc1\u660e\uff0c\u53ef\u4ee5\u8003\u8651\u6dfb\u52a0\u4e00\u884c\u548c\u4e00\u5217\uff0c\u5de6\u4e0a\u89d2\u4e3a1\uff09\uff0c\u5f97\u5230\u683c\u7684\u884c\u5217\u5f0f\u4e3a \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} \u53ef\u4ee5\u53c2\u89c1\u8003\u7814\u5b87\u54e5\u7684\u5982\u4e0b\u8bc1\u660e \u90a3\u4e48\u7ecf\u8fc7 LLL \u7b97\u6cd5\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u83b7\u5f97 ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} \u4e00\u822c\u6765\u8bf4\u540e\u4e00\u9879\u5728\u5f00 n \u6b21\u65b9\u65f6\u8d8b\u5411\u4e8e1\uff0c\u56e0\u4e3a a_i a_i \u90fd\u662f\u5e38\u6570\uff0c\u4e00\u822c\u4e0d\u4f1a\u548c n \u76f8\u5173\uff0c\u6240\u4ee5 ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k k \u6bd4\u8f83\u5c0f\u3002\u6b64\u5916\uff0c b_1 b_1 \u53c8\u662f\u539f\u5411\u91cf\u7684\u7ebf\u6027\u7ec4\u5408\uff0c\u90a3\u4e48 b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i \u663e\u7136\u5982\u679c c \u8db3\u591f\u5927\uff0c\u90a3\u4e48\u540e\u9762\u7684\u6c42\u548c\u5fc5\u987b\u8db3\u591f\u5c0f\uff0c\u624d\u53ef\u4ee5\u6ee1\u8db3\u4e0a\u9762\u7684\u7ea6\u675f\u3002","title":"\u7b80\u5355\u5e94\u7528"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction-zh/#_4","text":"Survey: Lattice Reduction Attacks on RSA","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction/","text":"EN | ZH \u683c\u57fa\u89c4\u7ea6 \u00b6 Lenstra \u2013 Lenstra \u2013 Lovasz \u00b6 basic introduction \u00b6 The LLL algorithm is to find a set of bases on the lattice, which satisfies the following effects. Moreover, the following properties of the base generated by this method are very useful. Simple application \u00b6 Here I will give a second example from LLL paper. Given n real numbers \\alpha_i,...,\\alpha_n \\alpha_i,...,\\alpha_n , find the rational linear approximation of the n numbers, ie find n numbers m_i m_i , so that \\sum\\limits_{i=1}^{n }m_i\\alpha_i \\sum\\limits_{i=1}^{n }m_i\\alpha_i is equal to 0 as much as possible. We can construct a matrix like this, where a_i a_i is a rational approximation of \\alpha_i \\alpha_i . A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] The matrix is n*(n+1), we can find the determinant corresponding to this lattice according to the method of finding the determinant. $ Det (L) = sqrt {AA} $ ^ T We further consider such a matrix A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] Then AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] Further, let's try it from low-dimensional to high-dimensional (strictly prove that you can consider adding a row and a column, the upper left corner is 1), and the determinant of the lattice is \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} Can refer to the following proof of the postgraduate Yuge Then after the LLL algorithm, we can get ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} In general, the latter item tends to 1 when it is opened n times, because a_i a_i is a constant and is generally not related to n, so ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k k is relatively small. In addition, b_1 b_1 is a linear combination of the original vectors, then b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i Obviously if c is large enough, then the subsequent summation must be small enough to satisfy the above constraints. Reference \u00b6 Survey: Lattice Reduction Attacks on RSA","title":"\u683c\u57fa\u89c4\u7ea6\u7b97\u6cd5"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction/#_1","text":"","title":"\u683c\u57fa\u89c4\u7ea6"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction/#lenstra-lenstra-lovasz","text":"","title":"Lenstra \u2013 Lenstra \u2013 Lovasz"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction/#basic-introduction","text":"The LLL algorithm is to find a set of bases on the lattice, which satisfies the following effects. Moreover, the following properties of the base generated by this method are very useful.","title":"basic introduction"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction/#simple-application","text":"Here I will give a second example from LLL paper. Given n real numbers \\alpha_i,...,\\alpha_n \\alpha_i,...,\\alpha_n , find the rational linear approximation of the n numbers, ie find n numbers m_i m_i , so that \\sum\\limits_{i=1}^{n }m_i\\alpha_i \\sum\\limits_{i=1}^{n }m_i\\alpha_i is equal to 0 as much as possible. We can construct a matrix like this, where a_i a_i is a rational approximation of \\alpha_i \\alpha_i . A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & ca_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & c a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & c a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & c a_n \\\\ \\end{matrix} \\right] The matrix is n*(n+1), we can find the determinant corresponding to this lattice according to the method of finding the determinant. $ Det (L) = sqrt {AA} $ ^ T We further consider such a matrix A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & 0 & \\cdots & 0 & a_2 \\\\ 0 & 0 & 1 & \\cdots & 0 & a_3 \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & a_n \\\\ \\end{matrix} \\right] Then AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] AA^T = \\left[ \\begin{matrix} 1+a_1^2 & a_1a_2 & a_1a_3 & \\cdots & a_1a_n \\\\ a_2a_1 & 1+a_2^2 & a_2a_3 & \\cdots & a_2a_n \\\\ a_3a_1 & a_3a_2 & 1+a_3^2 & \\cdots & a_3a_n \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_na_1 & a_na_2 &a_na_3 & \\cdots & 1+a_n^2 \\\\ \\end{matrix} \\right] Further, let's try it from low-dimensional to high-dimensional (strictly prove that you can consider adding a row and a column, the upper left corner is 1), and the determinant of the lattice is \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} \\sqrt{1+\\sum\\limits_{i=1}^n\\alpha_i^2} Can refer to the following proof of the postgraduate Yuge Then after the LLL algorithm, we can get ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} ||b_1|| \\leq 2^{\\frac{n-1}{4}} (1+\\sum\\limits_{i=1}^n\\alpha_i^2)^{\\frac{1}{2(n+1)}} In general, the latter item tends to 1 when it is opened n times, because a_i a_i is a constant and is generally not related to n, so ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k ||b_1|| \\leq 2^{\\frac{n-1}{4}}*k k is relatively small. In addition, b_1 b_1 is a linear combination of the original vectors, then b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i b_1[n]=\\sum\\limits_{i=1}^{n}m_ic*a_i=c\\sum\\limits_{i=1}^{n}m_i*a_i Obviously if c is large enough, then the subsequent summation must be small enough to satisfy the above constraints.","title":"Simple application"},{"location":"crypto/ctf-wiki/asymmetric/lattice/lattice-reduction/#reference","text":"Survey: Lattice Reduction Attacks on RSA","title":"Reference"},{"location":"crypto/ctf-wiki/asymmetric/lattice/overview-zh/","text":"EN | ZH \u683c\u6982\u8ff0 \u00b6 \u683c\u5728\u6570\u5b66\u4e0a\u81f3\u5c11\u6709\u4e24\u79cd\u542b\u4e49 \u5b9a\u4e49\u5728\u975e\u7a7a\u6709\u9650\u96c6\u5408\u4e0a\u7684\u504f\u5e8f\u96c6\u5408 L\uff0c\u6ee1\u8db3\u96c6\u5408 L \u4e2d\u7684\u4efb\u610f\u5143\u7d20 a\uff0cb\uff0c\u4f7f\u5f97 a\uff0cb \u5728 L \u4e2d\u5b58\u5728\u4e00\u4e2a\u6700\u5927\u4e0b\u754c\uff0c\u548c\u6700\u5c0f\u4e0a\u754c\u3002\u5177\u4f53\u53c2\u89c1https://en.wikipedia.org/wiki/Lattice_(order)\u3002 \u7fa4\u8bba\u4e2d\u7684\u5b9a\u4e49\uff0c\u662f R^n R^n \u4e2d\u7684\u6ee1\u8db3\u67d0\u79cd\u6027\u8d28\u7684\u5b50\u96c6\u3002\u5f53\u7136\uff0c\u4e5f\u53ef\u4ee5\u662f\u5176\u5b83\u7fa4\u3002 \u76ee\u524d\u5173\u4e8e\u683c\u65b9\u9762\u7684\u7814\u7a76\u4e3b\u8981\u6709\u4ee5\u4e0b\u51e0\u5927\u65b9\u5411 \u683c\u4e2d\u8ba1\u7b97\u95ee\u9898\u7684\u56f0\u96be\u6027\uff0c\u5373\u8fd9\u4e9b\u95ee\u9898\u7684\u8ba1\u7b97\u590d\u6742\u6027\uff0c\u4e3b\u8981\u5305\u62ec SVP \u95ee\u9898 CVP \u95ee\u9898 \u5982\u4f55\u6c42\u89e3\u683c\u4e2d\u7684\u56f0\u96be\u6027\u95ee\u9898\uff0c\u76ee\u524d\u65e2\u6709\u8fd1\u4f3c\u7b97\u6cd5\uff0c\u4e5f\u6709\u4e00\u4e9b\u7cbe\u786e\u6027\u7b97\u6cd5\u3002 \u57fa\u4e8e\u683c\u7684\u5bc6\u7801\u5206\u6790\uff0c\u5373\u5982\u4f55\u5229\u7528\u683c\u7406\u8bba\u5206\u6790\u4e00\u4e9b\u5df2\u6709\u7684\u5bc6\u7801\u5b66\u7b97\u6cd5\uff0c\u76ee\u524d\u6709\u5982\u4e0b\u7814\u7a76 Knapsack cryptosystems DSA nonce biases Factoring RSA keys with bits known Small RSA private exponents Stereotyped messages with small RSA exponents \u5982\u4f55\u57fa\u4e8e\u683c\u56f0\u96be\u95ee\u9898\u8bbe\u8ba1\u65b0\u7684\u5bc6\u7801\u4f53\u5236\uff0c\u8fd9\u4e5f\u662f\u540e\u91cf\u5b50\u5bc6\u7801\u65f6\u4ee3\u7684\u91cd\u8981\u7814\u7a76\u65b9\u5411\u4e4b\u4e00\uff0c\u76ee\u524d\u6709\u4ee5\u4e0b\u7814\u7a76 Fully homomorphic encryption The Goldreich\u2013Goldwasser\u2013Halevi (GGH) cryptosystem The NTRU cryptosystem The Ajtai\u2013Dwork cryptosystem and the LWE cryptosystem","title":"Overview zh"},{"location":"crypto/ctf-wiki/asymmetric/lattice/overview-zh/#_1","text":"\u683c\u5728\u6570\u5b66\u4e0a\u81f3\u5c11\u6709\u4e24\u79cd\u542b\u4e49 \u5b9a\u4e49\u5728\u975e\u7a7a\u6709\u9650\u96c6\u5408\u4e0a\u7684\u504f\u5e8f\u96c6\u5408 L\uff0c\u6ee1\u8db3\u96c6\u5408 L \u4e2d\u7684\u4efb\u610f\u5143\u7d20 a\uff0cb\uff0c\u4f7f\u5f97 a\uff0cb \u5728 L \u4e2d\u5b58\u5728\u4e00\u4e2a\u6700\u5927\u4e0b\u754c\uff0c\u548c\u6700\u5c0f\u4e0a\u754c\u3002\u5177\u4f53\u53c2\u89c1https://en.wikipedia.org/wiki/Lattice_(order)\u3002 \u7fa4\u8bba\u4e2d\u7684\u5b9a\u4e49\uff0c\u662f R^n R^n \u4e2d\u7684\u6ee1\u8db3\u67d0\u79cd\u6027\u8d28\u7684\u5b50\u96c6\u3002\u5f53\u7136\uff0c\u4e5f\u53ef\u4ee5\u662f\u5176\u5b83\u7fa4\u3002 \u76ee\u524d\u5173\u4e8e\u683c\u65b9\u9762\u7684\u7814\u7a76\u4e3b\u8981\u6709\u4ee5\u4e0b\u51e0\u5927\u65b9\u5411 \u683c\u4e2d\u8ba1\u7b97\u95ee\u9898\u7684\u56f0\u96be\u6027\uff0c\u5373\u8fd9\u4e9b\u95ee\u9898\u7684\u8ba1\u7b97\u590d\u6742\u6027\uff0c\u4e3b\u8981\u5305\u62ec SVP \u95ee\u9898 CVP \u95ee\u9898 \u5982\u4f55\u6c42\u89e3\u683c\u4e2d\u7684\u56f0\u96be\u6027\u95ee\u9898\uff0c\u76ee\u524d\u65e2\u6709\u8fd1\u4f3c\u7b97\u6cd5\uff0c\u4e5f\u6709\u4e00\u4e9b\u7cbe\u786e\u6027\u7b97\u6cd5\u3002 \u57fa\u4e8e\u683c\u7684\u5bc6\u7801\u5206\u6790\uff0c\u5373\u5982\u4f55\u5229\u7528\u683c\u7406\u8bba\u5206\u6790\u4e00\u4e9b\u5df2\u6709\u7684\u5bc6\u7801\u5b66\u7b97\u6cd5\uff0c\u76ee\u524d\u6709\u5982\u4e0b\u7814\u7a76 Knapsack cryptosystems DSA nonce biases Factoring RSA keys with bits known Small RSA private exponents Stereotyped messages with small RSA exponents \u5982\u4f55\u57fa\u4e8e\u683c\u56f0\u96be\u95ee\u9898\u8bbe\u8ba1\u65b0\u7684\u5bc6\u7801\u4f53\u5236\uff0c\u8fd9\u4e5f\u662f\u540e\u91cf\u5b50\u5bc6\u7801\u65f6\u4ee3\u7684\u91cd\u8981\u7814\u7a76\u65b9\u5411\u4e4b\u4e00\uff0c\u76ee\u524d\u6709\u4ee5\u4e0b\u7814\u7a76 Fully homomorphic encryption The Goldreich\u2013Goldwasser\u2013Halevi (GGH) cryptosystem The NTRU cryptosystem The Ajtai\u2013Dwork cryptosystem and the LWE cryptosystem","title":"\u683c\u6982\u8ff0"},{"location":"crypto/ctf-wiki/asymmetric/lattice/overview/","text":"EN | ZH \u683c\u6982\u8981 \u00b6 Lattice has at least two meanings in mathematics Define a partial order set L on a non-empty finite set that satisfies any element a, b in set L such that a, b has a maximum lower bound, and a minimum upper bound in L. See https://en.wikipedia.org/wiki/Lattice_(order ) for details. The definition in group theory is a subset of R^n R^n that satisfies a certain property. Of course, it can also be other groups. At present, the research on the lattice mainly has the following major directions. The difficulty of calculating problems in the lattice, that is, the computational complexity of these problems, mainly including SVP problem CVP issues How to solve the difficult problem in the lattice, there are both approximate algorithms and some precision algorithms. Lattice-based cryptanalysis, that is, how to use lattice theory to analyze some existing cryptographic algorithms. Knapsack cryptosystems DSA nonce biases Factoring RSA keys with bits known Small RSA private exponents Stereotyped messages with small RSA exponents How to design a new cryptosystem based on the problem of lattice difficulty, which is also one of the important research directions in the post-quantum cryptosystem. Fully homomorphic encryption The Goldreich\u2013Goldwasser\u2013Halevi (GGH) cryptosystem The NTRU cryptosystem The Ajtai\u2013Dwork cryptosystem and the LWE cryptosystem","title":"\u683c\u6982\u8ff0"},{"location":"crypto/ctf-wiki/asymmetric/lattice/overview/#_1","text":"Lattice has at least two meanings in mathematics Define a partial order set L on a non-empty finite set that satisfies any element a, b in set L such that a, b has a maximum lower bound, and a minimum upper bound in L. See https://en.wikipedia.org/wiki/Lattice_(order ) for details. The definition in group theory is a subset of R^n R^n that satisfies a certain property. Of course, it can also be other groups. At present, the research on the lattice mainly has the following major directions. The difficulty of calculating problems in the lattice, that is, the computational complexity of these problems, mainly including SVP problem CVP issues How to solve the difficult problem in the lattice, there are both approximate algorithms and some precision algorithms. Lattice-based cryptanalysis, that is, how to use lattice theory to analyze some existing cryptographic algorithms. Knapsack cryptosystems DSA nonce biases Factoring RSA keys with bits known Small RSA private exponents Stereotyped messages with small RSA exponents How to design a new cryptosystem based on the problem of lattice difficulty, which is also one of the important research directions in the post-quantum cryptosystem. Fully homomorphic encryption The Goldreich\u2013Goldwasser\u2013Halevi (GGH) cryptosystem The NTRU cryptosystem The Ajtai\u2013Dwork cryptosystem and the LWE cryptosystem","title":"\u683c\u6982\u8981"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/","text":"EN | ZH RSA \u9009\u62e9\u660e\u5bc6\u6587\u653b\u51fb \u00b6 \u9009\u62e9\u660e\u6587\u653b\u51fb \u00b6 \u8fd9\u91cc\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5047\u5982\u6211\u4eec\u6709\u4e00\u4e2a\u52a0\u5bc6 oracle \uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u77e5\u9053 n \u548c e\uff0c\u90a3 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u52a0\u5bc6 oracle \u83b7\u53d6 n\u3002 \u5728 e \u6bd4\u8f83\u5c0f\uff08 e<2^{64} e<2^{64} \uff09\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528 Pollard\u2019s kangaroo algorithm \u7b97\u6cd5\u83b7\u53d6 e\u3002\u8fd9\u4e00\u70b9\u6bd4\u8f83\u663e\u7136\u3002 \u6211\u4eec\u53ef\u4ee5\u52a0\u5bc6 2\uff0c4\uff0c8\uff0c16\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u77e5\u9053 c_2=2^{e} \\bmod n c_2=2^{e} \\bmod n c_4=4^{e} \\bmod n c_4=4^{e} \\bmod n c_8=8^{e} \\bmod n c_8=8^{e} \\bmod n \u90a3\u4e48 c_2^2 \\equiv c_4 \\bmod n c_2^2 \\equiv c_4 \\bmod n c_2^3 \\equiv c_8 \\bmod n c_2^3 \\equiv c_8 \\bmod n \u6545\u800c c_2^2-c_4=kn c_2^2-c_4=kn c_2^3-c_8=tn c_2^3-c_8=tn \u6211\u4eec\u53ef\u4ee5\u6c42\u51fa kn \u548c tn \u7684\u6700\u5927\u516c\u56e0\u6570\uff0c\u5f88\u5927\u6982\u7387\u5c31\u662f n \u4e86\u3002\u6211\u4eec\u8fd8\u53ef\u4ee5\u6784\u9020\u66f4\u591a\u7684\u4f8b\u5b50\u4ece\u6765\u66f4\u52a0\u786e\u5b9a\u6027\u5730\u627e n\u3002 \u4efb\u610f\u5bc6\u6587\u89e3\u5bc6 \u00b6 \u5047\u8bbe\u7231\u4e3d\u4e1d\u521b\u5efa\u4e86\u5bc6\u6587 C = P^e \\bmod n C = P^e \\bmod n \u5e76\u4e14\u628a C \u53d1\u9001\u7ed9\u9c8d\u52c3\uff0c\u540c\u65f6\u5047\u8bbe\u6211\u4eec\u8981\u5bf9\u7231\u4e3d\u4e1d\u52a0\u5bc6\u540e\u7684\u4efb\u610f\u5bc6\u6587\u89e3\u5bc6\uff0c\u800c\u4e0d\u662f\u53ea\u89e3\u5bc6 C\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u62e6\u622a C\uff0c\u5e76\u8fd0\u7528\u4e0b\u5217\u6b65\u9aa4\u6c42\u51fa P\uff1a \u9009\u62e9\u4efb\u610f\u7684 X\\in Z_n^{*} X\\in Z_n^{*} \uff0c\u5373 X \u4e0e N \u4e92\u7d20 \u8ba1\u7b97 Y=C \\times X^e \\bmod n Y=C \\times X^e \\bmod n \u7531\u4e8e\u6211\u4eec\u53ef\u4ee5\u8fdb\u884c\u9009\u62e9\u5bc6\u6587\u653b\u51fb\uff0c\u90a3\u4e48\u6211\u4eec\u6c42\u5f97 Y \u5bf9\u5e94\u7684\u89e3\u5bc6\u7ed3\u679c Z=Y^d Z=Y^d \u90a3\u4e48\uff0c\u7531\u4e8e Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= P X\\bmod n Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= P X\\bmod n \uff0c\u7531\u4e8e X \u4e0e N \u4e92\u7d20\uff0c\u6211\u4eec\u5f88\u5bb9\u6613\u6c42\u5f97\u76f8\u5e94\u7684\u9006\u5143\uff0c\u8fdb\u800c\u53ef\u4ee5\u5f97\u5230 P RSA parity oracle \u00b6 \u5047\u8bbe\u76ee\u524d\u5b58\u5728\u4e00\u4e2a Oracle\uff0c\u5b83\u4f1a\u5bf9\u4e00\u4e2a\u7ed9\u5b9a\u7684\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u5e76\u4e14\u4f1a\u68c0\u67e5\u89e3\u5bc6\u7684\u660e\u6587\u7684\u5947\u5076\u6027\uff0c\u5e76\u6839\u636e\u5947\u5076\u6027\u8fd4\u56de\u76f8\u5e94\u7684\u503c\uff0c\u6bd4\u5982 1 \u8868\u793a\u5947\u6570\uff0c0 \u8868\u793a\u5076\u6570\u3002\u90a3\u4e48\u7ed9\u5b9a\u4e00\u4e2a\u52a0\u5bc6\u540e\u7684\u5bc6\u6587\uff0c\u6211\u4eec\u53ea\u9700\u8981 log(N) \u6b21\u5c31\u53ef\u4ee5\u77e5\u9053\u8fd9\u4e2a\u5bc6\u6587\u5bf9\u5e94\u7684\u660e\u6587\u6d88\u606f\u3002 \u539f\u7406 \u00b6 \u5047\u8bbe C=P^e \\bmod N C=P^e \\bmod N \u7b2c\u4e00\u6b21\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u7ed9\u670d\u52a1\u5668\u53d1\u9001 C*2^e=(2P)^e \\bmod N C*2^e=(2P)^e \\bmod N \u670d\u52a1\u5668\u4f1a\u8ba1\u7b97\u5f97\u5230 2P \\bmod N 2P \\bmod N \u8fd9\u91cc 2P \u662f\u5076\u6570\uff0c\u5b83\u7684\u5e42\u6b21\u4e5f\u662f\u5076\u6570\u3002 N \u662f\u5947\u6570\uff0c\u56e0\u4e3a\u5b83\u662f\u7531\u4e24\u4e2a\u5927\u7d20\u6570\u76f8\u4e58\u5f97\u5230\u3002 \u90a3\u4e48 \u670d\u52a1\u5668\u8fd4\u56de\u5947\u6570\uff0c\u5373 2P \\bmod N 2P \\bmod N \u4e3a\u5947\u6570\uff0c\u5219\u8bf4\u660e 2P \u5927\u4e8e N\uff0c\u4e14\u51cf\u53bb\u4e86\u5947\u6570\u4e2a N\uff0c\u53c8\u56e0\u4e3a 2P<2N 2P<2N \uff0c\u56e0\u6b64\u51cf\u53bb\u4e86\u4e00\u4e2aN\uff0c \u5373 \\frac{N}{2} \\leq P < N \\frac{N}{2} \\leq P < N \uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u8003\u8651\u5411\u4e0b\u53d6\u6574\u3002 \u670d\u52a1\u5668\u8fd4\u56de\u5076\u6570\uff0c\u5219\u8bf4\u660e 2P \u5c0f\u4e8e N\u3002\u5373 0\\leq P < \\frac{N}{2} 0\\leq P < \\frac{N}{2} \uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5411\u4e0b\u53d6\u6574\u3002 \u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u6570\u5b66\u5f52\u7eb3\u6cd5\uff0c\u5373\u5047\u8bbe\u5728\u7b2c i \u6b21\u65f6\uff0c \\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}} \\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}} \u8fdb\u4e00\u6b65\uff0c\u5728\u7b2c i+1 \u6b21\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u9001 C*2^{(i+1)e} C*2^{(i+1)e} \u670d\u52a1\u5668\u4f1a\u8ba1\u7b97\u5f97\u5230 2^{i+1}P \\bmod N=2^{i+1}P-kN 2^{i+1}P \\bmod N=2^{i+1}P-kN 0 \\leq 2^{i+1}P-kN<N 0 \\leq 2^{i+1}P-kN<N \\frac{kN}{2^{i+1}} \\leq P < \\frac{kN+N}{2^{i+1}} \\frac{kN}{2^{i+1}} \\leq P < \\frac{kN+N}{2^{i+1}} \u6839\u636e\u7b2c i \u6b21\u7684\u7ed3\u679c \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} \u90a3\u4e48 \u670d\u52a1\u5668\u8fd4\u56de\u5947\u6570\uff0c\u5219 k \u5fc5\u7136\u662f\u4e00\u4e2a\u5947\u6570\uff0ck=2y+1\uff0c \u90a3\u4e48 \\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^{i+1}} \\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^{i+1}} \u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u7531\u4e8e P \u5fc5\u7136\u5b58\u5728\uff0c\u6240\u4ee5\u7b2c i+1 \u5f97\u5230\u7684\u8fd9\u4e2a\u8303\u56f4\u548c\u7b2c i \u6b21\u5f97\u5230\u7684\u8303\u56f4\u5fc5\u7136\u5b58\u5728\u4ea4\u96c6\u3002\u6240\u4ee5 y \u5fc5\u7136\u4e0e x \u76f8\u7b49\u3002 \u670d\u52a1\u5668\u8fd4\u56de\u5076\u6570\uff0c\u5219 k \u5fc5\u7136\u662f\u4e00\u4e2a\u5076\u6570\uff0ck=2y\uff0c\u6b64\u65f6 y \u5fc5\u7136\u4e5f\u4e0e x \u76f8\u7b49\uff0c\u90a3\u4e48 \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+N}{2^{i+1}} \u8fdb\u4e00\u6b65\u6211\u4eec\u53ef\u4ee5\u8fd9\u4e48\u5f52\u7eb3 lb = 0 ub = N if server returns 1 lb = ( lb + ub ) / 2 else : ub = ( lb + ub ) / 2 \u8fd9\u91cc\u867d\u7136\u662f\u6574\u9664\uff0c \u5373\u4e0b\u53d6\u6574\uff0c\u4f46\u662f\u65e0\u6240\u8c13\u6211\u4eec\u5728\u6700\u521d\u65f6\u5df2\u7ecf\u5206\u6790\u4e86\u8fd9\u4e2a\u95ee\u9898\u3002 2018 Google CTF Perfect Secrecy \u00b6 \u8fd9\u91cc\u4ee5 2018 \u5e74 Google CTF \u7684\u9898\u76ee\u4e3a\u4f8b\u8fdb\u884c\u5206\u6790 #!/usr/bin/env python3 import sys import random from cryptography.hazmat.primitives import serialization from cryptography.hazmat.backends import default_backend def ReadPrivateKey ( filename ): return serialization . load_pem_private_key ( open ( filename , 'rb' ) . read (), password = None , backend = default_backend ()) def RsaDecrypt ( private_key , ciphertext ): assert ( len ( ciphertext ) <= ( private_key . public_key () . key_size // 8 )), 'Ciphertext too large' return pow ( int . from_bytes ( ciphertext , 'big' ), private_key . private_numbers () . d , private_key . public_key () . public_numbers () . n ) def Challenge ( private_key , reader , writer ): try : m0 = reader . read ( 1 ) m1 = reader . read ( 1 ) ciphertext = reader . read ( private_key . public_key () . key_size // 8 ) dice = RsaDecrypt ( private_key , ciphertext ) for rounds in range ( 100 ): p = [ m0 , m1 ][ dice & 1 ] k = random . randint ( 0 , 2 ) c = ( ord ( p ) + k ) % 2 writer . write ( bytes (( c ,))) writer . flush () return 0 except Exception as e : return 1 def main (): private_key = ReadPrivateKey ( sys . argv [ 1 ]) return Challenge ( private_key , sys . stdin . buffer , sys . stdout . buffer ) if __name__ == '__main__' : sys . exit ( main ()) \u53ef\u4ee5\u770b\u51fa \u6211\u4eec\u53ef\u4ee5\u7ed9\u670d\u52a1\u5668\u4e24\u4e2a\u6570\uff0c\u670d\u52a1\u5668\u4f1a\u6839\u636e\u89e3\u5bc6\u540e\u7684\u5bc6\u6587\u5185\u5bb9\u6765\u51b3\u5b9a\u4f7f\u7528\u54ea\u4e00\u4e2a\u3002 \u670d\u52a1\u5668\u4f1a\u4f7f\u7528 random.randint(0, 2) \u6765\u751f\u6210\u968f\u673a\u6570\uff0c\u5e76\u8f93\u51fa\u76f8\u5173\u7684\u968f\u673a 01 \u5b57\u8282 c\u3002 \u4e4d\u4e00\u770b\uff0c\u4f3c\u4e4e\u662f\u5b8c\u5168\u968f\u673a\u7684\uff0c\u4ed4\u7ec6\u67e5\u4e00\u4e0b random.randint(0, 2) \u53ef\u4ee5\u77e5\u9053\u5176\u751f\u6210\u968f\u673a\u6570\u662f\u5305\u62ec\u8fb9\u754c\u7684\uff0c\u56e0\u6b64\u5176\u751f\u6210\u5076\u6570\u7684\u6982\u7387\u5927\u4e8e\u751f\u6210\u5947\u6570\u7684\u6982\u7387\uff0c\u90a3\u4e48 c \u4e0e p \u540c\u5947\u5076\u7684\u6982\u7387\u4e3a \u2154\u3002\u8fdb\u800c\u6211\u4eec\u901a\u8fc7\u8bbe\u7f6e m0 \u548c m1 \u5c31\u53ef\u4ee5\u77e5\u9053\u89e3\u5bc6\u540e\u7684\u5bc6\u6587\u7684\u6700\u540e\u4e00\u4f4d\u662f 0 \u8fd8\u662f 1 \u3002\u8fd9\u5176\u5b9e\u5c31\u662f RSA parity oracle\u3002 exp \u5982\u4e0b import gmpy2 from pwn import * encflag = open ( './flag.txt' ) . read () encflag = encflag . encode ( 'hex' ) encflag = int ( encflag , 16 ) #context.log_level = 'debug' m = [ ' \\x00 ' , ' \\x07 ' ] n = 0xDA53A899D5573091AF6CC9C9A9FC315F76402C8970BBB1986BFE8E29CED12D0ADF61B21D6C281CCBF2EFED79AA7DD23A2776B03503B1AF354E35BF58C91DB7D7C62F6B92C918C90B68859C77CAE9FDB314F82490A0D6B50C5DC85F5C92A6FDF19716AC8451EFE8BBDF488AE098A7C76ADD2599F2CA642073AFA20D143AF403D1 e = 65537 flag = \"\" def guessvalue ( cnt ): if cnt [ 0 ] > cnt [ 1 ]: return 0 return 1 i = 0 while True : cnt = dict () cnt [ 0 ] = cnt [ 1 ] = 0 p = remote ( 'perfect-secrecy.ctfcompetition.com' , 1337 ) p . send ( m [ 0 ]) p . send ( m [ 1 ]) tmp = pow ( 2 , i ) two_inv = gmpy2 . invert ( tmp , n ) two_cipher = gmpy2 . powmod ( two_inv , e , n ) tmp = encflag * two_cipher % n tmp = hex ( tmp )[ 2 :] . strip ( 'L' ) tmp = '0' * ( 256 - len ( tmp )) + tmp tmp = tmp . decode ( 'hex' ) assert ( len ( tmp ) == 128 ) p . send ( tmp ) #print tmp data = \"\" while ( len ( data ) != 100 ): data += p . recv () for c in data : cnt [ u8 ( c )] += 1 p . close () flag = str ( guessvalue ( cnt )) + flag print i , flag i += 1 \u7ed3\u679c\u5982\u4e0b 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 \u89e3\u7801\u540e\u5c31\u53ef\u4ee5\u5f97\u5230 flag CTF { h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337 } \u9898\u76ee \u00b6 2016 Plaid CTF rabit 2016 sharif CTF lsb-oracle-150 2018 Backdoor CTF BIT-LEAKER 2018 XMAN \u9009\u62d4\u8d5b baby RSA RSA Byte Oracle \u00b6 \u5047\u8bbe\u76ee\u524d\u5b58\u5728\u4e00\u4e2a Oracle\uff0c\u5b83\u4f1a\u5bf9\u4e00\u4e2a\u7ed9\u5b9a\u7684\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u5e76\u4e14\u4f1a\u7ed9\u51fa\u660e\u6587\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002\u90a3\u4e48\u7ed9\u5b9a\u4e00\u4e2a\u52a0\u5bc6\u540e\u7684\u5bc6\u6587\uff0c\u6211\u4eec\u53ea\u9700\u8981 \\log_{256}n \\log_{256}n \u6b21\u5c31\u53ef\u4ee5\u77e5\u9053\u8fd9\u4e2a\u5bc6\u6587\u5bf9\u5e94\u7684\u660e\u6587\u6d88\u606f\u3002 \u539f\u7406 \u00b6 \u8fd9\u4e2a\u5176\u5b9e\u7b97\u4f5c RSA parity Oracle \u7684\u6269\u5c55\uff0c\u65e2\u7136\u53ef\u4ee5\u6cc4\u9732\u51fa\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u90a3\u4e48\u6309\u9053\u7406\u6211\u4eec\u83b7\u53d6\u5bc6\u6587\u5bf9\u5e94\u660e\u6587\u7684\u6b21\u6570\u5e94\u8be5\u53ef\u4ee5\u51cf\u5c11\u3002 \u5047\u8bbe C=P^e \\bmod N C=P^e \\bmod N \u7b2c\u4e00\u6b21\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u7ed9\u670d\u52a1\u5668\u53d1\u9001 C*256^e=(256P)^e \\bmod N C*256^e=(256P)^e \\bmod N \u670d\u52a1\u5668\u4f1a\u8ba1\u7b97\u5f97\u5230 256P \\bmod N 256P \\bmod N \u8fd9\u91cc 256P \u662f\u5076\u6570\u3002 N \u662f\u5947\u6570\uff0c\u56e0\u4e3a\u5b83\u662f\u7531\u4e24\u4e2a\u5927\u7d20\u6570\u76f8\u4e58\u5f97\u5230\u3002 \u7531\u4e8e P \u4e00\u822c\u662f\u5c0f\u4e8e N \u7684\uff0c\u90a3\u4e48 256P \\bmod N=256P-kn, k<256 256P \\bmod N=256P-kn, k<256 \u3002\u800c\u4e14\u5bf9\u4e8e\u4e24\u4e2a\u4e0d\u540c\u7684 k_1,k_2 k_1,k_2 \uff0c\u6211\u4eec\u6709 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 \u6211\u4eec\u53ef\u4ee5\u5229\u7528\u53cd\u8bc1\u6cd5\u6765\u8bc1\u660e\u4e0a\u8ff0\u4e0d\u7b49\u5f0f\u3002\u540c\u65f6 256P-kn 256P-kn \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u5176\u5b9e\u5c31\u662f -kn -kn \u5728\u6a21 256 \u7684\u60c5\u51b5\u4e0b\u83b7\u53d6\u7684\u3002\u90a3\u4e48\uff0c\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u9996\u5148\u679a\u4e3e\u51fa 0~255 \u60c5\u51b5\u4e0b\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u6784\u9020\u4e00\u4e2a k \u548c\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u7684\u6620\u5c04\u8868 map \u5f53\u670d\u52a1\u5668\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u5b57\u8282 b\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u4e0a\u8ff0\u6784\u9020\u7684\u6620\u5c04\u8868\u5f97\u77e5 k\uff0c\u5373\u51cf\u53bb\u4e86 k \u4e2aN\uff0c \u5373 kN \\leq 256 P \\leq (k+1)N kN \\leq 256 P \\leq (k+1)N \u3002 \u6b64\u540e\uff0c\u6211\u4eec\u4f7f\u7528\u6570\u5b66\u5f52\u7eb3\u6cd5\u6765\u83b7\u53d6 P \u7684\u8303\u56f4\uff0c\u5373\u5047\u8bbe\u5728\u7b2c i \u6b21\u65f6\uff0c \\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i}} \\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i}} \u8fdb\u4e00\u6b65\uff0c\u5728\u7b2c i+1 \u6b21\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u9001 C*256^{(i+1)e} C*256^{(i+1)e} \u670d\u52a1\u5668\u4f1a\u8ba1\u7b97\u5f97\u5230 256^{i+1}P \\bmod N=256^{i+1}P-kN 256^{i+1}P \\bmod N=256^{i+1}P-kN 0 \\leq 256^{i+1}P-kN<N 0 \\leq 256^{i+1}P-kN<N \\frac{kN}{256^{i+1}} \\leq P < \\frac{kN+N}{256^{i+1}} \\frac{kN}{256^{i+1}} \\leq P < \\frac{kN+N}{256^{i+1}} \u6839\u636e\u7b2c i \u6b21\u7684\u7ed3\u679c \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} \u6211\u4eec\u8fd9\u91cc\u53ef\u4ee5\u5047\u8bbe k=256y+t k=256y+t \uff0c \u800c\u8fd9\u91cc\u7684 t \u5c31\u662f\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6620\u5c04\u8868\u83b7\u53d6\u7684\u3002 \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} \u4e0e\u6b64\u540c\u65f6\uff0c\u7531\u4e8e P \u5fc5\u7136\u5b58\u5728\uff0c\u6240\u4ee5\u7b2c i+1 \u5f97\u5230\u7684\u8fd9\u4e2a\u8303\u56f4\u548c\u7b2c i \u6b21\u5f97\u5230\u7684\u8303\u56f4\u5fc5\u7136\u5b58\u5728\u4ea4\u96c6\u3002 \u6240\u4ee5 y \u5fc5\u7136\u4e0e x \u76f8\u7b49\u3002 \u8fdb\u4e00\u6b65\u6211\u4eec\u53ef\u4ee5\u8fd9\u4e48\u5f52\u7eb3\uff0c\u521d\u59cb\u60c5\u51b5\u4e0b lb = 0 ub = N \u5047\u8bbe\u670d\u52a1\u5668\u8fd4\u56de\u4e86 b\uff0c\u90a3\u4e48 k = mab [ b ] interval = ( ub - lb ) / 256 lb = lb + interval * k ub = lb + interval 2018 HITCON lost key \u00b6 \u8fd9\u662f\u4e00\u4e2a\u7efc\u5408\u9898\u76ee\uff0c\u9996\u5148\u6ca1\u6709\u7ed9\u51fa n\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u9009\u62e9\u660e\u6587\u653b\u51fb\u7684\u65b9\u5f0f\u83b7\u53d6 n\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u8fdb\u4e00\u6b65\u83b7\u53d6 e\uff0c\u6700\u540e\u5229\u7528\u4ee3\u7801\u5982\u4e0b from pwn import * import gmpy2 from fractions import Fraction p = process ( './rsa.py' ) #p = remote('18.179.251.168', 21700) #context.log_level = 'debug' p . recvuntil ( 'Here is the flag! \\n ' ) flagcipher = int ( p . recvuntil ( ' \\n ' , drop = True ), 16 ) def long_to_hex ( n ): s = hex ( n )[ 2 :] . rstrip ( 'L' ) if len ( s ) % 2 : s = '0' + s return s def send ( ch , num ): p . sendlineafter ( 'cmd: ' , ch ) p . sendlineafter ( 'input: ' , long_to_hex ( num )) data = p . recvuntil ( ' \\n ' ) return int ( data , 16 ) if __name__ == \"__main__\" : # get n cipher2 = send ( 'A' , 2 ) cipher4 = send ( 'A' , 4 ) nset = [] nset . append ( cipher2 * cipher2 - cipher4 ) cipher3 = send ( 'A' , 3 ) cipher9 = send ( 'A' , 9 ) nset . append ( cipher3 * cipher3 - cipher9 ) cipher5 = send ( 'A' , 5 ) cipher25 = send ( 'A' , 25 ) nset . append ( cipher5 * cipher5 - cipher25 ) n = nset [ 0 ] for item in nset : n = gmpy2 . gcd ( item , n ) # get map between k and return byte submap = {} for i in range ( 0 , 256 ): submap [ - n * i % 256 ] = i # get cipher256 cipher256 = send ( 'A' , 256 ) back = flagcipher L = Fraction ( 0 , 1 ) R = Fraction ( 1 , 1 ) for i in range ( 128 ): print i flagcipher = flagcipher * cipher256 % n b = send ( 'B' , flagcipher ) k = submap [ b ] L , R = L + ( R - L ) * Fraction ( k , 256 ), L + ( R - L ) * Fraction ( k + 1 , 256 ) low = int ( L * n ) print long_to_hex ( low - low % 256 + send ( 'B' , back )) . decode ( 'hex' ) \u53c2\u8003 \u00b6 https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack https://pastebin.com/KnEUSMxp","title":"Rsa chosen plain cipher zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#rsa","text":"","title":"RSA \u9009\u62e9\u660e\u5bc6\u6587\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#_1","text":"\u8fd9\u91cc\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5047\u5982\u6211\u4eec\u6709\u4e00\u4e2a\u52a0\u5bc6 oracle \uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u77e5\u9053 n \u548c e\uff0c\u90a3 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u52a0\u5bc6 oracle \u83b7\u53d6 n\u3002 \u5728 e \u6bd4\u8f83\u5c0f\uff08 e<2^{64} e<2^{64} \uff09\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528 Pollard\u2019s kangaroo algorithm \u7b97\u6cd5\u83b7\u53d6 e\u3002\u8fd9\u4e00\u70b9\u6bd4\u8f83\u663e\u7136\u3002 \u6211\u4eec\u53ef\u4ee5\u52a0\u5bc6 2\uff0c4\uff0c8\uff0c16\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u77e5\u9053 c_2=2^{e} \\bmod n c_2=2^{e} \\bmod n c_4=4^{e} \\bmod n c_4=4^{e} \\bmod n c_8=8^{e} \\bmod n c_8=8^{e} \\bmod n \u90a3\u4e48 c_2^2 \\equiv c_4 \\bmod n c_2^2 \\equiv c_4 \\bmod n c_2^3 \\equiv c_8 \\bmod n c_2^3 \\equiv c_8 \\bmod n \u6545\u800c c_2^2-c_4=kn c_2^2-c_4=kn c_2^3-c_8=tn c_2^3-c_8=tn \u6211\u4eec\u53ef\u4ee5\u6c42\u51fa kn \u548c tn \u7684\u6700\u5927\u516c\u56e0\u6570\uff0c\u5f88\u5927\u6982\u7387\u5c31\u662f n \u4e86\u3002\u6211\u4eec\u8fd8\u53ef\u4ee5\u6784\u9020\u66f4\u591a\u7684\u4f8b\u5b50\u4ece\u6765\u66f4\u52a0\u786e\u5b9a\u6027\u5730\u627e n\u3002","title":"\u9009\u62e9\u660e\u6587\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#_2","text":"\u5047\u8bbe\u7231\u4e3d\u4e1d\u521b\u5efa\u4e86\u5bc6\u6587 C = P^e \\bmod n C = P^e \\bmod n \u5e76\u4e14\u628a C \u53d1\u9001\u7ed9\u9c8d\u52c3\uff0c\u540c\u65f6\u5047\u8bbe\u6211\u4eec\u8981\u5bf9\u7231\u4e3d\u4e1d\u52a0\u5bc6\u540e\u7684\u4efb\u610f\u5bc6\u6587\u89e3\u5bc6\uff0c\u800c\u4e0d\u662f\u53ea\u89e3\u5bc6 C\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u62e6\u622a C\uff0c\u5e76\u8fd0\u7528\u4e0b\u5217\u6b65\u9aa4\u6c42\u51fa P\uff1a \u9009\u62e9\u4efb\u610f\u7684 X\\in Z_n^{*} X\\in Z_n^{*} \uff0c\u5373 X \u4e0e N \u4e92\u7d20 \u8ba1\u7b97 Y=C \\times X^e \\bmod n Y=C \\times X^e \\bmod n \u7531\u4e8e\u6211\u4eec\u53ef\u4ee5\u8fdb\u884c\u9009\u62e9\u5bc6\u6587\u653b\u51fb\uff0c\u90a3\u4e48\u6211\u4eec\u6c42\u5f97 Y \u5bf9\u5e94\u7684\u89e3\u5bc6\u7ed3\u679c Z=Y^d Z=Y^d \u90a3\u4e48\uff0c\u7531\u4e8e Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= P X\\bmod n Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= P X\\bmod n \uff0c\u7531\u4e8e X \u4e0e N \u4e92\u7d20\uff0c\u6211\u4eec\u5f88\u5bb9\u6613\u6c42\u5f97\u76f8\u5e94\u7684\u9006\u5143\uff0c\u8fdb\u800c\u53ef\u4ee5\u5f97\u5230 P","title":"\u4efb\u610f\u5bc6\u6587\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#rsa-parity-oracle","text":"\u5047\u8bbe\u76ee\u524d\u5b58\u5728\u4e00\u4e2a Oracle\uff0c\u5b83\u4f1a\u5bf9\u4e00\u4e2a\u7ed9\u5b9a\u7684\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u5e76\u4e14\u4f1a\u68c0\u67e5\u89e3\u5bc6\u7684\u660e\u6587\u7684\u5947\u5076\u6027\uff0c\u5e76\u6839\u636e\u5947\u5076\u6027\u8fd4\u56de\u76f8\u5e94\u7684\u503c\uff0c\u6bd4\u5982 1 \u8868\u793a\u5947\u6570\uff0c0 \u8868\u793a\u5076\u6570\u3002\u90a3\u4e48\u7ed9\u5b9a\u4e00\u4e2a\u52a0\u5bc6\u540e\u7684\u5bc6\u6587\uff0c\u6211\u4eec\u53ea\u9700\u8981 log(N) \u6b21\u5c31\u53ef\u4ee5\u77e5\u9053\u8fd9\u4e2a\u5bc6\u6587\u5bf9\u5e94\u7684\u660e\u6587\u6d88\u606f\u3002","title":"RSA parity oracle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#_3","text":"\u5047\u8bbe C=P^e \\bmod N C=P^e \\bmod N \u7b2c\u4e00\u6b21\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u7ed9\u670d\u52a1\u5668\u53d1\u9001 C*2^e=(2P)^e \\bmod N C*2^e=(2P)^e \\bmod N \u670d\u52a1\u5668\u4f1a\u8ba1\u7b97\u5f97\u5230 2P \\bmod N 2P \\bmod N \u8fd9\u91cc 2P \u662f\u5076\u6570\uff0c\u5b83\u7684\u5e42\u6b21\u4e5f\u662f\u5076\u6570\u3002 N \u662f\u5947\u6570\uff0c\u56e0\u4e3a\u5b83\u662f\u7531\u4e24\u4e2a\u5927\u7d20\u6570\u76f8\u4e58\u5f97\u5230\u3002 \u90a3\u4e48 \u670d\u52a1\u5668\u8fd4\u56de\u5947\u6570\uff0c\u5373 2P \\bmod N 2P \\bmod N \u4e3a\u5947\u6570\uff0c\u5219\u8bf4\u660e 2P \u5927\u4e8e N\uff0c\u4e14\u51cf\u53bb\u4e86\u5947\u6570\u4e2a N\uff0c\u53c8\u56e0\u4e3a 2P<2N 2P<2N \uff0c\u56e0\u6b64\u51cf\u53bb\u4e86\u4e00\u4e2aN\uff0c \u5373 \\frac{N}{2} \\leq P < N \\frac{N}{2} \\leq P < N \uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u8003\u8651\u5411\u4e0b\u53d6\u6574\u3002 \u670d\u52a1\u5668\u8fd4\u56de\u5076\u6570\uff0c\u5219\u8bf4\u660e 2P \u5c0f\u4e8e N\u3002\u5373 0\\leq P < \\frac{N}{2} 0\\leq P < \\frac{N}{2} \uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5411\u4e0b\u53d6\u6574\u3002 \u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u6570\u5b66\u5f52\u7eb3\u6cd5\uff0c\u5373\u5047\u8bbe\u5728\u7b2c i \u6b21\u65f6\uff0c \\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}} \\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}} \u8fdb\u4e00\u6b65\uff0c\u5728\u7b2c i+1 \u6b21\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u9001 C*2^{(i+1)e} C*2^{(i+1)e} \u670d\u52a1\u5668\u4f1a\u8ba1\u7b97\u5f97\u5230 2^{i+1}P \\bmod N=2^{i+1}P-kN 2^{i+1}P \\bmod N=2^{i+1}P-kN 0 \\leq 2^{i+1}P-kN<N 0 \\leq 2^{i+1}P-kN<N \\frac{kN}{2^{i+1}} \\leq P < \\frac{kN+N}{2^{i+1}} \\frac{kN}{2^{i+1}} \\leq P < \\frac{kN+N}{2^{i+1}} \u6839\u636e\u7b2c i \u6b21\u7684\u7ed3\u679c \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} \u90a3\u4e48 \u670d\u52a1\u5668\u8fd4\u56de\u5947\u6570\uff0c\u5219 k \u5fc5\u7136\u662f\u4e00\u4e2a\u5947\u6570\uff0ck=2y+1\uff0c \u90a3\u4e48 \\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^{i+1}} \\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^{i+1}} \u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u7531\u4e8e P \u5fc5\u7136\u5b58\u5728\uff0c\u6240\u4ee5\u7b2c i+1 \u5f97\u5230\u7684\u8fd9\u4e2a\u8303\u56f4\u548c\u7b2c i \u6b21\u5f97\u5230\u7684\u8303\u56f4\u5fc5\u7136\u5b58\u5728\u4ea4\u96c6\u3002\u6240\u4ee5 y \u5fc5\u7136\u4e0e x \u76f8\u7b49\u3002 \u670d\u52a1\u5668\u8fd4\u56de\u5076\u6570\uff0c\u5219 k \u5fc5\u7136\u662f\u4e00\u4e2a\u5076\u6570\uff0ck=2y\uff0c\u6b64\u65f6 y \u5fc5\u7136\u4e5f\u4e0e x \u76f8\u7b49\uff0c\u90a3\u4e48 \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+N}{2^{i+1}} \u8fdb\u4e00\u6b65\u6211\u4eec\u53ef\u4ee5\u8fd9\u4e48\u5f52\u7eb3 lb = 0 ub = N if server returns 1 lb = ( lb + ub ) / 2 else : ub = ( lb + ub ) / 2 \u8fd9\u91cc\u867d\u7136\u662f\u6574\u9664\uff0c \u5373\u4e0b\u53d6\u6574\uff0c\u4f46\u662f\u65e0\u6240\u8c13\u6211\u4eec\u5728\u6700\u521d\u65f6\u5df2\u7ecf\u5206\u6790\u4e86\u8fd9\u4e2a\u95ee\u9898\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#2018-google-ctf-perfect-secrecy","text":"\u8fd9\u91cc\u4ee5 2018 \u5e74 Google CTF \u7684\u9898\u76ee\u4e3a\u4f8b\u8fdb\u884c\u5206\u6790 #!/usr/bin/env python3 import sys import random from cryptography.hazmat.primitives import serialization from cryptography.hazmat.backends import default_backend def ReadPrivateKey ( filename ): return serialization . load_pem_private_key ( open ( filename , 'rb' ) . read (), password = None , backend = default_backend ()) def RsaDecrypt ( private_key , ciphertext ): assert ( len ( ciphertext ) <= ( private_key . public_key () . key_size // 8 )), 'Ciphertext too large' return pow ( int . from_bytes ( ciphertext , 'big' ), private_key . private_numbers () . d , private_key . public_key () . public_numbers () . n ) def Challenge ( private_key , reader , writer ): try : m0 = reader . read ( 1 ) m1 = reader . read ( 1 ) ciphertext = reader . read ( private_key . public_key () . key_size // 8 ) dice = RsaDecrypt ( private_key , ciphertext ) for rounds in range ( 100 ): p = [ m0 , m1 ][ dice & 1 ] k = random . randint ( 0 , 2 ) c = ( ord ( p ) + k ) % 2 writer . write ( bytes (( c ,))) writer . flush () return 0 except Exception as e : return 1 def main (): private_key = ReadPrivateKey ( sys . argv [ 1 ]) return Challenge ( private_key , sys . stdin . buffer , sys . stdout . buffer ) if __name__ == '__main__' : sys . exit ( main ()) \u53ef\u4ee5\u770b\u51fa \u6211\u4eec\u53ef\u4ee5\u7ed9\u670d\u52a1\u5668\u4e24\u4e2a\u6570\uff0c\u670d\u52a1\u5668\u4f1a\u6839\u636e\u89e3\u5bc6\u540e\u7684\u5bc6\u6587\u5185\u5bb9\u6765\u51b3\u5b9a\u4f7f\u7528\u54ea\u4e00\u4e2a\u3002 \u670d\u52a1\u5668\u4f1a\u4f7f\u7528 random.randint(0, 2) \u6765\u751f\u6210\u968f\u673a\u6570\uff0c\u5e76\u8f93\u51fa\u76f8\u5173\u7684\u968f\u673a 01 \u5b57\u8282 c\u3002 \u4e4d\u4e00\u770b\uff0c\u4f3c\u4e4e\u662f\u5b8c\u5168\u968f\u673a\u7684\uff0c\u4ed4\u7ec6\u67e5\u4e00\u4e0b random.randint(0, 2) \u53ef\u4ee5\u77e5\u9053\u5176\u751f\u6210\u968f\u673a\u6570\u662f\u5305\u62ec\u8fb9\u754c\u7684\uff0c\u56e0\u6b64\u5176\u751f\u6210\u5076\u6570\u7684\u6982\u7387\u5927\u4e8e\u751f\u6210\u5947\u6570\u7684\u6982\u7387\uff0c\u90a3\u4e48 c \u4e0e p \u540c\u5947\u5076\u7684\u6982\u7387\u4e3a \u2154\u3002\u8fdb\u800c\u6211\u4eec\u901a\u8fc7\u8bbe\u7f6e m0 \u548c m1 \u5c31\u53ef\u4ee5\u77e5\u9053\u89e3\u5bc6\u540e\u7684\u5bc6\u6587\u7684\u6700\u540e\u4e00\u4f4d\u662f 0 \u8fd8\u662f 1 \u3002\u8fd9\u5176\u5b9e\u5c31\u662f RSA parity oracle\u3002 exp \u5982\u4e0b import gmpy2 from pwn import * encflag = open ( './flag.txt' ) . read () encflag = encflag . encode ( 'hex' ) encflag = int ( encflag , 16 ) #context.log_level = 'debug' m = [ ' \\x00 ' , ' \\x07 ' ] n = 0xDA53A899D5573091AF6CC9C9A9FC315F76402C8970BBB1986BFE8E29CED12D0ADF61B21D6C281CCBF2EFED79AA7DD23A2776B03503B1AF354E35BF58C91DB7D7C62F6B92C918C90B68859C77CAE9FDB314F82490A0D6B50C5DC85F5C92A6FDF19716AC8451EFE8BBDF488AE098A7C76ADD2599F2CA642073AFA20D143AF403D1 e = 65537 flag = \"\" def guessvalue ( cnt ): if cnt [ 0 ] > cnt [ 1 ]: return 0 return 1 i = 0 while True : cnt = dict () cnt [ 0 ] = cnt [ 1 ] = 0 p = remote ( 'perfect-secrecy.ctfcompetition.com' , 1337 ) p . send ( m [ 0 ]) p . send ( m [ 1 ]) tmp = pow ( 2 , i ) two_inv = gmpy2 . invert ( tmp , n ) two_cipher = gmpy2 . powmod ( two_inv , e , n ) tmp = encflag * two_cipher % n tmp = hex ( tmp )[ 2 :] . strip ( 'L' ) tmp = '0' * ( 256 - len ( tmp )) + tmp tmp = tmp . decode ( 'hex' ) assert ( len ( tmp ) == 128 ) p . send ( tmp ) #print tmp data = \"\" while ( len ( data ) != 100 ): data += p . recv () for c in data : cnt [ u8 ( c )] += 1 p . close () flag = str ( guessvalue ( cnt )) + flag print i , flag i += 1 \u7ed3\u679c\u5982\u4e0b 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 \u89e3\u7801\u540e\u5c31\u53ef\u4ee5\u5f97\u5230 flag CTF { h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337 }","title":"2018 Google CTF Perfect Secrecy"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#_4","text":"2016 Plaid CTF rabit 2016 sharif CTF lsb-oracle-150 2018 Backdoor CTF BIT-LEAKER 2018 XMAN \u9009\u62d4\u8d5b baby RSA","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#rsa-byte-oracle","text":"\u5047\u8bbe\u76ee\u524d\u5b58\u5728\u4e00\u4e2a Oracle\uff0c\u5b83\u4f1a\u5bf9\u4e00\u4e2a\u7ed9\u5b9a\u7684\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u5e76\u4e14\u4f1a\u7ed9\u51fa\u660e\u6587\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002\u90a3\u4e48\u7ed9\u5b9a\u4e00\u4e2a\u52a0\u5bc6\u540e\u7684\u5bc6\u6587\uff0c\u6211\u4eec\u53ea\u9700\u8981 \\log_{256}n \\log_{256}n \u6b21\u5c31\u53ef\u4ee5\u77e5\u9053\u8fd9\u4e2a\u5bc6\u6587\u5bf9\u5e94\u7684\u660e\u6587\u6d88\u606f\u3002","title":"RSA Byte Oracle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#_5","text":"\u8fd9\u4e2a\u5176\u5b9e\u7b97\u4f5c RSA parity Oracle \u7684\u6269\u5c55\uff0c\u65e2\u7136\u53ef\u4ee5\u6cc4\u9732\u51fa\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u90a3\u4e48\u6309\u9053\u7406\u6211\u4eec\u83b7\u53d6\u5bc6\u6587\u5bf9\u5e94\u660e\u6587\u7684\u6b21\u6570\u5e94\u8be5\u53ef\u4ee5\u51cf\u5c11\u3002 \u5047\u8bbe C=P^e \\bmod N C=P^e \\bmod N \u7b2c\u4e00\u6b21\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u7ed9\u670d\u52a1\u5668\u53d1\u9001 C*256^e=(256P)^e \\bmod N C*256^e=(256P)^e \\bmod N \u670d\u52a1\u5668\u4f1a\u8ba1\u7b97\u5f97\u5230 256P \\bmod N 256P \\bmod N \u8fd9\u91cc 256P \u662f\u5076\u6570\u3002 N \u662f\u5947\u6570\uff0c\u56e0\u4e3a\u5b83\u662f\u7531\u4e24\u4e2a\u5927\u7d20\u6570\u76f8\u4e58\u5f97\u5230\u3002 \u7531\u4e8e P \u4e00\u822c\u662f\u5c0f\u4e8e N \u7684\uff0c\u90a3\u4e48 256P \\bmod N=256P-kn, k<256 256P \\bmod N=256P-kn, k<256 \u3002\u800c\u4e14\u5bf9\u4e8e\u4e24\u4e2a\u4e0d\u540c\u7684 k_1,k_2 k_1,k_2 \uff0c\u6211\u4eec\u6709 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 \u6211\u4eec\u53ef\u4ee5\u5229\u7528\u53cd\u8bc1\u6cd5\u6765\u8bc1\u660e\u4e0a\u8ff0\u4e0d\u7b49\u5f0f\u3002\u540c\u65f6 256P-kn 256P-kn \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u5176\u5b9e\u5c31\u662f -kn -kn \u5728\u6a21 256 \u7684\u60c5\u51b5\u4e0b\u83b7\u53d6\u7684\u3002\u90a3\u4e48\uff0c\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u9996\u5148\u679a\u4e3e\u51fa 0~255 \u60c5\u51b5\u4e0b\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u6784\u9020\u4e00\u4e2a k \u548c\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u7684\u6620\u5c04\u8868 map \u5f53\u670d\u52a1\u5668\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u5b57\u8282 b\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u4e0a\u8ff0\u6784\u9020\u7684\u6620\u5c04\u8868\u5f97\u77e5 k\uff0c\u5373\u51cf\u53bb\u4e86 k \u4e2aN\uff0c \u5373 kN \\leq 256 P \\leq (k+1)N kN \\leq 256 P \\leq (k+1)N \u3002 \u6b64\u540e\uff0c\u6211\u4eec\u4f7f\u7528\u6570\u5b66\u5f52\u7eb3\u6cd5\u6765\u83b7\u53d6 P \u7684\u8303\u56f4\uff0c\u5373\u5047\u8bbe\u5728\u7b2c i \u6b21\u65f6\uff0c \\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i}} \\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i}} \u8fdb\u4e00\u6b65\uff0c\u5728\u7b2c i+1 \u6b21\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u9001 C*256^{(i+1)e} C*256^{(i+1)e} \u670d\u52a1\u5668\u4f1a\u8ba1\u7b97\u5f97\u5230 256^{i+1}P \\bmod N=256^{i+1}P-kN 256^{i+1}P \\bmod N=256^{i+1}P-kN 0 \\leq 256^{i+1}P-kN<N 0 \\leq 256^{i+1}P-kN<N \\frac{kN}{256^{i+1}} \\leq P < \\frac{kN+N}{256^{i+1}} \\frac{kN}{256^{i+1}} \\leq P < \\frac{kN+N}{256^{i+1}} \u6839\u636e\u7b2c i \u6b21\u7684\u7ed3\u679c \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} \u6211\u4eec\u8fd9\u91cc\u53ef\u4ee5\u5047\u8bbe k=256y+t k=256y+t \uff0c \u800c\u8fd9\u91cc\u7684 t \u5c31\u662f\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6620\u5c04\u8868\u83b7\u53d6\u7684\u3002 \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} \u4e0e\u6b64\u540c\u65f6\uff0c\u7531\u4e8e P \u5fc5\u7136\u5b58\u5728\uff0c\u6240\u4ee5\u7b2c i+1 \u5f97\u5230\u7684\u8fd9\u4e2a\u8303\u56f4\u548c\u7b2c i \u6b21\u5f97\u5230\u7684\u8303\u56f4\u5fc5\u7136\u5b58\u5728\u4ea4\u96c6\u3002 \u6240\u4ee5 y \u5fc5\u7136\u4e0e x \u76f8\u7b49\u3002 \u8fdb\u4e00\u6b65\u6211\u4eec\u53ef\u4ee5\u8fd9\u4e48\u5f52\u7eb3\uff0c\u521d\u59cb\u60c5\u51b5\u4e0b lb = 0 ub = N \u5047\u8bbe\u670d\u52a1\u5668\u8fd4\u56de\u4e86 b\uff0c\u90a3\u4e48 k = mab [ b ] interval = ( ub - lb ) / 256 lb = lb + interval * k ub = lb + interval","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#2018-hitcon-lost-key","text":"\u8fd9\u662f\u4e00\u4e2a\u7efc\u5408\u9898\u76ee\uff0c\u9996\u5148\u6ca1\u6709\u7ed9\u51fa n\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u9009\u62e9\u660e\u6587\u653b\u51fb\u7684\u65b9\u5f0f\u83b7\u53d6 n\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u8fdb\u4e00\u6b65\u83b7\u53d6 e\uff0c\u6700\u540e\u5229\u7528\u4ee3\u7801\u5982\u4e0b from pwn import * import gmpy2 from fractions import Fraction p = process ( './rsa.py' ) #p = remote('18.179.251.168', 21700) #context.log_level = 'debug' p . recvuntil ( 'Here is the flag! \\n ' ) flagcipher = int ( p . recvuntil ( ' \\n ' , drop = True ), 16 ) def long_to_hex ( n ): s = hex ( n )[ 2 :] . rstrip ( 'L' ) if len ( s ) % 2 : s = '0' + s return s def send ( ch , num ): p . sendlineafter ( 'cmd: ' , ch ) p . sendlineafter ( 'input: ' , long_to_hex ( num )) data = p . recvuntil ( ' \\n ' ) return int ( data , 16 ) if __name__ == \"__main__\" : # get n cipher2 = send ( 'A' , 2 ) cipher4 = send ( 'A' , 4 ) nset = [] nset . append ( cipher2 * cipher2 - cipher4 ) cipher3 = send ( 'A' , 3 ) cipher9 = send ( 'A' , 9 ) nset . append ( cipher3 * cipher3 - cipher9 ) cipher5 = send ( 'A' , 5 ) cipher25 = send ( 'A' , 25 ) nset . append ( cipher5 * cipher5 - cipher25 ) n = nset [ 0 ] for item in nset : n = gmpy2 . gcd ( item , n ) # get map between k and return byte submap = {} for i in range ( 0 , 256 ): submap [ - n * i % 256 ] = i # get cipher256 cipher256 = send ( 'A' , 256 ) back = flagcipher L = Fraction ( 0 , 1 ) R = Fraction ( 1 , 1 ) for i in range ( 128 ): print i flagcipher = flagcipher * cipher256 % n b = send ( 'B' , flagcipher ) k = submap [ b ] L , R = L + ( R - L ) * Fraction ( k , 256 ), L + ( R - L ) * Fraction ( k + 1 , 256 ) low = int ( L * n ) print long_to_hex ( low - low % 256 + send ( 'B' , back )) . decode ( 'hex' )","title":"2018 HITCON lost key"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher-zh/#_6","text":"https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack https://pastebin.com/KnEUSMxp","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/","text":"EN | ZH RSA Selecting a clear ciphertext attack \u00b6 Select plaintext attack \u00b6 Here is an example, if we have an encryption oracle, but we don't know n and e, then We can get n by encrypting oracle. When e is small ( e<2^{64} e&lt;2^{64} ), we can use the Pollard's kangaroo algorithm algorithm to get e. This is more obvious. We can encrypt 2, 4, 8, and 16. Then we can know $ C_2 = 2 ^ {e} n $ way C_4 = $ 4 ^ {e} n $ way $ C_8 = 8 ^ {e} n $ way Then c_2^2 \\equiv c_4 \\bmod n c_2^2 \\equiv c_4 \\bmod n c_2^3 \\equiv c_8 \\bmod n c_2^3 \\equiv c_8 \\bmod n Therefore c_2^2-c_4=kn c_2^2-c_4=kn $ c_2 ^ 3-c_8 = tn $ We can find the greatest common factor of kn and tn, and the big probability is n. We can also construct more examples to find n more deterministically. Any ciphertext decryption \u00b6 Suppose Alice creates the ciphertext C = P^e \\bmod n C = P^e \\bmod n and sends C to Bob, and assuming we want to decrypt any ciphertext encrypted by Alice, instead of just decrypting C, then we can intercept C, and use the following steps to find P: Select any X\\in Z_n^{*} X\\in Z_n^{*} , ie X and N. Calculate Y=C \\times X^e \\bmod n Y=C \\times X^e \\bmod n Since we can choose to ciphertext attack, we find the decryption result corresponding to Y Z=Y^d Z=Y^d Then, since Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n , since X and N are mutually prime, we are very It is easy to find the corresponding inverse element, and then you can get P RSA parity oracle \u00b6 Suppose there is currently an Oracle that decrypts a given ciphertext and checks the parity of the decrypted plaintext and returns the corresponding value based on parity, such as 1 for odd numbers and 0 for even numbers. Then given an encrypted ciphertext, we only need log(N) times to know the plaintext message corresponding to this ciphertext. Principle \u00b6 Hypothesis P $ C = e ^ N $ way The first time we can send to the server $ C * 2 ^ = e (2P) e ^ N $ way The server will calculate 2P $ N $ way Here 2P is an even number and its power is even. N is an odd number because it is multiplied by two large prime numbers. Then The server returns an odd number, ie 2P \\bmod N 2P \\bmod N is an odd number, indicating that 2P is greater than N, and an odd number of Ns is subtracted, and because 2P<2N 2P&lt;2N , an N is subtracted, ie \\frac{N }{2} \\leq P < N \\frac{N }{2} \\leq P &lt; N , we can also consider rounding down. If the server returns an even number, then 2P is less than N. That is, 0\\leq P < \\frac{N}{2} 0\\leq P &lt; \\frac{N}{2} , we can also round down. Here we use mathematical induction, which assumes that at the ith time, \\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}} \\frac{xN}{2^{i}} \\leq P &lt; \\frac{xN+N}{2^{i}} Further, at the i+1th time, we can send C*2^{(i+1)e} C*2^{(i+1)e} The server will calculate $ 2 ^ {i + 1} P way N = 2 ^ {i + 1} P $ kN 0 \\leq 2^{i+1}P-kN<N 0 \\leq 2^{i+1}P-kN<N $ frac {kN} {2 ^ {i + 1}} leq P < frac {kN + N} According to the result of the ith \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} Then If the server returns an odd number, then k must be an odd number, k=2y+1, then \\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^ {i+1}} \\frac{2yN+N}{2^{i+1}} \\leq P &lt; \\frac{2yN+2N}{2^ {i+1}} . At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x. If the server returns an even number, then k must be an even number, k=2y, where y must also be equal to x, then \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+ N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P &lt; \\frac{2xN+ N}{2^{i+1}} Further we can conclude lb = 0 ub = N if server returns 1 lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 Although it is divisible, that is, it is rounded down, but it does not matter that we have analyzed this problem at the beginning. 2018 Google CTF Perfect Secrecy \u00b6 Here is an example of the 2018 Google CTF topic. #!/usr/bin/env python3 import sys import random from cryptography.hazmat.primitives import serialization from cryptography.hazmat.backends import default_backend def ReadPrivateKey ( filename ): return serialization . load_pem_private_key ( open ( filename , 'rb' ) . read (), password = None , backend = default_backend ()) def RsaDecrypt ( private_key , ciphertext ): assert ( len ( ciphertext ) <= ( private_key . public_key () . key_size // 8 )), 'Ciphertext too large' return pow ( int . from_bytes ( ciphertext , 'big' ), private_key . private_numbers () . d , private_key . public_key () . public_numbers () . n ) def Challenge ( private_key , reader , writer ): try : m0 = reader . read ( 1 ) m1 = reader . read ( 1 ) ciphertext = reader . read ( private_key . public_key () . key_size // 8 ) dice = RsaDecrypt ( private_key , ciphertext ) for rounds in range ( 100 ): p = [ m0 , m1 ][ dice & 1 ] k = random . randint ( 0 , 2 ) c = ( word ( p ) + k ) % 2 writer . write ( bytes (( c ,))) writer . flush () return 0 except Exception as e : return 1 def main (): private_key = ReadPrivateKey ( sys . argv [ 1 ]) return Challenge ( private_key , sys . stdin . buffer , sys . stdout . buffer ) if __name__ == '__main__' : sys . exit ( main ()) As can be seen We can give the server two numbers, and the server will decide which one to use based on the decrypted ciphertext content. The server will use random.randint(0, 2) to generate a random number and output the associated random 01 byte c. At first glance, it seems to be completely random. Check out random.randint(0, 2) to know that the generated random number is bounded, so the probability of generating an even number is greater than the probability of generating an odd number, then c and p The probability of the same parity is \u2154. Furthermore, by setting m0 and m1, we can know whether the last digit of the decrypted ciphertext is 0 or 1. This is actually the RSA parity oracle. Exp is as follows import gmpy2 from pwn import * encflag = open ( './flag.txt' ) . read () encflag = encflag . encode ( 'hex' ) encflag = int ( encflag , 16 ) #context.log_level = 'debug' m = [ ' \\x00 ' , ' \\x07 ' ] n = 0xDA53A899D5573091AF6CC9C9A9FC315F76402C8970BBB1986BFE8E29CED12D0ADF61B21D6C281CCBF2EFED79AA7DD23A2776B03503B1AF354E35BF58C91DB7D7C62F6B92C918C90B68859C77CAE9FDB314F82490A0D6B50C5DC85F5C92A6FDF19716AC8451EFE8BBDF488AE098A7C76ADD2599F2CA642073AFA20D143AF403D1 e = 65537 flag = \"\" def guessvalue ( cnt ): if cnt [ 0 ] > cnt [ 1 ]: return 0 return 1 i = 0 while True : cnt = dict () cnt [ 0 ] = cnt [ 1 ] = 0 p = remote ( 'perfect-secrecy.ctfcompetition.com' , 1337 ) p . send ( m [ 0 ]) p . send ( m [ 1 ]) tmp = pow ( 2 , i ) two_inv = gmpy2 . invert ( tmp , n ) two_cipher = gmpy2 . powmod ( two_inv , e , n ) tmp = encflag * two_cipher % n tmp = hex ( tmp )[ 2 :] . strip ( 'L' ) tmp = '0' * ( 256 - len ( tmp )) + tmp tmp = tmp . decode ( 'hex' ) assert ( len ( tmp ) == 128 ) p . send ( tmp ) #print tmp data = \"\" while ( len ( data ) != 100 ): data += p . recv () for c in data : cnt [ U8 ( c )] + = 1 p . close () flag = str ( guessvalue ( cnt )) + flag print i , flag i += 1 Results are as follows 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 After decoding, you can get flag CTF { h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337 } Title \u00b6 2016 Plaid CTF rabit 2016 sharif CTF lsb-oracle-150 2018 Backdoor CTF BIT-LEAKER 2018 XMAN trials baby RSA RSA Byte Oracle \u00b6 Suppose there is currently an Oracle that decrypts a given ciphertext and gives the last byte of the plaintext. Then given an encrypted ciphertext, we only need \\log_{256}n \\log_{256}n times to know the plaintext message corresponding to this ciphertext. Principle \u00b6 This is actually an extension of RSA parity Oracle. Since the last byte can be revealed, then the number of times we get the ciphertext corresponding plaintext should be reduced. Hypothesis P $ C = e ^ N $ way The first time we can send to the server C $ 256 * e ^ = (256P) e ^ N $ way The server will calculate 256P $ N $ way Here 256P is an even number. N is an odd number because it is multiplied by two large prime numbers. Since P is generally less than N, then 256P \\bmod N=256P-kn, k<256 256P \\bmod N=256P-kn, k&lt;256 . And for two different k_1, k_2 k_1, k_2 , we have 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 We can use the counter-evidence method to prove the above inequality. At the same time, the last byte of 256P-kn 256P-kn is actually -kn -kn obtained in the case of modulo 256. So, in fact, we can first enumerate the last byte in the case of 0~255, construct a mapping table of k and the last byte. When the server returns the last byte b, we can know k according to the mapping table constructed above, that is, subtract k N, that is, kN \\leq 256 P \\leq (k+1)N kN \\leq 256 P \\leq (k+1)N . After that, we use mathematical induction to obtain the range of P, that is, assume that at the ith time, \\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i }} \\frac{xN}{256^{i}} \\leq P &lt; \\frac{xN+N}{256^{i }} Further, at the i+1th time, we can send C*256^{(i+1)e} C*256^{(i+1)e} The server will calculate $ 256 ^ {i + 1} P way N = 256 ^ {i + 1} P $ kN 0 \\leq 256^{i+1}P-kN<N 0 \\leq 256^{i+1}P-kN<N $ frac {kN} {256} {i + 1}} leq P < frac {kN + N} According to the result of the ith \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} We can assume k=256y+t k=256y+t here, and the t here is what we can get through the mapping table. \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x. Further we can summarize this, in the initial case lb = 0 ub = N Suppose the server returns b, then k = mab [ b ] interval = ( ub - lb ) / 256 lb = lb + interval * k ub = lb + interval 2018 HITCON lost key \u00b6 This is a comprehensive topic. First, we don't give n. We can use the method of selecting a plaintext attack to get n. Of course, we can further obtain e. Finally, the code is as follows. from pwn import * import gmpy2 from fractions import Fraction p = process ( './rsa.py' ) #p = remote('18.179.251.168', 21700) #context.log_level = 'debug' p . recvuntil ( 'Here is the flag! \\n ' ) flagcipher = int ( p . recvuntil ( ' \\n ' , drop = True ), 16 ) def long_to_hex ( n ): s = hex ( n )[ 2 :] . rstrip ( 'L' ) if len ( s ) % 2 : s = '0' + s return s def send ( ch , num ): p . sendlineafter ( 'cmd: ' , ch ) p . sendlineafter ( 'input: ' , long_to_hex ( num )) data = p . recvuntil ( ' \\n ' ) return int ( data , 16 ) if __name__ == \"__main__\" : # get n cipher2 = send ( 'A' , 2 ) cipher4 = send ( 'A' , 4 ) nset = [] nset . append ( cipher2 * cipher2 - cipher4 ) cipher3 = send ( 'A' , 3 ) cipher9 = send ( 'A' , 9 ) nset . append ( cipher3 * cipher3 - cipher9 ) cipher5 = send ( 'A' , 5 ) cipher25 = send ( 'A' , 25 ) nset . append ( cipher5 * cipher5 - cipher25 ) n = nset [ 0 ] for item in nset : n = gmpy2 . gcd ( item , n ) # get map between k and return byte submap = {} for i in range ( 0 , 256 ): submap [ - n * i % 256 ] = i # get cipher256 cipher256 = send ( 'A' , 256 ) back = flagcipher L = Fraction ( 0 , 1 ) R = Fraction ( 1 , 1 ) for i in range ( 128 ): print i flagcipher = flagcipher * cipher256 % n b = send ( 'B' , flagcipher ) k = submap [ b ] L , R = L + ( R - L ) * Fraction ( k , 256 ), L + ( R - L ) * Fraction ( k + 1 , 256 ) low = int ( L * n ) print long_to_hex ( low - low % 256 + send ( 'B' , back )) . decode ( 'hex' ) Reference \u00b6 https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack https://pastebin.com/KnEUSMxp","title":"\u9009\u62e9\u660e\u5bc6\u6587\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#rsa-selecting-a-clear-ciphertext-attack","text":"","title":"RSA Selecting a clear ciphertext attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#select-plaintext-attack","text":"Here is an example, if we have an encryption oracle, but we don't know n and e, then We can get n by encrypting oracle. When e is small ( e<2^{64} e&lt;2^{64} ), we can use the Pollard's kangaroo algorithm algorithm to get e. This is more obvious. We can encrypt 2, 4, 8, and 16. Then we can know $ C_2 = 2 ^ {e} n $ way C_4 = $ 4 ^ {e} n $ way $ C_8 = 8 ^ {e} n $ way Then c_2^2 \\equiv c_4 \\bmod n c_2^2 \\equiv c_4 \\bmod n c_2^3 \\equiv c_8 \\bmod n c_2^3 \\equiv c_8 \\bmod n Therefore c_2^2-c_4=kn c_2^2-c_4=kn $ c_2 ^ 3-c_8 = tn $ We can find the greatest common factor of kn and tn, and the big probability is n. We can also construct more examples to find n more deterministically.","title":"Select plaintext attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#any-ciphertext-decryption","text":"Suppose Alice creates the ciphertext C = P^e \\bmod n C = P^e \\bmod n and sends C to Bob, and assuming we want to decrypt any ciphertext encrypted by Alice, instead of just decrypting C, then we can intercept C, and use the following steps to find P: Select any X\\in Z_n^{*} X\\in Z_n^{*} , ie X and N. Calculate Y=C \\times X^e \\bmod n Y=C \\times X^e \\bmod n Since we can choose to ciphertext attack, we find the decryption result corresponding to Y Z=Y^d Z=Y^d Then, since Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n Z=Y^d=(C \\times X^e)^d=C^d X=P^{ed} X= PX\\bmod n , since X and N are mutually prime, we are very It is easy to find the corresponding inverse element, and then you can get P","title":"Any ciphertext decryption"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#rsa-parity-oracle","text":"Suppose there is currently an Oracle that decrypts a given ciphertext and checks the parity of the decrypted plaintext and returns the corresponding value based on parity, such as 1 for odd numbers and 0 for even numbers. Then given an encrypted ciphertext, we only need log(N) times to know the plaintext message corresponding to this ciphertext.","title":"RSA parity oracle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#principle","text":"Hypothesis P $ C = e ^ N $ way The first time we can send to the server $ C * 2 ^ = e (2P) e ^ N $ way The server will calculate 2P $ N $ way Here 2P is an even number and its power is even. N is an odd number because it is multiplied by two large prime numbers. Then The server returns an odd number, ie 2P \\bmod N 2P \\bmod N is an odd number, indicating that 2P is greater than N, and an odd number of Ns is subtracted, and because 2P<2N 2P&lt;2N , an N is subtracted, ie \\frac{N }{2} \\leq P < N \\frac{N }{2} \\leq P &lt; N , we can also consider rounding down. If the server returns an even number, then 2P is less than N. That is, 0\\leq P < \\frac{N}{2} 0\\leq P &lt; \\frac{N}{2} , we can also round down. Here we use mathematical induction, which assumes that at the ith time, \\frac{xN}{2^{i}} \\leq P < \\frac{xN+N}{2^{i}} \\frac{xN}{2^{i}} \\leq P &lt; \\frac{xN+N}{2^{i}} Further, at the i+1th time, we can send C*2^{(i+1)e} C*2^{(i+1)e} The server will calculate $ 2 ^ {i + 1} P way N = 2 ^ {i + 1} P $ kN 0 \\leq 2^{i+1}P-kN<N 0 \\leq 2^{i+1}P-kN<N $ frac {kN} {2 ^ {i + 1}} leq P < frac {kN + N} According to the result of the ith \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+2N}{2^{i+1}} Then If the server returns an odd number, then k must be an odd number, k=2y+1, then \\frac{2yN+N}{2^{i+1}} \\leq P < \\frac{2yN+2N}{2^ {i+1}} \\frac{2yN+N}{2^{i+1}} \\leq P &lt; \\frac{2yN+2N}{2^ {i+1}} . At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x. If the server returns an even number, then k must be an even number, k=2y, where y must also be equal to x, then \\frac{2xN}{2^{i+1}} \\leq P < \\frac{2xN+ N}{2^{i+1}} \\frac{2xN}{2^{i+1}} \\leq P &lt; \\frac{2xN+ N}{2^{i+1}} Further we can conclude lb = 0 ub = N if server returns 1 lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 Although it is divisible, that is, it is rounded down, but it does not matter that we have analyzed this problem at the beginning.","title":"Principle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#2018-google-ctf-perfect-secrecy","text":"Here is an example of the 2018 Google CTF topic. #!/usr/bin/env python3 import sys import random from cryptography.hazmat.primitives import serialization from cryptography.hazmat.backends import default_backend def ReadPrivateKey ( filename ): return serialization . load_pem_private_key ( open ( filename , 'rb' ) . read (), password = None , backend = default_backend ()) def RsaDecrypt ( private_key , ciphertext ): assert ( len ( ciphertext ) <= ( private_key . public_key () . key_size // 8 )), 'Ciphertext too large' return pow ( int . from_bytes ( ciphertext , 'big' ), private_key . private_numbers () . d , private_key . public_key () . public_numbers () . n ) def Challenge ( private_key , reader , writer ): try : m0 = reader . read ( 1 ) m1 = reader . read ( 1 ) ciphertext = reader . read ( private_key . public_key () . key_size // 8 ) dice = RsaDecrypt ( private_key , ciphertext ) for rounds in range ( 100 ): p = [ m0 , m1 ][ dice & 1 ] k = random . randint ( 0 , 2 ) c = ( word ( p ) + k ) % 2 writer . write ( bytes (( c ,))) writer . flush () return 0 except Exception as e : return 1 def main (): private_key = ReadPrivateKey ( sys . argv [ 1 ]) return Challenge ( private_key , sys . stdin . buffer , sys . stdout . buffer ) if __name__ == '__main__' : sys . exit ( main ()) As can be seen We can give the server two numbers, and the server will decide which one to use based on the decrypted ciphertext content. The server will use random.randint(0, 2) to generate a random number and output the associated random 01 byte c. At first glance, it seems to be completely random. Check out random.randint(0, 2) to know that the generated random number is bounded, so the probability of generating an even number is greater than the probability of generating an odd number, then c and p The probability of the same parity is \u2154. Furthermore, by setting m0 and m1, we can know whether the last digit of the decrypted ciphertext is 0 or 1. This is actually the RSA parity oracle. Exp is as follows import gmpy2 from pwn import * encflag = open ( './flag.txt' ) . read () encflag = encflag . encode ( 'hex' ) encflag = int ( encflag , 16 ) #context.log_level = 'debug' m = [ ' \\x00 ' , ' \\x07 ' ] n = 0xDA53A899D5573091AF6CC9C9A9FC315F76402C8970BBB1986BFE8E29CED12D0ADF61B21D6C281CCBF2EFED79AA7DD23A2776B03503B1AF354E35BF58C91DB7D7C62F6B92C918C90B68859C77CAE9FDB314F82490A0D6B50C5DC85F5C92A6FDF19716AC8451EFE8BBDF488AE098A7C76ADD2599F2CA642073AFA20D143AF403D1 e = 65537 flag = \"\" def guessvalue ( cnt ): if cnt [ 0 ] > cnt [ 1 ]: return 0 return 1 i = 0 while True : cnt = dict () cnt [ 0 ] = cnt [ 1 ] = 0 p = remote ( 'perfect-secrecy.ctfcompetition.com' , 1337 ) p . send ( m [ 0 ]) p . send ( m [ 1 ]) tmp = pow ( 2 , i ) two_inv = gmpy2 . invert ( tmp , n ) two_cipher = gmpy2 . powmod ( two_inv , e , n ) tmp = encflag * two_cipher % n tmp = hex ( tmp )[ 2 :] . strip ( 'L' ) tmp = '0' * ( 256 - len ( tmp )) + tmp tmp = tmp . decode ( 'hex' ) assert ( len ( tmp ) == 128 ) p . send ( tmp ) #print tmp data = \"\" while ( len ( data ) != 100 ): data += p . recv () for c in data : cnt [ U8 ( c )] + = 1 p . close () flag = str ( guessvalue ( cnt )) + flag print i , flag i += 1 Results are as follows 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 6533021797450432625003726192285181680054061843303961161444459679874621880787893445342698029728203298974356255732086344166897556918532195998159983477294838449903429031335408290610431938507208444225296242342845578895553611385588996615744823221415296689514934439749745119968629875229882861818946483594948270 After decoding, you can get flag CTF { h3ll0__17_5_m3_1_w45_w0nd3r1n6_1f_4f73r_4ll_7h353_y34r5_y0u_d_l1k3_70_m337 }","title":"2018 Google CTF Perfect Secrecy"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#title","text":"2016 Plaid CTF rabit 2016 sharif CTF lsb-oracle-150 2018 Backdoor CTF BIT-LEAKER 2018 XMAN trials baby RSA","title":"Title"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#rsa-byte-oracle","text":"Suppose there is currently an Oracle that decrypts a given ciphertext and gives the last byte of the plaintext. Then given an encrypted ciphertext, we only need \\log_{256}n \\log_{256}n times to know the plaintext message corresponding to this ciphertext.","title":"RSA Byte Oracle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#principle_1","text":"This is actually an extension of RSA parity Oracle. Since the last byte can be revealed, then the number of times we get the ciphertext corresponding plaintext should be reduced. Hypothesis P $ C = e ^ N $ way The first time we can send to the server C $ 256 * e ^ = (256P) e ^ N $ way The server will calculate 256P $ N $ way Here 256P is an even number. N is an odd number because it is multiplied by two large prime numbers. Since P is generally less than N, then 256P \\bmod N=256P-kn, k<256 256P \\bmod N=256P-kn, k&lt;256 . And for two different k_1, k_2 k_1, k_2 , we have 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 256P-k_1n \\not\\equiv 256P-k_2n \\bmod 256 We can use the counter-evidence method to prove the above inequality. At the same time, the last byte of 256P-kn 256P-kn is actually -kn -kn obtained in the case of modulo 256. So, in fact, we can first enumerate the last byte in the case of 0~255, construct a mapping table of k and the last byte. When the server returns the last byte b, we can know k according to the mapping table constructed above, that is, subtract k N, that is, kN \\leq 256 P \\leq (k+1)N kN \\leq 256 P \\leq (k+1)N . After that, we use mathematical induction to obtain the range of P, that is, assume that at the ith time, \\frac{xN}{256^{i}} \\leq P < \\frac{xN+N}{256^{i }} \\frac{xN}{256^{i}} \\leq P &lt; \\frac{xN+N}{256^{i }} Further, at the i+1th time, we can send C*256^{(i+1)e} C*256^{(i+1)e} The server will calculate $ 256 ^ {i + 1} P way N = 256 ^ {i + 1} P $ kN 0 \\leq 256^{i+1}P-kN<N 0 \\leq 256^{i+1}P-kN<N $ frac {kN} {256} {i + 1}} leq P < frac {kN + N} According to the result of the ith \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} \\frac{256xN}{256^{i+1}} \\leq P < \\frac{256xN+256N}{256^{i+1}} We can assume k=256y+t k=256y+t here, and the t here is what we can get through the mapping table. \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} \\frac{256yN+tN}{256^{i+1}} \\leq P < \\frac{256yN+(t+1)N}{256^{i+1}} At the same time, since P necessarily exists, the range obtained by the i+1 and the range obtained by the i-th must have an intersection. So y must be equal to x. Further we can summarize this, in the initial case lb = 0 ub = N Suppose the server returns b, then k = mab [ b ] interval = ( ub - lb ) / 256 lb = lb + interval * k ub = lb + interval","title":"Principle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#2018-hitcon-lost-key","text":"This is a comprehensive topic. First, we don't give n. We can use the method of selecting a plaintext attack to get n. Of course, we can further obtain e. Finally, the code is as follows. from pwn import * import gmpy2 from fractions import Fraction p = process ( './rsa.py' ) #p = remote('18.179.251.168', 21700) #context.log_level = 'debug' p . recvuntil ( 'Here is the flag! \\n ' ) flagcipher = int ( p . recvuntil ( ' \\n ' , drop = True ), 16 ) def long_to_hex ( n ): s = hex ( n )[ 2 :] . rstrip ( 'L' ) if len ( s ) % 2 : s = '0' + s return s def send ( ch , num ): p . sendlineafter ( 'cmd: ' , ch ) p . sendlineafter ( 'input: ' , long_to_hex ( num )) data = p . recvuntil ( ' \\n ' ) return int ( data , 16 ) if __name__ == \"__main__\" : # get n cipher2 = send ( 'A' , 2 ) cipher4 = send ( 'A' , 4 ) nset = [] nset . append ( cipher2 * cipher2 - cipher4 ) cipher3 = send ( 'A' , 3 ) cipher9 = send ( 'A' , 9 ) nset . append ( cipher3 * cipher3 - cipher9 ) cipher5 = send ( 'A' , 5 ) cipher25 = send ( 'A' , 25 ) nset . append ( cipher5 * cipher5 - cipher25 ) n = nset [ 0 ] for item in nset : n = gmpy2 . gcd ( item , n ) # get map between k and return byte submap = {} for i in range ( 0 , 256 ): submap [ - n * i % 256 ] = i # get cipher256 cipher256 = send ( 'A' , 256 ) back = flagcipher L = Fraction ( 0 , 1 ) R = Fraction ( 1 , 1 ) for i in range ( 128 ): print i flagcipher = flagcipher * cipher256 % n b = send ( 'B' , flagcipher ) k = submap [ b ] L , R = L + ( R - L ) * Fraction ( k , 256 ), L + ( R - L ) * Fraction ( k + 1 , 256 ) low = int ( L * n ) print long_to_hex ( low - low % 256 + send ( 'B' , back )) . decode ( 'hex' )","title":"2018 HITCON lost key"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_chosen_plain_cipher/#reference","text":"https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack https://pastebin.com/KnEUSMxp","title":"Reference"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/","text":"EN | ZH RSA \u590d\u6742\u9898\u76ee \u00b6 2018 Tokyo Western Mixed Cipher \u00b6 \u9898\u76ee\u7ed9\u7684\u4fe1\u606f\u5982\u4e0b\u6240\u793a\uff1a \u6bcf\u6b21\u4ea4\u4e92\u53ef\u4ee5\u7ef4\u6301\u7684\u65f6\u95f4\u957f\u5ea6\u7ea6\u4e3a 5 \u5206\u949f \u6bcf\u6b21\u4ea4\u4e92\u4e2d\u4e2dn\u662f\u786e\u5b9a\u7684 1024 bit\uff0c\u4f46\u662f\u672a\u77e5\uff0c e \u4e3a 65537 \u4f7f\u7528 aes \u52a0\u5bc6\u4e86 flag\uff0c\u5bc6\u94a5\u548c IV \u5747\u4e0d\u77e5\u9053 \u6bcf\u6b21\u5bc6\u94a5\u662f\u56fa\u5b9a\u7684\uff0c\u4f46\u662f IV \u6bcf\u6b21\u90fd\u4f1a\u968f\u673a \u53ef\u4ee5\u4f7f\u7528 encrypt \u529f\u80fd\u968f\u610f\u4f7f\u7528 rsa \u548c aes \u8fdb\u884c\u52a0\u5bc6\uff0c\u5176\u4e2d\u6bcf\u6b21\u52a0\u5bc6\u90fd\u4f1a\u5bf9 aes \u7684 iv \u8fdb\u884c\u968f\u673a \u53ef\u4ee5\u4f7f\u7528 decrypt \u5bf9\u968f\u610f\u7684\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u4f46\u662f\u53ea\u80fd\u77e5\u9053\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u662f\u4ec0\u4e48 \u53ef\u4ee5\u4f7f\u7528 print_flag \u83b7\u53d6 flag \u5bc6\u6587 \u53ef\u4ee5\u4f7f\u7528 print_key \u83b7\u53d6 rsa \u52a0\u5bc6\u7684 aes \u5bc6\u94a5 \u672c\u9898\u76ee\u770b\u4f3c\u4e00\u4e2a\u9898\u76ee\uff0c\u5b9e\u5219\u662f 3 \u4e2a\u9898\u76ee\uff0c\u9700\u8981\u5206\u6b65\u9aa4\u89e3\u51b3\u3002\u5728\u6b64\u4e4b\u524d\uff0c\u6211\u5011\u6e96\u5099\u597d\u4ea4\u4e92\u7684\u51fd\u6578 def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"4\" ) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline ()[: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"1\" ) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline ()[: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"2\" ) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) GCD attack n \u00b6 \u7b2c\u4e00\u6b65\u6211\u4eec\u9700\u8981\u628a\u6ca1\u6709\u7ed9\u51fa\u7684 n \u7b97\u51fa\u6765\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u5229\u7528 encrypt \u529f\u80fd\u5bf9\u6211\u4eec\u8f93\u5165\u7684\u660e\u6587 x \u8fdb\u884c rsa \u52a0\u5bc6\uff0c\u90a3\u4e48\u53ef\u4ee5\u5229\u7528\u6574\u9664\u7684\u6027\u8d28\u7b97 n \u56e0\u4e3ax ^ e = c mod n \u6240\u4ee5 n | x ^ e - c \u6211\u4eec\u53ef\u4ee5\u6784\u9020\u8db3\u591f\u591a\u7684 x\uff0c\u7b97\u51fa\u6700\u591f\u591a\u7684 x ^ e - c\uff0c\u4ece\u800c\u8ba1\u7b97\u6700\u5927\u516c\u7ea6\u6570\uff0c\u5f97\u5230 n\u3002 def get_n(io): rsa_c,aes_c=encrypt_io(io,long_to_bytes(2)) n=pow(2,65537)-rsa_c for i in range(3,6): rsa_c, aes_c = encrypt_io(io, long_to_bytes(i)) n=primefac.gcd(n,pow(i,65537)-rsa_c) return n \u53ef\u4ee5\u5229\u7528\u52a0\u5bc6\u8fdb\u884c check def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , \"123\" ) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False RSA parity oracle \u00b6 \u5229\u7528 leak \u7684\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u6211\u4eec\u53ef\u4ee5\u8fdb\u884c\u9009\u62e9\u5bc6\u6587\u653b\u51fb\uff0c\u4f7f\u7528 RSA parity oracle \u56de\u590d aes \u7684\u79d8\u94a5 def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : print lb , ub tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : ub = ( lb + ub ) / 2 k += 1 print ub , len ( long_to_bytes ( ub )) return ub PRNG Predict \u00b6 \u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u89e3\u5bc6 flag \u768416\u5b57\u8282\u4e4b\u540e\u7684\u5185\u5bb9\u4e86\uff0c\u4f46\u662f\u524d16\u4e2a\u5b57\u8282\u6ca1\u6709 IV \u662f\u89e3\u5bc6\u4e0d\u4e86\u7684\u3002\u8fd9\u65f6\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0cIV \u751f\u6210\u4f7f\u7528\u7684\u968f\u673a\u6570\u4f7f\u7528\u4e86 getrandbits\uff0c\u5e76\u4e14\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6\u5230\u8db3\u591f\u591a\u7684\u968f\u673a\u6570\u91cf\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8fdb\u884c PRNG \u7684 predict\uff0c\u4ece\u800c\u76f4\u63a5\u83b7\u53d6\u968f\u673a\u6570 \u8fd9\u91cc\u4f7f\u7528\u4e86\u4e00\u4e2a\u73b0\u6210\u7684\u7684 java \u8fdb\u884c PRNG \u7684 Predict public class Main { static int [] state ; static int currentIndex ; 40 huo public static void main ( String [] args ) { state = new int [ 624 ] ; currentIndex = 0 ; // initialize(0); // for (int i = 0; i < 5; i++) { // System.out.println(state[i]); // } // for (int i = 0; i < 5; i++) { // System.out.println(nextNumber()); // } if ( args . length != 624 ) { System . err . println ( \"must be 624 args\" ); System . exit ( 1 ); } int [] arr = new int [ 624 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { arr [ i ] = Integer . parseInt ( args [ i ] ); } rev ( arr ); for ( int i = 0 ; i < 6240 huo4 ; i ++ ) { System . out . println ( state [ i ] ); } // System.out.println(\"currentIndex \" + currentIndex); // System.out.println(\"state[currentIndex] \" + state[currentIndex]); // System.out.println(\"next \" + nextNumber()); // want -2065863258 } static void nextState () { // Iterate through the state for ( int i = 0 ; i < 624 ; i ++ ) { // y is the first bit of the current number, // and the last 31 bits of the next number int y = ( state [ i ] & 0x80000000 ) + ( state [ ( i + 1 ) % 624 ] & 0x7fffffff ); // first bitshift y by 1 to the right int next = y >>> 1 ; // xor it with the 397th next number next ^= state [ ( i + 397 ) % 624 ] ; // if y is odd, xor with magic number if (( y & 1L ) == 1L ) { next ^= 0x9908b0df ; } // now we have the result state [ i ] = next ; } } static int nextNumber () { currentIndex ++ ; int tmp = state [ currentIndex ] ; tmp ^= ( tmp >>> 11 ); tmp ^= ( tmp << 7 ) & 0x9d2c5680 ; tmp ^= ( tmp << 15 ) & 0xefc60000 ; tmp ^= ( tmp >>> 18 ); return tmp ; } static void initialize ( int seed ) { // http://code.activestate.com/recipes/578056-mersenne-twister/ // global MT // global bitmask_1 // MT[0] = seed // for i in xrange(1,624): // MT[i] = ((1812433253 * MT[i-1]) ^ ((MT[i-1] >> 30) + i)) & bitmask_1 // copied Python 2.7's impl (probably uint problems) state [ 0 ] = seed ; for ( int i = 1 ; i < 624 ; i ++ ) { state [ i ] = (( 1812433253 * state [ i - 1 ] ) ^ (( state [ i - 1 ] >> 30 ) + i )) & 0xffffffff ; } } static int unBitshiftRightXor ( int value , int shift ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 << ( 32 - shift )) >>> ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= part >>> shift ; // add the part to the result result |= part ; i ++ ; } return result ; } static int unBitshiftLeftXor ( int value , int shift , int mask ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 >>> ( 32 - shift )) << ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= ( part << shift ) & mask ; // add the part to the result result |= part ; i ++ ; } return result ; } static void rev ( int [] nums ) { for ( int i = 0 ; i < 624 ; i ++ ) { int value = nums [ i ] ; value = unBitshiftRightXor ( value , 18 ); value = unBitshiftLeftXor ( value , 15 , 0xefc60000 ); value = unBitshiftLeftXor ( value , 7 , 0x9d2c5680 ); value = unBitshiftRightXor ( value , 11 ); state [ i ] = value ; } } } \u5199\u4e86\u4e00\u4e2a python \u76f4\u63a5\u8c03\u7528 java from Crypto.Util.number import long_to_bytes,bytes_to_long def encrypt_io(io,p): io.read_until(\"4: get encrypted keyn\") io.writeline(\"1\") io.read_until(\"input plain text: \") io.writeline(p) io.read_until(\"RSA: \") rsa_c=int(io.readline()[:-1],16) io.read_until(\"AES: \") aes_c=io.readline()[:-1].decode(\"hex\") return rsa_c,aes_c import subprocess import random def get_iv(io): rsa_c, aes_c=encrypt_io(io,\"1\") return bytes_to_long(aes_c[0:16]) def splitInto32(w128): w1 = w128 & (2**32-1) w2 = (w128 >> 32) & (2**32-1) w3 = (w128 >> 64) & (2**32-1) w4 = (w128 >> 96) return w1,w2,w3,w4 def sign(iv): # converts a 32 bit uint to a 32 bit signed int if(iv&0x80000000): iv = -0x100000000 + iv return iv def get_state(io): numbers=[] for i in range(156): print i numbers.append(get_iv(io)) observedNums = [sign(w) for n in numbers for w in splitInto32(n)] o = subprocess.check_output([\"java\", \"Main\"] + map(str, observedNums)) stateList = [int(s) % (2 ** 32) for s in o.split()] r = random.Random() state = (3, tuple(stateList + [624]), None) r.setstate(state) return r.getrandbits(128) EXP \u00b6 \u6574\u4f53\u653b\u51fb\u4ee3\u7801\u5982\u4e0b\uff1a from zio import * import primefac from Crypto.Util.number import long_to_bytes , bytes_to_long target = ( \"crypto.chal.ctf.westerns.tokyo\" , 5643 ) e = 65537 def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"4\" ) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline ()[: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"1\" ) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline ()[: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"2\" ) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) def get_n ( io ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( 2 )) n = pow ( 2 , 65537 ) - rsa_c for i in range ( 3 , 6 ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( i )) n = primefac . gcd ( n , pow ( i , 65537 ) - rsa_c ) return n def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , \"123\" ) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False import gmpy2 def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : print lb , ub tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : ub = ( lb + ub ) / 2 k += 1 print ub , len ( long_to_bytes ( ub )) return ub io = zio ( target , timeout = 10000 , print_read = COLORED ( NONE , 'red' ), print_write = COLORED ( NONE , 'green' )) n = get_n ( io ) print check_n ( io , n ) c = get_enc_key ( io ) print len ( decrypt_io ( io , c )) == 16 m = guess_m ( io , n , c ) for i in range ( m - 50000 , m + 50000 ): if pow ( i , e , n ) == c : aeskey = i print long_to_bytes ( aeskey )[ - 1 ] == decrypt_io ( io , c )[ - 1 ] print \"found aes key\" , hex ( aeskey ) import fuck_r next_iv = fuck_r . get_state ( io ) print \"##########################################\" print next_iv print aeskey io . interact () 2016 ASIS Find the flag \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 ASIS 2016 \u7ebf\u4e0a\u8d5b\u4e2d Find the flag \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002 \u6587\u4ef6\u89e3\u538b\u51fa\u6765\uff0c\u6709\u4e00\u4e2a\u5bc6\u6587\uff0c\u4e00\u4e2a\u516c\u94a5\uff0c\u4e00\u4e2a py \u811a\u672c\u3002\u770b\u4e00\u4e0b\u516c\u94a5\u3002 \u279c RSA openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 :d8:e2:4c:12:b7:b9:9e:fe:0a:9b:c0:4a:6a:3d: f5:8a:2a:94:42:69:b4:92:b7:37:6d:f1:29:02:3f: 20 :61:b9 Exponent: 12405943493775545863 ( 0xac2ac3e0ca0f5607 ) Modulus = D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9 \u8fd9\u4e48\u5c0f\u7684\u4e00\u4e2a N N \uff0c\u5148\u5206\u89e3\u4e00\u4e0b\u3002 p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 \u518d\u770b\u7ed9\u7684 py \u811a\u672c\u3002 #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 flag = open ( 'flag' , 'r' ) . read () * 30 def ext_rsa_encrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) pubkey = RSA . construct (( long ( n ), long ( e ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) return enc except : p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) f = open ( 'pubkey.pem' , 'w' ) f . write ( pubkey . exportKey ()) g = open ( 'flag.enc' , 'w' ) g . write ( ext_rsa_encrypt ( p , q , e , flag )) \u903b\u8f91\u5f88\u7b80\u5355\uff0c\u8bfb\u53d6 flag\uff0c\u91cd\u590d 30 \u904d\u4e3a\u5bc6\u6587\u3002\u968f\u673a\u53d6 p p \u548c q q \uff0c\u751f\u6210\u4e00\u4e2a\u516c\u94a5\uff0c\u5199\u5165 pubkey.pem \uff0c\u518d\u7528\u811a\u672c\u4e2d\u7684 ext_rsa_encrypt \u51fd\u6570\u8fdb\u884c\u52a0\u5bc6\uff0c\u6700\u540e\u5c06\u5bc6\u6587\u5199\u5165 flag.enc \u3002 \u5c1d\u8bd5\u4e00\u4e0b\u89e3\u5bc6\uff0c\u63d0\u793a\u5bc6\u6587\u8fc7\u957f\uff0c\u518d\u770b\u52a0\u5bc6\u51fd\u6570\uff0c\u539f\u6765\u5f53\u52a0\u5bc6\u5931\u8d25\u65f6\uff0c\u51fd\u6570\u4f1a\u8df3\u5230\u5f02\u5e38\u5904\u7406\uff0c\u4ee5\u4e00\u5b9a\u7b97\u6cd5\u91cd\u65b0\u53d6\u66f4\u5927\u7684 p p \u548c q q \uff0c\u76f4\u5230\u52a0\u5bc6\u6210\u529f\u3002 \u90a3\u4e48\u6211\u4eec\u53ea\u8981\u4e5f\u5199\u4e00\u4e2a\u76f8\u5e94\u7684\u89e3\u5bc6\u51fd\u6570\u5373\u53ef\u3002 #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 def ext_rsa_decrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( privatekey ) de_error = '' enc = key . decrypt ( msg . decode ( 'base64' ), de_error ) return enc except Exception as error : print error p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 n = p * q e = 12405943493775545863 # pubkey = RSA.construct((long(n), long(e))) # f = open('pubkey.pem', 'w') # f.write(pubkey.exportKey()) g = open ( 'flag.enc' , 'r' ) msg = g . read () flag = ext_rsa_decrypt ( p , q , e , msg ) print flag \u62ff\u5230 flag ASIS{F4ct0R__N_by_it3rat!ng!} SCTF RSA1 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 SCTF RSA1 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9996\u5148\u89e3\u538b\u538b\u7f29\u5305\u540e\uff0c\u5f97\u5230\u5982\u4e0b\u6587\u4ef6 \u279c level0 git: ( master ) \u2717 ls -al \u603b\u7528\u91cf 4 drwxrwxrwx 1 root root 0 7\u6708 30 16 :36 . drwxrwxrwx 1 root root 0 7\u6708 30 16 :34 .. -rwxrwxrwx 1 root root 349 5\u6708 2 2016 level1.passwd.enc -rwxrwxrwx 1 root root 2337 5\u6708 6 2016 level1.zip -rwxrwxrwx 1 root root 451 5\u6708 2 2016 public.key \u5c1d\u8bd5\u89e3\u538b\u7f29\u4e86\u4e00\u4e0b level1.zip \u73b0\u9700\u8981\u5bc6\u7801\u3002\u7136\u540e\u6839\u636e level1.passwd.enc \u53ef\u77e5\uff0c\u5e94\u8be5\u662f\u6211\u4eec\u9700\u8981\u89e3\u5bc6\u8fd9\u4e2a\u6587\u4ef6\u624d\u80fd\u5f97\u5230\u5bf9\u5e94\u7684\u5bc6\u7801\u3002\u67e5\u770b\u516c\u94a5 \u279c level0 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 :94:a0:3e:6e:0e:dc:f2:74:10:52:ef:1e:ea:a8: 89 :d6:f9:8d:01:11:51:db:5e:90:92:48:fd:39:0c: 70 :87:24:d8:98:3c:f3:33:1c:ba:c5:61:c2:ce:2c: 5a:f1:5e:65:b2:b2:46:91:56:b6:19:d5:d3:b2:a6: bb:a3:7d:56:93:99:4d:7e:4c:2f:aa:60:7b:3e:c8: fc:90:b2:00:62:4b:53:18:5b:a2:30:10:60:a8:21: ab:61:57:d7:e7:cc:67:1b:4d:cd:66:4c:7d:f1:1a: 2a:1d:5e:50:80:c1:5e:45:12:3a:ba:4a:53:64:d8: 72 :1f:84:4a:ae:5c:55:02:e8:8e:56:4d:38:70:a5: 16 :36:d3:bc:14:3e:2f:ae:2f:31:58:ba:00:ab:ac: c0:c5:ba:44:3c:29:70:56:01:6b:57:f5:d7:52:d7: 31 :56:0b:ab:0a:e6:8d:ad:08:22:a9:1f:cb:6e:49: cc:01:4c:12:d2:ab:a3:a5:97:e5:10:49:19:7f:69: d9:3b:c5:53:53:71:00:18:60:cc:69:1a:06:64:3b: 86 :94:70:a9:da:82:fc:54:6b:06:23:43:2d:b0:20: eb:b6:1b:91:35:5e:53:a6:e5:d8:9a:84:bb:30:46: b8:9f:63:bc:70:06:2d:59:d8:62:a5:fd:5c:ab:06: 68 :81 Exponent: 65537 ( 0x10001 ) Modulus = 94A03E6E0EDCF2741052EF1EEAA889D6F98D011151DB5E909248FD390C708724D8983CF3331CBAC561C2CE2C5AF15E65B2B2469156B619D5D3B2A6BBA37D5693994D7E4C2FAA607B3EC8FC90B200624B53185BA2301060A821AB6157D7E7CC671B4DCD664C7DF11A2A1D5E5080C15E45123ABA4A5364D8721F844AAE5C5502E88E564D3870A51636D3BC143E2FAE2F3158BA00ABACC0C5BA443C297056016B57F5D752D731560BAB0AE68DAD0822A91FCB6E49CC014C12D2ABA3A597E51049197F69D93BC5535371001860CC691A06643B869470A9DA82FC546B0623432DB020EBB61B91355E53A6E5D89A84BB3046B89F63BC70062D59D862A5FD5CAB066881 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlKA+bg7c8nQQUu8e6qiJ 1vmNARFR216Qkkj9OQxwhyTYmDzzMxy6xWHCzixa8V5lsrJGkVa2GdXTsqa7o31W k5lNfkwvqmB7Psj8kLIAYktTGFuiMBBgqCGrYVfX58xnG03NZkx98RoqHV5QgMFe RRI6ukpTZNhyH4RKrlxVAuiOVk04cKUWNtO8FD4vri8xWLoAq6zAxbpEPClwVgFr V/XXUtcxVgurCuaNrQgiqR/LbknMAUwS0qujpZflEEkZf2nZO8VTU3EAGGDMaRoG ZDuGlHCp2oL8VGsGI0MtsCDrthuRNV5TpuXYmoS7MEa4n2O8cAYtWdhipf1cqwZo gQIDAQAB -----END PUBLIC KEY----- \u53d1\u73b0\u867d\u7136\u8bf4\u662f 2048 \u4f4d\uff0c\u4f46\u662f\u663e\u7136\u6a21\u6570\u6ca1\u6709\u90a3\u4e48\u957f\uff0c\u5c1d\u8bd5\u5206\u89e3\u4e0b\uff0c\u5f97\u5230 p=250527704258269 q=74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 \u7136\u540e\u5c31\u53ef\u4ee5\u6784\u9020\uff0c\u5e76\u4e14\u89e3\u5bc6\uff0c\u4ee3\u7801\u5982\u4e0b from Crypto.PublicKey import RSA import gmpy2 from base64 import b64decode p = 250527704258269 q = 74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 e = 65537 n = p * q def getprivatekey ( n , e , p , q ): phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level1.passwd.enc' ) as f : cipher = f . read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) #getprivatekey(n, e, p, q) decrypt () \u53d1\u73b0\u4e0d\u5bf9 \u279c level0 git: ( master ) \u2717 python exp.py \u4e00\u5806\u4e71\u7801\u3002\u3002 \u8fd9\u65f6\u5019\u5c31\u8981\u8003\u8651\u5176\u4ed6\u60c5\u51b5\u4e86\uff0c\u4e00\u822c\u6765\u8bf4\u73b0\u5b9e\u4e2d\u5b9e\u73b0\u7684 RSA \u90fd\u4e0d\u4f1a\u76f4\u63a5\u7528\u539f\u751f\u7684 RSA\uff0c\u90fd\u4f1a\u52a0\u4e00\u4e9b\u586b\u5145\u6bd4\u5982 OAEP\uff0c\u6211\u4eec\u8fd9\u91cc\u8bd5\u8bd5\uff0c\u4fee\u6539\u4ee3\u7801 def decrypt1 () : with open ( './level1.passwd.enc' ) as f: cipher = f.read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f: key = RSA.importKey ( f ) key = PKCS1_OAEP.new ( key ) print key.decrypt ( cipher ) \u679c\u7136\u5982\u6b64\uff0c\u5f97\u5230 \u279c level0 git: ( master ) \u2717 python exp.py FaC5ori1ati0n_aTTA3k_p_tOO_sma11 \u5f97\u5230\u89e3\u538b\u5bc6\u7801\u3002\u7ee7\u7eed\uff0c\u67e5\u770b level1 \u4e2d\u7684\u516c\u94a5 \u279c level1 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 :c3:26:59:69:e1:ed:74:d2:e0:b4:9a:d5:6a:7c: 2f:2a:9e:c3:71:ff:13:4b:10:37:c0:6f:56:19:34: c5:cb:1f:6d:c0:e3:57:3b:47:c4:76:3e:21:a3:b0: 11 :11:78:d4:ee:4f:e8:99:2b:15:cb:cb:d7:73:e4: f9:a6:28:20:fd:db:8c:ea:16:ed:67:c2:48:12:6e: 4b:01:53:4a:67:cb:22:23:3b:34:2e:af:13:ef:93: 45 :16:2b:00:9f:e0:4b:d1:90:c9:2c:27:9a:34:c3: 3f:d7:ee:40:f5:82:50:39:aa:8c:e9:c2:7b:f4:36: e3:38:9d:04:50:db:a9:b7:3f:4b:2a:d6:8a:2a:5c: 87 :2a:eb:74:35:98:6a:9c:e4:52:cb:93:78:d2:da: 39 :83:f3:0c:d1:65:1e:66:9c:40:56:06:0d:58:fc: 41 :64:5e:06:da:83:d0:3b:06:42:70:da:38:53:e0: 54 :35:53:ce:de:79:4a:bf:f5:3b:e5:53:7f:6c:18: 12 :67:a9:de:37:7d:44:65:5e:68:0a:78:39:3d:bb: 00 :22:35:0e:a3:94:e6:94:15:1a:3d:39:c7:50:0e: b1:64:a5:29:a3:69:41:40:69:94:b0:0d:1a:ea:9a: 12 :27:50:ee:1e:3a:19:b7:29:70:b4:6d:1e:9d:61: 3e:7d Exponent: 65537 ( 0x10001 ) Modulus = C3265969E1ED74D2E0B49AD56A7C2F2A9EC371FF134B1037C06F561934C5CB1F6DC0E3573B47C4763E21A3B0111178D4EE4FE8992B15CBCBD773E4F9A62820FDDB8CEA16ED67C248126E4B01534A67CB22233B342EAF13EF9345162B009FE04BD190C92C279A34C33FD7EE40F5825039AA8CE9C27BF436E3389D0450DBA9B73F4B2AD68A2A5C872AEB7435986A9CE452CB9378D2DA3983F30CD1651E669C4056060D58FC41645E06DA83D03B064270DA3853E0543553CEDE794ABFF53BE5537F6C181267A9DE377D44655E680A78393DBB0022350EA394E694151A3D39C7500EB164A529A36941406994B00D1AEA9A122750EE1E3A19B72970B46D1E9D613E7D writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwyZZaeHtdNLgtJrVanwv Kp7Dcf8TSxA3wG9WGTTFyx9twONXO0fEdj4ho7AREXjU7k/omSsVy8vXc+T5pigg /duM6hbtZ8JIEm5LAVNKZ8siIzs0Lq8T75NFFisAn+BL0ZDJLCeaNMM/1+5A9YJQ OaqM6cJ79DbjOJ0EUNuptz9LKtaKKlyHKut0NZhqnORSy5N40to5g/MM0WUeZpxA VgYNWPxBZF4G2oPQOwZCcNo4U+BUNVPO3nlKv/U75VN/bBgSZ6neN31EZV5oCng5 PbsAIjUOo5TmlBUaPTnHUA6xZKUpo2lBQGmUsA0a6poSJ1DuHjoZtylwtG0enWE+ fQIDAQAB -----END PUBLIC KEY----- \u4f3c\u4e4e\u8fd8\u662f\u4e0d\u662f\u5f88\u5927\uff0c\u518d\u6b21\u5206\u89e3\uff0c\u7136\u540e\u8bd5\u4e86 factordb \u4e0d\u884c\uff0c\u8bd5\u8bd5 yafu\u3002\u7ed3\u679c\u5206\u89e3\u51fa\u6765\u4e86\u3002 P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496383 P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496259 \u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e24\u4e2a\u6570\u975e\u5e38\u76f8\u8fd1\uff0c\u53ef\u80fd\u662f factordb \u6ca1\u6709\u5b9e\u73b0\u8fd9\u7c7b\u5206\u89e3\u3002 \u7ee7\u800c\u4e0b\u9762\u7684\u64cd\u4f5c\u7c7b\u4f3c\u4e8e level0\u3002\u53ea\u662f\u8fd9\u6b21\u662f\u76f4\u63a5\u89e3\u5bc6\u5c31\u597d\uff0c\u6ca1\u5565\u586b\u5145\uff0c\u8bd5\u4e86\u586b\u5145\u53cd\u800c\u9519 \u5f97\u5230\u5bc6\u7801 fA35ORI11TLoN_Att1Ck_cL0sE_PrI8e_4acTorS \u3002\u7ee7\u7eed\u4e0b\u4e00\u6b65\uff0c\u67e5\u770b\u516c\u94a5 \u279c level2 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 1025 bit ) Modulus: 01 :ba:0c:c2:45:b4:5c:e5:b5:f5:6c:d5:ca:a5:90: c2:8d:12:3d:8a:6d:7f:b6:47:37:fb:7c:1f:5a:85: 8c:1e:35:13:8b:57:b2:21:4f:f4:b2:42:24:5f:33: f7:2c:2c:0d:21:c2:4a:d4:c5:f5:09:94:c2:39:9d: 73 :e5:04:a2:66:1d:9c:4b:99:d5:38:44:ab:13:d9: cd:12:a4:d0:16:79:f0:ac:75:f9:a4:ea:a8:7c:32: 16 :9a:17:d7:7d:80:fd:60:29:64:c7:ea:50:30:63: 76 :59:c7:36:5e:98:d2:ea:5b:b3:3a:47:17:08:2d: d5:24:7d:4f:a7:a1:f0:d5:73 Exponent: 01 :00:8e:81:dd:a0:e3:19:28:e8:ee:51:11:08:c7: 50 :5f:61:31:05:d2:e2:ff:9b:83:71:e4:29:c2:dd: 92 :70:65:d4:09:6d:58:c3:76:31:07:f1:d4:fc:cf: 2d:b3:0a:6d:02:7c:56:61:7c:be:7e:0b:7e:d9:22: 28 :66:9e:fb:3d:2f:2c:20:59:3c:21:ef:ff:31:00: 6a:fb:a7:68:de:4a:0a:4c:1a:a7:09:d5:48:98:c8: 1f:cf:fb:dd:f7:9c:ae:ae:0b:15:f4:b2:c7:e0:bc: ba:31:4f:5e:07:83:ad:0e:7f:b9:82:a4:d2:01:fa: 68 :29:6d:66:7c:cf:57:b9:4b Modulus = 1BA0CC245B45CE5B5F56CD5CAA590C28D123D8A6D7FB64737FB7C1F5A858C1E35138B57B2214FF4B242245F33F72C2C0D21C24AD4C5F50994C2399D73E504A2661D9C4B99D53844AB13D9CD12A4D01679F0AC75F9A4EAA87C32169A17D77D80FD602964C7EA5030637659C7365E98D2EA5BB33A4717082DD5247D4FA7A1F0D573 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQG6DMJFtFzltfVs1cqlkMKN Ej2KbX+2Rzf7fB9ahYweNROLV7IhT/SyQiRfM/csLA0hwkrUxfUJlMI5nXPlBKJm HZxLmdU4RKsT2c0SpNAWefCsdfmk6qh8MhaaF9d9gP1gKWTH6lAwY3ZZxzZemNLq W7M6RxcILdUkfU+nofDVcwKBgQEAjoHdoOMZKOjuUREIx1BfYTEF0uL/m4Nx5CnC 3ZJwZdQJbVjDdjEH8dT8zy2zCm0CfFZhfL5+C37ZIihmnvs9LywgWTwh7/8xAGr7 p2jeSgpMGqcJ1UiYyB/P+933nK6uCxX0ssfgvLoxT14Hg60Of7mCpNIB+mgpbWZ8 z1e5Sw == -----END PUBLIC KEY----- \u53d1\u73b0\u79c1\u94a5 e \u548c n \u51e0\u4e4e\u4e00\u6837\u5927\uff0c\u8003\u8651 d \u6bd4\u8f83\u5c0f\uff0c\u4f7f\u7528 Wiener's Attack\u3002\u5f97\u5230 d\uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u518d\u6b21\u9a8c\u8bc1\u4e00\u904d\u3002 \u279c level2 git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- \u8fd9\u65f6\u6211\u4eec\u89e3\u5bc6\u5bc6\u6587\uff0c\u89e3\u5bc6\u4ee3\u7801\u5982\u4e0b from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode d = 29897859398360008828023114464512538800655735360280670512160838259524245332403 L with open ( './public.key' ) as f : key = RSA . importKey ( f ) n = key . n e = key . e def getprivatekey ( n , e , d ): priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level3.passwd.enc' ) as f : cipher = f . read () with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) getprivatekey ( n , e , d ) decrypt () \u5229\u7528\u672b\u5c3e\u7684\u5b57\u7b26\u4e32 wIe6ER1s_1TtA3k_e_t00_larg3 \u89e3\u5bc6\u538b\u7f29\u5305\uff0c\u6ce8\u610f\u53bb\u6389 B\u3002\u81f3\u6b64\u5168\u90e8\u89e3\u5bc6\u7ed3\u675f\uff0c\u5f97\u5230 flag\u3002 2018 WCTF RSA \u00b6 \u9898\u76ee\u57fa\u672c\u63cf\u8ff0\u4e3a Description: Encrypted message for user \"admin\": <<<320881698662242726122152659576060496538921409976895582875089953705144841691963343665651276480485795667557825130432466455684921314043200553005547236066163215094843668681362420498455007509549517213285453773102481574390864574950259479765662844102553652977000035769295606566722752949297781646289262341623549414376262470908749643200171565760656987980763971637167709961003784180963669498213369651680678149962512216448400681654410536708661206594836597126012192813519797526082082969616915806299114666037943718435644796668877715954887614703727461595073689441920573791980162741306838415524808171520369350830683150672985523901>>> admin public key: n = 483901264006946269405283937218262944021205510033824140430120406965422208942781742610300462772237450489835092525764447026827915305166372385721345243437217652055280011968958645513779764522873874876168998429546523181404652757474147967518856439439314619402447703345139460317764743055227009595477949315591334102623664616616842043021518775210997349987012692811620258928276654394316710846752732008480088149395145019159397592415637014390713798032125010969597335893399022114906679996982147566245244212524824346645297637425927685406944205604775116409108280942928854694743108774892001745535921521172975113294131711065606768927 e = 65537 Service: http://36.110.234.253 \u8fd9\u4e2a\u9898\u76ee\u73b0\u5728\u5df2\u7ecf\u6ca1\u6709\u529e\u6cd5\u5728\u7ebf\u83b7\u53d6 binary \u4e86\uff0c\u73b0\u5728\u5f97\u5230\u7684 binary \u662f\u4e4b\u524d\u5df2\u7ecf\u4e0b\u8f7d\u597d\u7684\uff0c\u6211\u4eec\u5f53\u65f6\u9700\u8981\u767b\u5f55\u7528\u6237\u7684 admin \u6765\u4e0b\u8f7d\u5bf9\u5e94\u7684 generator\u3002 \u901a\u8fc7\u7b80\u5355\u9006\u5411\u8fd9\u4e2a generator\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e2a\u7a0b\u5e8f\u662f\u8fd9\u4e48\u5de5\u4f5c\u7684 \u5229\u7528\u7528\u6237\u7ed9\u5b9a\u7684 license\uff0832 \u4e2a\u5b57\u8282\uff09\uff0c\u8fed\u4ee3\u89e3\u5bc6\u67d0\u4e2a \u56fa\u5b9a\u4f4d\u7f6e \u4e4b\u540e\u7684\u6570\u636e\uff0c\u6bcf 32 \u4e2a\u5b57\u8282\u4e00\u7ec4\uff0c\u4e0e\u5bc6\u94a5\u76f8\u5f02\u6216\u5f97\u5230\u7ed3\u679c\u3002 \u5bc6\u94a5\u7684\u751f\u6210\u65b9\u6cd5\u4e3a k_1=key k_1=key k_2 =sha256(k_1) k_2 =sha256(k_1) ... k_n=sha256(k_{n-1}) k_n=sha256(k_{n-1}) \u5176\u4e2d\uff0c\u56fa\u5b9a\u4f4d\u7f6e\u5c31\u662f\u5728\u627e\u6e90\u6587\u4ef6 generator \u4e2d\u7b2c\u4e8c\u6b21\u51fa\u73b0 ENCRYPTED \u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u518d\u6b21\u504f\u79fb 32 \u4e2a\u5b57\u8282\u3002 _ENCRYPT_STR = ENCRYPTED_STR ; v10 = 0 ; ENCRYPTED_LEN = strlen ( ENCRYPTED_STR ); do { do ++ v9 ; while ( strncmp ( & file_contents [ v9 ], _ENCRYPT_STR , ENCRYPTED_LEN ) ); ++ v10 ; } while ( v10 <= 1 ); v11 = & file_start_off_32 [ loc2 + ENCRYPTED_LEN ]; v12 = loc2 + ENCRYPTED_LEN ; len = file_size - ( loc2 + ENCRYPTED_LEN ) - 32 ; decrypt ( & file_start_off_32 [ v12 ], & license , len ); sha256_file_start ( v11 , len , & output ); if ( ! memcmp ( & output , & file_contents [ v12 ], 0x20 u ) ) { v14 = fopen ( \"out.exe\" , \"wb\" ); fwrite ( v11 , 1 u , len , v14 ); fclose ( v14 ); sprintf ( byte_406020 , \"out.exe %s \" , argv [ 1 ]); system ( byte_406020 ); } \u540c\u65f6\uff0c\u6211\u4eec\u9700\u8981\u786e\u4fdd\u751f\u6210\u7684\u6587\u4ef6\u7684\u6821\u9a8c\u5bf9\u5e94\u7684\u54c8\u5e0c\u503c\u6070\u597d\u4e3a\u6307\u5b9a\u7684\u503c\uff0c\u7531\u4e8e\u6587\u4ef6\u6700\u540e\u662f\u4e00\u4e2a exe \u6587\u4ef6\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u6700\u540e\u7684\u6587\u4ef6\u5934\u5c31\u662f\u6807\u51c6\u7684 exe \u6587\u4ef6\uff0c\u56e0\u6b64\u5c31\u4e0d\u9700\u8981\u77e5\u9053\u539f\u59cb\u7684 license \u6587\u4ef6\uff0c\u8fdb\u800c\u6211\u4eec\u53ef\u4ee5\u7f16\u5199 python \u811a\u672c\u751f\u6210 exe\u3002 \u5728\u751f\u6210\u7684 exe \u4e2d\uff0c\u6211\u4eec\u5206\u6790\u51fa\u7a0b\u5e8f\u7684\u57fa\u672c\u6d41\u7a0b\u4e3a \u8bfb\u53d6 license \u4f7f\u7528 license \u4f5c\u4e3a seed \u5206\u522b\u751f\u6210 pq \u5229\u7528 p\uff0cq \u751f\u6210 n\uff0ce\uff0cd\u3002 \u5176\u6f0f\u6d1e\u51fa\u73b0\u5728\u751f\u6210 p\uff0cq \u7684\u65b9\u6cd5\u4e0a\uff0c\u800c\u4e14\u751f\u6210 p \u548c q \u7684\u65b9\u6cd5\u7c7b\u4f3c\u3002 \u6211\u4eec\u5982\u679c\u4ed4\u7ec6\u5206\u6790\u4e0b\u751f\u6210\u7d20\u6570\u7684\u51fd\u6570\u7684\u8bdd\uff0c\u53ef\u4ee5\u770b\u5230\u6bcf\u4e2a\u7d20\u6570\u90fd\u662f\u5206\u4e3a\u4e24\u90e8\u5206\u751f\u6210\u7684 \u751f\u6210\u5de6\u534a\u90e8\u5206 512 \u4f4d\u3002 \u751f\u6210\u53f3\u534a\u90e8\u5206 512 \u4f4d\u3002 \u5de6\u53f3\u6784\u6210 1024 \u6bd4\u7279\u4f4d\uff0c\u5224\u65ad\u662f\u4e0d\u662f\u7d20\u6570\uff0c\u662f\u7d20\u6570\u5c31\u6210\u529f\uff0c\u4e0d\u662f\u7d20\u6570\uff0c\u7ee7\u7eed\u751f\u6210\u3002 \u5176\u4e2d\u751f\u6210\u6bcf\u90e8\u5206\u7684\u65b9\u5f0f\u76f8\u540c\uff0c\u65b9\u5f0f\u4e3a sha512 ( const1 | const2 | const3 | const4 | const5 | const6 | const7 | const8 | v9 ) v9 = r % 1000000007 \u53ea\u6709 v9 \u4f1a\u6709\u6240\u53d8\u5316\uff0c\u4f46\u662f\u5b83\u7684\u8303\u56f4\u5374\u662f\u56fa\u5b9a\u7684\u3002 \u90a3\u4e48\uff0c\u5982\u679c\u6211\u4eec\u8868\u793a p\uff0cq \u4e3a p=a*2^{512}+b p=a*2^{512}+b q=c*2^{512}+d q=c*2^{512}+d \u90a3\u4e48 n=pq=ac*2^{1024}+(ad+bc)*2^{512}+bd n=pq=ac*2^{1024}+(ad+bc)*2^{512}+bd \u90a3\u4e48 n \\equiv bd \\bmod 2^{512} n \\equiv bd \\bmod 2^{512} \u800c\u4e14\u7531\u4e8e p \u548c q \u5728\u751f\u6210\u65f6\uff0ca\uff0cb\uff0cc\uff0cd \u5747\u53ea\u6709 1000000007 \u79cd\u53ef\u80fd\u6027\u3002 \u8fdb\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u7684\u53ef\u80fd\u6027\uff0c\u9996\u5148\u8ba1\u7b97\u51fa b \u53ef\u80fd\u7684\u96c6\u5408\u4e3a S\uff0c\u540c\u65f6\u6211\u4eec\u4f7f\u7528\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\uff0c\u8ba1\u7b97 n/d \\equiv b \\bmod 2^{512} n/d \\equiv b \\bmod 2^{512} \u8fd9\u91cc\u7531\u4e8e b \u548c d \u90fd\u662f p \u7684\u5c3e\u6570\uff0c\u6240\u4ee5\u4e00\u5b9a\u4e0d\u4f1a\u662f 2 \u7684\u500d\u6570\uff0c\u8fdb\u800c\u5fc5\u7136\u5b58\u5728\u9006\u5143\u3002 \u8fd9\u6837\u505a\u867d\u7136\u53ef\u4ee5\uff0c\u7136\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7b97\u4e00\u4e0b\u5b58\u50a8\u7a7a\u95f4 64*1000000007 / 1024 / 1024 / 1024=59 64*1000000007 / 1024 / 1024 / 1024=59 \u4e5f\u5c31\u662f\u8bf4\u9700\u8981 59 G\uff0c\u592a\u5927\u4e86\uff0c\uff0c\u6240\u4ee5\u6211\u4eec\u4ecd\u7136\u9700\u8981\u8fdb\u4e00\u6b65\u8003\u8651 n \\equiv bd \\bmod 2^{64} n \\equiv bd \\bmod 2^{64} \u8fd9\u6837\uff0c\u6211\u4eec\u7684\u5185\u5b58\u9700\u6c42\u77ac\u95f4\u5c31\u964d\u5230\u4e86 8 G\u5de6\u53f3\u3002\u6211\u4eec\u4ecd\u7136\u4f7f\u7528\u679a\u4e3e\u7684\u65b9\u6cd5\u8fdb\u884c\u8fd0\u7b97\u3002 \u5176\u6b21\uff0c\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528 python\uff0c\uff0cpython \u5360\u636e\u7a7a\u95f4\u592a\u5927\uff0c\u56e0\u6b64\u9700\u8981\u4f7f\u7528 c/c++ \u7f16\u5199\u3002 \u679a\u4e3e\u6240\u6709\u53ef\u80fd\u7684 d \u8ba1\u7b97\u5bf9\u5e94\u7684\u503c n/d n/d \u5982\u679c\u5bf9\u5e94\u7684\u503c\u5728\u96c6\u5408 S \u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u8ba4\u4e3a\u627e\u5230\u4e86\u4e00\u5bf9\u5408\u6cd5\u7684 b \u548c d\uff0c\u56e0\u6b64\u6211\u4eec\u5c31\u53ef\u4ee5\u6062\u590d p \u548c q \u7684\u4e00\u534a\u3002 \u4e4b\u540e\uff0c\u6211\u4eec\u6839\u636e n-bd=ac*2^{1024}+(ad+bc)*2^{512} n-bd=ac*2^{1024}+(ad+bc)*2^{512} \u53ef\u4ee5\u5f97\u5230 \\frac{n-bd}{2^{512}} = ac*2^{512}+ad+bc \\frac{n-bd}{2^{512}} = ac*2^{512}+ad+bc \\frac{n-bd}{2^{512}} \\equiv ad+bc \\bmod 2^{512} \\frac{n-bd}{2^{512}} \\equiv ad+bc \\bmod 2^{512} \u7c7b\u4f3c\u5730\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba1\u7b97\u51fa a \u548c c\uff0c\u4ece\u800c\u6211\u4eec\u5c31\u53ef\u4ee5\u5b8c\u5168\u6062\u590d\u51fa p \u548c q\u3002 \u5728\u5177\u4f53\u6c42\u89e3\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5728\u6c42 p \u548c q \u7684\u4e00\u90e8\u5206\u65f6\uff0c\u53ef\u4ee5\u53d1\u73b0\u56e0\u4e3a\u662f\u6a21 2^{64} 2^{64} \uff0c\u6240\u4ee5\u53ef\u80fd\u5b58\u5728\u78b0\u649e\uff08\u4f46\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u662f p\uff0c\u53e6\u5916\u4e00\u4e2a\u662fq\uff0c\u6070\u597d\u5bf9\u79f0\u3002\uff09\u3002\u4e0b\u9762\u6211\u4eec\u5c31\u6c42\u5f97\u4e86 b \u5bf9\u5e94\u7684 v9\u3002 \u6ce8\u610f\uff1a\u8fd9\u91cc\u679a\u4e3e\u51fa\u6765\u7684\u7a7a\u95f4\u5927\u7ea6\u5360\u7528 11 \u4e2a G\uff08\u5305\u62ec\u7d22\u5f15\uff09\uff0c\u6240\u4ee5\u8bf7\u9009\u62e9\u5408\u9002\u7684\u4f4d\u7f6e\u3002 b64: 9646799660ae61bd idx_b: 683101175 idx_d: 380087137 search 23000000 search 32000000 search 2b000000 search d000000 search 3a000000 search 1c000000 search 6000000 search 24000000 search 15000000 search 33000000 search 2c000000 search e000000 b64: 9c63259ccab14e0b idx_b: 380087137 idx_d: 683101175 search 1d000000 search 3b000000 search 7000000 search 16000000 search 25000000 search 34000000 \u5176\u5b9e\uff0c\u6211\u4eec\u5728\u771f\u6b63\u5f97\u5230 p \u6216\u8005 q \u7684\u4e00\u90e8\u5206\u540e\uff0c\u53e6\u5916\u4e00\u90e8\u5206\u5b8c\u5168\u53ef\u4ee5\u4f7f\u7528\u66b4\u529b\u679a\u4e3e\u7684\u65b9\u5f0f\u83b7\u53d6\uff0c\u56e0\u4e3a\u8ba1\u7b97\u91cf\u51e0\u4e4e\u90fd\u662f\u4e00\u6837\u7684\uff0c\u6700\u540e\u7ed3\u679c\u4e3a ... hash 7000000 hash 30000000 p = 13941980378318401138358022650359689981503197475898780162570451627011086685747898792021456273309867273596062609692135266568225130792940286468658349600244497842007796641075219414527752166184775338649475717002974228067471300475039847366710107240340943353277059789603253261584927112814333110145596444757506023869 q = 34708215825599344705664824520726905882404144201254119866196373178307364907059866991771344831208091628520160602680905288551154065449544826571548266737597974653701384486239432802606526550681745553825993460110874794829496264513592474794632852329487009767217491691507153684439085094523697171206345793871065206283 plain text 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 hash 16000000 hash 25000000 hash b000000 hash 34000000 hash 1 a000000 ... \u279c 2018 - WCTF - rsa git :( master ) \u2717 python Python 2.7 . 14 ( default , Mar 22 2018 , 14 : 43 : 05 ) [ GCC 4.2 . 1 Compatible Apple LLVM 9.0 . 0 ( clang - 900.0 . 39.2 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> p = 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 >>> hex ( p )[ 2 :] . decode ( 'hex' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/local/Cellar/python@2/2.7.14_3/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/hex_codec.py\" , line 42 , in hex_decode output = binascii . a2b_hex ( input ) TypeError : Odd - length string >>> hex ( p )[ 2 : - 1 ] . decode ( 'hex' ) 'flag {fa6778724ed740396fc001b198f30313} ' \u6700\u540e\u6211\u4eec\u4fbf\u62ff\u5230 flag \u4e86\u3002 \u8be6\u7ec6\u7684\u5229\u7528\u4ee3\u7801\u8bf7\u53c2\u89c1 ctf-challenge \u4ed3\u5e93\u3002 \u76f8\u5173\u7f16\u8bd1\u6307\u4ee4\uff0c\u9700\u8981\u94fe\u63a5\u76f8\u5173\u7684\u5e93\u3002 g++ exp2.cpp -std = c++11 -o main2 -lgmp -lcrypto -pthread \u53c2\u8003 \u00b6 https://upbhack.de/posts/wctf-2018-writeup-rsa/","title":"Rsa complex zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#rsa","text":"","title":"RSA \u590d\u6742\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#2018-tokyo-western-mixed-cipher","text":"\u9898\u76ee\u7ed9\u7684\u4fe1\u606f\u5982\u4e0b\u6240\u793a\uff1a \u6bcf\u6b21\u4ea4\u4e92\u53ef\u4ee5\u7ef4\u6301\u7684\u65f6\u95f4\u957f\u5ea6\u7ea6\u4e3a 5 \u5206\u949f \u6bcf\u6b21\u4ea4\u4e92\u4e2d\u4e2dn\u662f\u786e\u5b9a\u7684 1024 bit\uff0c\u4f46\u662f\u672a\u77e5\uff0c e \u4e3a 65537 \u4f7f\u7528 aes \u52a0\u5bc6\u4e86 flag\uff0c\u5bc6\u94a5\u548c IV \u5747\u4e0d\u77e5\u9053 \u6bcf\u6b21\u5bc6\u94a5\u662f\u56fa\u5b9a\u7684\uff0c\u4f46\u662f IV \u6bcf\u6b21\u90fd\u4f1a\u968f\u673a \u53ef\u4ee5\u4f7f\u7528 encrypt \u529f\u80fd\u968f\u610f\u4f7f\u7528 rsa \u548c aes \u8fdb\u884c\u52a0\u5bc6\uff0c\u5176\u4e2d\u6bcf\u6b21\u52a0\u5bc6\u90fd\u4f1a\u5bf9 aes \u7684 iv \u8fdb\u884c\u968f\u673a \u53ef\u4ee5\u4f7f\u7528 decrypt \u5bf9\u968f\u610f\u7684\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u4f46\u662f\u53ea\u80fd\u77e5\u9053\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u662f\u4ec0\u4e48 \u53ef\u4ee5\u4f7f\u7528 print_flag \u83b7\u53d6 flag \u5bc6\u6587 \u53ef\u4ee5\u4f7f\u7528 print_key \u83b7\u53d6 rsa \u52a0\u5bc6\u7684 aes \u5bc6\u94a5 \u672c\u9898\u76ee\u770b\u4f3c\u4e00\u4e2a\u9898\u76ee\uff0c\u5b9e\u5219\u662f 3 \u4e2a\u9898\u76ee\uff0c\u9700\u8981\u5206\u6b65\u9aa4\u89e3\u51b3\u3002\u5728\u6b64\u4e4b\u524d\uff0c\u6211\u5011\u6e96\u5099\u597d\u4ea4\u4e92\u7684\u51fd\u6578 def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"4\" ) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline ()[: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"1\" ) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline ()[: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"2\" ) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" )","title":"2018 Tokyo Western Mixed Cipher"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#gcd-attack-n","text":"\u7b2c\u4e00\u6b65\u6211\u4eec\u9700\u8981\u628a\u6ca1\u6709\u7ed9\u51fa\u7684 n \u7b97\u51fa\u6765\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u5229\u7528 encrypt \u529f\u80fd\u5bf9\u6211\u4eec\u8f93\u5165\u7684\u660e\u6587 x \u8fdb\u884c rsa \u52a0\u5bc6\uff0c\u90a3\u4e48\u53ef\u4ee5\u5229\u7528\u6574\u9664\u7684\u6027\u8d28\u7b97 n \u56e0\u4e3ax ^ e = c mod n \u6240\u4ee5 n | x ^ e - c \u6211\u4eec\u53ef\u4ee5\u6784\u9020\u8db3\u591f\u591a\u7684 x\uff0c\u7b97\u51fa\u6700\u591f\u591a\u7684 x ^ e - c\uff0c\u4ece\u800c\u8ba1\u7b97\u6700\u5927\u516c\u7ea6\u6570\uff0c\u5f97\u5230 n\u3002 def get_n(io): rsa_c,aes_c=encrypt_io(io,long_to_bytes(2)) n=pow(2,65537)-rsa_c for i in range(3,6): rsa_c, aes_c = encrypt_io(io, long_to_bytes(i)) n=primefac.gcd(n,pow(i,65537)-rsa_c) return n \u53ef\u4ee5\u5229\u7528\u52a0\u5bc6\u8fdb\u884c check def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , \"123\" ) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False","title":"GCD attack n"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#rsa-parity-oracle","text":"\u5229\u7528 leak \u7684\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u6211\u4eec\u53ef\u4ee5\u8fdb\u884c\u9009\u62e9\u5bc6\u6587\u653b\u51fb\uff0c\u4f7f\u7528 RSA parity oracle \u56de\u590d aes \u7684\u79d8\u94a5 def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : print lb , ub tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : ub = ( lb + ub ) / 2 k += 1 print ub , len ( long_to_bytes ( ub )) return ub","title":"RSA parity oracle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#prng-predict","text":"\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u89e3\u5bc6 flag \u768416\u5b57\u8282\u4e4b\u540e\u7684\u5185\u5bb9\u4e86\uff0c\u4f46\u662f\u524d16\u4e2a\u5b57\u8282\u6ca1\u6709 IV \u662f\u89e3\u5bc6\u4e0d\u4e86\u7684\u3002\u8fd9\u65f6\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0cIV \u751f\u6210\u4f7f\u7528\u7684\u968f\u673a\u6570\u4f7f\u7528\u4e86 getrandbits\uff0c\u5e76\u4e14\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6\u5230\u8db3\u591f\u591a\u7684\u968f\u673a\u6570\u91cf\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8fdb\u884c PRNG \u7684 predict\uff0c\u4ece\u800c\u76f4\u63a5\u83b7\u53d6\u968f\u673a\u6570 \u8fd9\u91cc\u4f7f\u7528\u4e86\u4e00\u4e2a\u73b0\u6210\u7684\u7684 java \u8fdb\u884c PRNG \u7684 Predict public class Main { static int [] state ; static int currentIndex ; 40 huo public static void main ( String [] args ) { state = new int [ 624 ] ; currentIndex = 0 ; // initialize(0); // for (int i = 0; i < 5; i++) { // System.out.println(state[i]); // } // for (int i = 0; i < 5; i++) { // System.out.println(nextNumber()); // } if ( args . length != 624 ) { System . err . println ( \"must be 624 args\" ); System . exit ( 1 ); } int [] arr = new int [ 624 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { arr [ i ] = Integer . parseInt ( args [ i ] ); } rev ( arr ); for ( int i = 0 ; i < 6240 huo4 ; i ++ ) { System . out . println ( state [ i ] ); } // System.out.println(\"currentIndex \" + currentIndex); // System.out.println(\"state[currentIndex] \" + state[currentIndex]); // System.out.println(\"next \" + nextNumber()); // want -2065863258 } static void nextState () { // Iterate through the state for ( int i = 0 ; i < 624 ; i ++ ) { // y is the first bit of the current number, // and the last 31 bits of the next number int y = ( state [ i ] & 0x80000000 ) + ( state [ ( i + 1 ) % 624 ] & 0x7fffffff ); // first bitshift y by 1 to the right int next = y >>> 1 ; // xor it with the 397th next number next ^= state [ ( i + 397 ) % 624 ] ; // if y is odd, xor with magic number if (( y & 1L ) == 1L ) { next ^= 0x9908b0df ; } // now we have the result state [ i ] = next ; } } static int nextNumber () { currentIndex ++ ; int tmp = state [ currentIndex ] ; tmp ^= ( tmp >>> 11 ); tmp ^= ( tmp << 7 ) & 0x9d2c5680 ; tmp ^= ( tmp << 15 ) & 0xefc60000 ; tmp ^= ( tmp >>> 18 ); return tmp ; } static void initialize ( int seed ) { // http://code.activestate.com/recipes/578056-mersenne-twister/ // global MT // global bitmask_1 // MT[0] = seed // for i in xrange(1,624): // MT[i] = ((1812433253 * MT[i-1]) ^ ((MT[i-1] >> 30) + i)) & bitmask_1 // copied Python 2.7's impl (probably uint problems) state [ 0 ] = seed ; for ( int i = 1 ; i < 624 ; i ++ ) { state [ i ] = (( 1812433253 * state [ i - 1 ] ) ^ (( state [ i - 1 ] >> 30 ) + i )) & 0xffffffff ; } } static int unBitshiftRightXor ( int value , int shift ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 << ( 32 - shift )) >>> ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= part >>> shift ; // add the part to the result result |= part ; i ++ ; } return result ; } static int unBitshiftLeftXor ( int value , int shift , int mask ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 >>> ( 32 - shift )) << ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= ( part << shift ) & mask ; // add the part to the result result |= part ; i ++ ; } return result ; } static void rev ( int [] nums ) { for ( int i = 0 ; i < 624 ; i ++ ) { int value = nums [ i ] ; value = unBitshiftRightXor ( value , 18 ); value = unBitshiftLeftXor ( value , 15 , 0xefc60000 ); value = unBitshiftLeftXor ( value , 7 , 0x9d2c5680 ); value = unBitshiftRightXor ( value , 11 ); state [ i ] = value ; } } } \u5199\u4e86\u4e00\u4e2a python \u76f4\u63a5\u8c03\u7528 java from Crypto.Util.number import long_to_bytes,bytes_to_long def encrypt_io(io,p): io.read_until(\"4: get encrypted keyn\") io.writeline(\"1\") io.read_until(\"input plain text: \") io.writeline(p) io.read_until(\"RSA: \") rsa_c=int(io.readline()[:-1],16) io.read_until(\"AES: \") aes_c=io.readline()[:-1].decode(\"hex\") return rsa_c,aes_c import subprocess import random def get_iv(io): rsa_c, aes_c=encrypt_io(io,\"1\") return bytes_to_long(aes_c[0:16]) def splitInto32(w128): w1 = w128 & (2**32-1) w2 = (w128 >> 32) & (2**32-1) w3 = (w128 >> 64) & (2**32-1) w4 = (w128 >> 96) return w1,w2,w3,w4 def sign(iv): # converts a 32 bit uint to a 32 bit signed int if(iv&0x80000000): iv = -0x100000000 + iv return iv def get_state(io): numbers=[] for i in range(156): print i numbers.append(get_iv(io)) observedNums = [sign(w) for n in numbers for w in splitInto32(n)] o = subprocess.check_output([\"java\", \"Main\"] + map(str, observedNums)) stateList = [int(s) % (2 ** 32) for s in o.split()] r = random.Random() state = (3, tuple(stateList + [624]), None) r.setstate(state) return r.getrandbits(128)","title":"PRNG Predict"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#exp","text":"\u6574\u4f53\u653b\u51fb\u4ee3\u7801\u5982\u4e0b\uff1a from zio import * import primefac from Crypto.Util.number import long_to_bytes , bytes_to_long target = ( \"crypto.chal.ctf.westerns.tokyo\" , 5643 ) e = 65537 def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"4\" ) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline ()[: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"1\" ) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline ()[: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( \"2\" ) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) def get_n ( io ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( 2 )) n = pow ( 2 , 65537 ) - rsa_c for i in range ( 3 , 6 ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( i )) n = primefac . gcd ( n , pow ( i , 65537 ) - rsa_c ) return n def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , \"123\" ) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False import gmpy2 def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : print lb , ub tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : ub = ( lb + ub ) / 2 k += 1 print ub , len ( long_to_bytes ( ub )) return ub io = zio ( target , timeout = 10000 , print_read = COLORED ( NONE , 'red' ), print_write = COLORED ( NONE , 'green' )) n = get_n ( io ) print check_n ( io , n ) c = get_enc_key ( io ) print len ( decrypt_io ( io , c )) == 16 m = guess_m ( io , n , c ) for i in range ( m - 50000 , m + 50000 ): if pow ( i , e , n ) == c : aeskey = i print long_to_bytes ( aeskey )[ - 1 ] == decrypt_io ( io , c )[ - 1 ] print \"found aes key\" , hex ( aeskey ) import fuck_r next_iv = fuck_r . get_state ( io ) print \"##########################################\" print next_iv print aeskey io . interact ()","title":"EXP"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#2016-asis-find-the-flag","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 ASIS 2016 \u7ebf\u4e0a\u8d5b\u4e2d Find the flag \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002 \u6587\u4ef6\u89e3\u538b\u51fa\u6765\uff0c\u6709\u4e00\u4e2a\u5bc6\u6587\uff0c\u4e00\u4e2a\u516c\u94a5\uff0c\u4e00\u4e2a py \u811a\u672c\u3002\u770b\u4e00\u4e0b\u516c\u94a5\u3002 \u279c RSA openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 :d8:e2:4c:12:b7:b9:9e:fe:0a:9b:c0:4a:6a:3d: f5:8a:2a:94:42:69:b4:92:b7:37:6d:f1:29:02:3f: 20 :61:b9 Exponent: 12405943493775545863 ( 0xac2ac3e0ca0f5607 ) Modulus = D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9 \u8fd9\u4e48\u5c0f\u7684\u4e00\u4e2a N N \uff0c\u5148\u5206\u89e3\u4e00\u4e0b\u3002 p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 \u518d\u770b\u7ed9\u7684 py \u811a\u672c\u3002 #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 flag = open ( 'flag' , 'r' ) . read () * 30 def ext_rsa_encrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) pubkey = RSA . construct (( long ( n ), long ( e ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) return enc except : p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) f = open ( 'pubkey.pem' , 'w' ) f . write ( pubkey . exportKey ()) g = open ( 'flag.enc' , 'w' ) g . write ( ext_rsa_encrypt ( p , q , e , flag )) \u903b\u8f91\u5f88\u7b80\u5355\uff0c\u8bfb\u53d6 flag\uff0c\u91cd\u590d 30 \u904d\u4e3a\u5bc6\u6587\u3002\u968f\u673a\u53d6 p p \u548c q q \uff0c\u751f\u6210\u4e00\u4e2a\u516c\u94a5\uff0c\u5199\u5165 pubkey.pem \uff0c\u518d\u7528\u811a\u672c\u4e2d\u7684 ext_rsa_encrypt \u51fd\u6570\u8fdb\u884c\u52a0\u5bc6\uff0c\u6700\u540e\u5c06\u5bc6\u6587\u5199\u5165 flag.enc \u3002 \u5c1d\u8bd5\u4e00\u4e0b\u89e3\u5bc6\uff0c\u63d0\u793a\u5bc6\u6587\u8fc7\u957f\uff0c\u518d\u770b\u52a0\u5bc6\u51fd\u6570\uff0c\u539f\u6765\u5f53\u52a0\u5bc6\u5931\u8d25\u65f6\uff0c\u51fd\u6570\u4f1a\u8df3\u5230\u5f02\u5e38\u5904\u7406\uff0c\u4ee5\u4e00\u5b9a\u7b97\u6cd5\u91cd\u65b0\u53d6\u66f4\u5927\u7684 p p \u548c q q \uff0c\u76f4\u5230\u52a0\u5bc6\u6210\u529f\u3002 \u90a3\u4e48\u6211\u4eec\u53ea\u8981\u4e5f\u5199\u4e00\u4e2a\u76f8\u5e94\u7684\u89e3\u5bc6\u51fd\u6570\u5373\u53ef\u3002 #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 def ext_rsa_decrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( privatekey ) de_error = '' enc = key . decrypt ( msg . decode ( 'base64' ), de_error ) return enc except Exception as error : print error p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 n = p * q e = 12405943493775545863 # pubkey = RSA.construct((long(n), long(e))) # f = open('pubkey.pem', 'w') # f.write(pubkey.exportKey()) g = open ( 'flag.enc' , 'r' ) msg = g . read () flag = ext_rsa_decrypt ( p , q , e , msg ) print flag \u62ff\u5230 flag ASIS{F4ct0R__N_by_it3rat!ng!}","title":"2016 ASIS Find the flag"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#sctf-rsa1","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 SCTF RSA1 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9996\u5148\u89e3\u538b\u538b\u7f29\u5305\u540e\uff0c\u5f97\u5230\u5982\u4e0b\u6587\u4ef6 \u279c level0 git: ( master ) \u2717 ls -al \u603b\u7528\u91cf 4 drwxrwxrwx 1 root root 0 7\u6708 30 16 :36 . drwxrwxrwx 1 root root 0 7\u6708 30 16 :34 .. -rwxrwxrwx 1 root root 349 5\u6708 2 2016 level1.passwd.enc -rwxrwxrwx 1 root root 2337 5\u6708 6 2016 level1.zip -rwxrwxrwx 1 root root 451 5\u6708 2 2016 public.key \u5c1d\u8bd5\u89e3\u538b\u7f29\u4e86\u4e00\u4e0b level1.zip \u73b0\u9700\u8981\u5bc6\u7801\u3002\u7136\u540e\u6839\u636e level1.passwd.enc \u53ef\u77e5\uff0c\u5e94\u8be5\u662f\u6211\u4eec\u9700\u8981\u89e3\u5bc6\u8fd9\u4e2a\u6587\u4ef6\u624d\u80fd\u5f97\u5230\u5bf9\u5e94\u7684\u5bc6\u7801\u3002\u67e5\u770b\u516c\u94a5 \u279c level0 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 :94:a0:3e:6e:0e:dc:f2:74:10:52:ef:1e:ea:a8: 89 :d6:f9:8d:01:11:51:db:5e:90:92:48:fd:39:0c: 70 :87:24:d8:98:3c:f3:33:1c:ba:c5:61:c2:ce:2c: 5a:f1:5e:65:b2:b2:46:91:56:b6:19:d5:d3:b2:a6: bb:a3:7d:56:93:99:4d:7e:4c:2f:aa:60:7b:3e:c8: fc:90:b2:00:62:4b:53:18:5b:a2:30:10:60:a8:21: ab:61:57:d7:e7:cc:67:1b:4d:cd:66:4c:7d:f1:1a: 2a:1d:5e:50:80:c1:5e:45:12:3a:ba:4a:53:64:d8: 72 :1f:84:4a:ae:5c:55:02:e8:8e:56:4d:38:70:a5: 16 :36:d3:bc:14:3e:2f:ae:2f:31:58:ba:00:ab:ac: c0:c5:ba:44:3c:29:70:56:01:6b:57:f5:d7:52:d7: 31 :56:0b:ab:0a:e6:8d:ad:08:22:a9:1f:cb:6e:49: cc:01:4c:12:d2:ab:a3:a5:97:e5:10:49:19:7f:69: d9:3b:c5:53:53:71:00:18:60:cc:69:1a:06:64:3b: 86 :94:70:a9:da:82:fc:54:6b:06:23:43:2d:b0:20: eb:b6:1b:91:35:5e:53:a6:e5:d8:9a:84:bb:30:46: b8:9f:63:bc:70:06:2d:59:d8:62:a5:fd:5c:ab:06: 68 :81 Exponent: 65537 ( 0x10001 ) Modulus = 94A03E6E0EDCF2741052EF1EEAA889D6F98D011151DB5E909248FD390C708724D8983CF3331CBAC561C2CE2C5AF15E65B2B2469156B619D5D3B2A6BBA37D5693994D7E4C2FAA607B3EC8FC90B200624B53185BA2301060A821AB6157D7E7CC671B4DCD664C7DF11A2A1D5E5080C15E45123ABA4A5364D8721F844AAE5C5502E88E564D3870A51636D3BC143E2FAE2F3158BA00ABACC0C5BA443C297056016B57F5D752D731560BAB0AE68DAD0822A91FCB6E49CC014C12D2ABA3A597E51049197F69D93BC5535371001860CC691A06643B869470A9DA82FC546B0623432DB020EBB61B91355E53A6E5D89A84BB3046B89F63BC70062D59D862A5FD5CAB066881 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAlKA+bg7c8nQQUu8e6qiJ 1vmNARFR216Qkkj9OQxwhyTYmDzzMxy6xWHCzixa8V5lsrJGkVa2GdXTsqa7o31W k5lNfkwvqmB7Psj8kLIAYktTGFuiMBBgqCGrYVfX58xnG03NZkx98RoqHV5QgMFe RRI6ukpTZNhyH4RKrlxVAuiOVk04cKUWNtO8FD4vri8xWLoAq6zAxbpEPClwVgFr V/XXUtcxVgurCuaNrQgiqR/LbknMAUwS0qujpZflEEkZf2nZO8VTU3EAGGDMaRoG ZDuGlHCp2oL8VGsGI0MtsCDrthuRNV5TpuXYmoS7MEa4n2O8cAYtWdhipf1cqwZo gQIDAQAB -----END PUBLIC KEY----- \u53d1\u73b0\u867d\u7136\u8bf4\u662f 2048 \u4f4d\uff0c\u4f46\u662f\u663e\u7136\u6a21\u6570\u6ca1\u6709\u90a3\u4e48\u957f\uff0c\u5c1d\u8bd5\u5206\u89e3\u4e0b\uff0c\u5f97\u5230 p=250527704258269 q=74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 \u7136\u540e\u5c31\u53ef\u4ee5\u6784\u9020\uff0c\u5e76\u4e14\u89e3\u5bc6\uff0c\u4ee3\u7801\u5982\u4e0b from Crypto.PublicKey import RSA import gmpy2 from base64 import b64decode p = 250527704258269 q = 74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 e = 65537 n = p * q def getprivatekey ( n , e , p , q ): phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level1.passwd.enc' ) as f : cipher = f . read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) #getprivatekey(n, e, p, q) decrypt () \u53d1\u73b0\u4e0d\u5bf9 \u279c level0 git: ( master ) \u2717 python exp.py \u4e00\u5806\u4e71\u7801\u3002\u3002 \u8fd9\u65f6\u5019\u5c31\u8981\u8003\u8651\u5176\u4ed6\u60c5\u51b5\u4e86\uff0c\u4e00\u822c\u6765\u8bf4\u73b0\u5b9e\u4e2d\u5b9e\u73b0\u7684 RSA \u90fd\u4e0d\u4f1a\u76f4\u63a5\u7528\u539f\u751f\u7684 RSA\uff0c\u90fd\u4f1a\u52a0\u4e00\u4e9b\u586b\u5145\u6bd4\u5982 OAEP\uff0c\u6211\u4eec\u8fd9\u91cc\u8bd5\u8bd5\uff0c\u4fee\u6539\u4ee3\u7801 def decrypt1 () : with open ( './level1.passwd.enc' ) as f: cipher = f.read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f: key = RSA.importKey ( f ) key = PKCS1_OAEP.new ( key ) print key.decrypt ( cipher ) \u679c\u7136\u5982\u6b64\uff0c\u5f97\u5230 \u279c level0 git: ( master ) \u2717 python exp.py FaC5ori1ati0n_aTTA3k_p_tOO_sma11 \u5f97\u5230\u89e3\u538b\u5bc6\u7801\u3002\u7ee7\u7eed\uff0c\u67e5\u770b level1 \u4e2d\u7684\u516c\u94a5 \u279c level1 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 :c3:26:59:69:e1:ed:74:d2:e0:b4:9a:d5:6a:7c: 2f:2a:9e:c3:71:ff:13:4b:10:37:c0:6f:56:19:34: c5:cb:1f:6d:c0:e3:57:3b:47:c4:76:3e:21:a3:b0: 11 :11:78:d4:ee:4f:e8:99:2b:15:cb:cb:d7:73:e4: f9:a6:28:20:fd:db:8c:ea:16:ed:67:c2:48:12:6e: 4b:01:53:4a:67:cb:22:23:3b:34:2e:af:13:ef:93: 45 :16:2b:00:9f:e0:4b:d1:90:c9:2c:27:9a:34:c3: 3f:d7:ee:40:f5:82:50:39:aa:8c:e9:c2:7b:f4:36: e3:38:9d:04:50:db:a9:b7:3f:4b:2a:d6:8a:2a:5c: 87 :2a:eb:74:35:98:6a:9c:e4:52:cb:93:78:d2:da: 39 :83:f3:0c:d1:65:1e:66:9c:40:56:06:0d:58:fc: 41 :64:5e:06:da:83:d0:3b:06:42:70:da:38:53:e0: 54 :35:53:ce:de:79:4a:bf:f5:3b:e5:53:7f:6c:18: 12 :67:a9:de:37:7d:44:65:5e:68:0a:78:39:3d:bb: 00 :22:35:0e:a3:94:e6:94:15:1a:3d:39:c7:50:0e: b1:64:a5:29:a3:69:41:40:69:94:b0:0d:1a:ea:9a: 12 :27:50:ee:1e:3a:19:b7:29:70:b4:6d:1e:9d:61: 3e:7d Exponent: 65537 ( 0x10001 ) Modulus = C3265969E1ED74D2E0B49AD56A7C2F2A9EC371FF134B1037C06F561934C5CB1F6DC0E3573B47C4763E21A3B0111178D4EE4FE8992B15CBCBD773E4F9A62820FDDB8CEA16ED67C248126E4B01534A67CB22233B342EAF13EF9345162B009FE04BD190C92C279A34C33FD7EE40F5825039AA8CE9C27BF436E3389D0450DBA9B73F4B2AD68A2A5C872AEB7435986A9CE452CB9378D2DA3983F30CD1651E669C4056060D58FC41645E06DA83D03B064270DA3853E0543553CEDE794ABFF53BE5537F6C181267A9DE377D44655E680A78393DBB0022350EA394E694151A3D39C7500EB164A529A36941406994B00D1AEA9A122750EE1E3A19B72970B46D1E9D613E7D writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwyZZaeHtdNLgtJrVanwv Kp7Dcf8TSxA3wG9WGTTFyx9twONXO0fEdj4ho7AREXjU7k/omSsVy8vXc+T5pigg /duM6hbtZ8JIEm5LAVNKZ8siIzs0Lq8T75NFFisAn+BL0ZDJLCeaNMM/1+5A9YJQ OaqM6cJ79DbjOJ0EUNuptz9LKtaKKlyHKut0NZhqnORSy5N40to5g/MM0WUeZpxA VgYNWPxBZF4G2oPQOwZCcNo4U+BUNVPO3nlKv/U75VN/bBgSZ6neN31EZV5oCng5 PbsAIjUOo5TmlBUaPTnHUA6xZKUpo2lBQGmUsA0a6poSJ1DuHjoZtylwtG0enWE+ fQIDAQAB -----END PUBLIC KEY----- \u4f3c\u4e4e\u8fd8\u662f\u4e0d\u662f\u5f88\u5927\uff0c\u518d\u6b21\u5206\u89e3\uff0c\u7136\u540e\u8bd5\u4e86 factordb \u4e0d\u884c\uff0c\u8bd5\u8bd5 yafu\u3002\u7ed3\u679c\u5206\u89e3\u51fa\u6765\u4e86\u3002 P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496383 P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496259 \u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e24\u4e2a\u6570\u975e\u5e38\u76f8\u8fd1\uff0c\u53ef\u80fd\u662f factordb \u6ca1\u6709\u5b9e\u73b0\u8fd9\u7c7b\u5206\u89e3\u3002 \u7ee7\u800c\u4e0b\u9762\u7684\u64cd\u4f5c\u7c7b\u4f3c\u4e8e level0\u3002\u53ea\u662f\u8fd9\u6b21\u662f\u76f4\u63a5\u89e3\u5bc6\u5c31\u597d\uff0c\u6ca1\u5565\u586b\u5145\uff0c\u8bd5\u4e86\u586b\u5145\u53cd\u800c\u9519 \u5f97\u5230\u5bc6\u7801 fA35ORI11TLoN_Att1Ck_cL0sE_PrI8e_4acTorS \u3002\u7ee7\u7eed\u4e0b\u4e00\u6b65\uff0c\u67e5\u770b\u516c\u94a5 \u279c level2 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 1025 bit ) Modulus: 01 :ba:0c:c2:45:b4:5c:e5:b5:f5:6c:d5:ca:a5:90: c2:8d:12:3d:8a:6d:7f:b6:47:37:fb:7c:1f:5a:85: 8c:1e:35:13:8b:57:b2:21:4f:f4:b2:42:24:5f:33: f7:2c:2c:0d:21:c2:4a:d4:c5:f5:09:94:c2:39:9d: 73 :e5:04:a2:66:1d:9c:4b:99:d5:38:44:ab:13:d9: cd:12:a4:d0:16:79:f0:ac:75:f9:a4:ea:a8:7c:32: 16 :9a:17:d7:7d:80:fd:60:29:64:c7:ea:50:30:63: 76 :59:c7:36:5e:98:d2:ea:5b:b3:3a:47:17:08:2d: d5:24:7d:4f:a7:a1:f0:d5:73 Exponent: 01 :00:8e:81:dd:a0:e3:19:28:e8:ee:51:11:08:c7: 50 :5f:61:31:05:d2:e2:ff:9b:83:71:e4:29:c2:dd: 92 :70:65:d4:09:6d:58:c3:76:31:07:f1:d4:fc:cf: 2d:b3:0a:6d:02:7c:56:61:7c:be:7e:0b:7e:d9:22: 28 :66:9e:fb:3d:2f:2c:20:59:3c:21:ef:ff:31:00: 6a:fb:a7:68:de:4a:0a:4c:1a:a7:09:d5:48:98:c8: 1f:cf:fb:dd:f7:9c:ae:ae:0b:15:f4:b2:c7:e0:bc: ba:31:4f:5e:07:83:ad:0e:7f:b9:82:a4:d2:01:fa: 68 :29:6d:66:7c:cf:57:b9:4b Modulus = 1BA0CC245B45CE5B5F56CD5CAA590C28D123D8A6D7FB64737FB7C1F5A858C1E35138B57B2214FF4B242245F33F72C2C0D21C24AD4C5F50994C2399D73E504A2661D9C4B99D53844AB13D9CD12A4D01679F0AC75F9A4EAA87C32169A17D77D80FD602964C7EA5030637659C7365E98D2EA5BB33A4717082DD5247D4FA7A1F0D573 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQG6DMJFtFzltfVs1cqlkMKN Ej2KbX+2Rzf7fB9ahYweNROLV7IhT/SyQiRfM/csLA0hwkrUxfUJlMI5nXPlBKJm HZxLmdU4RKsT2c0SpNAWefCsdfmk6qh8MhaaF9d9gP1gKWTH6lAwY3ZZxzZemNLq W7M6RxcILdUkfU+nofDVcwKBgQEAjoHdoOMZKOjuUREIx1BfYTEF0uL/m4Nx5CnC 3ZJwZdQJbVjDdjEH8dT8zy2zCm0CfFZhfL5+C37ZIihmnvs9LywgWTwh7/8xAGr7 p2jeSgpMGqcJ1UiYyB/P+933nK6uCxX0ssfgvLoxT14Hg60Of7mCpNIB+mgpbWZ8 z1e5Sw == -----END PUBLIC KEY----- \u53d1\u73b0\u79c1\u94a5 e \u548c n \u51e0\u4e4e\u4e00\u6837\u5927\uff0c\u8003\u8651 d \u6bd4\u8f83\u5c0f\uff0c\u4f7f\u7528 Wiener's Attack\u3002\u5f97\u5230 d\uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u518d\u6b21\u9a8c\u8bc1\u4e00\u904d\u3002 \u279c level2 git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- \u8fd9\u65f6\u6211\u4eec\u89e3\u5bc6\u5bc6\u6587\uff0c\u89e3\u5bc6\u4ee3\u7801\u5982\u4e0b from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode d = 29897859398360008828023114464512538800655735360280670512160838259524245332403 L with open ( './public.key' ) as f : key = RSA . importKey ( f ) n = key . n e = key . e def getprivatekey ( n , e , d ): priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level3.passwd.enc' ) as f : cipher = f . read () with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) getprivatekey ( n , e , d ) decrypt () \u5229\u7528\u672b\u5c3e\u7684\u5b57\u7b26\u4e32 wIe6ER1s_1TtA3k_e_t00_larg3 \u89e3\u5bc6\u538b\u7f29\u5305\uff0c\u6ce8\u610f\u53bb\u6389 B\u3002\u81f3\u6b64\u5168\u90e8\u89e3\u5bc6\u7ed3\u675f\uff0c\u5f97\u5230 flag\u3002","title":"SCTF RSA1"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#2018-wctf-rsa","text":"\u9898\u76ee\u57fa\u672c\u63cf\u8ff0\u4e3a Description: Encrypted message for user \"admin\": <<<320881698662242726122152659576060496538921409976895582875089953705144841691963343665651276480485795667557825130432466455684921314043200553005547236066163215094843668681362420498455007509549517213285453773102481574390864574950259479765662844102553652977000035769295606566722752949297781646289262341623549414376262470908749643200171565760656987980763971637167709961003784180963669498213369651680678149962512216448400681654410536708661206594836597126012192813519797526082082969616915806299114666037943718435644796668877715954887614703727461595073689441920573791980162741306838415524808171520369350830683150672985523901>>> admin public key: n = 483901264006946269405283937218262944021205510033824140430120406965422208942781742610300462772237450489835092525764447026827915305166372385721345243437217652055280011968958645513779764522873874876168998429546523181404652757474147967518856439439314619402447703345139460317764743055227009595477949315591334102623664616616842043021518775210997349987012692811620258928276654394316710846752732008480088149395145019159397592415637014390713798032125010969597335893399022114906679996982147566245244212524824346645297637425927685406944205604775116409108280942928854694743108774892001745535921521172975113294131711065606768927 e = 65537 Service: http://36.110.234.253 \u8fd9\u4e2a\u9898\u76ee\u73b0\u5728\u5df2\u7ecf\u6ca1\u6709\u529e\u6cd5\u5728\u7ebf\u83b7\u53d6 binary \u4e86\uff0c\u73b0\u5728\u5f97\u5230\u7684 binary \u662f\u4e4b\u524d\u5df2\u7ecf\u4e0b\u8f7d\u597d\u7684\uff0c\u6211\u4eec\u5f53\u65f6\u9700\u8981\u767b\u5f55\u7528\u6237\u7684 admin \u6765\u4e0b\u8f7d\u5bf9\u5e94\u7684 generator\u3002 \u901a\u8fc7\u7b80\u5355\u9006\u5411\u8fd9\u4e2a generator\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e2a\u7a0b\u5e8f\u662f\u8fd9\u4e48\u5de5\u4f5c\u7684 \u5229\u7528\u7528\u6237\u7ed9\u5b9a\u7684 license\uff0832 \u4e2a\u5b57\u8282\uff09\uff0c\u8fed\u4ee3\u89e3\u5bc6\u67d0\u4e2a \u56fa\u5b9a\u4f4d\u7f6e \u4e4b\u540e\u7684\u6570\u636e\uff0c\u6bcf 32 \u4e2a\u5b57\u8282\u4e00\u7ec4\uff0c\u4e0e\u5bc6\u94a5\u76f8\u5f02\u6216\u5f97\u5230\u7ed3\u679c\u3002 \u5bc6\u94a5\u7684\u751f\u6210\u65b9\u6cd5\u4e3a k_1=key k_1=key k_2 =sha256(k_1) k_2 =sha256(k_1) ... k_n=sha256(k_{n-1}) k_n=sha256(k_{n-1}) \u5176\u4e2d\uff0c\u56fa\u5b9a\u4f4d\u7f6e\u5c31\u662f\u5728\u627e\u6e90\u6587\u4ef6 generator \u4e2d\u7b2c\u4e8c\u6b21\u51fa\u73b0 ENCRYPTED \u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u518d\u6b21\u504f\u79fb 32 \u4e2a\u5b57\u8282\u3002 _ENCRYPT_STR = ENCRYPTED_STR ; v10 = 0 ; ENCRYPTED_LEN = strlen ( ENCRYPTED_STR ); do { do ++ v9 ; while ( strncmp ( & file_contents [ v9 ], _ENCRYPT_STR , ENCRYPTED_LEN ) ); ++ v10 ; } while ( v10 <= 1 ); v11 = & file_start_off_32 [ loc2 + ENCRYPTED_LEN ]; v12 = loc2 + ENCRYPTED_LEN ; len = file_size - ( loc2 + ENCRYPTED_LEN ) - 32 ; decrypt ( & file_start_off_32 [ v12 ], & license , len ); sha256_file_start ( v11 , len , & output ); if ( ! memcmp ( & output , & file_contents [ v12 ], 0x20 u ) ) { v14 = fopen ( \"out.exe\" , \"wb\" ); fwrite ( v11 , 1 u , len , v14 ); fclose ( v14 ); sprintf ( byte_406020 , \"out.exe %s \" , argv [ 1 ]); system ( byte_406020 ); } \u540c\u65f6\uff0c\u6211\u4eec\u9700\u8981\u786e\u4fdd\u751f\u6210\u7684\u6587\u4ef6\u7684\u6821\u9a8c\u5bf9\u5e94\u7684\u54c8\u5e0c\u503c\u6070\u597d\u4e3a\u6307\u5b9a\u7684\u503c\uff0c\u7531\u4e8e\u6587\u4ef6\u6700\u540e\u662f\u4e00\u4e2a exe \u6587\u4ef6\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u6700\u540e\u7684\u6587\u4ef6\u5934\u5c31\u662f\u6807\u51c6\u7684 exe \u6587\u4ef6\uff0c\u56e0\u6b64\u5c31\u4e0d\u9700\u8981\u77e5\u9053\u539f\u59cb\u7684 license \u6587\u4ef6\uff0c\u8fdb\u800c\u6211\u4eec\u53ef\u4ee5\u7f16\u5199 python \u811a\u672c\u751f\u6210 exe\u3002 \u5728\u751f\u6210\u7684 exe \u4e2d\uff0c\u6211\u4eec\u5206\u6790\u51fa\u7a0b\u5e8f\u7684\u57fa\u672c\u6d41\u7a0b\u4e3a \u8bfb\u53d6 license \u4f7f\u7528 license \u4f5c\u4e3a seed \u5206\u522b\u751f\u6210 pq \u5229\u7528 p\uff0cq \u751f\u6210 n\uff0ce\uff0cd\u3002 \u5176\u6f0f\u6d1e\u51fa\u73b0\u5728\u751f\u6210 p\uff0cq \u7684\u65b9\u6cd5\u4e0a\uff0c\u800c\u4e14\u751f\u6210 p \u548c q \u7684\u65b9\u6cd5\u7c7b\u4f3c\u3002 \u6211\u4eec\u5982\u679c\u4ed4\u7ec6\u5206\u6790\u4e0b\u751f\u6210\u7d20\u6570\u7684\u51fd\u6570\u7684\u8bdd\uff0c\u53ef\u4ee5\u770b\u5230\u6bcf\u4e2a\u7d20\u6570\u90fd\u662f\u5206\u4e3a\u4e24\u90e8\u5206\u751f\u6210\u7684 \u751f\u6210\u5de6\u534a\u90e8\u5206 512 \u4f4d\u3002 \u751f\u6210\u53f3\u534a\u90e8\u5206 512 \u4f4d\u3002 \u5de6\u53f3\u6784\u6210 1024 \u6bd4\u7279\u4f4d\uff0c\u5224\u65ad\u662f\u4e0d\u662f\u7d20\u6570\uff0c\u662f\u7d20\u6570\u5c31\u6210\u529f\uff0c\u4e0d\u662f\u7d20\u6570\uff0c\u7ee7\u7eed\u751f\u6210\u3002 \u5176\u4e2d\u751f\u6210\u6bcf\u90e8\u5206\u7684\u65b9\u5f0f\u76f8\u540c\uff0c\u65b9\u5f0f\u4e3a sha512 ( const1 | const2 | const3 | const4 | const5 | const6 | const7 | const8 | v9 ) v9 = r % 1000000007 \u53ea\u6709 v9 \u4f1a\u6709\u6240\u53d8\u5316\uff0c\u4f46\u662f\u5b83\u7684\u8303\u56f4\u5374\u662f\u56fa\u5b9a\u7684\u3002 \u90a3\u4e48\uff0c\u5982\u679c\u6211\u4eec\u8868\u793a p\uff0cq \u4e3a p=a*2^{512}+b p=a*2^{512}+b q=c*2^{512}+d q=c*2^{512}+d \u90a3\u4e48 n=pq=ac*2^{1024}+(ad+bc)*2^{512}+bd n=pq=ac*2^{1024}+(ad+bc)*2^{512}+bd \u90a3\u4e48 n \\equiv bd \\bmod 2^{512} n \\equiv bd \\bmod 2^{512} \u800c\u4e14\u7531\u4e8e p \u548c q \u5728\u751f\u6210\u65f6\uff0ca\uff0cb\uff0cc\uff0cd \u5747\u53ea\u6709 1000000007 \u79cd\u53ef\u80fd\u6027\u3002 \u8fdb\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u7684\u53ef\u80fd\u6027\uff0c\u9996\u5148\u8ba1\u7b97\u51fa b \u53ef\u80fd\u7684\u96c6\u5408\u4e3a S\uff0c\u540c\u65f6\u6211\u4eec\u4f7f\u7528\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\uff0c\u8ba1\u7b97 n/d \\equiv b \\bmod 2^{512} n/d \\equiv b \\bmod 2^{512} \u8fd9\u91cc\u7531\u4e8e b \u548c d \u90fd\u662f p \u7684\u5c3e\u6570\uff0c\u6240\u4ee5\u4e00\u5b9a\u4e0d\u4f1a\u662f 2 \u7684\u500d\u6570\uff0c\u8fdb\u800c\u5fc5\u7136\u5b58\u5728\u9006\u5143\u3002 \u8fd9\u6837\u505a\u867d\u7136\u53ef\u4ee5\uff0c\u7136\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u7b97\u4e00\u4e0b\u5b58\u50a8\u7a7a\u95f4 64*1000000007 / 1024 / 1024 / 1024=59 64*1000000007 / 1024 / 1024 / 1024=59 \u4e5f\u5c31\u662f\u8bf4\u9700\u8981 59 G\uff0c\u592a\u5927\u4e86\uff0c\uff0c\u6240\u4ee5\u6211\u4eec\u4ecd\u7136\u9700\u8981\u8fdb\u4e00\u6b65\u8003\u8651 n \\equiv bd \\bmod 2^{64} n \\equiv bd \\bmod 2^{64} \u8fd9\u6837\uff0c\u6211\u4eec\u7684\u5185\u5b58\u9700\u6c42\u77ac\u95f4\u5c31\u964d\u5230\u4e86 8 G\u5de6\u53f3\u3002\u6211\u4eec\u4ecd\u7136\u4f7f\u7528\u679a\u4e3e\u7684\u65b9\u6cd5\u8fdb\u884c\u8fd0\u7b97\u3002 \u5176\u6b21\uff0c\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528 python\uff0c\uff0cpython \u5360\u636e\u7a7a\u95f4\u592a\u5927\uff0c\u56e0\u6b64\u9700\u8981\u4f7f\u7528 c/c++ \u7f16\u5199\u3002 \u679a\u4e3e\u6240\u6709\u53ef\u80fd\u7684 d \u8ba1\u7b97\u5bf9\u5e94\u7684\u503c n/d n/d \u5982\u679c\u5bf9\u5e94\u7684\u503c\u5728\u96c6\u5408 S \u4e2d\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u8ba4\u4e3a\u627e\u5230\u4e86\u4e00\u5bf9\u5408\u6cd5\u7684 b \u548c d\uff0c\u56e0\u6b64\u6211\u4eec\u5c31\u53ef\u4ee5\u6062\u590d p \u548c q \u7684\u4e00\u534a\u3002 \u4e4b\u540e\uff0c\u6211\u4eec\u6839\u636e n-bd=ac*2^{1024}+(ad+bc)*2^{512} n-bd=ac*2^{1024}+(ad+bc)*2^{512} \u53ef\u4ee5\u5f97\u5230 \\frac{n-bd}{2^{512}} = ac*2^{512}+ad+bc \\frac{n-bd}{2^{512}} = ac*2^{512}+ad+bc \\frac{n-bd}{2^{512}} \\equiv ad+bc \\bmod 2^{512} \\frac{n-bd}{2^{512}} \\equiv ad+bc \\bmod 2^{512} \u7c7b\u4f3c\u5730\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba1\u7b97\u51fa a \u548c c\uff0c\u4ece\u800c\u6211\u4eec\u5c31\u53ef\u4ee5\u5b8c\u5168\u6062\u590d\u51fa p \u548c q\u3002 \u5728\u5177\u4f53\u6c42\u89e3\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5728\u6c42 p \u548c q \u7684\u4e00\u90e8\u5206\u65f6\uff0c\u53ef\u4ee5\u53d1\u73b0\u56e0\u4e3a\u662f\u6a21 2^{64} 2^{64} \uff0c\u6240\u4ee5\u53ef\u80fd\u5b58\u5728\u78b0\u649e\uff08\u4f46\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u662f p\uff0c\u53e6\u5916\u4e00\u4e2a\u662fq\uff0c\u6070\u597d\u5bf9\u79f0\u3002\uff09\u3002\u4e0b\u9762\u6211\u4eec\u5c31\u6c42\u5f97\u4e86 b \u5bf9\u5e94\u7684 v9\u3002 \u6ce8\u610f\uff1a\u8fd9\u91cc\u679a\u4e3e\u51fa\u6765\u7684\u7a7a\u95f4\u5927\u7ea6\u5360\u7528 11 \u4e2a G\uff08\u5305\u62ec\u7d22\u5f15\uff09\uff0c\u6240\u4ee5\u8bf7\u9009\u62e9\u5408\u9002\u7684\u4f4d\u7f6e\u3002 b64: 9646799660ae61bd idx_b: 683101175 idx_d: 380087137 search 23000000 search 32000000 search 2b000000 search d000000 search 3a000000 search 1c000000 search 6000000 search 24000000 search 15000000 search 33000000 search 2c000000 search e000000 b64: 9c63259ccab14e0b idx_b: 380087137 idx_d: 683101175 search 1d000000 search 3b000000 search 7000000 search 16000000 search 25000000 search 34000000 \u5176\u5b9e\uff0c\u6211\u4eec\u5728\u771f\u6b63\u5f97\u5230 p \u6216\u8005 q \u7684\u4e00\u90e8\u5206\u540e\uff0c\u53e6\u5916\u4e00\u90e8\u5206\u5b8c\u5168\u53ef\u4ee5\u4f7f\u7528\u66b4\u529b\u679a\u4e3e\u7684\u65b9\u5f0f\u83b7\u53d6\uff0c\u56e0\u4e3a\u8ba1\u7b97\u91cf\u51e0\u4e4e\u90fd\u662f\u4e00\u6837\u7684\uff0c\u6700\u540e\u7ed3\u679c\u4e3a ... hash 7000000 hash 30000000 p = 13941980378318401138358022650359689981503197475898780162570451627011086685747898792021456273309867273596062609692135266568225130792940286468658349600244497842007796641075219414527752166184775338649475717002974228067471300475039847366710107240340943353277059789603253261584927112814333110145596444757506023869 q = 34708215825599344705664824520726905882404144201254119866196373178307364907059866991771344831208091628520160602680905288551154065449544826571548266737597974653701384486239432802606526550681745553825993460110874794829496264513592474794632852329487009767217491691507153684439085094523697171206345793871065206283 plain text 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 hash 16000000 hash 25000000 hash b000000 hash 34000000 hash 1 a000000 ... \u279c 2018 - WCTF - rsa git :( master ) \u2717 python Python 2.7 . 14 ( default , Mar 22 2018 , 14 : 43 : 05 ) [ GCC 4.2 . 1 Compatible Apple LLVM 9.0 . 0 ( clang - 900.0 . 39.2 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> p = 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 >>> hex ( p )[ 2 :] . decode ( 'hex' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/local/Cellar/python@2/2.7.14_3/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/hex_codec.py\" , line 42 , in hex_decode output = binascii . a2b_hex ( input ) TypeError : Odd - length string >>> hex ( p )[ 2 : - 1 ] . decode ( 'hex' ) 'flag {fa6778724ed740396fc001b198f30313} ' \u6700\u540e\u6211\u4eec\u4fbf\u62ff\u5230 flag \u4e86\u3002 \u8be6\u7ec6\u7684\u5229\u7528\u4ee3\u7801\u8bf7\u53c2\u89c1 ctf-challenge \u4ed3\u5e93\u3002 \u76f8\u5173\u7f16\u8bd1\u6307\u4ee4\uff0c\u9700\u8981\u94fe\u63a5\u76f8\u5173\u7684\u5e93\u3002 g++ exp2.cpp -std = c++11 -o main2 -lgmp -lcrypto -pthread","title":"2018 WCTF RSA"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex-zh/#_1","text":"https://upbhack.de/posts/wctf-2018-writeup-rsa/","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/","text":"EN | ZH RSA Complex topic \u00b6 2018 Tokyo Western Mixed Cipher \u00b6 The information given by the title is as follows: The length of time each interaction can last is approximately 5 minutes n is a certain 1024 bit in each interaction, but unknown, e is 65537 Encrypted flag with aes, neither key nor IV Each time the key is fixed, but the IV will be random each time You can use rsa and aes for encryption with the encrypt function, where each encryption will randomly random es of aes You can use decrypt to decrypt random ciphertext, but only know what the last byte is. You can use the print_flag to get the flag ciphertext sa encrypted aes key can be obtained using print_key This topic looks like a topic, but in fact it is 3 topics, which need to be solved step by step. Before that, we are ready to interact with the function def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 4 & quot ;) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline () [: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 1 & quot ;) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline () [: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 2 & quot ;) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) GCD attack n \u00b6 In the first step, we need to calculate the n that is not given, because we can use the encrypt function to rsa encrypt the plaintext x we input, then we can use the nature of the divisibility to calculate n. Because x ^ e = c mod n So n | x ^ e - c We can construct enough x to calculate the most x ^ e - c to calculate the greatest common divisor and get n. def get_n(io): rsa_c,aes_c=encrypt_io(io,long_to_bytes(2)) n=pow(2,65537)-rsa_c for i in range(3,6): rsa_c, aes_c = encrypt_io(io, long_to_bytes(i)) n=primefac.gcd(n,pow(i,65537)-rsa_c) return n Can use encryption to check def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , & quot ; 123 & quot ;) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False RSA parity oracle \u00b6 Using the last byte of leave, we can choose to ciphertext attack, use RSA parity oracle to reply to the key of aes def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : Print LB , UB tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 k + = 1 print ub , len ( long_to_bytes ( ub )) return ub PRNG Predict \u00b6 Here we can decrypt the contents of the 16 bytes of the flag, but the first 16 bytes without the IV can not be decrypted. At this point we can find that the random number used by IV generation uses getrandbits, and we can get enough random numbers, then we can make the PRNG prediction, and then get the random number directly. Here I use a ready-made java for Predict of PRNG. public class Main { static int [] state ; static int currentIndex ; 40 huo public static void main ( String [] args ) { state = new int [ 624 ] ; currentIndex = 0 ; // initialize(0); // for (int i = 0; i < 5; i++) { // System.out.println(state[i]); // } // for (int i = 0; i < 5; i++) { // System.out.println(nextNumber()); // } if ( args . length != 624 ) { System . err . println ( \"must be 624 args\" ); System . exit ( 1 ); } int [] arr = new int [ 624 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { arr [ i ] = Integer . parseInt ( args [ i ] ); } breaking ( scarring ); for ( int i = 0 ; i < 6240 huo4 ; i ++ ) { System . out . println ( state [ i ] ); } // System.out.println(\"currentIndex \" + currentIndex); // System.out.println(\"state[currentIndex] \" + state[currentIndex]); // System.out.println(\"next \" + nextNumber()); // want -2065863258 } static void nextState () { // Iterate through the state for ( int i = 0 ; i < 624 ; i ++ ) { // y is the first bit of the current number, // and the last 31 bits of the next number int y = ( state [ i ] & 0x80000000 ) + ( state [ ( i + 1 ) % 624 ] & 0x7fffffff ); // first bitshift y by 1 to the right int next = y >>> 1 ; // xor it with the 397th next number next ^= state [ ( i + 397 ) % 624 ] ; // if y is odd, xor with magic number if (( y & 1L ) == 1L ) { next ^= 0x9908b0df ; } // now we have the result state [ i ] = next ; } } static int nextNumber () { currentIndex ++ ; int tmp = state [ currentIndex ] ; tmp ^= ( tmp >>> 11 ); tmp ^= ( tmp << 7 ) & 0x9d2c5680 ; tmp ^= ( tmp << 15 ) & 0xefc60000 ; tmp ^= ( tmp >>> 18 ); return tmp ; } static void initialize ( int seed ) { // http://code.activestate.com/recipes/578056-mersenne-twister/ // global MT // global bitmask_1 // MT[0] = seed // for i in xrange(1,624): // MT[i] = ((1812433253 * MT[i-1]) ^ ((MT[i-1] >> 30) + i)) & bitmask_1 // copied Python 2.7's impl (probably uint problems) state [ 0 ] = seed ; for ( int i = 1 ; i < 624 ; i ++ ) { state [ i ] = (( 1812433253 * state [ i - 1 ] ) ^ (( state [ i - 1 ] >> 30 ) + i )) & 0xffffffff ; } } static int unBitshiftRightXor ( int value , int shift ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 << ( 32 - shift )) >>> ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= part >>> shift ; // add the part to the result result |= part ; i ++ ; } return result ; } static int unBitshiftLeftXor ( int value , int shift , int mask ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 >>> ( 32 - shift )) << ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= ( part << shift ) & mask ; // add the part to the result result |= part ; i ++ ; } return result ; } static void rev ( int [] nums ) { for ( int i = 0 ; i < 624 ; i ++ ) { int value = nums [ i ] ; value = unBitshiftRightXor ( value , 18 ); value = unBitshiftLeftXor ( value , 15 , 0xefc60000 ); value = unBitshiftLeftXor ( value , 7 , 0x9d2c5680 ); value = unBitshiftRightXor ( value , 11 ); state [ i ] = value ; } } } Wrote a python and call java directly from Crypto.Util.number import long_to_bytes,bytes_to_long def encrypt_io (io, p): io.read_until(\"4: get encrypted keyn\") io.writeline ( &quot;1&quot;) io.read_until(\"input plain text: \") io.writeline(p) io.read_until(\"RSA: \") rsa_c = int (io.readline () [: - 1], 16) io.read_until(\"AES: \") aes_c=io.readline()[:-1].decode(\"hex\") return rsa_c,aes_c import subprocess import random def get_iv(io): rsa_c, aes_c = encrypt_io (io, &quot;1&quot;) return bytes_to_long(aes_c[0:16]) def splitInto32(w128): w1 = w128 & (2**32-1) w2 = (w128 >> 32) & (2**32-1) w3 = (w128 &gt;&gt; 64) &amp; (2 ** 32-1) w4 = (w128 >> 96) return w1,w2,w3,w4 def sign(iv): # converts a 32 bit uint to a 32 bit signed int if(iv&0x80000000): iv = -0x100000000 + iv return iv def get_state(io): numbers=[] for i in range(156): print i numbers.append(get_iv(io)) observedNums = [sign(w) for n in numbers for w in splitInto32(n)] o = subprocess.check_output([\"java\", \"Main\"] + map(str, observedNums)) stateList = [int(s) % (2 ** 32) for s in o.split()] r = random.Random() state = (3, tuple(stateList + [624]), None) r.setstate(state) return r.getrandbits(128) EXP \u00b6 The overall attack code is as follows: from zio import * import import from Crypto.Util.number import long_to_bytes , bytes_to_long target = ( \"crypto.chal.ctf.westerns.tokyo\" , 5643 ) e = 65537 def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 4 & quot ;) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline () [: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 1 & quot ;) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline () [: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 2 & quot ;) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) def get_n ( io ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( 2 )) n = pow ( 2 , 65537 ) - rsa_c for i in range ( 3 , 6 ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( i )) n = primefac . gcd ( n , pow ( i , 65537 ) - rsa_c ) return n def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , & quot ; 123 & quot ;) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False import gmpy2 def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : Print LB , UB tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 k + = 1 print ub , len ( long_to_bytes ( ub )) return ub io = zio ( target , timeout = 10000 , print_read = COLORED ( NONE , 'red' ), print_write = COLORED ( NONE , 'green' )) n = get_n ( io ) print check_n ( io , n ) c = get_enc_key ( io ) print len ( decrypt_io ( io , c )) == 16 m = guess_m ( io , n , c ) for i in range ( m - 50000 , m + 50000 ): if pow ( i , e , n ) == c : aeskey = i print long_to_bytes ( aeskey )[ - 1 ] == decrypt_io ( io , c )[ - 1 ] print \"found aes key\" , hex ( aeskey ) import fuck_r next_iv = fuck_r . get_state ( io ) print \"##########################################\" print next_iv print aeskey io . interact () 2016 ASIS Find the flag \u00b6 Here we take the example of Find the flag in the ASIS 2016 online game. The file is extracted and has a ciphertext, a public key, and a py script. Take a look at the public key. \u279c RSA openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 : d8: e2: 4c: 12 : b7: b9: 9e: fe: 0a: 9b: c0: 4a: f5: 8a: 2a: 94 : 42 : 69 : b4: 92 : b7: 37 : 6d: f1: 29 : 20 : 61 : b9 Exponent: 12405943493775545863 ( 0xac2ac3e0ca0f5607 ) Modulus = D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9 Such a small N N , first break it down. p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 Look at the py script again. #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 flag = open ( 'flag' , 'r' ) . read () * 30 def ext_rsa_encrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) pubkey = RSA . construct (( long ( n ), long ( e ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) return enc except : p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) f = open ( 'pubkey.pem' , 'w' ) f . write ( pubkey . exportKey ()) g = open ( 'flag.enc' , 'w' ) g . write ( ext_rsa_encrypt ( p , q , e , flag )) The logic is very simple, read the flag and repeat 30 times for the ciphertext. Randomly take p p and q q , generate a public key, write pubkey.pem , encrypt it with the ext_rsa_encrypt function in the script, and finally write the ciphertext to flag.enc . Try decryption, suggest that the ciphertext is too long, and then look at the encryption function. When the encryption fails, the function will jump to the exception handling and re-take the larger p p and q q with a certain algorithm until the encryption succeeds. Then we just need to write a corresponding decryption function. #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 def ext_rsa_decrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( privatekey ) de_error = & #39;&#39; enc = key . decrypt ( msg . decode ( 'base64' ), de_error ) return enc except Exception as error : print error p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 n = p * q e = 12405943493775545863 # pubkey = RSA.construct((long(n), long(e))) # f = open('pubkey.pem', 'w') # f.write(pubkey.exportKey()) g = open ( 'flag.enc' , 'r' ) msg = g . read () flag = ext_rsa_decrypt ( p , q , e , msg ) print flag Get the flag ASIS {F4ct0R__N_by_it3rat! Ng!} SCTF RSA1 \u00b6 Here we take SCTF RSA1 as an example. After decompressing the compressed package, we get the following file. \u279c level0 git: ( master ) \u2717 ls -al Total dosage 4drwxrwxrwx 1 root root 0 7\u6708 30 16 :36 . drwxrwxrwx 1 root root 0 7\u6708 30 16 :34 .. -rwxrwxrwx 1 root root 349 5\u6708 2 2016 level1.passwd.enc -rwxrwxrwx 1 root root 2337 5\u6708 6 2016 level1.zip -rwxrwxrwx 1 root root 451 5\u6708 2 2016 public.key Try to unzip the level1.zip now requires a password. Then according to level1.passwd.enc, we should decrypt the file to get the corresponding password. View public key \u279c level0 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 :94:a0:3e:6e:0e:dc:f2:74:10:52:ef:1e:ea:a8: 89 :d6:f9:8d:01:11:51:db:5e:90:92:48:fd:39:0c: 70 : 87 : 24 : D8: 98 : 3C: F3: 33 : 1c: BA: 5 : 61 : c2: EC: 2c: 5a:f1:5e:65:b2:b2:46:91:56:b6:19:d5:d3:b2:a6: bb: a3: 7d: 56 : 93 : 99 : 4d: 7e: 4c: 2f: aa: 60 : 7b: 3e: c8: fc:90:b2:00:62:4b:53:18:5b:a2:30:10:60:a8:21: ab: 61 : 57 : d7: e7: cc: 67 : 1b: 4d: cd: 66 : 4c: 7d: f1: 1a: 2a:1d:5e:50:80:c1:5e:45:12:3a:ba:4a:53:64:d8: ( A5: 1 : 84 : 4a: a: 5c: 55 : 02 : e8: 8e: 56 : 4d: 38 : 70 : a5: 16 : 36 : d3: bc: 14 : 3e: 2f: ae: 2f: 31 : 58 : ba: 00 : ab: ac: c0:c5:ba:44:3c:29:70:56:01:6b:57:f5:d7:52:d7: 31 : 56 : 0b: ab: 0a: e6: 8d: ad: 08 : 22 : a9: 1f: cc: 01 : 4c: 12 : d2: ab: a3: a5: 97 : e5: 10 : 49 : 19 : 7f: d9:3b:c5:53:53:71:00:18:60:cc:69:1a:06:64:3b: 86 : 94 : 70 : a9: yes: 82 : fc: 54 : 6b: 06 : 23 : 43 : eb: b6: 1b: 91 : 35 : 5e: 53 : a6: e5: d8: 9a: 84 : b8: 9f: 63 : bc: 70 : 06 : 2d: 59 : d8: 62 : a5: fd: 5c: ab: 06 : 68 :81 Exponent: 65537 ( 0x10001 ) Modulus = 94A03E6E0EDCF2741052EF1EEAA889D6F98D011151DB5E909248FD390C708724D8983CF3331CBAC561C2CE2C5AF15E65B2B2469156B619D5D3B2A6BBA37D5693994D7E4C2FAA607B3EC8FC90B200624B53185BA2301060A821AB6157D7E7CC671B4DCD664C7DF11A2A1D5E5080C15E45123ABA4A5364D8721F844AAE5C5502E88E564D3870A51636D3BC143E2FAE2F3158BA00ABACC0C5BA443C297056016B57F5D752D731560BAB0AE68DAD0822A91FCB6E49CC014C12D2ABA3A597E51049197F69D93BC5535371001860CC691A06643B869470A9DA82FC546B0623432DB020EBB61B91355E53A6E5D89A84BB3046B89F63BC70062D59D862A5FD5CAB066881 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqkkiG9w0BAQEFAAOCAQ8AMIIBCgKCQQll + bg7c8nQQUu8e6qiJ 1vmNARFR216Qkkj9OQxwhyTYmDzzMxy6xWHCzixa8V5lsrJGkVa2GdXTsqa7o31W k5lNfkwvqmB7Psj8kLIAYktTGFuiMBBgqCGrYVfX58xnG03NZkx98RoqHV5QgMFe RRI6ukpTZNhyH4RKrlxVAuiOVk04cKUWNtO8FD4vri8xWLoAq6zAxbpEPClwVgFr V / XXUtcxVgurCuaNrQgiqR / LbknMAUwS0qujpZflEEkZf2nZO8VTU3EAGGDMaRoG ZDuGlHCp2oL8VGsGI0MtsCDrthuRNV5TpuXYmoS7MEa4n2O8cAYtWdhipf1cqwZo DOWNLOAD -----END PUBLIC KEY----- It is found that although it is 2048 bits, it is obvious that the modulus is not so long. Try to decompose and get p=250527704258269 q=74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 Then you can construct and decrypt, the code is as follows from Crypto.PublicKey import RSA import gmpy2 from base64 import b64decode p = 250527704258269 q = 74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 e = 65537 n = p * q def getprivatekey ( n , e , p , q ): Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level1.passwd.enc' ) as f : cipher = f . read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) #getprivatekey(n, e, p, q) decrypt () Found wrong \u279c level0 git: ( master ) \u2717 python exp.py A bunch of garbled. . At this time, we must consider other situations. Generally speaking, the RSA implemented in reality will not directly use the original RSA, and will add some padding such as OAEP. Let's try and modify the code here. def decrypt1 () : with open ( './level1.passwd.enc' ) as f: cipher = f.read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f: key = RSA.importKey ( f ) key = PKCS1_OAEP.new ( key ) print key.decrypt ( cipher ) Sure enough, get \u279c level0 git: ( master ) \u2717 python exp.py FaC5ori1ati0n_aTTA3k_p_tOO_sma11 Get the decompression password. Go ahead and look at the public key in level1 \u279c level1 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 : c3: 26 : 59 : 69 : e1: ed: 74 : d2: e0: b4: 9a: d5: 6a: 2f: 2a: 9e: c3: 71 : ff: 13 : 4b: 10 : 37 : c0: 6f: 56 : 19 : 34 : c5: cb: 1f: 6d: c0: e3: 57 : 3b: 47 : c4: 11 :11:78:d4:ee:4f:e8:99:2b:15:cb:cb:d7:73:e4: f9:a6:28:20:fd:db:8c:ea:16:ed:67:c2:48:12:6e: 4b: 01 : 53 : 4a: 67 : cb: 22 : 23 : 3b: 34 : 2e: af: 13 : ef: 93 :45: 16 : 2b: 00 : 9f: e0: 4b: d1: 90 : c9: 2c: 3f: d7: ee: 40 : f5: aa: 8c: e9: c2: 7b: f4: 36 : e3: 38 : 9d: 04 : 50 : db: a9: b7: 3f: 4b: 2a: d6: 87 : 2a: eb: 74 : 35 : 98 : 6a: 9c: e4: 52 : cb: 93 : 78 : 39 :83:f3:0c:d1:65:1e:66:9c:40:56:06:0d:58:fc: 41 : 64 : 5e: 06 : yes: 83 : d0: 3b: 06 : 42 : 70 : 54 :35:53:ce:de:79:4a:bf:f5:3b:e5:53:7f:6c:18: 12 : 67 : a9: de: 37 : 7d: 44 : 65 : 5e: 68 : 0 : 78 : 39 : 3d: bb: 00 : 22 : 35 : 0e: a3: 94 : e6: 94 : 15 : 1a: 3d: 39 : c7: 50 : 0e: b1: 64 : a5: 29 : 40 : 69 : 94 : b0: 0d: 1a: ea: 9a: And it & #39;s not like that. 3e: 7d Exponent: 65537 ( 0x10001 ) Modulus = C3265969E1ED74D2E0B49AD56A7C2F2A9EC371FF134B1037C06F561934C5CB1F6DC0E3573B47C4763E21A3B0111178D4EE4FE8992B15CBCBD773E4F9A62820FDDB8CEA16ED67C248126E4B01534A67CB22233B342EAF13EF9345162B009FE04BD190C92C279A34C33FD7EE40F5825039AA8CE9C27BF436E3389D0450DBA9B73F4B2AD68A2A5C872AEB7435986A9CE452CB9378D2DA3983F30CD1651E669C4056060D58FC41645E06DA83D03B064270DA3853E0543553CEDE794ABFF53BE5537F6C181267A9DE377D44655E680A78393DBB0022350EA394E694151A3D39C7500EB164A529A36941406994B00D1AEA9A122750EE1E3A19B72970B46D1E9D613E7D writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwyZZaeHtdNLgtJrVan Kp7Dcf8TSxA3wG9WGTTFyx9twONXO0fEdj4ho7AREXjU7k/omSsVy8vXc+T5pigg /duM6hbtZ8JIEm5LAVNKZ8siIzs0Lq8T75NFFisAn+BL0ZDJLCeaNMM/1+5A9YJQ OaqM6cJ79DbjOJ0EUNuptz9LKtaKKlyHKut0NZhqnORSy5N40to5g/MM0WUeZpxA VgYNWPxBZF4G2oPQOwZCcNo4U + BUNVPO3nlKv / U75VN / bBgSZ6neN31EZV5oCng5 PbsAIjUOo5TmlBUaPTnHUA6xZKUpo2lBQGmUsA0a6poSJ1DuHjoZtylwtG0enWE+ FQIDAQAB -----END PUBLIC KEY----- It seems that it is still not very big, break down again, and then try the factordb not, try yafu. The result is broken down. P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496383 P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496259 It can be found that these two numbers are very similar, and it may be that factordb does not implement this type of decomposition. Then the following operation is similar to level0. Just this time it is just a direct decryption, no filling, try to fill but wrong Get the password fA35ORI11TLoN_Att1Ck_cL0sE_PrI8e_4acTorS . Continue to the next step to view the public key \u279c level2 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 1025 bit ) Modulus: 01 : ba: 0c: c2: 45 : b4: 5c: e5: b5: f5: 6c: d5: ca: a5: 90 : c2:8d:12:3d:8a:6d:7f:b6:47:37:fb:7c:1f:5a:85: 8c:1e:35:13:8b:57:b2:21:4f:f4:b2:42:24:5f:33: f7: 2c: 2c: 0d: 21 : c2: 4a: d4: c5: f5: 09 : 94 : c2: 39 : 9d: 73 : e5: 04 : a2: 66 : 1d: 9c: 4b: 99 : d5: 38 : 44 : cd: 12 : a4: d0: 16 : 79 : f0: ac: 75 : f9: a4: ea: a8: 7c: 32 : 16 : 9 : 17 : d7: 7d: 80 : f: 60 : 29 : 64 : c7: ea: 50 : 30 : 63 : 76 :59:c7:36:5e:98:d2:ea:5b:b3:3a:47:17:08:2d: d5: 24 : 7d: 4f: a7: a1: f0: d5: 73 Exponent: 01 :00:8e:81:dd:a0:e3:19:28:e8:ee:51:11:08:c7: 50 :5f:61:31:05:d2:e2:ff:9b:83:71:e4:29:c2:dd: 92 :70:65:d4:09:6d:58:c3:76:31:07:f1:d4:fc:cf: 2d: b3: 0a: 6d: 02 : 7c: 56 : 61 : 7c: 7e: db: 28 : 66 : 9e: fb: 3d: 2f: 2c: 20 : 59 : 3c: 21 : ef: ff: 31 : 00 : 6a: 68 : 4a: 0a: 4c: 1a: a7: 09 : d5: 48 : 98 : c8: 1f:cf:fb:dd:f7:9c:ae:ae:0b:15:f4:b2:c7:e0:bc: ba: 31 : 4f: 5e: 07 : 83 : to: 0e: 7f: b9: 82 : a4: d2: 01 : ago: 68 : 29 : 6d: 66 : 7c: cf: 57 : b9: 4b Modulus = 1BA0CC245B45CE5B5F56CD5CAA590C28D123D8A6D7FB64737FB7C1F5A858C1E35138B57B2214FF4B242245F33F72C2C0D21C24AD4C5F50994C2399D73E504A2661D9C4B99D53844AB13D9CD12A4D01679F0AC75F9A4EAA87C32169A17D77D80FD602964C7EA5030637659C7365E98D2EA5BB33A4717082DD5247D4FA7A1F0D573 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQG6DMJFtFzltfVs1cqlkMKN Ej2KbX+2Rzf7fB9ahYweNROLV7IhT/SyQiRfM/csLA0hwkrUxfUJlMI5nXPlBKJm HZxLmdU4RKsT2c0SpNAWefCsdfmk6qh8MhaaF9d9gP1gKWTH6lAwY3ZZxzZemNLq W7M6RxcILdUkfU+nofDVcwKBgQEAjoHdoOMZKOjuUREIx1BfYTEF0uL/m4Nx5CnC 3ZJwZdQJbVjDdjEH8dT8zy2zCm0CfFZhfL5 + C37ZIihmnvs9LywgWTwh7 / 8xAGr7 p2jeSgpMGqcJ1UiYyB/P+933nK6uCxX0ssfgvLoxT14Hg60Of7mCpNIB+mgpbWZ8 z1e5Sw == -----END PUBLIC KEY----- It is found that the private keys e and n are almost the same size. Considering that d is relatively small, use Wiener's Attack. Get d, of course, you can verify it again. \u279c level2 git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- At this time we decrypt the ciphertext and decrypt the code as follows from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode d = 29897859398360008828023114464512538800655735360280670512160838259524245332403 L with open ( './public.key' ) as f : key = RSA . importKey ( f ) n = key . n e = key . e def getprivatekey ( n , e , d ): priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level3.passwd.enc' ) as f : cipher = f . read () with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) getprivatekey ( n , e , d ) decrypt () Use the string wIe6ER1s_1TtA3k_e_t00_larg3 at the end to decrypt the compressed package, taking care to remove B. At this point, all decryption ends and a flag is obtained. 2018 WCTF RSA \u00b6 The basic description of the topic is Description: Encrypted message for user \"admin\": <<<320881698662242726122152659576060496538921409976895582875089953705144841691963343665651276480485795667557825130432466455684921314043200553005547236066163215094843668681362420498455007509549517213285453773102481574390864574950259479765662844102553652977000035769295606566722752949297781646289262341623549414376262470908749643200171565760656987980763971637167709961003784180963669498213369651680678149962512216448400681654410536708661206594836597126012192813519797526082082969616915806299114666037943718435644796668877715954887614703727461595073689441920573791980162741306838415524808171520369350830683150672985523901>>> admin public key: n = 483901264006946269405283937218262944021205510033824140430120406965422208942781742610300462772237450489835092525764447026827915305166372385721345243437217652055280011968958645513779764522873874876168998429546523181404652757474147967518856439439314619402447703345139460317764743055227009595477949315591334102623664616616842043021518775210997349987012692811620258928276654394316710846752732008480088149395145019159397592415637014390713798032125010969597335893399022114906679996982147566245244212524824346645297637425927685406944205604775116409108280942928854694743108774892001745535921521172975113294131711065606768927 e = 65537 Service: http://36.110.234.253 There is no way to get the binary online now. The binary obtained is now downloaded. We need to log in to the user's admin to download the corresponding generator. By simply reversing this generator, we can see that this program works like this. Iteratively decrypts the data after a certain fixed location** with a user-specified license (32 bytes), each set of 32 bytes, different from the key or the result. The key is generated by k_1=key k_1=key k_2 =sha256(k_1) k_2 =sha256(k_1) ... k_n=sha256(k_{n-1}) k_n=sha256(k_{n-1}) Among them, the fixed position is the position where the ENCRYPTED appears for the second time in the source file generator , and then offset by 32 bytes. _ENCRYPT_STR = ENCRYPTED_STR ; v10 = 0 ; ENCRYPTED_LEN = strlen ( ENCRYPTED_STR ); do { do ++ v9 ; while ( strncmp ( & file_contents [ v9 ], _ENCRYPT_STR , ENCRYPTED_LEN ) ); ++ v10 ; } while ( v10 <= 1 ); v11 = & file_start_off_32 [ loc2 + ENCRYPTED_LEN ]; v12 = loc2 + ENCRYPTED_LEN ; len = file_size - ( loc2 + ENCRYPTED_LEN ) - 32 ; decrypt ( & file_start_off_32 [ v12 ], & license , len ); sha256_file_start ( v11 , len , & output ); if ( ! memcmp ( & output , & file_contents [ v12 ], 0x20 u ) ) { v14 = fopen ( \"out.exe\" , \"wb\" ); fwrite ( v11 , 1 u , len , v14 ); fclose ( v14 ); sprintf ( byte_406020 , \"out.exe %s \" , argv [ 1 ]); system ( byte_406020 ); } At the same time, we need to ensure that the hash of the generated file is exactly the specified value. Since the file is an exe file at the end, we can think that the last file header is the standard exe file, so we don't need to know the original. The license file, and then we can write a python script to generate the exe. In the generated exe, we analyze the basic flow of the program as Read the license 2. Use the license as the seed to generate pq separately. 3. Use p,q to generate n,e,d. The vulnerability appears on the method of generating p, q, and the method of generating p and q is similar. If we carefully analyze the function of generating prime numbers, we can see that each prime number is generated in two parts. Generate 512 bits in the left half. Generate the right half of the 512 bits. The left and right 1024 bits are determined to determine whether it is a prime number. If the prime number is successful, it is not a prime number and continues to be generated. The way to generate each part is the same, in the way sha512 ( const1 | const2 | const3 | const4 | const5 | const6 | const7 | const8 | v9 ) v9 = r % 1000000007 Only v9 will change, but its scope is fixed. So if we say p,q is p=a*2^{512}+b p=a*2^{512}+b q=c*2^{512}+d q=c*2^{512}+d Then $ n = pq = a * 2 ^ {1024} + (ad + bc) * 2 ^ {512} + bd $ Then $ N equiv bd way 2 ^ {512} $ And since p and q are generated, a, b, c, and d have only 1000000007 possibilities. Furthermore, we can enumerate all the possibilities, first calculate the possible set of b as S, and we use the intermediate encounter attack to calculate n/d \\equiv b \\bmod 2^{512} n/d \\equiv b \\bmod 2^{512} Since b and d are both the mantissa of p, they must not be a multiple of 2, and there must be an inverse. Although this can be done, however, we can simply calculate the storage space. 64*1000000007 / 1024 / 1024 / 1024=59 64*1000000007 / 1024 / 1024 / 1024=59 That means 59 G is needed, too big, so we still need to think further $ N equiv bd way 2 ^ {64} $ In this way, our memory demand dropped to around 8 G in an instant. We still use the enumeration method to perform the operation. Second, we can't use python, python takes up too much space, so it needs to be written in c/c++. Enumerate all possible d to calculate the corresponding value n/d n/d If the corresponding value is in set S, then we can think of finding a pair of legal b and d, so we can recover half of p and q. After that, we $ B = n ^ {1024} and * 2 + (a + b) * 2 ^ {$ 512} Can get $ Frac {n} {2-b ^} = {512} and {512} * 2 ^ + b + for $ $ Frac {n} {2-bd} ^ {512} equiv ad + bc way 2 ^ {512} $ Similarly, we can calculate a and c so that we can fully recover p and q. In the process of solving the concrete, when we find part of p and q, we can find that because it is modulo 2^{64} 2^{64} , there may be a collision (but in fact, one is p, the other is q, just symmetry.). Below we find the v9 corresponding to b. Note: The space enumerated here takes up approximately 11 Gs (including the index), so choose the appropriate location. b64: 9646799660ae61bd idx_b: 683101175 idx_d: 380087137 search 23000000 search 32000000 search 2b000000 search d000000 search 3a000000 search 1c000000 search 6000000 search 24000000 search 15000000 search 33000000 search 2c000000 search e000000 b64: 9c63259ccab14e0b idx_b: 380087137 idx_d: 683101175 search 1d000000 search 3b000000 search 7000000 search 16000000 search 25000000 search 34000000 In fact, after we actually get a part of p or q, the other part can be obtained by violent enumeration, because the calculation is almost the same, and the final result is ... hash 7000000 hash 30000000 p = 13941980378318401138358022650359689981503197475898780162570451627011086685747898792021456273309867273596062609692135266568225130792940286468658349600244497842007796641075219414527752166184775338649475717002974228067471300475039847366710107240340943353277059789603253261584927112814333110145596444757506023869 q = 34708215825599344705664824520726905882404144201254119866196373178307364907059866991771344831208091628520160602680905288551154065449544826571548266737597974653701384486239432802606526550681745553825993460110874794829496264513592474794632852329487009767217491691507153684439085094523697171206345793871065206283 plain text 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 hash 16000000 hash 25000000 hash b000000 hash 34000000 hash 1 a000000 ... \u279c 2018 - WCTF - rsa go to : ( master ) \u2717 python Python 2.7 . 14 ( default , Mar 22 2018 , 14 : 43 : 05 ) [ GCC 4.2 . 1 Compatible Apple LLVM 9.0 . 0 ( clang - 900.0 . 39.2 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> p = 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 >>> hex ( p )[ 2 :] . decode ( 'hex' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/local/Cellar/python@2/2.7.14_3/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/hex_codec.py\" , line 42 , in hex_decode output = binascii . a2b_hex ( input ) TypeError : Odd - length string >>> hex ( p )[ 2 : - 1 ] . decode ( 'hex' ) 'flag {fa6778724ed740396fc001b198f30313} ' Finally we got the flag. Please refer to the ctf-challenge repository for detailed utilization code. Related compilation instructions need to link related libraries. g++ exp2.cpp -std = c++11 -o main2 -lgmp -lcrypto -pthread Reference \u00b6 https://upbhack.de/posts/wctf-2018-writeup-rsa/","title":"\u7efc\u5408"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#rsa-complex-topic","text":"","title":"RSA Complex topic"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#2018-tokyo-western-mixed-cipher","text":"The information given by the title is as follows: The length of time each interaction can last is approximately 5 minutes n is a certain 1024 bit in each interaction, but unknown, e is 65537 Encrypted flag with aes, neither key nor IV Each time the key is fixed, but the IV will be random each time You can use rsa and aes for encryption with the encrypt function, where each encryption will randomly random es of aes You can use decrypt to decrypt random ciphertext, but only know what the last byte is. You can use the print_flag to get the flag ciphertext sa encrypted aes key can be obtained using print_key This topic looks like a topic, but in fact it is 3 topics, which need to be solved step by step. Before that, we are ready to interact with the function def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 4 & quot ;) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline () [: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 1 & quot ;) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline () [: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 2 & quot ;) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" )","title":"2018 Tokyo Western Mixed Cipher"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#gcd-attack-n","text":"In the first step, we need to calculate the n that is not given, because we can use the encrypt function to rsa encrypt the plaintext x we input, then we can use the nature of the divisibility to calculate n. Because x ^ e = c mod n So n | x ^ e - c We can construct enough x to calculate the most x ^ e - c to calculate the greatest common divisor and get n. def get_n(io): rsa_c,aes_c=encrypt_io(io,long_to_bytes(2)) n=pow(2,65537)-rsa_c for i in range(3,6): rsa_c, aes_c = encrypt_io(io, long_to_bytes(i)) n=primefac.gcd(n,pow(i,65537)-rsa_c) return n Can use encryption to check def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , & quot ; 123 & quot ;) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False","title":"GCD attack n"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#rsa-parity-oracle","text":"Using the last byte of leave, we can choose to ciphertext attack, use RSA parity oracle to reply to the key of aes def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : Print LB , UB tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 k + = 1 print ub , len ( long_to_bytes ( ub )) return ub","title":"RSA parity oracle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#prng-predict","text":"Here we can decrypt the contents of the 16 bytes of the flag, but the first 16 bytes without the IV can not be decrypted. At this point we can find that the random number used by IV generation uses getrandbits, and we can get enough random numbers, then we can make the PRNG prediction, and then get the random number directly. Here I use a ready-made java for Predict of PRNG. public class Main { static int [] state ; static int currentIndex ; 40 huo public static void main ( String [] args ) { state = new int [ 624 ] ; currentIndex = 0 ; // initialize(0); // for (int i = 0; i < 5; i++) { // System.out.println(state[i]); // } // for (int i = 0; i < 5; i++) { // System.out.println(nextNumber()); // } if ( args . length != 624 ) { System . err . println ( \"must be 624 args\" ); System . exit ( 1 ); } int [] arr = new int [ 624 ] ; for ( int i = 0 ; i < args . length ; i ++ ) { arr [ i ] = Integer . parseInt ( args [ i ] ); } breaking ( scarring ); for ( int i = 0 ; i < 6240 huo4 ; i ++ ) { System . out . println ( state [ i ] ); } // System.out.println(\"currentIndex \" + currentIndex); // System.out.println(\"state[currentIndex] \" + state[currentIndex]); // System.out.println(\"next \" + nextNumber()); // want -2065863258 } static void nextState () { // Iterate through the state for ( int i = 0 ; i < 624 ; i ++ ) { // y is the first bit of the current number, // and the last 31 bits of the next number int y = ( state [ i ] & 0x80000000 ) + ( state [ ( i + 1 ) % 624 ] & 0x7fffffff ); // first bitshift y by 1 to the right int next = y >>> 1 ; // xor it with the 397th next number next ^= state [ ( i + 397 ) % 624 ] ; // if y is odd, xor with magic number if (( y & 1L ) == 1L ) { next ^= 0x9908b0df ; } // now we have the result state [ i ] = next ; } } static int nextNumber () { currentIndex ++ ; int tmp = state [ currentIndex ] ; tmp ^= ( tmp >>> 11 ); tmp ^= ( tmp << 7 ) & 0x9d2c5680 ; tmp ^= ( tmp << 15 ) & 0xefc60000 ; tmp ^= ( tmp >>> 18 ); return tmp ; } static void initialize ( int seed ) { // http://code.activestate.com/recipes/578056-mersenne-twister/ // global MT // global bitmask_1 // MT[0] = seed // for i in xrange(1,624): // MT[i] = ((1812433253 * MT[i-1]) ^ ((MT[i-1] >> 30) + i)) & bitmask_1 // copied Python 2.7's impl (probably uint problems) state [ 0 ] = seed ; for ( int i = 1 ; i < 624 ; i ++ ) { state [ i ] = (( 1812433253 * state [ i - 1 ] ) ^ (( state [ i - 1 ] >> 30 ) + i )) & 0xffffffff ; } } static int unBitshiftRightXor ( int value , int shift ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 << ( 32 - shift )) >>> ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= part >>> shift ; // add the part to the result result |= part ; i ++ ; } return result ; } static int unBitshiftLeftXor ( int value , int shift , int mask ) { // we part of the value we are up to (with a width of shift bits) int i = 0 ; // we accumulate the result here int result = 0 ; // iterate until we've done the full 32 bits while ( i * shift < 32 ) { // create a mask for this part int partMask = ( - 1 >>> ( 32 - shift )) << ( shift * i ); // obtain the part int part = value & partMask ; // unapply the xor from the next part of the integer value ^= ( part << shift ) & mask ; // add the part to the result result |= part ; i ++ ; } return result ; } static void rev ( int [] nums ) { for ( int i = 0 ; i < 624 ; i ++ ) { int value = nums [ i ] ; value = unBitshiftRightXor ( value , 18 ); value = unBitshiftLeftXor ( value , 15 , 0xefc60000 ); value = unBitshiftLeftXor ( value , 7 , 0x9d2c5680 ); value = unBitshiftRightXor ( value , 11 ); state [ i ] = value ; } } } Wrote a python and call java directly from Crypto.Util.number import long_to_bytes,bytes_to_long def encrypt_io (io, p): io.read_until(\"4: get encrypted keyn\") io.writeline ( &quot;1&quot;) io.read_until(\"input plain text: \") io.writeline(p) io.read_until(\"RSA: \") rsa_c = int (io.readline () [: - 1], 16) io.read_until(\"AES: \") aes_c=io.readline()[:-1].decode(\"hex\") return rsa_c,aes_c import subprocess import random def get_iv(io): rsa_c, aes_c = encrypt_io (io, &quot;1&quot;) return bytes_to_long(aes_c[0:16]) def splitInto32(w128): w1 = w128 & (2**32-1) w2 = (w128 >> 32) & (2**32-1) w3 = (w128 &gt;&gt; 64) &amp; (2 ** 32-1) w4 = (w128 >> 96) return w1,w2,w3,w4 def sign(iv): # converts a 32 bit uint to a 32 bit signed int if(iv&0x80000000): iv = -0x100000000 + iv return iv def get_state(io): numbers=[] for i in range(156): print i numbers.append(get_iv(io)) observedNums = [sign(w) for n in numbers for w in splitInto32(n)] o = subprocess.check_output([\"java\", \"Main\"] + map(str, observedNums)) stateList = [int(s) % (2 ** 32) for s in o.split()] r = random.Random() state = (3, tuple(stateList + [624]), None) r.setstate(state) return r.getrandbits(128)","title":"PRNG Predict"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#exp","text":"The overall attack code is as follows: from zio import * import import from Crypto.Util.number import long_to_bytes , bytes_to_long target = ( \"crypto.chal.ctf.westerns.tokyo\" , 5643 ) e = 65537 def get_enc_key ( io ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 4 & quot ;) io . read_until ( \"here is encrypted key :)n\" ) c = int ( io . readline () [: - 1 ], 16 ) return c def encrypt_io ( io , p ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 1 & quot ;) io . read_until ( \"input plain text: \" ) io . writeline ( p ) io . read_until ( \"RSA: \" ) rsa_c = int ( io . readline () [: - 1 ], 16 ) io . read_until ( \"AES: \" ) aes_c = io . readline ()[: - 1 ] . decode ( \"hex\" ) return rsa_c , aes_c def decrypt_io ( io , c ): io . read_until ( \"4: get encrypted keyn\" ) io . writeline ( & quot ; 2 & quot ;) io . read_until ( \"input hexencoded cipher text: \" ) io . writeline ( long_to_bytes ( c ) . encode ( \"hex\" )) io . read_until ( \"RSA: \" ) return io . read_line ()[: - 1 ] . decode ( \"hex\" ) def get_n ( io ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( 2 )) n = pow ( 2 , 65537 ) - rsa_c for i in range ( 3 , 6 ): rsa_c , aes_c = encrypt_io ( io , long_to_bytes ( i )) n = primefac . gcd ( n , pow ( i , 65537 ) - rsa_c ) return n def check_n ( io , n ): rsa_c , aes_c = encrypt_io ( io , & quot ; 123 & quot ;) if pow ( bytes_to_long ( \"123\" ), e , n ) == rsa_c : return True else : return False import gmpy2 def guess_m ( io , n , c ): k = 1 lb = 0 ub = n while ub != lb : Print LB , UB tmp = c * gmpy2 . powmod ( 2 , k * e , n ) % n if ord ( decrypt_io ( io , tmp )[ - 1 ]) % 2 == 1 : lb = ( lb + ub ) / 2 else : UB = ( Ib + UB ) / 2 k + = 1 print ub , len ( long_to_bytes ( ub )) return ub io = zio ( target , timeout = 10000 , print_read = COLORED ( NONE , 'red' ), print_write = COLORED ( NONE , 'green' )) n = get_n ( io ) print check_n ( io , n ) c = get_enc_key ( io ) print len ( decrypt_io ( io , c )) == 16 m = guess_m ( io , n , c ) for i in range ( m - 50000 , m + 50000 ): if pow ( i , e , n ) == c : aeskey = i print long_to_bytes ( aeskey )[ - 1 ] == decrypt_io ( io , c )[ - 1 ] print \"found aes key\" , hex ( aeskey ) import fuck_r next_iv = fuck_r . get_state ( io ) print \"##########################################\" print next_iv print aeskey io . interact ()","title":"EXP"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#2016-asis-find-the-flag","text":"Here we take the example of Find the flag in the ASIS 2016 online game. The file is extracted and has a ciphertext, a public key, and a py script. Take a look at the public key. \u279c RSA openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 : d8: e2: 4c: 12 : b7: b9: 9e: fe: 0a: 9b: c0: 4a: f5: 8a: 2a: 94 : 42 : 69 : b4: 92 : b7: 37 : 6d: f1: 29 : 20 : 61 : b9 Exponent: 12405943493775545863 ( 0xac2ac3e0ca0f5607 ) Modulus = D8E24C12B7B99EFE0A9BC04A6A3DF58A2A944269B492B7376DF129023F2061B9 Such a small N N , first break it down. p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 Look at the py script again. #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 flag = open ( 'flag' , 'r' ) . read () * 30 def ext_rsa_encrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) pubkey = RSA . construct (( long ( n ), long ( e ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) return enc except : p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) f = open ( 'pubkey.pem' , 'w' ) f . write ( pubkey . exportKey ()) g = open ( 'flag.enc' , 'w' ) g . write ( ext_rsa_encrypt ( p , q , e , flag )) The logic is very simple, read the flag and repeat 30 times for the ciphertext. Randomly take p p and q q , generate a public key, write pubkey.pem , encrypt it with the ext_rsa_encrypt function in the script, and finally write the ciphertext to flag.enc . Try decryption, suggest that the ciphertext is too long, and then look at the encryption function. When the encryption fails, the function will jump to the exception handling and re-take the larger p p and q q with a certain algorithm until the encryption succeeds. Then we just need to write a corresponding decryption function. #!/usr/bin/python import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 def ext_rsa_decrypt ( p , q , e , msg ): m = bytes_to_long ( msg ) while True : n = p * q try : phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( e , phi ) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( privatekey ) de_error = & #39;&#39; enc = key . decrypt ( msg . decode ( 'base64' ), de_error ) return enc except Exception as error : print error p = gmpy . next_prime ( p ** 2 + q ** 2 ) q = gmpy . next_prime ( 2 * p * q ) e = gmpy . next_prime ( e ** 2 ) p = 311155972145869391293781528370734636009 q = 315274063651866931016337573625089033553 n = p * q e = 12405943493775545863 # pubkey = RSA.construct((long(n), long(e))) # f = open('pubkey.pem', 'w') # f.write(pubkey.exportKey()) g = open ( 'flag.enc' , 'r' ) msg = g . read () flag = ext_rsa_decrypt ( p , q , e , msg ) print flag Get the flag ASIS {F4ct0R__N_by_it3rat! Ng!}","title":"2016 ASIS Find the flag"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#sctf-rsa1","text":"Here we take SCTF RSA1 as an example. After decompressing the compressed package, we get the following file. \u279c level0 git: ( master ) \u2717 ls -al Total dosage 4drwxrwxrwx 1 root root 0 7\u6708 30 16 :36 . drwxrwxrwx 1 root root 0 7\u6708 30 16 :34 .. -rwxrwxrwx 1 root root 349 5\u6708 2 2016 level1.passwd.enc -rwxrwxrwx 1 root root 2337 5\u6708 6 2016 level1.zip -rwxrwxrwx 1 root root 451 5\u6708 2 2016 public.key Try to unzip the level1.zip now requires a password. Then according to level1.passwd.enc, we should decrypt the file to get the corresponding password. View public key \u279c level0 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 :94:a0:3e:6e:0e:dc:f2:74:10:52:ef:1e:ea:a8: 89 :d6:f9:8d:01:11:51:db:5e:90:92:48:fd:39:0c: 70 : 87 : 24 : D8: 98 : 3C: F3: 33 : 1c: BA: 5 : 61 : c2: EC: 2c: 5a:f1:5e:65:b2:b2:46:91:56:b6:19:d5:d3:b2:a6: bb: a3: 7d: 56 : 93 : 99 : 4d: 7e: 4c: 2f: aa: 60 : 7b: 3e: c8: fc:90:b2:00:62:4b:53:18:5b:a2:30:10:60:a8:21: ab: 61 : 57 : d7: e7: cc: 67 : 1b: 4d: cd: 66 : 4c: 7d: f1: 1a: 2a:1d:5e:50:80:c1:5e:45:12:3a:ba:4a:53:64:d8: ( A5: 1 : 84 : 4a: a: 5c: 55 : 02 : e8: 8e: 56 : 4d: 38 : 70 : a5: 16 : 36 : d3: bc: 14 : 3e: 2f: ae: 2f: 31 : 58 : ba: 00 : ab: ac: c0:c5:ba:44:3c:29:70:56:01:6b:57:f5:d7:52:d7: 31 : 56 : 0b: ab: 0a: e6: 8d: ad: 08 : 22 : a9: 1f: cc: 01 : 4c: 12 : d2: ab: a3: a5: 97 : e5: 10 : 49 : 19 : 7f: d9:3b:c5:53:53:71:00:18:60:cc:69:1a:06:64:3b: 86 : 94 : 70 : a9: yes: 82 : fc: 54 : 6b: 06 : 23 : 43 : eb: b6: 1b: 91 : 35 : 5e: 53 : a6: e5: d8: 9a: 84 : b8: 9f: 63 : bc: 70 : 06 : 2d: 59 : d8: 62 : a5: fd: 5c: ab: 06 : 68 :81 Exponent: 65537 ( 0x10001 ) Modulus = 94A03E6E0EDCF2741052EF1EEAA889D6F98D011151DB5E909248FD390C708724D8983CF3331CBAC561C2CE2C5AF15E65B2B2469156B619D5D3B2A6BBA37D5693994D7E4C2FAA607B3EC8FC90B200624B53185BA2301060A821AB6157D7E7CC671B4DCD664C7DF11A2A1D5E5080C15E45123ABA4A5364D8721F844AAE5C5502E88E564D3870A51636D3BC143E2FAE2F3158BA00ABACC0C5BA443C297056016B57F5D752D731560BAB0AE68DAD0822A91FCB6E49CC014C12D2ABA3A597E51049197F69D93BC5535371001860CC691A06643B869470A9DA82FC546B0623432DB020EBB61B91355E53A6E5D89A84BB3046B89F63BC70062D59D862A5FD5CAB066881 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqkkiG9w0BAQEFAAOCAQ8AMIIBCgKCQQll + bg7c8nQQUu8e6qiJ 1vmNARFR216Qkkj9OQxwhyTYmDzzMxy6xWHCzixa8V5lsrJGkVa2GdXTsqa7o31W k5lNfkwvqmB7Psj8kLIAYktTGFuiMBBgqCGrYVfX58xnG03NZkx98RoqHV5QgMFe RRI6ukpTZNhyH4RKrlxVAuiOVk04cKUWNtO8FD4vri8xWLoAq6zAxbpEPClwVgFr V / XXUtcxVgurCuaNrQgiqR / LbknMAUwS0qujpZflEEkZf2nZO8VTU3EAGGDMaRoG ZDuGlHCp2oL8VGsGI0MtsCDrthuRNV5TpuXYmoS7MEa4n2O8cAYtWdhipf1cqwZo DOWNLOAD -----END PUBLIC KEY----- It is found that although it is 2048 bits, it is obvious that the modulus is not so long. Try to decompose and get p=250527704258269 q=74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 Then you can construct and decrypt, the code is as follows from Crypto.PublicKey import RSA import gmpy2 from base64 import b64decode p = 250527704258269 q = 74891071972884336452892671945839935839027130680745292701175368094445819328761543101567760612778187287503041052186054409602799660254304070752542327616415127619185118484301676127655806327719998855075907042722072624352495417865982621374198943186383488123852345021090112675763096388320624127451586578874243946255833495297552979177208715296225146999614483257176865867572412311362252398105201644557511678179053171328641678681062496129308882700731534684329411768904920421185529144505494827908706070460177001921614692189821267467546120600239688527687872217881231173729468019623441005792563703237475678063375349 e = 65537 n = p * q def getprivatekey ( n , e , p , q ): Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level1.passwd.enc' ) as f : cipher = f . read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) #getprivatekey(n, e, p, q) decrypt () Found wrong \u279c level0 git: ( master ) \u2717 python exp.py A bunch of garbled. . At this time, we must consider other situations. Generally speaking, the RSA implemented in reality will not directly use the original RSA, and will add some padding such as OAEP. Let's try and modify the code here. def decrypt1 () : with open ( './level1.passwd.enc' ) as f: cipher = f.read () cipher = b64decode ( cipher ) with open ( './private.pem' ) as f: key = RSA.importKey ( f ) key = PKCS1_OAEP.new ( key ) print key.decrypt ( cipher ) Sure enough, get \u279c level0 git: ( master ) \u2717 python exp.py FaC5ori1ati0n_aTTA3k_p_tOO_sma11 Get the decompression password. Go ahead and look at the public key in level1 \u279c level1 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 2048 bit ) Modulus: 00 : c3: 26 : 59 : 69 : e1: ed: 74 : d2: e0: b4: 9a: d5: 6a: 2f: 2a: 9e: c3: 71 : ff: 13 : 4b: 10 : 37 : c0: 6f: 56 : 19 : 34 : c5: cb: 1f: 6d: c0: e3: 57 : 3b: 47 : c4: 11 :11:78:d4:ee:4f:e8:99:2b:15:cb:cb:d7:73:e4: f9:a6:28:20:fd:db:8c:ea:16:ed:67:c2:48:12:6e: 4b: 01 : 53 : 4a: 67 : cb: 22 : 23 : 3b: 34 : 2e: af: 13 : ef: 93 :45: 16 : 2b: 00 : 9f: e0: 4b: d1: 90 : c9: 2c: 3f: d7: ee: 40 : f5: aa: 8c: e9: c2: 7b: f4: 36 : e3: 38 : 9d: 04 : 50 : db: a9: b7: 3f: 4b: 2a: d6: 87 : 2a: eb: 74 : 35 : 98 : 6a: 9c: e4: 52 : cb: 93 : 78 : 39 :83:f3:0c:d1:65:1e:66:9c:40:56:06:0d:58:fc: 41 : 64 : 5e: 06 : yes: 83 : d0: 3b: 06 : 42 : 70 : 54 :35:53:ce:de:79:4a:bf:f5:3b:e5:53:7f:6c:18: 12 : 67 : a9: de: 37 : 7d: 44 : 65 : 5e: 68 : 0 : 78 : 39 : 3d: bb: 00 : 22 : 35 : 0e: a3: 94 : e6: 94 : 15 : 1a: 3d: 39 : c7: 50 : 0e: b1: 64 : a5: 29 : 40 : 69 : 94 : b0: 0d: 1a: ea: 9a: And it & #39;s not like that. 3e: 7d Exponent: 65537 ( 0x10001 ) Modulus = C3265969E1ED74D2E0B49AD56A7C2F2A9EC371FF134B1037C06F561934C5CB1F6DC0E3573B47C4763E21A3B0111178D4EE4FE8992B15CBCBD773E4F9A62820FDDB8CEA16ED67C248126E4B01534A67CB22233B342EAF13EF9345162B009FE04BD190C92C279A34C33FD7EE40F5825039AA8CE9C27BF436E3389D0450DBA9B73F4B2AD68A2A5C872AEB7435986A9CE452CB9378D2DA3983F30CD1651E669C4056060D58FC41645E06DA83D03B064270DA3853E0543553CEDE794ABFF53BE5537F6C181267A9DE377D44655E680A78393DBB0022350EA394E694151A3D39C7500EB164A529A36941406994B00D1AEA9A122750EE1E3A19B72970B46D1E9D613E7D writing RSA key -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwyZZaeHtdNLgtJrVan Kp7Dcf8TSxA3wG9WGTTFyx9twONXO0fEdj4ho7AREXjU7k/omSsVy8vXc+T5pigg /duM6hbtZ8JIEm5LAVNKZ8siIzs0Lq8T75NFFisAn+BL0ZDJLCeaNMM/1+5A9YJQ OaqM6cJ79DbjOJ0EUNuptz9LKtaKKlyHKut0NZhqnORSy5N40to5g/MM0WUeZpxA VgYNWPxBZF4G2oPQOwZCcNo4U + BUNVPO3nlKv / U75VN / bBgSZ6neN31EZV5oCng5 PbsAIjUOo5TmlBUaPTnHUA6xZKUpo2lBQGmUsA0a6poSJ1DuHjoZtylwtG0enWE+ FQIDAQAB -----END PUBLIC KEY----- It seems that it is still not very big, break down again, and then try the factordb not, try yafu. The result is broken down. P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496383 P309 = 156956618844706820397012891168512561016172926274406409351605204875848894134762425857160007206769208250966468865321072899370821460169563046304363342283383730448855887559714662438206600780443071125634394511976108979417302078289773847706397371335621757603520669919857006339473738564640521800108990424511408496259 It can be found that these two numbers are very similar, and it may be that factordb does not implement this type of decomposition. Then the following operation is similar to level0. Just this time it is just a direct decryption, no filling, try to fill but wrong Get the password fA35ORI11TLoN_Att1Ck_cL0sE_PrI8e_4acTorS . Continue to the next step to view the public key \u279c level2 git: ( master ) \u2717 openssl rsa -pubin -in public.key -text -modulus Public-Key: ( 1025 bit ) Modulus: 01 : ba: 0c: c2: 45 : b4: 5c: e5: b5: f5: 6c: d5: ca: a5: 90 : c2:8d:12:3d:8a:6d:7f:b6:47:37:fb:7c:1f:5a:85: 8c:1e:35:13:8b:57:b2:21:4f:f4:b2:42:24:5f:33: f7: 2c: 2c: 0d: 21 : c2: 4a: d4: c5: f5: 09 : 94 : c2: 39 : 9d: 73 : e5: 04 : a2: 66 : 1d: 9c: 4b: 99 : d5: 38 : 44 : cd: 12 : a4: d0: 16 : 79 : f0: ac: 75 : f9: a4: ea: a8: 7c: 32 : 16 : 9 : 17 : d7: 7d: 80 : f: 60 : 29 : 64 : c7: ea: 50 : 30 : 63 : 76 :59:c7:36:5e:98:d2:ea:5b:b3:3a:47:17:08:2d: d5: 24 : 7d: 4f: a7: a1: f0: d5: 73 Exponent: 01 :00:8e:81:dd:a0:e3:19:28:e8:ee:51:11:08:c7: 50 :5f:61:31:05:d2:e2:ff:9b:83:71:e4:29:c2:dd: 92 :70:65:d4:09:6d:58:c3:76:31:07:f1:d4:fc:cf: 2d: b3: 0a: 6d: 02 : 7c: 56 : 61 : 7c: 7e: db: 28 : 66 : 9e: fb: 3d: 2f: 2c: 20 : 59 : 3c: 21 : ef: ff: 31 : 00 : 6a: 68 : 4a: 0a: 4c: 1a: a7: 09 : d5: 48 : 98 : c8: 1f:cf:fb:dd:f7:9c:ae:ae:0b:15:f4:b2:c7:e0:bc: ba: 31 : 4f: 5e: 07 : 83 : to: 0e: 7f: b9: 82 : a4: d2: 01 : ago: 68 : 29 : 6d: 66 : 7c: cf: 57 : b9: 4b Modulus = 1BA0CC245B45CE5B5F56CD5CAA590C28D123D8A6D7FB64737FB7C1F5A858C1E35138B57B2214FF4B242245F33F72C2C0D21C24AD4C5F50994C2399D73E504A2661D9C4B99D53844AB13D9CD12A4D01679F0AC75F9A4EAA87C32169A17D77D80FD602964C7EA5030637659C7365E98D2EA5BB33A4717082DD5247D4FA7A1F0D573 writing RSA key -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKBgQG6DMJFtFzltfVs1cqlkMKN Ej2KbX+2Rzf7fB9ahYweNROLV7IhT/SyQiRfM/csLA0hwkrUxfUJlMI5nXPlBKJm HZxLmdU4RKsT2c0SpNAWefCsdfmk6qh8MhaaF9d9gP1gKWTH6lAwY3ZZxzZemNLq W7M6RxcILdUkfU+nofDVcwKBgQEAjoHdoOMZKOjuUREIx1BfYTEF0uL/m4Nx5CnC 3ZJwZdQJbVjDdjEH8dT8zy2zCm0CfFZhfL5 + C37ZIihmnvs9LywgWTwh7 / 8xAGr7 p2jeSgpMGqcJ1UiYyB/P+933nK6uCxX0ssfgvLoxT14Hg60Of7mCpNIB+mgpbWZ8 z1e5Sw == -----END PUBLIC KEY----- It is found that the private keys e and n are almost the same size. Considering that d is relatively small, use Wiener's Attack. Get d, of course, you can verify it again. \u279c level2 git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- Hacked! ( 'hacked_d = ' , 29897859398360008828023114464512538800655735360280670512160838259524245332403L ) ------------------------- At this time we decrypt the ciphertext and decrypt the code as follows from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode d = 29897859398360008828023114464512538800655735360280670512160838259524245332403 L with open ( './public.key' ) as f : key = RSA . importKey ( f ) n = key . n e = key . e def getprivatekey ( n , e , d ): priviatekey = RSA . construct (( long ( n ), long ( e ), long ( d ))) with open ( 'private.pem' , 'w' ) as f : f . write ( priviatekey . exportKey ()) def decrypt (): with open ( './level3.passwd.enc' ) as f : cipher = f . read () with open ( './private.pem' ) as f : key = RSA . importKey ( f ) print key . decrypt ( cipher ) getprivatekey ( n , e , d ) decrypt () Use the string wIe6ER1s_1TtA3k_e_t00_larg3 at the end to decrypt the compressed package, taking care to remove B. At this point, all decryption ends and a flag is obtained.","title":"SCTF RSA1"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#2018-wctf-rsa","text":"The basic description of the topic is Description: Encrypted message for user \"admin\": <<<320881698662242726122152659576060496538921409976895582875089953705144841691963343665651276480485795667557825130432466455684921314043200553005547236066163215094843668681362420498455007509549517213285453773102481574390864574950259479765662844102553652977000035769295606566722752949297781646289262341623549414376262470908749643200171565760656987980763971637167709961003784180963669498213369651680678149962512216448400681654410536708661206594836597126012192813519797526082082969616915806299114666037943718435644796668877715954887614703727461595073689441920573791980162741306838415524808171520369350830683150672985523901>>> admin public key: n = 483901264006946269405283937218262944021205510033824140430120406965422208942781742610300462772237450489835092525764447026827915305166372385721345243437217652055280011968958645513779764522873874876168998429546523181404652757474147967518856439439314619402447703345139460317764743055227009595477949315591334102623664616616842043021518775210997349987012692811620258928276654394316710846752732008480088149395145019159397592415637014390713798032125010969597335893399022114906679996982147566245244212524824346645297637425927685406944205604775116409108280942928854694743108774892001745535921521172975113294131711065606768927 e = 65537 Service: http://36.110.234.253 There is no way to get the binary online now. The binary obtained is now downloaded. We need to log in to the user's admin to download the corresponding generator. By simply reversing this generator, we can see that this program works like this. Iteratively decrypts the data after a certain fixed location** with a user-specified license (32 bytes), each set of 32 bytes, different from the key or the result. The key is generated by k_1=key k_1=key k_2 =sha256(k_1) k_2 =sha256(k_1) ... k_n=sha256(k_{n-1}) k_n=sha256(k_{n-1}) Among them, the fixed position is the position where the ENCRYPTED appears for the second time in the source file generator , and then offset by 32 bytes. _ENCRYPT_STR = ENCRYPTED_STR ; v10 = 0 ; ENCRYPTED_LEN = strlen ( ENCRYPTED_STR ); do { do ++ v9 ; while ( strncmp ( & file_contents [ v9 ], _ENCRYPT_STR , ENCRYPTED_LEN ) ); ++ v10 ; } while ( v10 <= 1 ); v11 = & file_start_off_32 [ loc2 + ENCRYPTED_LEN ]; v12 = loc2 + ENCRYPTED_LEN ; len = file_size - ( loc2 + ENCRYPTED_LEN ) - 32 ; decrypt ( & file_start_off_32 [ v12 ], & license , len ); sha256_file_start ( v11 , len , & output ); if ( ! memcmp ( & output , & file_contents [ v12 ], 0x20 u ) ) { v14 = fopen ( \"out.exe\" , \"wb\" ); fwrite ( v11 , 1 u , len , v14 ); fclose ( v14 ); sprintf ( byte_406020 , \"out.exe %s \" , argv [ 1 ]); system ( byte_406020 ); } At the same time, we need to ensure that the hash of the generated file is exactly the specified value. Since the file is an exe file at the end, we can think that the last file header is the standard exe file, so we don't need to know the original. The license file, and then we can write a python script to generate the exe. In the generated exe, we analyze the basic flow of the program as Read the license 2. Use the license as the seed to generate pq separately. 3. Use p,q to generate n,e,d. The vulnerability appears on the method of generating p, q, and the method of generating p and q is similar. If we carefully analyze the function of generating prime numbers, we can see that each prime number is generated in two parts. Generate 512 bits in the left half. Generate the right half of the 512 bits. The left and right 1024 bits are determined to determine whether it is a prime number. If the prime number is successful, it is not a prime number and continues to be generated. The way to generate each part is the same, in the way sha512 ( const1 | const2 | const3 | const4 | const5 | const6 | const7 | const8 | v9 ) v9 = r % 1000000007 Only v9 will change, but its scope is fixed. So if we say p,q is p=a*2^{512}+b p=a*2^{512}+b q=c*2^{512}+d q=c*2^{512}+d Then $ n = pq = a * 2 ^ {1024} + (ad + bc) * 2 ^ {512} + bd $ Then $ N equiv bd way 2 ^ {512} $ And since p and q are generated, a, b, c, and d have only 1000000007 possibilities. Furthermore, we can enumerate all the possibilities, first calculate the possible set of b as S, and we use the intermediate encounter attack to calculate n/d \\equiv b \\bmod 2^{512} n/d \\equiv b \\bmod 2^{512} Since b and d are both the mantissa of p, they must not be a multiple of 2, and there must be an inverse. Although this can be done, however, we can simply calculate the storage space. 64*1000000007 / 1024 / 1024 / 1024=59 64*1000000007 / 1024 / 1024 / 1024=59 That means 59 G is needed, too big, so we still need to think further $ N equiv bd way 2 ^ {64} $ In this way, our memory demand dropped to around 8 G in an instant. We still use the enumeration method to perform the operation. Second, we can't use python, python takes up too much space, so it needs to be written in c/c++. Enumerate all possible d to calculate the corresponding value n/d n/d If the corresponding value is in set S, then we can think of finding a pair of legal b and d, so we can recover half of p and q. After that, we $ B = n ^ {1024} and * 2 + (a + b) * 2 ^ {$ 512} Can get $ Frac {n} {2-b ^} = {512} and {512} * 2 ^ + b + for $ $ Frac {n} {2-bd} ^ {512} equiv ad + bc way 2 ^ {512} $ Similarly, we can calculate a and c so that we can fully recover p and q. In the process of solving the concrete, when we find part of p and q, we can find that because it is modulo 2^{64} 2^{64} , there may be a collision (but in fact, one is p, the other is q, just symmetry.). Below we find the v9 corresponding to b. Note: The space enumerated here takes up approximately 11 Gs (including the index), so choose the appropriate location. b64: 9646799660ae61bd idx_b: 683101175 idx_d: 380087137 search 23000000 search 32000000 search 2b000000 search d000000 search 3a000000 search 1c000000 search 6000000 search 24000000 search 15000000 search 33000000 search 2c000000 search e000000 b64: 9c63259ccab14e0b idx_b: 380087137 idx_d: 683101175 search 1d000000 search 3b000000 search 7000000 search 16000000 search 25000000 search 34000000 In fact, after we actually get a part of p or q, the other part can be obtained by violent enumeration, because the calculation is almost the same, and the final result is ... hash 7000000 hash 30000000 p = 13941980378318401138358022650359689981503197475898780162570451627011086685747898792021456273309867273596062609692135266568225130792940286468658349600244497842007796641075219414527752166184775338649475717002974228067471300475039847366710107240340943353277059789603253261584927112814333110145596444757506023869 q = 34708215825599344705664824520726905882404144201254119866196373178307364907059866991771344831208091628520160602680905288551154065449544826571548266737597974653701384486239432802606526550681745553825993460110874794829496264513592474794632852329487009767217491691507153684439085094523697171206345793871065206283 plain text 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 hash 16000000 hash 25000000 hash b000000 hash 34000000 hash 1 a000000 ... \u279c 2018 - WCTF - rsa go to : ( master ) \u2717 python Python 2.7 . 14 ( default , Mar 22 2018 , 14 : 43 : 05 ) [ GCC 4.2 . 1 Compatible Apple LLVM 9.0 . 0 ( clang - 900.0 . 39.2 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information . >>> p = 13040004482825754828623640066604760502140535607603761856185408344834209443955563791062741885 >>> hex ( p )[ 2 :] . decode ( 'hex' ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/local/Cellar/python@2/2.7.14_3/Frameworks/Python.framework/Versions/2.7/lib/python2.7/encodings/hex_codec.py\" , line 42 , in hex_decode output = binascii . a2b_hex ( input ) TypeError : Odd - length string >>> hex ( p )[ 2 : - 1 ] . decode ( 'hex' ) 'flag {fa6778724ed740396fc001b198f30313} ' Finally we got the flag. Please refer to the ctf-challenge repository for detailed utilization code. Related compilation instructions need to link related libraries. g++ exp2.cpp -std = c++11 -o main2 -lgmp -lcrypto -pthread","title":"2018 WCTF RSA"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_complex/#reference","text":"https://upbhack.de/posts/wctf-2018-writeup-rsa/","title":"Reference"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/","text":"EN | ZH Coppersmith \u76f8\u5173\u653b\u51fb \u00b6 \u57fa\u672c\u539f\u7406 \u00b6 Coppersmith \u76f8\u5173\u653b\u51fb\u4e0e Don Coppersmith \u7d27\u5bc6\u76f8\u5173\uff0c\u4ed6\u63d0\u51fa\u4e86\u4e00\u79cd\u9488\u5bf9\u4e8e\u6a21\u591a\u9879\u5f0f\uff08\u5355\u53d8\u91cf\uff0c\u4e8c\u5143\u53d8\u91cf\uff0c\u751a\u81f3\u591a\u5143\u53d8\u91cf\uff09\u627e\u6240\u6709\u5c0f\u6574\u6570\u6839\u7684\u591a\u9879\u5f0f\u65f6\u95f4\u7684\u65b9\u6cd5\u3002 \u8fd9\u91cc\u6211\u4eec\u4ee5\u5355\u53d8\u91cf\u4e3a\u4e3b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u5047\u8bbe \u6a21\u6570\u4e3a N \uff0cN \u5177\u6709\u4e00\u4e2a\u56e0\u5b50 b\\geq N^{\\beta},0< \\beta \\leq 1 b\\geq N^{\\beta},0< \\beta \\leq 1 \u591a\u9879\u5f0f F \u7684\u6b21\u6570\u4e3a \\delta \\delta \u90a3\u4e48\u8be5\u65b9\u6cd5\u53ef\u4ee5\u5728 O(c\\delta^5log^9(N)) O(c\\delta^5log^9(N)) \u7684\u590d\u6742\u5ea6\u5185\u627e\u5230\u8be5\u591a\u9879\u5f0f\u6240\u6709\u7684\u6839 x_0 x_0 \uff0c\u8fd9\u91cc\u6211\u4eec\u8981\u6c42 |x_0|<cN^{\\frac{\\beta^2}{\\delta}} |x_0|<cN^{\\frac{\\beta^2}{\\delta}} \u3002 \u5728\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c\u6211\u4eec\u7684\u76ee\u6807\u662f\u627e\u5230\u5728\u6a21 N \u610f\u4e49\u4e0b\u591a\u9879\u5f0f\u6240\u6709\u7684\u6839\uff0c\u8fd9\u4e00\u95ee\u9898\u88ab\u8ba4\u4e3a\u662f\u590d\u6742\u7684\u3002 Coppersmith method \u4e3b\u8981\u662f\u901a\u8fc7 Lenstra\u2013Lenstra\u2013Lov\u00e1sz lattice basis reduction algorithm \uff08LLL\uff09\u65b9\u6cd5\u627e\u5230 \u4e0e\u8be5\u591a\u9879\u5f0f\u5177\u6709\u76f8\u540c\u6839 x_0 x_0 \u66f4\u5c0f\u7cfb\u6570 \u5b9a\u4e49\u57df\u4e3a\u6574\u6570\u57df \u7684\u591a\u9879\u5f0f g\uff0c\u7531\u4e8e\u5728\u6574\u6570\u57df\u4e0a\u627e\u591a\u9879\u5f0f\u7684\u6839\u662f\u7b80\u5355\u7684\uff08Berlekamp\u2013Zassenhaus\uff09\uff0c\u4ece\u800c\u6211\u4eec\u5c31\u5f97\u5230\u4e86\u539f\u591a\u9879\u5f0f\u5728\u6a21\u610f\u4e49\u4e0b\u7684\u6574\u6570\u6839\u3002 \u90a3\u4e48\u95ee\u9898\u7684\u5173\u952e\u5c31\u662f\u5982\u4f55\u5c06 f \u8f6c\u6362\u5230 g \u5462\uff1fHowgrave-Graham \u7ed9\u51fa\u4e86\u4e00\u79cd\u601d\u8def \u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u9700\u8981\u627e\u5230\u4e00\u4e2a\u5177\u6709\u201c\u66f4\u5c0f\u7cfb\u6570\u201d\u7684\u591a\u9879\u5f0f g\uff0c\u4e5f\u5c31\u662f\u4e0b\u9762\u7684\u8f6c\u6362\u65b9\u5f0f \u5728 LLL \u7b97\u6cd5\u4e2d\uff0c\u6709\u4e24\u70b9\u662f\u975e\u5e38\u6709\u7528\u7684 \u53ea\u5bf9\u539f\u6765\u7684\u57fa\u5411\u91cf\u8fdb\u884c\u6574\u6570\u7ebf\u6027\u53d8\u6362\uff0c\u8fd9\u53ef\u4ee5\u4f7f\u5f97\u6211\u4eec\u5728\u5f97\u5230 g \u65f6\uff0c\u4ecd\u7136\u4ee5\u539f\u6765\u7684 x_0 x_0 \u4e3a\u6839\u3002 \u751f\u6210\u7684\u65b0\u7684\u57fa\u5411\u91cf\u7684\u6a21\u957f\u662f\u6709\u754c\u7684\uff0c\u8fd9\u53ef\u4ee5\u4f7f\u5f97\u6211\u4eec\u5229\u7528 Howgrave-Graham \u5b9a\u7406\u3002 \u5728\u8fd9\u6837\u7684\u57fa\u7840\u4e4b\u4e0a\uff0c\u6211\u4eec\u518d\u6784\u9020\u51fa\u591a\u9879\u5f0f\u65cf g \u5c31\u53ef\u4ee5\u4e86\u3002 \u5173\u4e8e\u66f4\u52a0\u7ec6\u8282\u7684\u5185\u5bb9\uff0c\u8bf7\u81ea\u884c\u641c\u7d22\u3002\u540c\u65f6\u8fd9\u90e8\u5206\u5185\u5bb9\u4e5f\u4f1a\u4e0d\u65ad\u66f4\u65b0\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u7531\u4e8e Coppersmith \u6839\u7684\u7ea6\u675f\uff0c\u5728 RSA \u4e2d\u7684\u5e94\u7528\u65f6\uff0c\u5f80\u5f80\u53ea\u9002\u7528\u4e8e e \u8f83\u5c0f\u7684\u60c5\u51b5\u3002 Basic Broadcast Attack \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5982\u679c\u4e00\u4e2a\u7528\u6237\u4f7f\u7528\u540c\u4e00\u4e2a\u52a0\u5bc6\u6307\u6570 e \u52a0\u5bc6\u4e86\u540c\u4e00\u4e2a\u5bc6\u6587\uff0c\u5e76\u53d1\u9001\u7ed9\u4e86\u5176\u4ed6 e \u4e2a\u7528\u6237\u3002\u90a3\u4e48\u5c31\u4f1a\u4ea7\u751f\u5e7f\u64ad\u653b\u51fb\u3002\u8fd9\u4e00\u653b\u51fb\u7531 H\u00e5stad \u63d0\u51fa\u3002 \u653b\u51fb\u539f\u7406 \u00b6 \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe e \u4e3a 3\uff0c\u5e76\u4e14\u52a0\u5bc6\u8005\u4f7f\u7528\u4e86\u4e09\u4e2a\u4e0d\u540c\u7684\u6a21\u6570 n_1,n_2,n_3 n_1,n_2,n_3 \u7ed9\u4e09\u4e2a\u4e0d\u540c\u7684\u7528\u6237\u53d1\u9001\u4e86\u52a0\u5bc6\u540e\u7684\u6d88\u606f m\uff0c\u5982\u4e0b \\begin{align*} c_1&=m^3\\bmod n_1 \\\\ c_2&=m^3\\bmod n_2 \\\\ c_3&=m^3\\bmod n_3 \\end{align*} \\begin{align*} c_1&=m^3\\bmod n_1 \\\\ c_2&=m^3\\bmod n_2 \\\\ c_3&=m^3\\bmod n_3 \\end{align*} \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe n_1,n_2,n_3\u200b n_1,n_2,n_3\u200b \u4e92\u7d20\uff0c\u4e0d\u7136\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fdb\u884c\u5206\u89e3\uff0c\u7136\u540e\u5f97\u5230 d\uff0c\u8fdb\u800c\u7136\u540e\u76f4\u63a5\u89e3\u5bc6\u3002 \u540c\u65f6\uff0c\u6211\u4eec\u5047\u8bbe m<n_i, 1\\leq i \\leq 3 m<n_i, 1\\leq i \\leq 3 \u3002\u5982\u679c\u8fd9\u4e2a\u6761\u4ef6\u4e0d\u6ee1\u8db3\u7684\u8bdd\uff0c\u5c31\u4f1a\u4f7f\u5f97\u60c5\u51b5\u53d8\u5f97\u6bd4\u8f83\u590d\u6742\uff0c\u8fd9\u91cc\u6211\u4eec\u6682\u4e0d\u8ba8\u8bba\u3002 \u65e2\u7136\u4ed6\u4eec\u4e92\u7d20\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff0c\u53ef\u5f97 m^3 \\equiv C \\bmod n_1n_2n_3 m^3 \\equiv C \\bmod n_1n_2n_3 \u3002 \u6b64\u5916\uff0c\u65e2\u7136 m<n_i, 1\\leq i \\leq 3 m<n_i, 1\\leq i \\leq 3 \uff0c\u90a3\u4e48\u6211\u4eec\u77e5\u9053 m^3 < n_1n_2n_3 m^3 < n_1n_2n_3 \u5e76\u4e14 C<m^3 < n_1n_2n_3 C<m^3 < n_1n_2n_3 \uff0c\u90a3\u4e48 m^3 = C m^3 = C \uff0c\u6211\u4eec\u5bf9 C \u5f00\u4e09\u6b21\u6839\u5373\u53ef\u5f97\u5230 m \u7684\u503c\u3002 \u5bf9\u4e8e\u8f83\u5927\u7684 e \u6765\u8bf4\uff0c\u6211\u4eec\u53ea\u662f\u9700\u8981\u66f4\u591a\u7684\u660e\u5bc6\u6587\u5bf9\u3002 SCTF RSA3 LEVEL4 \u00b6 \u53c2\u8003 http://ohroot.com/2016/07/11/rsa-in-ctf \u3002 \u8fd9\u91cc\u6211\u4eec\u4ee5 SCTF RSA3 \u4e2d\u7684 level4 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9996\u5148\u7f16\u5199\u4ee3\u7801\u63d0\u53d6 cap \u5305\u4e2d\u7684\u6570\u636e\uff0c\u5982\u4e0b #!/usr/bin/env python from scapy.all import * import zlib import struct PA = 24 packets = rdpcap ( './syc_security_system_traffic3.pcap' ) client = '192.168.1.180' list_n = [] list_m = [] list_id = [] data = [] for packet in packets: # TCP Flag PA 24 means carry data if packet [ TCP ] .flags == PA or packet [ TCP ] .flags == PA + 1 : src = packet [ IP ] .src raw_data = packet [ TCP ] .load head = raw_data.strip ()[ :7 ] if head == \"We have\" : n, e = raw_data.strip () .replace ( \"We have got N is \" , \"\" ) .split ( '\\ne is ' ) data.append ( n.strip ()) if head == \"encrypt\" : m = raw_data.replace ( 'encrypted messages is 0x' , '' ) .strip () data.append ( str ( int ( m, 16 ))) with open ( './data.txt' , 'w' ) as f: for i in range ( 0 , len ( data ) , 2 ) : tmp = ',' .join ( s for s in data [ i:i + 2 ]) f.write ( tmp + '\\n' ) \u5176\u6b21\uff0c\u5229\u7528\u5f97\u5230\u7684\u6570\u636e\u76f4\u63a5\u4f7f\u7528\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u6c42\u89e3\u3002 from functools import reduce import gmpy import json , binascii def modinv ( a , m ): return int ( gmpy . invert ( gmpy . mpz ( a ), gmpy . mpz ( m ))) def chinese_remainder ( n , a ): sum = 0 prod = reduce ( lambda a , b : a * b , n ) # \u5e76\u884c\u8fd0\u7b97 for n_i , a_i in zip ( n , a ): p = prod // n_i sum += a_i * modinv ( p , n_i ) * p return int ( sum % prod ) nset = [] cset = [] with open ( \"data.txt\" ) as f : now = f . read () . strip ( ' \\n ' ) . split ( ' \\n ' ) for item in now : item = item . split ( ',' ) nset . append ( int ( item [ 0 ])) cset . append ( int ( item [ 1 ])) m = chinese_remainder ( nset , cset ) m = int ( gmpy . mpz ( m ) . root ( 19 )[ 0 ]) print binascii . unhexlify ( hex ( m )[ 2 : - 1 ]) \u5f97\u5230\u5bc6\u6587\uff0c\u7136\u540e\u518d\u6b21\u89e3\u5bc6\u5373\u53ef\u5f97\u5230 flag\u3002 H1sTaDs_B40aDcadt_attaCk_e_are_same_and_smA9l \u9898\u76ee \u00b6 2017 WHCTF OldDriver 2018 N1CTF easy_fs Broadcast Attack with Linear Padding \u00b6 \u5bf9\u4e8e\u5177\u6709\u7ebf\u6027\u586b\u5145\u7684\u60c5\u51b5\u4e0b\uff0c\u4ecd\u7136\u53ef\u4ee5\u653b\u51fb\uff0c\u8fd9\u65f6\u5019\u5c31\u4f1a\u4f7f\u7528 Coppersmith method \u7684\u65b9\u6cd5\u4e86\uff0c\u8fd9\u91cc\u6682\u4e0d\u4ecb\u7ecd\u3002\u53ef\u4ee5\u53c2\u8003 https://en.wikipedia.org/wiki/Coppersmith%27s_attack#Generalizations Related Message Attack \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5f53 Alice \u4f7f\u7528\u540c\u4e00\u516c\u94a5\u5bf9\u4e24\u4e2a\u5177\u6709\u67d0\u79cd\u7ebf\u6027\u5173\u7cfb\u7684\u6d88\u606f M1 \u4e0e M2 \u8fdb\u884c\u52a0\u5bc6\uff0c\u5e76\u5c06\u52a0\u5bc6\u540e\u7684\u6d88\u606f C1\uff0cC2 \u53d1\u9001\u7ed9\u4e86 Bob \u65f6\uff0c\u6211\u4eec\u5c31\u53ef\u80fd\u53ef\u4ee5\u83b7\u5f97\u5bf9\u5e94\u7684\u6d88\u606f M1 \u4e0e M2\u3002\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u6a21\u6570\u4e3a N\uff0c\u4e24\u8005\u4e4b\u95f4\u7684\u7ebf\u6027\u5173\u7cfb\u5982\u4e0b M_1 \\equiv f(M_2) \\bmod N M_1 \\equiv f(M_2) \\bmod N \u5176\u4e2d f \u4e3a\u4e00\u4e2a\u7ebf\u6027\u51fd\u6570\uff0c\u6bd4\u5982\u8bf4 f=ax+b f=ax+b \u3002 \u5728\u5177\u6709\u8f83\u5c0f\u9519\u8bef\u6982\u7387\u4e0b\u7684\u60c5\u51b5\u4e0b\uff0c\u5176\u590d\u6742\u5ea6\u4e3a O(elog^2N) O(elog^2N) \u3002 \u8fd9\u4e00\u653b\u51fb\u7531 Franklin\uff0cReiter \u63d0\u51fa\u3002 \u653b\u51fb\u539f\u7406 \u00b6 \u9996\u5148\uff0c\u6211\u4eec\u77e5\u9053 C_1 \\equiv M_1 ^e \\bmod N C_1 \\equiv M_1 ^e \\bmod N \uff0c\u5e76\u4e14 M_1 \\equiv f(M_2) \\bmod N M_1 \\equiv f(M_2) \\bmod N \uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u77e5\u9053 M_2 M_2 \u662f f(x)^e \\equiv C_1 \\bmod N f(x)^e \\equiv C_1 \\bmod N \u7684\u4e00\u4e2a\u89e3\uff0c\u5373\u5b83\u662f\u65b9\u7a0b f(x)^e-C_1 f(x)^e-C_1 \u5728\u6a21 N \u610f\u4e49\u4e0b\u7684\u4e00\u4e2a\u6839\u3002\u540c\u6837\u7684\uff0c M_2 M_2 \u662f x^e - C_2 x^e - C_2 \u5728\u6a21 N \u610f\u4e49\u4e0b\u7684\u4e00\u4e2a\u6839\u3002\u6240\u4ee5\u8bf4 x-M_2 x-M_2 \u540c\u65f6\u6574\u9664\u4ee5\u4e0a\u4e24\u4e2a\u591a\u9879\u5f0f\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u6c42\u5f97\u4e24\u4e2a\u591a\u9879\u5f0f\u7684\u6700\u5927\u516c\u56e0\u5b50\uff0c\u5982\u679c\u6700\u5927\u516c\u56e0\u5b50\u6070\u597d\u662f\u7ebf\u6027\u7684\u8bdd\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u6c42\u5f97\u4e86 M_2 M_2 \u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5728 e=3 e=3 \u7684\u60c5\u51b5\u4e0b\uff0c\u6700\u5927\u516c\u56e0\u5b50\u4e00\u5b9a\u662f\u7ebf\u6027\u7684\u3002 \u8fd9\u91cc\u6211\u4eec\u5173\u6ce8\u4e00\u4e0b e=3 e=3 \uff0c\u4e14 f(x)=ax+b f(x)=ax+b \u7684\u60c5\u51b5\u3002\u9996\u5148\u6211\u4eec\u6709 C_1 \\equiv M_1 ^3 \\bmod N,M_1 \\equiv aM_2+b \\bmod N C_1 \\equiv M_1 ^3 \\bmod N,M_1 \\equiv aM_2+b \\bmod N \u90a3\u4e48\u6211\u4eec\u6709 C_1 \\equiv (aM_2+b)^3 \\bmod N,C_2 \\equiv M_2^3 \\bmod N C_1 \\equiv (aM_2+b)^3 \\bmod N,C_2 \\equiv M_2^3 \\bmod N \u6211\u4eec\u9700\u8981\u660e\u786e\u4e00\u4e0b\u6211\u4eec\u60f3\u8981\u5f97\u5230\u7684\u662f\u6d88\u606f m\uff0c\u6240\u4ee5\u9700\u8981\u5c06\u5176\u5355\u72ec\u6784\u9020\u51fa\u6765\u3002 \u9996\u5148\uff0c\u6211\u4eec\u6709\u5f0f 1 (aM_2+b)^3=a^3M_2^3+3a^2M^2b+3aM_2b^2+b^3 (aM_2+b)^3=a^3M_2^3+3a^2M^2b+3aM_2b^2+b^3 \u518d\u8005\u6211\u4eec\u6784\u9020\u5982\u4e0b\u5f0f 2 (aM_2)^3-b^3 \\equiv (aM_2-b)(a^2M_2^2+aM_2b+b^2) \\bmod N (aM_2)^3-b^3 \\equiv (aM_2-b)(a^2M_2^2+aM_2b+b^2) \\bmod N \u6839\u636e\u5f0f 1 \u6211\u4eec\u6709 a^3M_2^3-2b^3+3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1 \\bmod N a^3M_2^3-2b^3+3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1 \\bmod N \u7ee7\u800c\u6211\u4eec\u6709\u5f0f 3 3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1-a^3C_2+2b^3 \\bmod N 3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1-a^3C_2+2b^3 \\bmod N \u90a3\u4e48\u6211\u4eec\u6839\u636e\u5f0f 2 \u4e0e\u5f0f 3 \u53ef\u5f97 (a^3C_2-b^3)*3b \\equiv (aM_2-b)( C_1-a^3C_2+2b^3 ) \\bmod N (a^3C_2-b^3)*3b \\equiv (aM_2-b)( C_1-a^3C_2+2b^3 ) \\bmod N \u8fdb\u800c\u6211\u4eec\u6709 aM_2-b=\\frac{3a^3bC_2-3b^4}{C_1-a^3C_2+2b^3} aM_2-b=\\frac{3a^3bC_2-3b^4}{C_1-a^3C_2+2b^3} \u8fdb\u800c aM_2\\equiv \\frac{2a^3bC_2-b^4+C_1b}{C_1-a^3C_2+2b^3} aM_2\\equiv \\frac{2a^3bC_2-b^4+C_1b}{C_1-a^3C_2+2b^3} \u8fdb\u800c M_2 \\equiv\\frac{2a^3bC_2-b^4+C_1b}{aC_1-a^4C_2+2ab^3}=\\frac{b}{a}\\frac{C_1+2a^3C_2-b^3}{C_1-a^3C_2+2b^3} M_2 \\equiv\\frac{2a^3bC_2-b^4+C_1b}{aC_1-a^4C_2+2ab^3}=\\frac{b}{a}\\frac{C_1+2a^3C_2-b^3}{C_1-a^3C_2+2b^3} \u4e0a\u9762\u7684\u5f0f\u5b50\u4e2d\u53f3\u8fb9\u6240\u6709\u7684\u5185\u5bb9\u90fd\u662f\u5df2\u77e5\u7684\u5185\u5bb9\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u83b7\u53d6\u5bf9\u5e94\u7684\u6d88\u606f\u3002 \u6709\u5174\u8da3\u7684\u53ef\u4ee5\u8fdb\u4e00\u6b65\u9605\u8bfb A New Related Message Attack on RSA \u4ee5\u53ca paper \u8fd9\u91cc\u6682\u4e0d\u505a\u8fc7\u591a\u7684\u8bb2\u89e3\u3002 SCTF RSA3 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 SCTF RSA3 \u4e2d\u7684 level3 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002\u9996\u5148\uff0c\u8ddf\u8e2a TCP \u6d41\u53ef\u4ee5\u77e5\u9053\uff0c\u52a0\u5bc6\u65b9\u5f0f\u662f\u5c06\u660e\u6587\u52a0\u4e0a\u7528\u6237\u7684 user id \u8fdb\u884c\u52a0\u5bc6\uff0c\u800c\u4e14\u8fd8\u5b58\u5728\u591a\u7ec4\u3002\u8fd9\u91cc\u6211\u4eec\u9009\u62e9\u7b2c 0 \u7ec4\u548c\u7b2c 9 \u7ec4\uff0c\u4ed6\u4eec\u7684\u6a21\u6570\u4e00\u6837\uff0c\u89e3\u5bc6\u811a\u672c\u5982\u4e0b import gmpy2 id1 = 1002 id2 = 2614 c1 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c5bb724d1cee07e221e028d9b8bc24360208840fbdfd4794733adcac45c38ad0225fde19a6a4c38e4207368f5902c871efdf1bdf4760b1a98ec1417893c8fce8389b6434c0fee73b13c284e8c9fb5c77e420a2b5b1a1c10b2a7a3545e95c1d47835c2718 L c2 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c72722fe4fe5a901e2531b3dbcb87e5aa19bbceecbf9f32eacefe81777d9bdca781b1ec8f8b68799b4aa4c6ad120506222c7f0c3e11b37dd0ce08381fabf9c14bc74929bf524645989ae2df77c8608d0512c1cc4150765ab8350843b57a2464f848d8e08 L n = 25357901189172733149625332391537064578265003249917817682864120663898336510922113258397441378239342349767317285221295832462413300376704507936359046120943334215078540903962128719706077067557948218308700143138420408053500628616299338204718213283481833513373696170774425619886049408103217179262264003765695390547355624867951379789924247597370496546249898924648274419164899831191925127182066301237673243423539604219274397539786859420866329885285232179983055763704201023213087119895321260046617760702320473069743688778438854899409292527695993045482549594428191729963645157765855337481923730481041849389812984896044723939553 a = 1 b = id1 - id2 def getmessage ( a , b , c1 , c2 , n ): b3 = gmpy2 . powmod ( b , 3 , n ) part1 = b * ( c1 + 2 * c2 - b3 ) % n part2 = a * ( c1 - c2 + 2 * b3 ) % n part2 = gmpy2 . invert ( part2 , n ) return part1 * part2 % n message = getmessage ( a , b , c1 , c2 , n ) - id2 message = hex ( message )[ 2 :] if len ( message ) % 2 != 0 : message = '0' + message print message . decode ( 'hex' ) \u5f97\u5230\u660e\u6587 \u279c sctf-rsa3-level3 git: ( master ) \u2717 python exp.py F4An8LIn_rElT3r_rELa53d_Me33Age_aTtaCk_e_I2_s7aLL \u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 sage \u6765\u505a\uff0c\u4f1a\u66f4\u52a0\u7b80\u5355\u4e00\u70b9\u3002 import binascii def attack ( c1 , c2 , b , e , n ): PR .< x >= PolynomialRing ( Zmod ( n )) g1 = x ^ e - c1 g2 = ( x + b ) ^ e - c2 def gcd ( g1 , g2 ): while g2 : g1 , g2 = g2 , g1 % g2 return g1 . monic () return - gcd ( g1 , g2 )[ 0 ] c1 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c5bb724d1cee07e221e028d9b8bc24360208840fbdfd4794733adcac45c38ad0225fde19a6a4c38e4207368f5902c871efdf1bdf4760b1a98ec1417893c8fce8389b6434c0fee73b13c284e8c9fb5c77e420a2b5b1a1c10b2a7a3545e95c1d47835c2718 L c2 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c72722fe4fe5a901e2531b3dbcb87e5aa19bbceecbf9f32eacefe81777d9bdca781b1ec8f8b68799b4aa4c6ad120506222c7f0c3e11b37dd0ce08381fabf9c14bc74929bf524645989ae2df77c8608d0512c1cc4150765ab8350843b57a2464f848d8e08 L n = 25357901189172733149625332391537064578265003249917817682864120663898336510922113258397441378239342349767317285221295832462413300376704507936359046120943334215078540903962128719706077067557948218308700143138420408053500628616299338204718213283481833513373696170774425619886049408103217179262264003765695390547355624867951379789924247597370496546249898924648274419164899831191925127182066301237673243423539604219274397539786859420866329885285232179983055763704201023213087119895321260046617760702320473069743688778438854899409292527695993045482549594428191729963645157765855337481923730481041849389812984896044723939553 e = 3 a = 1 id1 = 1002 id2 = 2614 b = id2 - id1 m1 = attack ( c1 , c2 , b , e , n ) print binascii . unhexlify ( \" %x \" % int ( m1 - id1 )) \u7ed3\u679c\u5982\u4e0b \u279c sctf-rsa3-level3 git: ( master ) \u2717 sage exp.sage sys:1: RuntimeWarning: not adding directory '' to sys.path since everybody can write to it. Untrusted users could put files in this directory which might then be imported by your Python code. As a general precaution from similar exploits, you should not execute Python code from this directory F4An8LIn_rElT3r_rELa53d_Me33Age_aTtaCk_e_I2_s7aLL \u9898\u76ee \u00b6 hitcon 2014 rsaha N1CTF 2018 rsa_padding Coppersmith\u2019s short-pad attack \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u76ee\u524d\u5728\u5927\u90e8\u5206\u6d88\u606f\u52a0\u5bc6\u4e4b\u524d\u90fd\u4f1a\u8fdb\u884c padding\uff0c\u4f46\u662f\u5982\u679c padding \u7684\u957f\u5ea6\u8fc7\u77ed\uff0c\u4e5f\u6709 \u53ef\u80fd \u88ab\u5f88\u5bb9\u6613\u5730\u653b\u51fb\u3002 \u8fd9\u91cc\u6240\u8c13 padding \u8fc7\u77ed\uff0c\u5176\u5b9e\u5c31\u662f\u5bf9\u5e94\u7684\u591a\u9879\u5f0f\u7684\u6839\u4f1a\u8fc7\u5c0f\u3002 \u653b\u51fb\u539f\u7406 \u00b6 \u6211\u4eec\u5047\u8bbe\u7231\u4e3d\u4e1d\u8981\u7ed9\u9c8d\u52c3\u53d1\u9001\u6d88\u606f\uff0c\u9996\u5148\u7231\u4e3d\u4e1d\u5bf9\u8981\u52a0\u5bc6\u7684\u6d88\u606f M \u8fdb\u884c\u968f\u673a padding\uff0c\u7136\u540e\u52a0\u5bc6\u5f97\u5230\u5bc6\u6587 C1\uff0c\u53d1\u9001\u7ed9\u9c8d\u52c3\u3002\u8fd9\u65f6\uff0c\u4e2d\u95f4\u4eba\u76ae\u7279\u622a\u83b7\u4e86\u5bc6\u6587\u3002\u4e00\u6bb5\u65f6\u95f4\u540e\uff0c\u7231\u4e3d\u4e1d\u6ca1\u6709\u6536\u5230\u9c8d\u52c3\u7684\u56de\u590d\uff0c\u518d\u6b21\u5bf9\u8981\u52a0\u5bc6\u7684\u6d88\u606f M \u8fdb\u884c\u968f\u673a padding\uff0c\u7136\u540e\u52a0\u5bc6\u5f97\u5230\u5bc6\u6587 C2\uff0c\u53d1\u9001\u7ed9 Bob\u3002\u76ae\u7279\u518d\u4e00\u6b21\u622a\u83b7\u3002\u8fd9\u65f6\uff0c\u76ae\u7279\u5c31 \u53ef\u80fd \u53ef\u4ee5\u5229\u7528\u5982\u4e0b\u539f\u7406\u89e3\u5bc6\u3002 \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u6a21\u6570 N \u7684\u957f\u5ea6\u4e3a k\uff0c\u5e76\u4e14 padding \u7684\u957f\u5ea6\u4e3a m=\\lfloor \\frac{k}{e^2} \\rfloor m=\\lfloor \\frac{k}{e^2} \\rfloor \u3002\u6b64\u5916\uff0c\u5047\u8bbe\u8981\u52a0\u5bc6\u7684\u6d88\u606f\u7684\u957f\u5ea6\u6700\u591a\u4e3a k-m \u6bd4\u7279\uff0cpadding \u7684\u65b9\u5f0f\u5982\u4e0b M_1=2^mM+r_1, 0\\leq r_1\\leq 2^m M_1=2^mM+r_1, 0\\leq r_1\\leq 2^m \u6d88\u606f M2 \u7684 padding \u65b9\u5f0f\u7c7b\u4f3c\u3002 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u5982\u4e0b\u7684\u65b9\u5f0f\u6765\u89e3\u5bc6\u3002 \u9996\u5148\u5b9a\u4e49 g_1(x,y)=x^e-C_1 g_2(x,y)=(x+y)^e-C_2 g_1(x,y)=x^e-C_1 g_2(x,y)=(x+y)^e-C_2 \u5176\u4e2d y=r_2-r_1 y=r_2-r_1 \u3002\u663e\u7136\u8fd9\u4e24\u4e2a\u65b9\u7a0b\u5177\u6709\u76f8\u540c\u7684\u6839 M1\u3002\u7136\u540e\u8fd8\u6709\u4e00\u7cfb\u5217\u7684\u63a8\u5bfc\u3002 Known High Bits Message Attack \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u9996\u5148\u52a0\u5bc6\u4e86\u6d88\u606f m\uff0c\u5982\u4e0b C\\equiv m^d \\bmod N C\\equiv m^d \\bmod N \u5e76\u4e14\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u77e5\u9053\u6d88\u606f m \u7684\u5f88\u5927\u7684\u4e00\u90e8\u5206 m_0 m_0 \uff0c\u5373 m=m_0+x m=m_0+x \uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u77e5\u9053 x x \u3002\u90a3\u4e48\u6211\u4eec\u5c31\u6709\u53ef\u80fd\u901a\u8fc7\u8be5\u65b9\u6cd5\u8fdb\u884c\u6062\u590d\u6d88\u606f\u3002\u8fd9\u91cc\u6211\u4eec\u4e0d\u77e5\u9053\u7684 x \u5176\u5b9e\u5c31\u662f\u591a\u9879\u5f0f\u7684\u6839\uff0c\u9700\u8981\u6ee1\u8db3 Coppersmith \u7684\u7ea6\u675f\u3002 \u53ef\u4ee5\u53c2\u8003 https://github.com/mimoo/RSA-and-LLL-attacks \u3002 Factoring with High Bits Known \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5f53\u6211\u4eec\u77e5\u9053\u4e00\u4e2a\u516c\u94a5\u4e2d\u6a21\u6570 N \u7684\u4e00\u4e2a\u56e0\u5b50\u7684\u8f83\u9ad8\u4f4d\u65f6\uff0c\u6211\u4eec\u5c31\u6709\u4e00\u5b9a\u51e0\u7387\u6765\u5206\u89e3 N\u3002 \u653b\u51fb\u5de5\u5177 \u00b6 \u8bf7\u53c2\u8003 https://github.com/mimoo/RSA-and-LLL-attacks \u3002\u4e0a\u9762\u6709\u4f7f\u7528\u6559\u7a0b\u3002\u5173\u6ce8\u4e0b\u9762\u7684\u4ee3\u7801 beta = 0.5 dd = f . degree () epsilon = beta / 7 mm = ceil ( beta ** 2 / ( dd * epsilon )) tt = floor ( dd * mm * (( 1 / beta ) - 1 )) XX = ceil ( N ** (( beta ** 2 / dd ) - epsilon )) + 1000000000000000000000000000000000 roots = coppersmith_howgrave_univariate ( f , N , beta , mm , tt , XX ) \u5176\u4e2d\uff0c \u5fc5\u987b\u6ee1\u8db3 q\\geq N^{beta} q\\geq N^{beta} \uff0c\u6240\u4ee5\u8fd9\u91cc\u7ed9\u51fa\u4e86 beta=0.5 beta=0.5 \uff0c\u663e\u7136\u4e24\u4e2a\u56e0\u6570\u4e2d\u5fc5\u7136\u6709\u4e00\u4e2a\u662f\u5927\u4e8e\u7684\u3002 XX \u662f f(x)=q'+x f(x)=q'+x \u5728\u6a21 q \u610f\u4e49\u4e0b\u7684\u6839\u7684\u4e0a\u754c\uff0c\u81ea\u7136\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u8c03\u6574\u5b83\uff0c\u8fd9\u91cc\u5176\u5b9e\u4e5f\u8868\u660e\u4e86\u6211\u4eec\u5df2\u77e5\u7684 q' q' \u4e0e\u56e0\u6570 q \u4e4b\u95f4\u53ef\u80fd\u7684\u5dee\u8ddd\u3002 2016 HCTF RSA2 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 2016 \u5e74 HCTF \u4e2d\u7684 RSA2 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002 \u9996\u5148\u7a0b\u5e8f\u7684\u5f00\u5934\u662f\u4e00\u4e2a\u7ed5\u8fc7\u9a8c\u8bc1\u7684\uff0c\u7ed5\u8fc7\u5373\u53ef\uff0c\u4ee3\u7801\u5982\u4e0b from pwn import * from hashlib import sha512 sh = remote ( '127.0.0.1' , 9999 ) context . log_level = 'debug' def sha512_proof ( prefix , verify ): i = 0 pading = \"\" while True : try : i = randint ( 0 , 1000 ) pading += str ( i ) if len ( pading ) > 200 : pading = pading [ 200 :] #print pading except StopIteration : break r = sha512 ( prefix + pading ) . hexdigest () if verify in r : return pading def verify (): sh . recvuntil ( \"Prefix: \" ) prefix = sh . recvline () print len ( prefix ) prefix = prefix [: - 1 ] prefix = prefix . decode ( 'base64' ) proof = sha512_proof ( prefix , \"fffffff\" ) sh . send ( proof . encode ( 'base64' )) if __name__ == '__main__' : verify () print 'verify success' sh . recvuntil ( \"token: \" ) token = \"5c9597f3c8245907ea71a89d9d39d08e\" sh . sendline ( token ) sh . recvuntil ( \"n: \" ) n = sh . readline () . strip () n = int ( n [ 2 :], 16 ) sh . recvuntil ( \"e: \" ) e = sh . readline () . strip () e = int ( e [ 2 :], 16 ) sh . recvuntil ( \"e2: \" ) e2 = sh . readline () . strip () e2 = int ( e2 [ 2 :], 16 ) sh . recvuntil ( \"is: \" ) enc_flag = sh . readline () . strip () enc_flag = int ( enc_flag [ 2 : - 1 ], 16 ) print \"n: \" , hex ( n ) print \"e: \" , hex ( e ) print \"e2: \" , hex ( e2 ) print \"flag: \" , hex ( enc_flag ) \u8fd9\u91cc\u6211\u4eec\u4e5f\u5df2\u7ecf\u5f97\u5230 n\uff0ce\uff0ce2\uff0c\u52a0\u5bc6\u540e\u7684 flag \u4e86\uff0c\u5982\u4e0b n : 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f e : 0x10001 e2 : 0xf93b flag : 0xf11e932fa420790ca3976468dc4df1e6b20519ebfdc427c09e06940e1ef0ca566d41714dc1545ddbdcae626eb51c7fa52608384a36a2a021960d71023b5d0f63e6b38b46ac945ddafea42f01d24cc33ce16825df7aa61395d13617ae619dca2df15b5963c77d6ededf2fe06fd36ae8c5ce0e3c21d72f2d7f20cd9a8696fbb628df29299a6b836c418cbfe91e2b5be74bdfdb4efdd1b33f57ebb72c5246d5dce635529f1f69634d565a631e950d4a34a02281cbed177b5a624932c2bc02f0c8fd9afd332ccf93af5048f02b8bd72213d6a52930b0faa0926973883136d8530b8acf732aede8bb71cb187691ebd93a0ea8aeec7f82d0b8b74bcf010c8a38a1fa8 \u63a5\u4e0b\u6765\u6211\u4eec\u6765\u5206\u6790\u4e3b\u7a0b\u5e8f\u3002\u53ef\u4ee5\u770b\u51fa p , q , e = gen_key () n = p * q phi_n = ( p - 1 ) * ( q - 1 ) d = invmod ( e , phi_n ) while True : e2 = random . randint ( 0x1000 , 0x10000 ) if gcd ( e2 , phi_n ) == 1 : break \u6211\u4eec\u5f97\u5230\u7684 n=p \\times q n=p \\times q \u3002\u800c p\uff0cq \u4ee5\u53ca\u6211\u4eec\u5df2\u77e5\u7684 e \u90fd\u5728 gen_key \u51fd\u6570\u4e2d\u751f\u6210\u3002\u770b\u4e00\u770b gen_key \u51fd\u6570 def gen_key (): while True : p = getPrime ( k / 2 ) if gcd ( e , p - 1 ) == 1 : break q_t = getPrime ( k / 2 ) n_t = p * q_t t = get_bit ( n_t , k / 16 , 1 ) y = get_bit ( n_t , 5 * k / 8 , 0 ) p4 = get_bit ( p , 5 * k / 16 , 1 ) u = pi_b ( p4 , 1 ) n = bytes_to_long ( long_to_bytes ( t ) + long_to_bytes ( u ) + long_to_bytes ( y )) q = n / p if q % 2 == 0 : q += 1 while True : if isPrime ( q ) and gcd ( e , q - 1 ) == 1 : break m = getPrime ( k / 16 ) + 1 q ^= m return ( p , q , e ) \u5176\u4e2d\u6211\u4eec\u5df2\u77e5\u5982\u4e0b\u53c2\u6570 k=2048 e=0x10001 k=2048 e=0x10001 \u9996\u5148\uff0c\u7a0b\u5e8f\u5148\u5f97\u5230\u4e86 1024 \u6bd4\u7279\u4f4d\u7684\u7d20\u6570 p\uff0c\u5e76\u4e14 gcd(2,p-1)=1 \u3002 \u7136\u540e\uff0c\u7a0b\u5e8f\u53c8\u5f97\u5230\u4e86\u4e00\u4e2a 1024 \u6bd4\u7279\u4f4d\u7684\u7d20\u6570 q_t q_t \uff0c\u5e76\u4e14\u8ba1\u7b97 n_t=p \\times q_t n_t=p \\times q_t \u3002 \u4e0b\u9762\u591a\u6b21\u8c03\u7528\u4e86 get_bit \u51fd\u6570\uff0c\u6211\u4eec\u6765\u7b80\u5355\u5206\u6790\u4e00\u4e0b def get_bit ( number , n_bit , dire ): ''' dire: 1: left 0: right ''' if dire : sn = size ( number ) if sn % 8 != 0 : sn += ( 8 - sn % 8 ) return number >> ( sn - n_bit ) else : return number & ( pow ( 2 , n_bit ) - 1 ) \u53ef\u4ee5\u770b\u51fa\u6839\u636e dire(ction) \u7684\u4e0d\u540c\uff0c\u4f1a\u5f97\u5230\u4e0d\u540c\u7684\u6570 dire=1 \u65f6\uff0c\u7a0b\u5e8f\u9996\u5148\u8ba1\u7b97 number \u7684\u4e8c\u8fdb\u5236\u4f4d\u6570 sn \uff0c\u5982\u679c\u4e0d\u662f 8 \u7684\u6574\u6570\u500d\u7684\u8bdd\uff0c\u5c31\u5c06 sn \u589e\u5927\u4e3a 8 \u7684\u6574\u6570\u500d\uff0c\u7136\u540e\u8fd4\u56de number \u53f3\u79fb sn-n_bit \u7684\u6570\u5b57\u3002\u5176\u5b9e \u5c31\u662f\u6700\u591a\u4fdd\u7559 number \u7684 n_bit \u4f4d\u3002 dire=0 \u65f6\uff0c\u7a0b\u5e8f\u76f4\u63a5\u83b7\u53d6 number \u7684\u4f4e n_bit \u4f4d\u3002 \u7136\u540e\u6211\u4eec\u518d\u6765\u770b\u7a0b\u5e8f t = get_bit ( n_t , k / 16 , 1 ) y = get_bit ( n_t , 5 * k / 8 , 0 ) p4 = get_bit ( p , 5 * k / 16 , 1 ) \u8fd9\u4e09\u4e2a\u64cd\u4f5c\u5206\u522b\u505a\u4e86\u5982\u4e0b\u7684\u4e8b\u60c5 t \u4e3a n_t \u7684\u6700\u591a\u9ad8 k/16 \u4f4d\uff0c\u5373 128 \u4f4d\uff0c\u4f4d\u6570\u4e0d\u56fa\u5b9a\u3002 y \u4e3a n_t \u7684\u4f4e 5*k/8 \u4f4d\uff0c\u5373 1280 \u4f4d\uff0c\u4f4d\u6570\u56fa\u5b9a\u3002 p4 \u4e3a p \u7684\u6700\u591a\u9ad8 5*k/16 \u4f4d\uff0c\u5373 640 \u4f4d\uff0c\u4f4d\u6570\u4e0d\u56fa\u5b9a\u3002 \u6b64\u540e\uff0c\u7a0b\u5e8f\u6709\u5982\u4e0b\u64cd\u4f5c u = pi_b ( p4 , 1 ) \u5229\u7528 pi_b \u5bf9 p4 \u8fdb\u884c\u4e86\u52a0\u5bc6 def pi_b ( x , m ): ''' m: 1: encrypt 0: decrypt ''' enc = DES . new ( key ) if m : method = enc . encrypt else : method = enc . decrypt s = long_to_bytes ( x ) sp = [ s [ a : a + 8 ] for a in xrange ( 0 , len ( s ), 8 )] r = \"\" for a in sp : r += method ( a ) return bytes_to_long ( r ) \u5176\u4e2d\uff0c\u6211\u4eec\u5df2\u77e5\u4e86\u5bc6\u94a5 key\uff0c\u6240\u4ee5\u53ea\u8981\u6211\u4eec\u6709\u5bc6\u6587\u5c31\u53ef\u4ee5\u89e3\u5bc6\u3002\u6b64\u5916\uff0c\u53ef\u4ee5\u770b\u5230\u7684\u662f\u7a0b\u5e8f\u662f\u5bf9\u4f20\u5165\u7684\u6d88\u606f\u8fdb\u884c 8 \u5b57\u8282\u5206\u7ec4\uff0c\u91c7\u7528\u5bc6\u7801\u672c\u65b9\u5f0f\u52a0\u5bc6\uff0c\u6240\u4ee5\u5bc6\u6587\u4e4b\u95f4\u4e92\u4e0d\u5f71\u54cd\u3002 \u4e0b\u9762 n = bytes_to_long ( long_to_bytes ( t ) + long_to_bytes ( u ) + long_to_bytes ( y )) q = n / p if q % 2 == 0 : q += 1 while True : if isPrime ( q ) and gcd ( e , q - 1 ) == 1 : break m = getPrime ( k / 16 ) + 1 q ^= m return ( p , q , e ) \u7a0b\u5e8f\u5c06 t\uff0cu\uff0cy \u62fc\u63a5\u5728\u4e00\u8d77\u5f97\u5230 n\uff0c\u8fdb\u800c\uff0c\u7a0b\u5e8f\u5f97\u5230\u4e86 q\uff0c\u5e76\u5bf9 q \u7684\u4f4e k/16 \u4f4d\u505a\u4e86\u6291\u6216\uff0c\u7136\u540e\u8fd4\u56de q' \u3002 \u5728\u4e3b\u7a0b\u5e8f\u91cc\uff0c\u518d\u4e00\u6b21\u5f97\u5230\u4e86 n'=p*q' \u3002\u8fd9\u91cc\u6211\u4eec\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b n'=p * ( q + random(2^{k/16})) \u800c p \u662f k/2 \u4f4d\u7684\uff0c\u6240\u4ee5\u8bf4\uff0crandom \u7684\u90e8\u5206\u6700\u591a\u53ef\u4ee5\u5f71\u54cd\u539f\u6765\u7684 n \u7684\u6700\u4f4e\u7684 k/2+k/16=9k/16 k/2+k/16=9k/16 \u6bd4\u7279\u4f4d\u3002 \u800c\uff0c\u6211\u4eec\u8fd8\u77e5\u9053 n \u7684\u6700\u4f4e\u7684 5k/8=10k/16 \u6bd4\u7279\u4e3a\u5176\u5b9e\u5c31\u662f y\uff0c\u6240\u4ee5\u5176\u5e76\u6ca1\u6709\u5f71\u54cd\u5230 u\uff0c\u5373\u4f7f\u5f71\u54cd\u5230\u4e5f\u5c31\u6700\u591a\u5f71\u54cd\u5230\u4e00\u4f4d\u3002 \u6240\u4ee5\u6211\u4eec\u9996\u5148\u53ef\u4ee5\u5229\u7528\u6211\u4eec\u5f97\u5230\u7684 n \u6765\u83b7\u53d6 u\uff0c\u5982\u4e0b u=hex(n)[2:-1][-480:-320] \u867d\u7136\uff0c\u8fd9\u6837\u53ef\u80fd\u4f1a\u83b7\u5f97\u8f83\u591a\u4f4d\u6570\u7684 u\uff0c\u4f46\u662f\u8fd9\u6837\u5e76\u4e0d\u5f71\u54cd\uff0c\u6211\u4eec\u5bf9 u \u89e3\u5bc6\u7684\u65f6\u5019\u6bcf\u4e00\u5206\u7ec4\u90fd\u4e92\u4e0d\u5f71\u54cd\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u53ef\u80fd\u5f71\u54cd\u6700\u9ad8\u4f4d\u6570\u7684 p4\u3002\u800c p4 \u7684\u7684\u9ad8 8 \u4f4d\u4e5f\u6709\u53ef\u80fd\u662f\u586b\u5145\u7684\u3002\u4f46\u8fd9\u4e5f\u5e76\u4e0d\u5f71\u54cd\uff0c\u6211\u4eec\u5df2\u7ecf\u5f97\u5230\u4e86\u56e0\u5b50 p \u7684\u7684\u5f88\u591a\u90e8\u5206\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u53bb\u5c1d\u8bd5\u7740\u89e3\u5bc6\u4e86\u3002\u5982\u4e0b if __name__ == \"__main__\" : n = 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f u = hex ( n )[ 2 : - 1 ][ - 480 : - 320 ] u = int ( u , 16 ) p4 = pi_b ( u , 0 ) print hex ( p4 ) \u89e3\u5bc6\u7ed3\u679c\u5982\u4e0b \u279c 2016 - HCTF - RSA2 git :( master ) \u2717 python exp_p4 . py 0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde1362693 L \u4e0b\u9762\uff0c\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 sage \u6765\u89e3\u5bc6\uff0c\u8fd9\u91cc sage \u91cc\u9762\u5df2\u7ecf\u5b9e\u73b0\u4e86\u8fd9\u4e2a\u653b\u51fb\uff0c\u6211\u4eec\u76f4\u63a5\u62ff\u6765\u7528\u5c31\u597d from sage.all import * import binascii n = 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f p4 = 0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde1362693 cipher = 0xf11e932fa420790ca3976468dc4df1e6b20519ebfdc427c09e06940e1ef0ca566d41714dc1545ddbdcae626eb51c7fa52608384a36a2a021960d71023b5d0f63e6b38b46ac945ddafea42f01d24cc33ce16825df7aa61395d13617ae619dca2df15b5963c77d6ededf2fe06fd36ae8c5ce0e3c21d72f2d7f20cd9a8696fbb628df29299a6b836c418cbfe91e2b5be74bdfdb4efdd1b33f57ebb72c5246d5dce635529f1f69634d565a631e950d4a34a02281cbed177b5a624932c2bc02f0c8fd9afd332ccf93af5048f02b8bd72213d6a52930b0faa0926973883136d8530b8acf732aede8bb71cb187691ebd93a0ea8aeec7f82d0b8b74bcf010c8a38a1fa8 e2 = 0xf93b pbits = 1024 kbits = pbits - p4 . nbits () print p4 . nbits () p4 = p4 << kbits PR .< x > = PolynomialRing ( Zmod ( n )) f = x + p4 roots = f . small_roots ( X = 2 ^ kbits , beta = 0.4 ) if roots : p = p4 + int ( roots [ 0 ]) print \"p: \" , hex ( int ( p )) assert n % p == 0 q = n / int ( p ) print \"q: \" , hex ( int ( q )) print gcd ( p , q ) phin = ( p - 1 ) * ( q - 1 ) print gcd ( e2 , phin ) d = inverse_mod ( e2 , phin ) flag = pow ( cipher , d , n ) flag = hex ( int ( flag ))[ 2 : - 1 ] print binascii . unhexlify ( flag ) \u5173\u4e8e small_roots \u7684\u4f7f\u7528\uff0c\u53ef\u4ee5\u53c2\u8003 SAGE \u8bf4\u660e \u3002 \u7ed3\u679c\u5982\u4e0b \u279c 2016 -HCTF-RSA2 git: ( master ) \u2717 sage payload.sage sys:1: RuntimeWarning: not adding directory '' to sys.path since everybody can write to it. Untrusted users could put files in this directory which might then be imported by your Python code. As a general precaution from similar exploits, you should not execute Python code from this directory 640 p: 0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde13626933aa6762057e1df53d27356ee6a09b17ef4f4986d862e3bb24f99446a0ab2385228295f4b776c1f391ab2a0d8c0dec1e5L q: 0xb306030a7c6ace771db8adb45fae597f3c1be739d79fd39dfa6fd7f8c177e99eb29f0462c3f023e0530b545df6e656dadb984953c265b26f860b68aa6d304fa403b0b0e37183008592ec2a333c431e2906c9859d7cbc4386ef4c4407ead946d855ecd6a8b2067ad8a99b21111b26905fcf0d53a1b893547b46c3142b06061853L 1 1 hctf { d8e8fca2dc0f896fd7cb4cb0031ba249 } \u9898\u76ee \u00b6 2016 \u6e56\u6e58\u676f \u7b80\u5355\u7684 RSA 2017 WHCTF Untitled Boneh and Durfee attack \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5f53 d \u8f83\u5c0f\u65f6\uff0c\u6ee1\u8db3 d < N^{0.292} d < N^{0.292} \u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u8be5\u653b\u51fb\uff0c\u6bd4 Wiener's Attack \u8981\u5f3a\u4e00\u4e9b\u3002 \u653b\u51fb\u539f\u7406 \u00b6 \u8fd9\u91cc\u7b80\u5355\u8bf4\u4e00\u4e0b\u539f\u7406\u3002 \u9996\u5148 ed \\equiv 1 \\bmod \\varphi(N)/2 ed \\equiv 1 \\bmod \\varphi(N)/2 \u8fdb\u800c\u6709 ed +k\\varphi(N)/2=1 ed +k\\varphi(N)/2=1 \u5373 k \\varphi(N)/2 \\equiv 1 \\bmod e k \\varphi(N)/2 \\equiv 1 \\bmod e \u53c8 \\varphi(N)=(p-1)(q-1)=qp-p-q+1=N-p-q+1 \\varphi(N)=(p-1)(q-1)=qp-p-q+1=N-p-q+1 \u6240\u4ee5 k(N-p-q+1)/2 \\equiv 1 \\bmod e k(N-p-q+1)/2 \\equiv 1 \\bmod e \u5047\u8bbe A=\\frac{N+1}{2} A=\\frac{N+1}{2} \uff0c y=\\frac{-p-q}{2} y=\\frac{-p-q}{2} \uff0c\u539f\u5f0f\u53ef\u5316\u4e3a f(k,y)=k(A+y) \\equiv 1 \\bmod e f(k,y)=k(A+y) \\equiv 1 \\bmod e \u5176\u4e2d |k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta} |k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta} |y|<2*N^{0.5} |y|<2*N^{0.5} y \u7684\u4f30\u8ba1\u7528\u5230\u4e86 p\u3001q \u6bd4\u8f83\u5747\u5300\u7684\u5047\u8bbe\u3002\u8fd9\u91cc delta \u4e3a\u9884\u4f30\u7684\u5c0f\u4e8e 0.292 \u7684\u503c\u3002 \u5982\u679c\u6211\u4eec\u6c42\u5f97\u4e86\u8be5\u4e8c\u5143\u65b9\u7a0b\u7684\u6839\uff0c\u90a3\u4e48\u6211\u4eec\u81ea\u7136\u4e5f\u5c31\u53ef\u4ee5\u89e3\u4e00\u5143\u4e8c\u6b21\u65b9\u7a0b N=pq,p+q=-2y N=pq,p+q=-2y \u6765\u5f97\u5230 p \u4e0e q\u3002 \u66f4\u52a0\u5177\u4f53\u7684\u63a8\u5bfc\uff0c\u53c2\u8003 New Results on the Cryptanalysis of Low Exponent RSA. \u653b\u51fb\u5de5\u5177 \u00b6 \u8bf7\u53c2\u8003 https://github.com/mimoo/RSA-and-LLL-attacks \u3002\u4e0a\u9762\u6709\u4f7f\u7528\u6559\u7a0b\u3002 2015 PlaidCTF Curious \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 2015 \u5e74 PlaidCTF Curious \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002 \u9996\u5148\u9898\u76ee\u7ed9\u4e86\u4e00\u5806 N\uff0ce\uff0cc\u3002\u7b80\u5355\u770b\u4e00\u4e0b\u53ef\u4ee5\u53d1\u73b0\u8be5 e \u6bd4\u8f83\u5927\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4f7f\u7528 Wiener's Attack\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u66f4\u5f3a\u7684\u76ee\u524d\u4ecb\u7ecd\u7684\u653b\u51fb\u3002 \u6838\u5fc3\u4ee3\u7801\u5982\u4e0b nlist = list () elist = list () clist = list () with open ( 'captured' ) as f : # read the line {N : e : c} and do nothing with it f . readline () for i in f . readlines (): ( N , e , c ) = i [ 1 : - 2 ] . split ( \" : \" ) nlist . append ( long ( N , 16 )) elist . append ( long ( e , 16 )) clist . append ( long ( c , 16 )) for i in range ( len ( nlist )): print 'index i' n = nlist [ i ] e = elist [ i ] c = clist [ i ] d = solve ( n , e ) if d == 0 : continue else : m = power_mod ( c , d , n ) hex_string = \" %x \" % m import binascii print \"the plaintext:\" , binascii . unhexlify ( hex_string ) return \u7ed3\u679c\u5982\u4e0b === solution found === private key found: 23974584842546960047080386914966001070087596246662608796022581200084145416583 the plaintext: flag_S0Y0UKN0WW13N3R $4 TT4CK! 2019 Defcon Quals ASRybaB \u00b6 \u9898\u76ee\u5927\u6982\u610f\u601d\u662f\uff0c\u6211\u4eec\u63a5\u6536\u4e09\u5bf9 RSA \uff0c\u7136\u540e\u9700\u8981\u6c42\u51fa d\uff0c\u7136\u540e\u5bf9\u7ed9\u5b9a\u7684\u6570\u5b57 v[i] \u52a0\u5bc6\uff0c\u53d1\u9001\u7ed9\u670d\u52a1\u5668\uff0c\u53ea\u8981\u65f6\u95f4\u5728\u4e00\u5b9a\u8303\u56f4\u5185\uff0c940s\uff0c\u5373\u53ef\u3002\u90a3\u96be\u70b9\u81ea\u7136\u5728 create_key \u51fd\u6570\u4e86\u3002 def send_challenges (): code = marshal . loads ( \"63000000000d000000070000004300000073df010000740000721d0064010064020015000000000100640200157d00006e00007401007d01007c0100640300157d02006402007d0300786f007c03006a02008300007c01006b030072a400784c007403007296007404006a05007c02008301007d04007404006a05007c02008301007d05007406007c04007c0500188301006a02008300007c0100640400146b0400724b0050714b00714b00577c04007c0500147d0300713600577c0400640500187c050064050018147d06006406007d07006407007d080078090174030072ce017404006a07007408006403007409007c01007c0700148301008302007408006403007409007c01007c070014830100640500178302008302007d09007871007c09006a02008300007c01007c0800146b0000727b016402007d0a007844007404006a0a007c0a00830100736d017404006a0700740800640300640800830200740800640300640800830200740800640300640900830200178302007d0a00712a01577c09007c0a00397d0900710b01577404006a0b007c09007c06008302006405006b0300729a0171c6006e00007404006a0c007c09007c06008302007d0b007404006a0b007c0b007c06008302006405006b030072ca0171c6006e00005071c60057640a007d0c007c03007c0b0066020053280b0000004e690700000069000000006902000000675839b4c876bedf3f6901000000674e62105839b4d03f678d976e1283c0d23f692d000000690c0000006903000000280d000000740500000046616c736574050000004e53495a45740a0000006269745f6c656e67746874040000005472756574060000006e756d626572740e0000006765745374726f6e675072696d657403000000616273740e00000067657452616e646f6d52616e67657403000000706f777403000000696e74740700000069735072696d6574030000004743447407000000696e7665727365280d00000074010000007874050000004e73697a657406000000707173697a6574010000004e740100000070740100000071740300000070686974060000006c696d69743174060000006c696d697432740100000064740300000070707074010000006574030000007a7a7a2800000000280000000073150000002f6f726967696e616c6368616c6c656e67652e7079740a0000006372656174655f6b657917000000733e000000000106010a010d0206010a010601150109010f010f04200108010e0112020601060109013c0119010601120135020e011801060112011801060105020604\" . decode ( \"hex\" )) create_key = types . FunctionType ( code , globals (), \"create_key\" ) ck = create_key \u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u770b\u770b\u8fd9\u4e2a\u5230\u5e95\u662f\u5728\u5e72\u5565 >>> import marshal >>> data = \"63000000000d000000070000004300000073df010000740000721d0064010064020015000000000100640200157d00006e00007401007d01007c0100640300157d02006402007d0300786f007c03006a02008300007c01006b030072a400784c007403007296007404006a05007c02008301007d04007404006a05007c02008301007d05007406007c04007c0500188301006a02008300007c0100640400146b0400724b0050714b00714b00577c04007c0500147d0300713600577c0400640500187c050064050018147d06006406007d07006407007d080078090174030072ce017404006a07007408006403007409007c01007c0700148301008302007408006403007409007c01007c070014830100640500178302008302007d09007871007c09006a02008300007c01007c0800146b0000727b016402007d0a007844007404006a0a007c0a00830100736d017404006a0700740800640300640800830200740800640300640800830200740800640300640900830200178302007d0a00712a01577c09007c0a00397d0900710b01577404006a0b007c09007c06008302006405006b0300729a0171c6006e00007404006a0c007c09007c06008302007d0b007404006a0b007c0b007c06008302006405006b030072ca0171c6006e00005071c60057640a007d0c007c03007c0b0066020053280b0000004e690700000069000000006902000000675839b4c876bedf3f6901000000674e62105839b4d03f678d976e1283c0d23f692d000000690c0000006903000000280d000000740500000046616c736574050000004e53495a45740a0000006269745f6c656e67746874040000005472756574060000006e756d626572740e0000006765745374726f6e675072696d657403000000616273740e00000067657452616e646f6d52616e67657403000000706f777403000000696e74740700000069735072696d6574030000004743447407000000696e7665727365280d00000074010000007874050000004e73697a657406000000707173697a6574010000004e740100000070740100000071740300000070686974060000006c696d69743174060000006c696d697432740100000064740300000070707074010000006574030000007a7a7a2800000000280000000073150000002f6f726967696e616c6368616c6c656e67652e7079740a0000006372656174655f6b657917000000733e000000000106010a010d0206010a010601150109010f010f04200108010e0112020601060109013c0119010601120135020e011801060112011801060105020604\" >>> code = marshal . loads ( data ) >>> code = marshal . loads ( data . decode ( 'hex' )) >>> import dis >>> dis . dis ( code ) 24 0 LOAD_GLOBAL 0 ( False ) 3 POP_JUMP_IF_FALSE 29 25 6 LOAD_CONST 1 ( 7 ) 9 LOAD_CONST 2 ( 0 ) 12 BINARY_DIVIDE 13 STOP_CODE 14 STOP_CODE 15 STOP_CODE ... 56 428 LOAD_GLOBAL 4 ( number ) 431 LOAD_ATTR 11 ( GCD ) 434 LOAD_FAST 11 ( e ) 437 LOAD_FAST 6 ( phi ) 440 CALL_FUNCTION 2 443 LOAD_CONST 5 ( 1 ) 446 COMPARE_OP 3 ( != ) 449 POP_JUMP_IF_FALSE 458 ... \u57fa\u672c\u53ef\u4ee5\u731c\u51fa\u6765\u8fd9\u662f\u5728\u751f\u6210 n\uff0ce\uff0cd\uff0c\u5176\u5b9e\u548c\u6211\u4eec\u6700\u521d\u7684\u9884\u671f\u4e5f\u5dee\u4e0d\u591a\u3002\u6211\u4eec\u6765\u76f4\u63a5\u53cd\u7f16\u8bd1\u4e00\u4e0b >>> from uncompyle6 import code_deparse >>> code_deparse ( code ) Instruction context : 25 6 LOAD_CONST 1 7 9 LOAD_CONST 2 0 12 BINARY_DIVIDE -> 13 STOP_CODE 14 STOP_CODE 15 STOP_CODE Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/local/lib/python2.7/site-packages/uncompyle6/semantics/pysource.py\" , line 2310 , in code_deparse deparsed . ast = deparsed . build_ast ( tokens , customize , isTopLevel = isTopLevel ) File \"/usr/local/lib/python2.7/site-packages/uncompyle6/semantics/pysource.py\" , line 2244 , in build_ast raise ParserError ( e , tokens ) uncompyle6 . semantics . parser_error . ParserError : --- This code section failed : --- ... 64 469 LOAD_FAST 3 'N' 472 LOAD_FAST 11 'e' 475 BUILD_TUPLE_2 2 None 478 RETURN_VALUE - 1 RETURN_LAST Parse error at or near ` STOP_CODE ' instruction at offset 13 \u53ef\u4ee5\u53d1\u73b0 STOP_CODE\uff0c\u6709\u70b9\u732b\u817b\uff0c\u5982\u679c\u4ed4\u7ec6\u770b\u6700\u521d\u7684\u53cd\u6c47\u7f16\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u6700\u524d\u9762\u7684\u90a3\u90e8\u5206\u4ee3\u7801\u662f\u5728\u6df7\u6dc6 >>> dis . dis ( code ) 24 0 LOAD_GLOBAL 0 ( False ) 3 POP_JUMP_IF_FALSE 29 25 6 LOAD_CONST 1 ( 7 ) 9 LOAD_CONST 2 ( 0 ) 12 BINARY_DIVIDE 13 STOP_CODE 14 STOP_CODE 15 STOP_CODE 26 16 STOP_CODE 17 POP_TOP 18 STOP_CODE 19 LOAD_CONST 2 ( 0 ) 22 BINARY_DIVIDE 23 STORE_FAST 0 ( x ) 26 JUMP_FORWARD 0 ( to 29 ) 28 >> 29 LOAD_GLOBAL 1 ( NSIZE ) 32 STORE_FAST 1 ( Nsize ) 29 35 LOAD_FAST 1 ( Nsize ) 38 LOAD_CONST 3 ( 2 ) 41 BINARY_DIVIDE 42 STORE_FAST 2 ( pqsize ) \u4e00\u76f4\u5230 29 35 LOAD_FAST 1 ( Nsize ) \u524d\u9762\u7684\u90fd\u6ca1\u6709\u4ec0\u4e48\u4f5c\u7528\uff0c\u611f\u89c9\u662f\u51fa\u9898\u8005\u6545\u610f\u4fee\u6539\u4e86\u4ee3\u7801\u3002\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u8fd9\u90e8\u5206\u4ee3\u7801\uff0c\u611f\u89c9\u50cf\u662f\u4e24\u90e8\u5206 # part 1 25 6 LOAD_CONST 1 ( 7 ) 9 LOAD_CONST 2 ( 0 ) 12 BINARY_DIVIDE 13 STOP_CODE 14 STOP_CODE 15 STOP_CODE # part 2 26 16 STOP_CODE 17 POP_TOP 18 STOP_CODE 19 LOAD_CONST 2 ( 0 ) 22 BINARY_DIVIDE 23 STORE_FAST 0 ( x ) 26 JUMP_FORWARD 0 ( to 29 ) \u6b63\u597d\u662f\u7b2c 25 \u884c\u548c\u7b2c 26 \u884c\uff0c\u5927\u6982\u731c\u4e00\u731c\uff0c\u611f\u89c9\u4e24\u4e2a\u90fd\u662f x=7/0\uff0c\u6240\u4ee5\u5c31\u60f3\u529e\u6cd5\u628a\u8fd9\u90e8\u5206\u7684\u4ee3\u7801\u4fee\u590d\u4e00\u4e0b\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5b9a\u4f4d\u8fd9\u90e8\u5206\u4ee3\u7801\u4e86\u3002\u6839\u636e\u624b\u518c\u53ef\u4ee5\u77e5\u9053 STOP_CODE \u662f 0\uff0c\u4ece\u800c\u6211\u4eec\u53ef\u4ee5\u5b9a\u4f4d\u7b2c 25 \u884c\u8bed\u53e5\u5230 26 \u884c\u8bed\u53e5\u4e3a t[6:26]\uff0c\u4ed6\u4eec\u5206\u522b\u90fd\u662f 10 \u5b57\u8282(6-15,16-25)\u3002 >>> t = code . co_code >>> t 't \\x00\\x00 r \\x1d\\x00 d \\x01\\x00 d \\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00 d \\x02\\x00\\x15 } \\x00\\x00 n \\x00\\x00 t \\x01\\x00 } \\x01\\x00 | \\x01\\x00 d \\x03\\x00\\x15 } \\x02\\x00 d \\x02\\x00 } \\x03\\x00 xo \\x00 | \\x03\\x00 j \\x02\\x00\\x83\\x00\\x00 | \\x01\\x00 k \\x03\\x00 r \\xa4\\x00 xL \\x00 t \\x03\\x00 r \\x96\\x00 t \\x04\\x00 j \\x05\\x00 | \\x02\\x00\\x83\\x01\\x00 } \\x04\\x00 t \\x04\\x00 j \\x05\\x00 | \\x02\\x00\\x83\\x01\\x00 } \\x05\\x00 t \\x06\\x00 | \\x04\\x00 | \\x05\\x00\\x18\\x83\\x01\\x00 j \\x02\\x00\\x83\\x00\\x00 | \\x01\\x00 d \\x04\\x00\\x14 k \\x04\\x00 rK \\x00 PqK \\x00 qK \\x00 W| \\x04\\x00 | \\x05\\x00\\x14 } \\x03\\x00 q6 \\x00 W| \\x04\\x00 d \\x05\\x00\\x18 | \\x05\\x00 d \\x05\\x00\\x18\\x14 } \\x06\\x00 d \\x06\\x00 } \\x07\\x00 d \\x07\\x00 } \\x08\\x00 x \\t\\x01 t \\x03\\x00 r \\xce\\x01 t \\x04\\x00 j \\x07\\x00 t \\x08\\x00 d \\x03\\x00 t \\t\\x00 | \\x01\\x00 | \\x07\\x00\\x14\\x83\\x01\\x00\\x83\\x02\\x00 t \\x08\\x00 d \\x03\\x00 t \\t\\x00 | \\x01\\x00 | \\x07\\x00\\x14\\x83\\x01\\x00 d \\x05\\x00\\x17\\x83\\x02\\x00\\x83\\x02\\x00 } \\t\\x00 xq \\x00 | \\t\\x00 j \\x02\\x00\\x83\\x00\\x00 | \\x01\\x00 | \\x08\\x00\\x14 k \\x00\\x00 r{ \\x01 d \\x02\\x00 } \\n\\x00 xD \\x00 t \\x04\\x00 j \\n\\x00 | \\n\\x00\\x83\\x01\\x00 sm \\x01 t \\x04\\x00 j \\x07\\x00 t \\x08\\x00 d \\x03\\x00 d \\x08\\x00\\x83\\x02\\x00 t \\x08\\x00 d \\x03\\x00 d \\x08\\x00\\x83\\x02\\x00 t \\x08\\x00 d \\x03\\x00 d \\t\\x00\\x83\\x02\\x00\\x17\\x83\\x02\\x00 } \\n\\x00 q* \\x01 W| \\t\\x00 | \\n\\x00 9} \\t\\x00 q \\x0b\\x01 Wt \\x04\\x00 j \\x0b\\x00 | \\t\\x00 | \\x06\\x00\\x83\\x02\\x00 d \\x05\\x00 k \\x03\\x00 r \\x9a\\x01 q \\xc6\\x00 n \\x00\\x00 t \\x04\\x00 j \\x0c\\x00 | \\t\\x00 | \\x06\\x00\\x83\\x02\\x00 } \\x0b\\x00 t \\x04\\x00 j \\x0b\\x00 | \\x0b\\x00 | \\x06\\x00\\x83\\x02\\x00 d \\x05\\x00 k \\x03\\x00 r \\xca\\x01 q \\xc6\\x00 n \\x00\\x00 Pq \\xc6\\x00 Wd \\n\\x00 } \\x0c\\x00 | \\x03\\x00 | \\x0b\\x00 f \\x02\\x00 S' >>> t [ 6 : 26 ] 'd \\x01\\x00 d \\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00 d \\x02\\x00\\x15 } \\x00\\x00 ' >>> t [ - 3 :] ' \\x02\\x00 S' >>> t = 'd \\x01\\x00 d \\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00 d \\x02\\x00\\x15 } \\x00\\x00 ' >>> t [ - 3 :] '} \\x00\\x00 ' >>> t [: 7 ] + t [ - 3 :] 'd \\x01\\x00 d \\x02\\x00\\x15 } \\x00\\x00 ' >>> _ . encode ( 'hex' ) '640100640200157d0000' \u4ece\u800c\u6211\u4eec\u53ef\u4ee5\u4fee\u590d\u539f code >>> data . find ( '640100' ) 56 >>> data1 = data [: 56 ] + '640100640200157d0000640100640200157d0000' + data [ 56 + 40 :] >>> code1 = marshal . loads ( data1 . decode ( 'hex' )) >>> code_deparse ( code1 ) if False : x = 7 / 0 x = 7 / 0 Nsize = NSIZE pqsize = Nsize / 2 N = 0 while N . bit_length () != Nsize : while True : p = number . getStrongPrime ( pqsize ) q = number . getStrongPrime ( pqsize ) if abs ( p - q ) . bit_length () > Nsize * 0.496 : break N = p * q phi = ( p - 1 ) * ( q - 1 ) limit1 = 0.261 limit2 = 0.293 while True : d = number . getRandomRange ( pow ( 2 , int ( Nsize * limit1 )), pow ( 2 , int ( Nsize * limit1 ) + 1 )) while d . bit_length () < Nsize * limit2 : ppp = 0 while not number . isPrime ( ppp ): ppp = number . getRandomRange ( pow ( 2 , 45 ), pow ( 2 , 45 ) + pow ( 2 , 12 )) d *= ppp if number . GCD ( d , phi ) != 1 : continue e = number . inverse ( d , phi ) if number . GCD ( e , phi ) != 1 : continue break zzz = 3 return ( N , e ) < uncompyle6 . semantics . pysource . SourceWalker object at 0x10a0ea110 > \u53ef\u4ee5\u770b\u5230\u751f\u6210\u7684 d \u662f\u6545\u610f\u8d85\u4e86 0.292 \u7684\uff0c\u4e0d\u8fc7\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 ppp \u8303\u56f4\u5f88\u5c0f\uff0c\u5b9e\u9645\u4e0a\u6211\u4eec\u53ef\u4ee5\u6d4b\u8bd5\u5f97\u5230\u8fd9\u4e2a\u8303\u56f4\u7684\u7d20\u6570\u4e3a 125 \u4e2a\u3002\u5e76\u4e14 1280 * 0.261 + 45 = 379.08000000000004 > 375.03999999999996 = 1280 * 0.293 \u6240\u4ee5\u5176\u5b9e\u8fd9\u91cc\u5c31\u4e58\u4e86\u4e00\u4e2a\u6570\uff0c\u90a3\u4e48\u6211\u4eec\u5176\u5b9e\u5c31\u53ef\u4ee5\u679a\u4e3e\u4e00\u4e0b\u4e58\u4e86\u4ec0\u4e48\uff0c\u5e76\u4fee\u6539 e1=e*ppp\uff0c\u5176\u5b9e\u5c31\u56de\u5f52\u5230\u6807\u51c6\u7684 Boneh and Durfee attack\u3002 \u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 https://github.com/mimoo/RSA-and-LLL-attacks \u7684\u811a\u672c\u4e5f\u4e0d\u884c\uff0c\u5fc5\u987b\u5f97\u63d0\u9ad8 m\uff0c\u57fa\u672c\u5f97\u63d0\u5230 8\uff0c\u8fd9\u6837\u4ecd\u7136\u4e0d\u662f\u5f88\u7a33\u5b9a\u3002 \u5982\u679c\u4ed4\u7ec6\u5c1d\u8bd5\u5c1d\u8bd5\u7684\u8bdd\uff0c\u5c31\u4f1a\u53d1\u73b0 e1>N\uff0c\u8fd9\u770b\u8d77\u6765\u95ee\u9898\u4e0d\u5927\uff0c\u4f46\u662f\u539f\u811a\u672c\u91cc\u5047\u8bbe\u7684\u6570\u503c\u662f e<N \u7684\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u8fdb\u884c\u9002\u5f53\u7684\u4fee\u6539\u9884\u4f30\u7684\u4e0a\u4e0b\u754c X = 2 * floor ( N ^ delta ) # this _might_ be too much Y = floor ( N ^ ( 1 / 2 )) # correct if p, q are ~ same size \u6839\u636e\u4e0a\u8ff0\u63a8\u5bfc\uff0c\u4e0a\u4e0b\u754c\u5e94\u8be5\u4e3a |k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta} |k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta} |y|<2*N^{0.5} |y|<2*N^{0.5} \u6700\u540e\u4e3b\u8981\u4fee\u6539\u4e86 m \u548c X \u7684\u4e0a\u754c delta = . 262 # this means that d < N^delta # # Lattice (tweak those values) # # you should tweak this (after a first run), (e.g. increment it until a solution is found) m = 8 # size of the lattice (bigger the better/slower) # you need to be a lattice master to tweak these t = int (( 1 - 2 * delta ) * m ) # optimization from Herrmann and May X = floor ( 3 * e / N * N ^ delta ) #4*floor(N^delta) # this _might_ be too much Y = floor ( 2 * N ^ ( 1 / 2 )) # correct if p, q are ~ same size \u6700\u540e\u53ef\u4ee5\u5f97\u5230\u7ed3\u679c [ DEBUG ] Received 0x1f bytes: 'Succcess!\\n' 'OOO{Br3akingL!mits?}\\n' OOO { Br3akingL!mits? } \u4e0d\u5f97\u4e0d\u8bf4\u8fd9\u4e2a\u9898\u76ee\uff0c\u771f\u7684\u662f\u9700\u8981 \u591a \u6838\u670d\u52a1\u5668\u3002\u3002 \u53c2\u8003\u8d44\u6599 \u00b6 Survey: Lattice Reduction Attacks on RSA An Introduction to Coppersmith\u2019s method and Applications in Cryptology","title":"Rsa coppersmith attack zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#coppersmith","text":"","title":"Coppersmith \u76f8\u5173\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_1","text":"Coppersmith \u76f8\u5173\u653b\u51fb\u4e0e Don Coppersmith \u7d27\u5bc6\u76f8\u5173\uff0c\u4ed6\u63d0\u51fa\u4e86\u4e00\u79cd\u9488\u5bf9\u4e8e\u6a21\u591a\u9879\u5f0f\uff08\u5355\u53d8\u91cf\uff0c\u4e8c\u5143\u53d8\u91cf\uff0c\u751a\u81f3\u591a\u5143\u53d8\u91cf\uff09\u627e\u6240\u6709\u5c0f\u6574\u6570\u6839\u7684\u591a\u9879\u5f0f\u65f6\u95f4\u7684\u65b9\u6cd5\u3002 \u8fd9\u91cc\u6211\u4eec\u4ee5\u5355\u53d8\u91cf\u4e3a\u4e3b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u5047\u8bbe \u6a21\u6570\u4e3a N \uff0cN \u5177\u6709\u4e00\u4e2a\u56e0\u5b50 b\\geq N^{\\beta},0< \\beta \\leq 1 b\\geq N^{\\beta},0< \\beta \\leq 1 \u591a\u9879\u5f0f F \u7684\u6b21\u6570\u4e3a \\delta \\delta \u90a3\u4e48\u8be5\u65b9\u6cd5\u53ef\u4ee5\u5728 O(c\\delta^5log^9(N)) O(c\\delta^5log^9(N)) \u7684\u590d\u6742\u5ea6\u5185\u627e\u5230\u8be5\u591a\u9879\u5f0f\u6240\u6709\u7684\u6839 x_0 x_0 \uff0c\u8fd9\u91cc\u6211\u4eec\u8981\u6c42 |x_0|<cN^{\\frac{\\beta^2}{\\delta}} |x_0|<cN^{\\frac{\\beta^2}{\\delta}} \u3002 \u5728\u8fd9\u4e2a\u95ee\u9898\u4e2d\uff0c\u6211\u4eec\u7684\u76ee\u6807\u662f\u627e\u5230\u5728\u6a21 N \u610f\u4e49\u4e0b\u591a\u9879\u5f0f\u6240\u6709\u7684\u6839\uff0c\u8fd9\u4e00\u95ee\u9898\u88ab\u8ba4\u4e3a\u662f\u590d\u6742\u7684\u3002 Coppersmith method \u4e3b\u8981\u662f\u901a\u8fc7 Lenstra\u2013Lenstra\u2013Lov\u00e1sz lattice basis reduction algorithm \uff08LLL\uff09\u65b9\u6cd5\u627e\u5230 \u4e0e\u8be5\u591a\u9879\u5f0f\u5177\u6709\u76f8\u540c\u6839 x_0 x_0 \u66f4\u5c0f\u7cfb\u6570 \u5b9a\u4e49\u57df\u4e3a\u6574\u6570\u57df \u7684\u591a\u9879\u5f0f g\uff0c\u7531\u4e8e\u5728\u6574\u6570\u57df\u4e0a\u627e\u591a\u9879\u5f0f\u7684\u6839\u662f\u7b80\u5355\u7684\uff08Berlekamp\u2013Zassenhaus\uff09\uff0c\u4ece\u800c\u6211\u4eec\u5c31\u5f97\u5230\u4e86\u539f\u591a\u9879\u5f0f\u5728\u6a21\u610f\u4e49\u4e0b\u7684\u6574\u6570\u6839\u3002 \u90a3\u4e48\u95ee\u9898\u7684\u5173\u952e\u5c31\u662f\u5982\u4f55\u5c06 f \u8f6c\u6362\u5230 g \u5462\uff1fHowgrave-Graham \u7ed9\u51fa\u4e86\u4e00\u79cd\u601d\u8def \u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u9700\u8981\u627e\u5230\u4e00\u4e2a\u5177\u6709\u201c\u66f4\u5c0f\u7cfb\u6570\u201d\u7684\u591a\u9879\u5f0f g\uff0c\u4e5f\u5c31\u662f\u4e0b\u9762\u7684\u8f6c\u6362\u65b9\u5f0f \u5728 LLL \u7b97\u6cd5\u4e2d\uff0c\u6709\u4e24\u70b9\u662f\u975e\u5e38\u6709\u7528\u7684 \u53ea\u5bf9\u539f\u6765\u7684\u57fa\u5411\u91cf\u8fdb\u884c\u6574\u6570\u7ebf\u6027\u53d8\u6362\uff0c\u8fd9\u53ef\u4ee5\u4f7f\u5f97\u6211\u4eec\u5728\u5f97\u5230 g \u65f6\uff0c\u4ecd\u7136\u4ee5\u539f\u6765\u7684 x_0 x_0 \u4e3a\u6839\u3002 \u751f\u6210\u7684\u65b0\u7684\u57fa\u5411\u91cf\u7684\u6a21\u957f\u662f\u6709\u754c\u7684\uff0c\u8fd9\u53ef\u4ee5\u4f7f\u5f97\u6211\u4eec\u5229\u7528 Howgrave-Graham \u5b9a\u7406\u3002 \u5728\u8fd9\u6837\u7684\u57fa\u7840\u4e4b\u4e0a\uff0c\u6211\u4eec\u518d\u6784\u9020\u51fa\u591a\u9879\u5f0f\u65cf g \u5c31\u53ef\u4ee5\u4e86\u3002 \u5173\u4e8e\u66f4\u52a0\u7ec6\u8282\u7684\u5185\u5bb9\uff0c\u8bf7\u81ea\u884c\u641c\u7d22\u3002\u540c\u65f6\u8fd9\u90e8\u5206\u5185\u5bb9\u4e5f\u4f1a\u4e0d\u65ad\u66f4\u65b0\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u7531\u4e8e Coppersmith \u6839\u7684\u7ea6\u675f\uff0c\u5728 RSA \u4e2d\u7684\u5e94\u7528\u65f6\uff0c\u5f80\u5f80\u53ea\u9002\u7528\u4e8e e \u8f83\u5c0f\u7684\u60c5\u51b5\u3002","title":"\u57fa\u672c\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#basic-broadcast-attack","text":"","title":"Basic Broadcast Attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_2","text":"\u5982\u679c\u4e00\u4e2a\u7528\u6237\u4f7f\u7528\u540c\u4e00\u4e2a\u52a0\u5bc6\u6307\u6570 e \u52a0\u5bc6\u4e86\u540c\u4e00\u4e2a\u5bc6\u6587\uff0c\u5e76\u53d1\u9001\u7ed9\u4e86\u5176\u4ed6 e \u4e2a\u7528\u6237\u3002\u90a3\u4e48\u5c31\u4f1a\u4ea7\u751f\u5e7f\u64ad\u653b\u51fb\u3002\u8fd9\u4e00\u653b\u51fb\u7531 H\u00e5stad \u63d0\u51fa\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_3","text":"\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe e \u4e3a 3\uff0c\u5e76\u4e14\u52a0\u5bc6\u8005\u4f7f\u7528\u4e86\u4e09\u4e2a\u4e0d\u540c\u7684\u6a21\u6570 n_1,n_2,n_3 n_1,n_2,n_3 \u7ed9\u4e09\u4e2a\u4e0d\u540c\u7684\u7528\u6237\u53d1\u9001\u4e86\u52a0\u5bc6\u540e\u7684\u6d88\u606f m\uff0c\u5982\u4e0b \\begin{align*} c_1&=m^3\\bmod n_1 \\\\ c_2&=m^3\\bmod n_2 \\\\ c_3&=m^3\\bmod n_3 \\end{align*} \\begin{align*} c_1&=m^3\\bmod n_1 \\\\ c_2&=m^3\\bmod n_2 \\\\ c_3&=m^3\\bmod n_3 \\end{align*} \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe n_1,n_2,n_3\u200b n_1,n_2,n_3\u200b \u4e92\u7d20\uff0c\u4e0d\u7136\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fdb\u884c\u5206\u89e3\uff0c\u7136\u540e\u5f97\u5230 d\uff0c\u8fdb\u800c\u7136\u540e\u76f4\u63a5\u89e3\u5bc6\u3002 \u540c\u65f6\uff0c\u6211\u4eec\u5047\u8bbe m<n_i, 1\\leq i \\leq 3 m<n_i, 1\\leq i \\leq 3 \u3002\u5982\u679c\u8fd9\u4e2a\u6761\u4ef6\u4e0d\u6ee1\u8db3\u7684\u8bdd\uff0c\u5c31\u4f1a\u4f7f\u5f97\u60c5\u51b5\u53d8\u5f97\u6bd4\u8f83\u590d\u6742\uff0c\u8fd9\u91cc\u6211\u4eec\u6682\u4e0d\u8ba8\u8bba\u3002 \u65e2\u7136\u4ed6\u4eec\u4e92\u7d20\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff0c\u53ef\u5f97 m^3 \\equiv C \\bmod n_1n_2n_3 m^3 \\equiv C \\bmod n_1n_2n_3 \u3002 \u6b64\u5916\uff0c\u65e2\u7136 m<n_i, 1\\leq i \\leq 3 m<n_i, 1\\leq i \\leq 3 \uff0c\u90a3\u4e48\u6211\u4eec\u77e5\u9053 m^3 < n_1n_2n_3 m^3 < n_1n_2n_3 \u5e76\u4e14 C<m^3 < n_1n_2n_3 C<m^3 < n_1n_2n_3 \uff0c\u90a3\u4e48 m^3 = C m^3 = C \uff0c\u6211\u4eec\u5bf9 C \u5f00\u4e09\u6b21\u6839\u5373\u53ef\u5f97\u5230 m \u7684\u503c\u3002 \u5bf9\u4e8e\u8f83\u5927\u7684 e \u6765\u8bf4\uff0c\u6211\u4eec\u53ea\u662f\u9700\u8981\u66f4\u591a\u7684\u660e\u5bc6\u6587\u5bf9\u3002","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#sctf-rsa3-level4","text":"\u53c2\u8003 http://ohroot.com/2016/07/11/rsa-in-ctf \u3002 \u8fd9\u91cc\u6211\u4eec\u4ee5 SCTF RSA3 \u4e2d\u7684 level4 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9996\u5148\u7f16\u5199\u4ee3\u7801\u63d0\u53d6 cap \u5305\u4e2d\u7684\u6570\u636e\uff0c\u5982\u4e0b #!/usr/bin/env python from scapy.all import * import zlib import struct PA = 24 packets = rdpcap ( './syc_security_system_traffic3.pcap' ) client = '192.168.1.180' list_n = [] list_m = [] list_id = [] data = [] for packet in packets: # TCP Flag PA 24 means carry data if packet [ TCP ] .flags == PA or packet [ TCP ] .flags == PA + 1 : src = packet [ IP ] .src raw_data = packet [ TCP ] .load head = raw_data.strip ()[ :7 ] if head == \"We have\" : n, e = raw_data.strip () .replace ( \"We have got N is \" , \"\" ) .split ( '\\ne is ' ) data.append ( n.strip ()) if head == \"encrypt\" : m = raw_data.replace ( 'encrypted messages is 0x' , '' ) .strip () data.append ( str ( int ( m, 16 ))) with open ( './data.txt' , 'w' ) as f: for i in range ( 0 , len ( data ) , 2 ) : tmp = ',' .join ( s for s in data [ i:i + 2 ]) f.write ( tmp + '\\n' ) \u5176\u6b21\uff0c\u5229\u7528\u5f97\u5230\u7684\u6570\u636e\u76f4\u63a5\u4f7f\u7528\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\u6c42\u89e3\u3002 from functools import reduce import gmpy import json , binascii def modinv ( a , m ): return int ( gmpy . invert ( gmpy . mpz ( a ), gmpy . mpz ( m ))) def chinese_remainder ( n , a ): sum = 0 prod = reduce ( lambda a , b : a * b , n ) # \u5e76\u884c\u8fd0\u7b97 for n_i , a_i in zip ( n , a ): p = prod // n_i sum += a_i * modinv ( p , n_i ) * p return int ( sum % prod ) nset = [] cset = [] with open ( \"data.txt\" ) as f : now = f . read () . strip ( ' \\n ' ) . split ( ' \\n ' ) for item in now : item = item . split ( ',' ) nset . append ( int ( item [ 0 ])) cset . append ( int ( item [ 1 ])) m = chinese_remainder ( nset , cset ) m = int ( gmpy . mpz ( m ) . root ( 19 )[ 0 ]) print binascii . unhexlify ( hex ( m )[ 2 : - 1 ]) \u5f97\u5230\u5bc6\u6587\uff0c\u7136\u540e\u518d\u6b21\u89e3\u5bc6\u5373\u53ef\u5f97\u5230 flag\u3002 H1sTaDs_B40aDcadt_attaCk_e_are_same_and_smA9l","title":"SCTF RSA3 LEVEL4"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_4","text":"2017 WHCTF OldDriver 2018 N1CTF easy_fs","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#broadcast-attack-with-linear-padding","text":"\u5bf9\u4e8e\u5177\u6709\u7ebf\u6027\u586b\u5145\u7684\u60c5\u51b5\u4e0b\uff0c\u4ecd\u7136\u53ef\u4ee5\u653b\u51fb\uff0c\u8fd9\u65f6\u5019\u5c31\u4f1a\u4f7f\u7528 Coppersmith method \u7684\u65b9\u6cd5\u4e86\uff0c\u8fd9\u91cc\u6682\u4e0d\u4ecb\u7ecd\u3002\u53ef\u4ee5\u53c2\u8003 https://en.wikipedia.org/wiki/Coppersmith%27s_attack#Generalizations","title":"Broadcast Attack with Linear Padding"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#related-message-attack","text":"","title":"Related Message Attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_5","text":"\u5f53 Alice \u4f7f\u7528\u540c\u4e00\u516c\u94a5\u5bf9\u4e24\u4e2a\u5177\u6709\u67d0\u79cd\u7ebf\u6027\u5173\u7cfb\u7684\u6d88\u606f M1 \u4e0e M2 \u8fdb\u884c\u52a0\u5bc6\uff0c\u5e76\u5c06\u52a0\u5bc6\u540e\u7684\u6d88\u606f C1\uff0cC2 \u53d1\u9001\u7ed9\u4e86 Bob \u65f6\uff0c\u6211\u4eec\u5c31\u53ef\u80fd\u53ef\u4ee5\u83b7\u5f97\u5bf9\u5e94\u7684\u6d88\u606f M1 \u4e0e M2\u3002\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u6a21\u6570\u4e3a N\uff0c\u4e24\u8005\u4e4b\u95f4\u7684\u7ebf\u6027\u5173\u7cfb\u5982\u4e0b M_1 \\equiv f(M_2) \\bmod N M_1 \\equiv f(M_2) \\bmod N \u5176\u4e2d f \u4e3a\u4e00\u4e2a\u7ebf\u6027\u51fd\u6570\uff0c\u6bd4\u5982\u8bf4 f=ax+b f=ax+b \u3002 \u5728\u5177\u6709\u8f83\u5c0f\u9519\u8bef\u6982\u7387\u4e0b\u7684\u60c5\u51b5\u4e0b\uff0c\u5176\u590d\u6742\u5ea6\u4e3a O(elog^2N) O(elog^2N) \u3002 \u8fd9\u4e00\u653b\u51fb\u7531 Franklin\uff0cReiter \u63d0\u51fa\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_6","text":"\u9996\u5148\uff0c\u6211\u4eec\u77e5\u9053 C_1 \\equiv M_1 ^e \\bmod N C_1 \\equiv M_1 ^e \\bmod N \uff0c\u5e76\u4e14 M_1 \\equiv f(M_2) \\bmod N M_1 \\equiv f(M_2) \\bmod N \uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u77e5\u9053 M_2 M_2 \u662f f(x)^e \\equiv C_1 \\bmod N f(x)^e \\equiv C_1 \\bmod N \u7684\u4e00\u4e2a\u89e3\uff0c\u5373\u5b83\u662f\u65b9\u7a0b f(x)^e-C_1 f(x)^e-C_1 \u5728\u6a21 N \u610f\u4e49\u4e0b\u7684\u4e00\u4e2a\u6839\u3002\u540c\u6837\u7684\uff0c M_2 M_2 \u662f x^e - C_2 x^e - C_2 \u5728\u6a21 N \u610f\u4e49\u4e0b\u7684\u4e00\u4e2a\u6839\u3002\u6240\u4ee5\u8bf4 x-M_2 x-M_2 \u540c\u65f6\u6574\u9664\u4ee5\u4e0a\u4e24\u4e2a\u591a\u9879\u5f0f\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u6c42\u5f97\u4e24\u4e2a\u591a\u9879\u5f0f\u7684\u6700\u5927\u516c\u56e0\u5b50\uff0c\u5982\u679c\u6700\u5927\u516c\u56e0\u5b50\u6070\u597d\u662f\u7ebf\u6027\u7684\u8bdd\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u6c42\u5f97\u4e86 M_2 M_2 \u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5728 e=3 e=3 \u7684\u60c5\u51b5\u4e0b\uff0c\u6700\u5927\u516c\u56e0\u5b50\u4e00\u5b9a\u662f\u7ebf\u6027\u7684\u3002 \u8fd9\u91cc\u6211\u4eec\u5173\u6ce8\u4e00\u4e0b e=3 e=3 \uff0c\u4e14 f(x)=ax+b f(x)=ax+b \u7684\u60c5\u51b5\u3002\u9996\u5148\u6211\u4eec\u6709 C_1 \\equiv M_1 ^3 \\bmod N,M_1 \\equiv aM_2+b \\bmod N C_1 \\equiv M_1 ^3 \\bmod N,M_1 \\equiv aM_2+b \\bmod N \u90a3\u4e48\u6211\u4eec\u6709 C_1 \\equiv (aM_2+b)^3 \\bmod N,C_2 \\equiv M_2^3 \\bmod N C_1 \\equiv (aM_2+b)^3 \\bmod N,C_2 \\equiv M_2^3 \\bmod N \u6211\u4eec\u9700\u8981\u660e\u786e\u4e00\u4e0b\u6211\u4eec\u60f3\u8981\u5f97\u5230\u7684\u662f\u6d88\u606f m\uff0c\u6240\u4ee5\u9700\u8981\u5c06\u5176\u5355\u72ec\u6784\u9020\u51fa\u6765\u3002 \u9996\u5148\uff0c\u6211\u4eec\u6709\u5f0f 1 (aM_2+b)^3=a^3M_2^3+3a^2M^2b+3aM_2b^2+b^3 (aM_2+b)^3=a^3M_2^3+3a^2M^2b+3aM_2b^2+b^3 \u518d\u8005\u6211\u4eec\u6784\u9020\u5982\u4e0b\u5f0f 2 (aM_2)^3-b^3 \\equiv (aM_2-b)(a^2M_2^2+aM_2b+b^2) \\bmod N (aM_2)^3-b^3 \\equiv (aM_2-b)(a^2M_2^2+aM_2b+b^2) \\bmod N \u6839\u636e\u5f0f 1 \u6211\u4eec\u6709 a^3M_2^3-2b^3+3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1 \\bmod N a^3M_2^3-2b^3+3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1 \\bmod N \u7ee7\u800c\u6211\u4eec\u6709\u5f0f 3 3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1-a^3C_2+2b^3 \\bmod N 3b(a^2M_2^2+aM_2b+b^2) \\equiv C_1-a^3C_2+2b^3 \\bmod N \u90a3\u4e48\u6211\u4eec\u6839\u636e\u5f0f 2 \u4e0e\u5f0f 3 \u53ef\u5f97 (a^3C_2-b^3)*3b \\equiv (aM_2-b)( C_1-a^3C_2+2b^3 ) \\bmod N (a^3C_2-b^3)*3b \\equiv (aM_2-b)( C_1-a^3C_2+2b^3 ) \\bmod N \u8fdb\u800c\u6211\u4eec\u6709 aM_2-b=\\frac{3a^3bC_2-3b^4}{C_1-a^3C_2+2b^3} aM_2-b=\\frac{3a^3bC_2-3b^4}{C_1-a^3C_2+2b^3} \u8fdb\u800c aM_2\\equiv \\frac{2a^3bC_2-b^4+C_1b}{C_1-a^3C_2+2b^3} aM_2\\equiv \\frac{2a^3bC_2-b^4+C_1b}{C_1-a^3C_2+2b^3} \u8fdb\u800c M_2 \\equiv\\frac{2a^3bC_2-b^4+C_1b}{aC_1-a^4C_2+2ab^3}=\\frac{b}{a}\\frac{C_1+2a^3C_2-b^3}{C_1-a^3C_2+2b^3} M_2 \\equiv\\frac{2a^3bC_2-b^4+C_1b}{aC_1-a^4C_2+2ab^3}=\\frac{b}{a}\\frac{C_1+2a^3C_2-b^3}{C_1-a^3C_2+2b^3} \u4e0a\u9762\u7684\u5f0f\u5b50\u4e2d\u53f3\u8fb9\u6240\u6709\u7684\u5185\u5bb9\u90fd\u662f\u5df2\u77e5\u7684\u5185\u5bb9\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u83b7\u53d6\u5bf9\u5e94\u7684\u6d88\u606f\u3002 \u6709\u5174\u8da3\u7684\u53ef\u4ee5\u8fdb\u4e00\u6b65\u9605\u8bfb A New Related Message Attack on RSA \u4ee5\u53ca paper \u8fd9\u91cc\u6682\u4e0d\u505a\u8fc7\u591a\u7684\u8bb2\u89e3\u3002","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#sctf-rsa3","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 SCTF RSA3 \u4e2d\u7684 level3 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002\u9996\u5148\uff0c\u8ddf\u8e2a TCP \u6d41\u53ef\u4ee5\u77e5\u9053\uff0c\u52a0\u5bc6\u65b9\u5f0f\u662f\u5c06\u660e\u6587\u52a0\u4e0a\u7528\u6237\u7684 user id \u8fdb\u884c\u52a0\u5bc6\uff0c\u800c\u4e14\u8fd8\u5b58\u5728\u591a\u7ec4\u3002\u8fd9\u91cc\u6211\u4eec\u9009\u62e9\u7b2c 0 \u7ec4\u548c\u7b2c 9 \u7ec4\uff0c\u4ed6\u4eec\u7684\u6a21\u6570\u4e00\u6837\uff0c\u89e3\u5bc6\u811a\u672c\u5982\u4e0b import gmpy2 id1 = 1002 id2 = 2614 c1 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c5bb724d1cee07e221e028d9b8bc24360208840fbdfd4794733adcac45c38ad0225fde19a6a4c38e4207368f5902c871efdf1bdf4760b1a98ec1417893c8fce8389b6434c0fee73b13c284e8c9fb5c77e420a2b5b1a1c10b2a7a3545e95c1d47835c2718 L c2 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c72722fe4fe5a901e2531b3dbcb87e5aa19bbceecbf9f32eacefe81777d9bdca781b1ec8f8b68799b4aa4c6ad120506222c7f0c3e11b37dd0ce08381fabf9c14bc74929bf524645989ae2df77c8608d0512c1cc4150765ab8350843b57a2464f848d8e08 L n = 25357901189172733149625332391537064578265003249917817682864120663898336510922113258397441378239342349767317285221295832462413300376704507936359046120943334215078540903962128719706077067557948218308700143138420408053500628616299338204718213283481833513373696170774425619886049408103217179262264003765695390547355624867951379789924247597370496546249898924648274419164899831191925127182066301237673243423539604219274397539786859420866329885285232179983055763704201023213087119895321260046617760702320473069743688778438854899409292527695993045482549594428191729963645157765855337481923730481041849389812984896044723939553 a = 1 b = id1 - id2 def getmessage ( a , b , c1 , c2 , n ): b3 = gmpy2 . powmod ( b , 3 , n ) part1 = b * ( c1 + 2 * c2 - b3 ) % n part2 = a * ( c1 - c2 + 2 * b3 ) % n part2 = gmpy2 . invert ( part2 , n ) return part1 * part2 % n message = getmessage ( a , b , c1 , c2 , n ) - id2 message = hex ( message )[ 2 :] if len ( message ) % 2 != 0 : message = '0' + message print message . decode ( 'hex' ) \u5f97\u5230\u660e\u6587 \u279c sctf-rsa3-level3 git: ( master ) \u2717 python exp.py F4An8LIn_rElT3r_rELa53d_Me33Age_aTtaCk_e_I2_s7aLL \u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 sage \u6765\u505a\uff0c\u4f1a\u66f4\u52a0\u7b80\u5355\u4e00\u70b9\u3002 import binascii def attack ( c1 , c2 , b , e , n ): PR .< x >= PolynomialRing ( Zmod ( n )) g1 = x ^ e - c1 g2 = ( x + b ) ^ e - c2 def gcd ( g1 , g2 ): while g2 : g1 , g2 = g2 , g1 % g2 return g1 . monic () return - gcd ( g1 , g2 )[ 0 ] c1 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c5bb724d1cee07e221e028d9b8bc24360208840fbdfd4794733adcac45c38ad0225fde19a6a4c38e4207368f5902c871efdf1bdf4760b1a98ec1417893c8fce8389b6434c0fee73b13c284e8c9fb5c77e420a2b5b1a1c10b2a7a3545e95c1d47835c2718 L c2 = 0x547995f4e2f4c007e6bb2a6913a3d685974a72b05bec02e8c03ba64278c9347d8aaaff672ad8460a8cf5bffa5d787c72722fe4fe5a901e2531b3dbcb87e5aa19bbceecbf9f32eacefe81777d9bdca781b1ec8f8b68799b4aa4c6ad120506222c7f0c3e11b37dd0ce08381fabf9c14bc74929bf524645989ae2df77c8608d0512c1cc4150765ab8350843b57a2464f848d8e08 L n = 25357901189172733149625332391537064578265003249917817682864120663898336510922113258397441378239342349767317285221295832462413300376704507936359046120943334215078540903962128719706077067557948218308700143138420408053500628616299338204718213283481833513373696170774425619886049408103217179262264003765695390547355624867951379789924247597370496546249898924648274419164899831191925127182066301237673243423539604219274397539786859420866329885285232179983055763704201023213087119895321260046617760702320473069743688778438854899409292527695993045482549594428191729963645157765855337481923730481041849389812984896044723939553 e = 3 a = 1 id1 = 1002 id2 = 2614 b = id2 - id1 m1 = attack ( c1 , c2 , b , e , n ) print binascii . unhexlify ( \" %x \" % int ( m1 - id1 )) \u7ed3\u679c\u5982\u4e0b \u279c sctf-rsa3-level3 git: ( master ) \u2717 sage exp.sage sys:1: RuntimeWarning: not adding directory '' to sys.path since everybody can write to it. Untrusted users could put files in this directory which might then be imported by your Python code. As a general precaution from similar exploits, you should not execute Python code from this directory F4An8LIn_rElT3r_rELa53d_Me33Age_aTtaCk_e_I2_s7aLL","title":"SCTF RSA3"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_7","text":"hitcon 2014 rsaha N1CTF 2018 rsa_padding","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#coppersmiths-short-pad-attack","text":"","title":"Coppersmith\u2019s short-pad attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_8","text":"\u76ee\u524d\u5728\u5927\u90e8\u5206\u6d88\u606f\u52a0\u5bc6\u4e4b\u524d\u90fd\u4f1a\u8fdb\u884c padding\uff0c\u4f46\u662f\u5982\u679c padding \u7684\u957f\u5ea6\u8fc7\u77ed\uff0c\u4e5f\u6709 \u53ef\u80fd \u88ab\u5f88\u5bb9\u6613\u5730\u653b\u51fb\u3002 \u8fd9\u91cc\u6240\u8c13 padding \u8fc7\u77ed\uff0c\u5176\u5b9e\u5c31\u662f\u5bf9\u5e94\u7684\u591a\u9879\u5f0f\u7684\u6839\u4f1a\u8fc7\u5c0f\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_9","text":"\u6211\u4eec\u5047\u8bbe\u7231\u4e3d\u4e1d\u8981\u7ed9\u9c8d\u52c3\u53d1\u9001\u6d88\u606f\uff0c\u9996\u5148\u7231\u4e3d\u4e1d\u5bf9\u8981\u52a0\u5bc6\u7684\u6d88\u606f M \u8fdb\u884c\u968f\u673a padding\uff0c\u7136\u540e\u52a0\u5bc6\u5f97\u5230\u5bc6\u6587 C1\uff0c\u53d1\u9001\u7ed9\u9c8d\u52c3\u3002\u8fd9\u65f6\uff0c\u4e2d\u95f4\u4eba\u76ae\u7279\u622a\u83b7\u4e86\u5bc6\u6587\u3002\u4e00\u6bb5\u65f6\u95f4\u540e\uff0c\u7231\u4e3d\u4e1d\u6ca1\u6709\u6536\u5230\u9c8d\u52c3\u7684\u56de\u590d\uff0c\u518d\u6b21\u5bf9\u8981\u52a0\u5bc6\u7684\u6d88\u606f M \u8fdb\u884c\u968f\u673a padding\uff0c\u7136\u540e\u52a0\u5bc6\u5f97\u5230\u5bc6\u6587 C2\uff0c\u53d1\u9001\u7ed9 Bob\u3002\u76ae\u7279\u518d\u4e00\u6b21\u622a\u83b7\u3002\u8fd9\u65f6\uff0c\u76ae\u7279\u5c31 \u53ef\u80fd \u53ef\u4ee5\u5229\u7528\u5982\u4e0b\u539f\u7406\u89e3\u5bc6\u3002 \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u6a21\u6570 N \u7684\u957f\u5ea6\u4e3a k\uff0c\u5e76\u4e14 padding \u7684\u957f\u5ea6\u4e3a m=\\lfloor \\frac{k}{e^2} \\rfloor m=\\lfloor \\frac{k}{e^2} \\rfloor \u3002\u6b64\u5916\uff0c\u5047\u8bbe\u8981\u52a0\u5bc6\u7684\u6d88\u606f\u7684\u957f\u5ea6\u6700\u591a\u4e3a k-m \u6bd4\u7279\uff0cpadding \u7684\u65b9\u5f0f\u5982\u4e0b M_1=2^mM+r_1, 0\\leq r_1\\leq 2^m M_1=2^mM+r_1, 0\\leq r_1\\leq 2^m \u6d88\u606f M2 \u7684 padding \u65b9\u5f0f\u7c7b\u4f3c\u3002 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u5982\u4e0b\u7684\u65b9\u5f0f\u6765\u89e3\u5bc6\u3002 \u9996\u5148\u5b9a\u4e49 g_1(x,y)=x^e-C_1 g_2(x,y)=(x+y)^e-C_2 g_1(x,y)=x^e-C_1 g_2(x,y)=(x+y)^e-C_2 \u5176\u4e2d y=r_2-r_1 y=r_2-r_1 \u3002\u663e\u7136\u8fd9\u4e24\u4e2a\u65b9\u7a0b\u5177\u6709\u76f8\u540c\u7684\u6839 M1\u3002\u7136\u540e\u8fd8\u6709\u4e00\u7cfb\u5217\u7684\u63a8\u5bfc\u3002","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#known-high-bits-message-attack","text":"","title":"Known High Bits Message Attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_10","text":"\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u9996\u5148\u52a0\u5bc6\u4e86\u6d88\u606f m\uff0c\u5982\u4e0b C\\equiv m^d \\bmod N C\\equiv m^d \\bmod N \u5e76\u4e14\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u77e5\u9053\u6d88\u606f m \u7684\u5f88\u5927\u7684\u4e00\u90e8\u5206 m_0 m_0 \uff0c\u5373 m=m_0+x m=m_0+x \uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u77e5\u9053 x x \u3002\u90a3\u4e48\u6211\u4eec\u5c31\u6709\u53ef\u80fd\u901a\u8fc7\u8be5\u65b9\u6cd5\u8fdb\u884c\u6062\u590d\u6d88\u606f\u3002\u8fd9\u91cc\u6211\u4eec\u4e0d\u77e5\u9053\u7684 x \u5176\u5b9e\u5c31\u662f\u591a\u9879\u5f0f\u7684\u6839\uff0c\u9700\u8981\u6ee1\u8db3 Coppersmith \u7684\u7ea6\u675f\u3002 \u53ef\u4ee5\u53c2\u8003 https://github.com/mimoo/RSA-and-LLL-attacks \u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#factoring-with-high-bits-known","text":"","title":"Factoring with High Bits Known"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_11","text":"\u5f53\u6211\u4eec\u77e5\u9053\u4e00\u4e2a\u516c\u94a5\u4e2d\u6a21\u6570 N \u7684\u4e00\u4e2a\u56e0\u5b50\u7684\u8f83\u9ad8\u4f4d\u65f6\uff0c\u6211\u4eec\u5c31\u6709\u4e00\u5b9a\u51e0\u7387\u6765\u5206\u89e3 N\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_12","text":"\u8bf7\u53c2\u8003 https://github.com/mimoo/RSA-and-LLL-attacks \u3002\u4e0a\u9762\u6709\u4f7f\u7528\u6559\u7a0b\u3002\u5173\u6ce8\u4e0b\u9762\u7684\u4ee3\u7801 beta = 0.5 dd = f . degree () epsilon = beta / 7 mm = ceil ( beta ** 2 / ( dd * epsilon )) tt = floor ( dd * mm * (( 1 / beta ) - 1 )) XX = ceil ( N ** (( beta ** 2 / dd ) - epsilon )) + 1000000000000000000000000000000000 roots = coppersmith_howgrave_univariate ( f , N , beta , mm , tt , XX ) \u5176\u4e2d\uff0c \u5fc5\u987b\u6ee1\u8db3 q\\geq N^{beta} q\\geq N^{beta} \uff0c\u6240\u4ee5\u8fd9\u91cc\u7ed9\u51fa\u4e86 beta=0.5 beta=0.5 \uff0c\u663e\u7136\u4e24\u4e2a\u56e0\u6570\u4e2d\u5fc5\u7136\u6709\u4e00\u4e2a\u662f\u5927\u4e8e\u7684\u3002 XX \u662f f(x)=q'+x f(x)=q'+x \u5728\u6a21 q \u610f\u4e49\u4e0b\u7684\u6839\u7684\u4e0a\u754c\uff0c\u81ea\u7136\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u8c03\u6574\u5b83\uff0c\u8fd9\u91cc\u5176\u5b9e\u4e5f\u8868\u660e\u4e86\u6211\u4eec\u5df2\u77e5\u7684 q' q' \u4e0e\u56e0\u6570 q \u4e4b\u95f4\u53ef\u80fd\u7684\u5dee\u8ddd\u3002","title":"\u653b\u51fb\u5de5\u5177"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#2016-hctf-rsa2","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 2016 \u5e74 HCTF \u4e2d\u7684 RSA2 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002 \u9996\u5148\u7a0b\u5e8f\u7684\u5f00\u5934\u662f\u4e00\u4e2a\u7ed5\u8fc7\u9a8c\u8bc1\u7684\uff0c\u7ed5\u8fc7\u5373\u53ef\uff0c\u4ee3\u7801\u5982\u4e0b from pwn import * from hashlib import sha512 sh = remote ( '127.0.0.1' , 9999 ) context . log_level = 'debug' def sha512_proof ( prefix , verify ): i = 0 pading = \"\" while True : try : i = randint ( 0 , 1000 ) pading += str ( i ) if len ( pading ) > 200 : pading = pading [ 200 :] #print pading except StopIteration : break r = sha512 ( prefix + pading ) . hexdigest () if verify in r : return pading def verify (): sh . recvuntil ( \"Prefix: \" ) prefix = sh . recvline () print len ( prefix ) prefix = prefix [: - 1 ] prefix = prefix . decode ( 'base64' ) proof = sha512_proof ( prefix , \"fffffff\" ) sh . send ( proof . encode ( 'base64' )) if __name__ == '__main__' : verify () print 'verify success' sh . recvuntil ( \"token: \" ) token = \"5c9597f3c8245907ea71a89d9d39d08e\" sh . sendline ( token ) sh . recvuntil ( \"n: \" ) n = sh . readline () . strip () n = int ( n [ 2 :], 16 ) sh . recvuntil ( \"e: \" ) e = sh . readline () . strip () e = int ( e [ 2 :], 16 ) sh . recvuntil ( \"e2: \" ) e2 = sh . readline () . strip () e2 = int ( e2 [ 2 :], 16 ) sh . recvuntil ( \"is: \" ) enc_flag = sh . readline () . strip () enc_flag = int ( enc_flag [ 2 : - 1 ], 16 ) print \"n: \" , hex ( n ) print \"e: \" , hex ( e ) print \"e2: \" , hex ( e2 ) print \"flag: \" , hex ( enc_flag ) \u8fd9\u91cc\u6211\u4eec\u4e5f\u5df2\u7ecf\u5f97\u5230 n\uff0ce\uff0ce2\uff0c\u52a0\u5bc6\u540e\u7684 flag \u4e86\uff0c\u5982\u4e0b n : 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f e : 0x10001 e2 : 0xf93b flag : 0xf11e932fa420790ca3976468dc4df1e6b20519ebfdc427c09e06940e1ef0ca566d41714dc1545ddbdcae626eb51c7fa52608384a36a2a021960d71023b5d0f63e6b38b46ac945ddafea42f01d24cc33ce16825df7aa61395d13617ae619dca2df15b5963c77d6ededf2fe06fd36ae8c5ce0e3c21d72f2d7f20cd9a8696fbb628df29299a6b836c418cbfe91e2b5be74bdfdb4efdd1b33f57ebb72c5246d5dce635529f1f69634d565a631e950d4a34a02281cbed177b5a624932c2bc02f0c8fd9afd332ccf93af5048f02b8bd72213d6a52930b0faa0926973883136d8530b8acf732aede8bb71cb187691ebd93a0ea8aeec7f82d0b8b74bcf010c8a38a1fa8 \u63a5\u4e0b\u6765\u6211\u4eec\u6765\u5206\u6790\u4e3b\u7a0b\u5e8f\u3002\u53ef\u4ee5\u770b\u51fa p , q , e = gen_key () n = p * q phi_n = ( p - 1 ) * ( q - 1 ) d = invmod ( e , phi_n ) while True : e2 = random . randint ( 0x1000 , 0x10000 ) if gcd ( e2 , phi_n ) == 1 : break \u6211\u4eec\u5f97\u5230\u7684 n=p \\times q n=p \\times q \u3002\u800c p\uff0cq \u4ee5\u53ca\u6211\u4eec\u5df2\u77e5\u7684 e \u90fd\u5728 gen_key \u51fd\u6570\u4e2d\u751f\u6210\u3002\u770b\u4e00\u770b gen_key \u51fd\u6570 def gen_key (): while True : p = getPrime ( k / 2 ) if gcd ( e , p - 1 ) == 1 : break q_t = getPrime ( k / 2 ) n_t = p * q_t t = get_bit ( n_t , k / 16 , 1 ) y = get_bit ( n_t , 5 * k / 8 , 0 ) p4 = get_bit ( p , 5 * k / 16 , 1 ) u = pi_b ( p4 , 1 ) n = bytes_to_long ( long_to_bytes ( t ) + long_to_bytes ( u ) + long_to_bytes ( y )) q = n / p if q % 2 == 0 : q += 1 while True : if isPrime ( q ) and gcd ( e , q - 1 ) == 1 : break m = getPrime ( k / 16 ) + 1 q ^= m return ( p , q , e ) \u5176\u4e2d\u6211\u4eec\u5df2\u77e5\u5982\u4e0b\u53c2\u6570 k=2048 e=0x10001 k=2048 e=0x10001 \u9996\u5148\uff0c\u7a0b\u5e8f\u5148\u5f97\u5230\u4e86 1024 \u6bd4\u7279\u4f4d\u7684\u7d20\u6570 p\uff0c\u5e76\u4e14 gcd(2,p-1)=1 \u3002 \u7136\u540e\uff0c\u7a0b\u5e8f\u53c8\u5f97\u5230\u4e86\u4e00\u4e2a 1024 \u6bd4\u7279\u4f4d\u7684\u7d20\u6570 q_t q_t \uff0c\u5e76\u4e14\u8ba1\u7b97 n_t=p \\times q_t n_t=p \\times q_t \u3002 \u4e0b\u9762\u591a\u6b21\u8c03\u7528\u4e86 get_bit \u51fd\u6570\uff0c\u6211\u4eec\u6765\u7b80\u5355\u5206\u6790\u4e00\u4e0b def get_bit ( number , n_bit , dire ): ''' dire: 1: left 0: right ''' if dire : sn = size ( number ) if sn % 8 != 0 : sn += ( 8 - sn % 8 ) return number >> ( sn - n_bit ) else : return number & ( pow ( 2 , n_bit ) - 1 ) \u53ef\u4ee5\u770b\u51fa\u6839\u636e dire(ction) \u7684\u4e0d\u540c\uff0c\u4f1a\u5f97\u5230\u4e0d\u540c\u7684\u6570 dire=1 \u65f6\uff0c\u7a0b\u5e8f\u9996\u5148\u8ba1\u7b97 number \u7684\u4e8c\u8fdb\u5236\u4f4d\u6570 sn \uff0c\u5982\u679c\u4e0d\u662f 8 \u7684\u6574\u6570\u500d\u7684\u8bdd\uff0c\u5c31\u5c06 sn \u589e\u5927\u4e3a 8 \u7684\u6574\u6570\u500d\uff0c\u7136\u540e\u8fd4\u56de number \u53f3\u79fb sn-n_bit \u7684\u6570\u5b57\u3002\u5176\u5b9e \u5c31\u662f\u6700\u591a\u4fdd\u7559 number \u7684 n_bit \u4f4d\u3002 dire=0 \u65f6\uff0c\u7a0b\u5e8f\u76f4\u63a5\u83b7\u53d6 number \u7684\u4f4e n_bit \u4f4d\u3002 \u7136\u540e\u6211\u4eec\u518d\u6765\u770b\u7a0b\u5e8f t = get_bit ( n_t , k / 16 , 1 ) y = get_bit ( n_t , 5 * k / 8 , 0 ) p4 = get_bit ( p , 5 * k / 16 , 1 ) \u8fd9\u4e09\u4e2a\u64cd\u4f5c\u5206\u522b\u505a\u4e86\u5982\u4e0b\u7684\u4e8b\u60c5 t \u4e3a n_t \u7684\u6700\u591a\u9ad8 k/16 \u4f4d\uff0c\u5373 128 \u4f4d\uff0c\u4f4d\u6570\u4e0d\u56fa\u5b9a\u3002 y \u4e3a n_t \u7684\u4f4e 5*k/8 \u4f4d\uff0c\u5373 1280 \u4f4d\uff0c\u4f4d\u6570\u56fa\u5b9a\u3002 p4 \u4e3a p \u7684\u6700\u591a\u9ad8 5*k/16 \u4f4d\uff0c\u5373 640 \u4f4d\uff0c\u4f4d\u6570\u4e0d\u56fa\u5b9a\u3002 \u6b64\u540e\uff0c\u7a0b\u5e8f\u6709\u5982\u4e0b\u64cd\u4f5c u = pi_b ( p4 , 1 ) \u5229\u7528 pi_b \u5bf9 p4 \u8fdb\u884c\u4e86\u52a0\u5bc6 def pi_b ( x , m ): ''' m: 1: encrypt 0: decrypt ''' enc = DES . new ( key ) if m : method = enc . encrypt else : method = enc . decrypt s = long_to_bytes ( x ) sp = [ s [ a : a + 8 ] for a in xrange ( 0 , len ( s ), 8 )] r = \"\" for a in sp : r += method ( a ) return bytes_to_long ( r ) \u5176\u4e2d\uff0c\u6211\u4eec\u5df2\u77e5\u4e86\u5bc6\u94a5 key\uff0c\u6240\u4ee5\u53ea\u8981\u6211\u4eec\u6709\u5bc6\u6587\u5c31\u53ef\u4ee5\u89e3\u5bc6\u3002\u6b64\u5916\uff0c\u53ef\u4ee5\u770b\u5230\u7684\u662f\u7a0b\u5e8f\u662f\u5bf9\u4f20\u5165\u7684\u6d88\u606f\u8fdb\u884c 8 \u5b57\u8282\u5206\u7ec4\uff0c\u91c7\u7528\u5bc6\u7801\u672c\u65b9\u5f0f\u52a0\u5bc6\uff0c\u6240\u4ee5\u5bc6\u6587\u4e4b\u95f4\u4e92\u4e0d\u5f71\u54cd\u3002 \u4e0b\u9762 n = bytes_to_long ( long_to_bytes ( t ) + long_to_bytes ( u ) + long_to_bytes ( y )) q = n / p if q % 2 == 0 : q += 1 while True : if isPrime ( q ) and gcd ( e , q - 1 ) == 1 : break m = getPrime ( k / 16 ) + 1 q ^= m return ( p , q , e ) \u7a0b\u5e8f\u5c06 t\uff0cu\uff0cy \u62fc\u63a5\u5728\u4e00\u8d77\u5f97\u5230 n\uff0c\u8fdb\u800c\uff0c\u7a0b\u5e8f\u5f97\u5230\u4e86 q\uff0c\u5e76\u5bf9 q \u7684\u4f4e k/16 \u4f4d\u505a\u4e86\u6291\u6216\uff0c\u7136\u540e\u8fd4\u56de q' \u3002 \u5728\u4e3b\u7a0b\u5e8f\u91cc\uff0c\u518d\u4e00\u6b21\u5f97\u5230\u4e86 n'=p*q' \u3002\u8fd9\u91cc\u6211\u4eec\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b n'=p * ( q + random(2^{k/16})) \u800c p \u662f k/2 \u4f4d\u7684\uff0c\u6240\u4ee5\u8bf4\uff0crandom \u7684\u90e8\u5206\u6700\u591a\u53ef\u4ee5\u5f71\u54cd\u539f\u6765\u7684 n \u7684\u6700\u4f4e\u7684 k/2+k/16=9k/16 k/2+k/16=9k/16 \u6bd4\u7279\u4f4d\u3002 \u800c\uff0c\u6211\u4eec\u8fd8\u77e5\u9053 n \u7684\u6700\u4f4e\u7684 5k/8=10k/16 \u6bd4\u7279\u4e3a\u5176\u5b9e\u5c31\u662f y\uff0c\u6240\u4ee5\u5176\u5e76\u6ca1\u6709\u5f71\u54cd\u5230 u\uff0c\u5373\u4f7f\u5f71\u54cd\u5230\u4e5f\u5c31\u6700\u591a\u5f71\u54cd\u5230\u4e00\u4f4d\u3002 \u6240\u4ee5\u6211\u4eec\u9996\u5148\u53ef\u4ee5\u5229\u7528\u6211\u4eec\u5f97\u5230\u7684 n \u6765\u83b7\u53d6 u\uff0c\u5982\u4e0b u=hex(n)[2:-1][-480:-320] \u867d\u7136\uff0c\u8fd9\u6837\u53ef\u80fd\u4f1a\u83b7\u5f97\u8f83\u591a\u4f4d\u6570\u7684 u\uff0c\u4f46\u662f\u8fd9\u6837\u5e76\u4e0d\u5f71\u54cd\uff0c\u6211\u4eec\u5bf9 u \u89e3\u5bc6\u7684\u65f6\u5019\u6bcf\u4e00\u5206\u7ec4\u90fd\u4e92\u4e0d\u5f71\u54cd\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u53ef\u80fd\u5f71\u54cd\u6700\u9ad8\u4f4d\u6570\u7684 p4\u3002\u800c p4 \u7684\u7684\u9ad8 8 \u4f4d\u4e5f\u6709\u53ef\u80fd\u662f\u586b\u5145\u7684\u3002\u4f46\u8fd9\u4e5f\u5e76\u4e0d\u5f71\u54cd\uff0c\u6211\u4eec\u5df2\u7ecf\u5f97\u5230\u4e86\u56e0\u5b50 p \u7684\u7684\u5f88\u591a\u90e8\u5206\u4e86\uff0c\u6211\u4eec\u53ef\u4ee5\u53bb\u5c1d\u8bd5\u7740\u89e3\u5bc6\u4e86\u3002\u5982\u4e0b if __name__ == \"__main__\" : n = 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f u = hex ( n )[ 2 : - 1 ][ - 480 : - 320 ] u = int ( u , 16 ) p4 = pi_b ( u , 0 ) print hex ( p4 ) \u89e3\u5bc6\u7ed3\u679c\u5982\u4e0b \u279c 2016 - HCTF - RSA2 git :( master ) \u2717 python exp_p4 . py 0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde1362693 L \u4e0b\u9762\uff0c\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 sage \u6765\u89e3\u5bc6\uff0c\u8fd9\u91cc sage \u91cc\u9762\u5df2\u7ecf\u5b9e\u73b0\u4e86\u8fd9\u4e2a\u653b\u51fb\uff0c\u6211\u4eec\u76f4\u63a5\u62ff\u6765\u7528\u5c31\u597d from sage.all import * import binascii n = 0x724d41149e1bd9d2aa9b333d467f2dfa399049a5d0b4ee770c9d4883123be11a52ff1bd382ad37d0ff8d58c8224529ca21c86e8a97799a31ddebd246aeeaf0788099b9c9c718713561329a8e529dfeae993036921f036caa4bdba94843e0a2e1254c626abe54dc3129e2f6e6e73bbbd05e7c6c6e9f44fcd0a496f38218ab9d52bf1f266004180b6f5b9bee7988c4fe5ab85b664280c3cfe6b80ae67ed8ba37825758b24feb689ff247ee699ebcc4232b4495782596cd3f29a8ca9e0c2d86ea69372944d027a0f485cea42b74dfd74ec06f93b997a111c7e18017523baf0f57ae28126c8824bd962052623eb565cee0ceee97a35fd8815d2c5c97ab9653c4553f p4 = 0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde1362693 cipher = 0xf11e932fa420790ca3976468dc4df1e6b20519ebfdc427c09e06940e1ef0ca566d41714dc1545ddbdcae626eb51c7fa52608384a36a2a021960d71023b5d0f63e6b38b46ac945ddafea42f01d24cc33ce16825df7aa61395d13617ae619dca2df15b5963c77d6ededf2fe06fd36ae8c5ce0e3c21d72f2d7f20cd9a8696fbb628df29299a6b836c418cbfe91e2b5be74bdfdb4efdd1b33f57ebb72c5246d5dce635529f1f69634d565a631e950d4a34a02281cbed177b5a624932c2bc02f0c8fd9afd332ccf93af5048f02b8bd72213d6a52930b0faa0926973883136d8530b8acf732aede8bb71cb187691ebd93a0ea8aeec7f82d0b8b74bcf010c8a38a1fa8 e2 = 0xf93b pbits = 1024 kbits = pbits - p4 . nbits () print p4 . nbits () p4 = p4 << kbits PR .< x > = PolynomialRing ( Zmod ( n )) f = x + p4 roots = f . small_roots ( X = 2 ^ kbits , beta = 0.4 ) if roots : p = p4 + int ( roots [ 0 ]) print \"p: \" , hex ( int ( p )) assert n % p == 0 q = n / int ( p ) print \"q: \" , hex ( int ( q )) print gcd ( p , q ) phin = ( p - 1 ) * ( q - 1 ) print gcd ( e2 , phin ) d = inverse_mod ( e2 , phin ) flag = pow ( cipher , d , n ) flag = hex ( int ( flag ))[ 2 : - 1 ] print binascii . unhexlify ( flag ) \u5173\u4e8e small_roots \u7684\u4f7f\u7528\uff0c\u53ef\u4ee5\u53c2\u8003 SAGE \u8bf4\u660e \u3002 \u7ed3\u679c\u5982\u4e0b \u279c 2016 -HCTF-RSA2 git: ( master ) \u2717 sage payload.sage sys:1: RuntimeWarning: not adding directory '' to sys.path since everybody can write to it. Untrusted users could put files in this directory which might then be imported by your Python code. As a general precaution from similar exploits, you should not execute Python code from this directory 640 p: 0xa37302107c17fb4ef5c3443f4ef9e220ac659670077b9aa9ff7381d11073affe9183e88acae0ab61fb75a3c7815ffcb1b756b27c4d90b2e0ada753fa17cc108c1d0de82c747db81b9e6f49bde13626933aa6762057e1df53d27356ee6a09b17ef4f4986d862e3bb24f99446a0ab2385228295f4b776c1f391ab2a0d8c0dec1e5L q: 0xb306030a7c6ace771db8adb45fae597f3c1be739d79fd39dfa6fd7f8c177e99eb29f0462c3f023e0530b545df6e656dadb984953c265b26f860b68aa6d304fa403b0b0e37183008592ec2a333c431e2906c9859d7cbc4386ef4c4407ead946d855ecd6a8b2067ad8a99b21111b26905fcf0d53a1b893547b46c3142b06061853L 1 1 hctf { d8e8fca2dc0f896fd7cb4cb0031ba249 }","title":"2016 HCTF RSA2"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_13","text":"2016 \u6e56\u6e58\u676f \u7b80\u5355\u7684 RSA 2017 WHCTF Untitled","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#boneh-and-durfee-attack","text":"","title":"Boneh and Durfee attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_14","text":"\u5f53 d \u8f83\u5c0f\u65f6\uff0c\u6ee1\u8db3 d < N^{0.292} d < N^{0.292} \u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u8be5\u653b\u51fb\uff0c\u6bd4 Wiener's Attack \u8981\u5f3a\u4e00\u4e9b\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_15","text":"\u8fd9\u91cc\u7b80\u5355\u8bf4\u4e00\u4e0b\u539f\u7406\u3002 \u9996\u5148 ed \\equiv 1 \\bmod \\varphi(N)/2 ed \\equiv 1 \\bmod \\varphi(N)/2 \u8fdb\u800c\u6709 ed +k\\varphi(N)/2=1 ed +k\\varphi(N)/2=1 \u5373 k \\varphi(N)/2 \\equiv 1 \\bmod e k \\varphi(N)/2 \\equiv 1 \\bmod e \u53c8 \\varphi(N)=(p-1)(q-1)=qp-p-q+1=N-p-q+1 \\varphi(N)=(p-1)(q-1)=qp-p-q+1=N-p-q+1 \u6240\u4ee5 k(N-p-q+1)/2 \\equiv 1 \\bmod e k(N-p-q+1)/2 \\equiv 1 \\bmod e \u5047\u8bbe A=\\frac{N+1}{2} A=\\frac{N+1}{2} \uff0c y=\\frac{-p-q}{2} y=\\frac{-p-q}{2} \uff0c\u539f\u5f0f\u53ef\u5316\u4e3a f(k,y)=k(A+y) \\equiv 1 \\bmod e f(k,y)=k(A+y) \\equiv 1 \\bmod e \u5176\u4e2d |k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta} |k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta} |y|<2*N^{0.5} |y|<2*N^{0.5} y \u7684\u4f30\u8ba1\u7528\u5230\u4e86 p\u3001q \u6bd4\u8f83\u5747\u5300\u7684\u5047\u8bbe\u3002\u8fd9\u91cc delta \u4e3a\u9884\u4f30\u7684\u5c0f\u4e8e 0.292 \u7684\u503c\u3002 \u5982\u679c\u6211\u4eec\u6c42\u5f97\u4e86\u8be5\u4e8c\u5143\u65b9\u7a0b\u7684\u6839\uff0c\u90a3\u4e48\u6211\u4eec\u81ea\u7136\u4e5f\u5c31\u53ef\u4ee5\u89e3\u4e00\u5143\u4e8c\u6b21\u65b9\u7a0b N=pq,p+q=-2y N=pq,p+q=-2y \u6765\u5f97\u5230 p \u4e0e q\u3002 \u66f4\u52a0\u5177\u4f53\u7684\u63a8\u5bfc\uff0c\u53c2\u8003 New Results on the Cryptanalysis of Low Exponent RSA.","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_16","text":"\u8bf7\u53c2\u8003 https://github.com/mimoo/RSA-and-LLL-attacks \u3002\u4e0a\u9762\u6709\u4f7f\u7528\u6559\u7a0b\u3002","title":"\u653b\u51fb\u5de5\u5177"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#2015-plaidctf-curious","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 2015 \u5e74 PlaidCTF Curious \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002 \u9996\u5148\u9898\u76ee\u7ed9\u4e86\u4e00\u5806 N\uff0ce\uff0cc\u3002\u7b80\u5355\u770b\u4e00\u4e0b\u53ef\u4ee5\u53d1\u73b0\u8be5 e \u6bd4\u8f83\u5927\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4f7f\u7528 Wiener's Attack\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u66f4\u5f3a\u7684\u76ee\u524d\u4ecb\u7ecd\u7684\u653b\u51fb\u3002 \u6838\u5fc3\u4ee3\u7801\u5982\u4e0b nlist = list () elist = list () clist = list () with open ( 'captured' ) as f : # read the line {N : e : c} and do nothing with it f . readline () for i in f . readlines (): ( N , e , c ) = i [ 1 : - 2 ] . split ( \" : \" ) nlist . append ( long ( N , 16 )) elist . append ( long ( e , 16 )) clist . append ( long ( c , 16 )) for i in range ( len ( nlist )): print 'index i' n = nlist [ i ] e = elist [ i ] c = clist [ i ] d = solve ( n , e ) if d == 0 : continue else : m = power_mod ( c , d , n ) hex_string = \" %x \" % m import binascii print \"the plaintext:\" , binascii . unhexlify ( hex_string ) return \u7ed3\u679c\u5982\u4e0b === solution found === private key found: 23974584842546960047080386914966001070087596246662608796022581200084145416583 the plaintext: flag_S0Y0UKN0WW13N3R $4 TT4CK!","title":"2015 PlaidCTF Curious"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#2019-defcon-quals-asrybab","text":"\u9898\u76ee\u5927\u6982\u610f\u601d\u662f\uff0c\u6211\u4eec\u63a5\u6536\u4e09\u5bf9 RSA \uff0c\u7136\u540e\u9700\u8981\u6c42\u51fa d\uff0c\u7136\u540e\u5bf9\u7ed9\u5b9a\u7684\u6570\u5b57 v[i] \u52a0\u5bc6\uff0c\u53d1\u9001\u7ed9\u670d\u52a1\u5668\uff0c\u53ea\u8981\u65f6\u95f4\u5728\u4e00\u5b9a\u8303\u56f4\u5185\uff0c940s\uff0c\u5373\u53ef\u3002\u90a3\u96be\u70b9\u81ea\u7136\u5728 create_key \u51fd\u6570\u4e86\u3002 def send_challenges (): code = marshal . loads ( \"63000000000d000000070000004300000073df010000740000721d0064010064020015000000000100640200157d00006e00007401007d01007c0100640300157d02006402007d0300786f007c03006a02008300007c01006b030072a400784c007403007296007404006a05007c02008301007d04007404006a05007c02008301007d05007406007c04007c0500188301006a02008300007c0100640400146b0400724b0050714b00714b00577c04007c0500147d0300713600577c0400640500187c050064050018147d06006406007d07006407007d080078090174030072ce017404006a07007408006403007409007c01007c0700148301008302007408006403007409007c01007c070014830100640500178302008302007d09007871007c09006a02008300007c01007c0800146b0000727b016402007d0a007844007404006a0a007c0a00830100736d017404006a0700740800640300640800830200740800640300640800830200740800640300640900830200178302007d0a00712a01577c09007c0a00397d0900710b01577404006a0b007c09007c06008302006405006b0300729a0171c6006e00007404006a0c007c09007c06008302007d0b007404006a0b007c0b007c06008302006405006b030072ca0171c6006e00005071c60057640a007d0c007c03007c0b0066020053280b0000004e690700000069000000006902000000675839b4c876bedf3f6901000000674e62105839b4d03f678d976e1283c0d23f692d000000690c0000006903000000280d000000740500000046616c736574050000004e53495a45740a0000006269745f6c656e67746874040000005472756574060000006e756d626572740e0000006765745374726f6e675072696d657403000000616273740e00000067657452616e646f6d52616e67657403000000706f777403000000696e74740700000069735072696d6574030000004743447407000000696e7665727365280d00000074010000007874050000004e73697a657406000000707173697a6574010000004e740100000070740100000071740300000070686974060000006c696d69743174060000006c696d697432740100000064740300000070707074010000006574030000007a7a7a2800000000280000000073150000002f6f726967696e616c6368616c6c656e67652e7079740a0000006372656174655f6b657917000000733e000000000106010a010d0206010a010601150109010f010f04200108010e0112020601060109013c0119010601120135020e011801060112011801060105020604\" . decode ( \"hex\" )) create_key = types . FunctionType ( code , globals (), \"create_key\" ) ck = create_key \u6211\u4eec\u53ef\u4ee5\u7b80\u5355\u770b\u770b\u8fd9\u4e2a\u5230\u5e95\u662f\u5728\u5e72\u5565 >>> import marshal >>> data = \"63000000000d000000070000004300000073df010000740000721d0064010064020015000000000100640200157d00006e00007401007d01007c0100640300157d02006402007d0300786f007c03006a02008300007c01006b030072a400784c007403007296007404006a05007c02008301007d04007404006a05007c02008301007d05007406007c04007c0500188301006a02008300007c0100640400146b0400724b0050714b00714b00577c04007c0500147d0300713600577c0400640500187c050064050018147d06006406007d07006407007d080078090174030072ce017404006a07007408006403007409007c01007c0700148301008302007408006403007409007c01007c070014830100640500178302008302007d09007871007c09006a02008300007c01007c0800146b0000727b016402007d0a007844007404006a0a007c0a00830100736d017404006a0700740800640300640800830200740800640300640800830200740800640300640900830200178302007d0a00712a01577c09007c0a00397d0900710b01577404006a0b007c09007c06008302006405006b0300729a0171c6006e00007404006a0c007c09007c06008302007d0b007404006a0b007c0b007c06008302006405006b030072ca0171c6006e00005071c60057640a007d0c007c03007c0b0066020053280b0000004e690700000069000000006902000000675839b4c876bedf3f6901000000674e62105839b4d03f678d976e1283c0d23f692d000000690c0000006903000000280d000000740500000046616c736574050000004e53495a45740a0000006269745f6c656e67746874040000005472756574060000006e756d626572740e0000006765745374726f6e675072696d657403000000616273740e00000067657452616e646f6d52616e67657403000000706f777403000000696e74740700000069735072696d6574030000004743447407000000696e7665727365280d00000074010000007874050000004e73697a657406000000707173697a6574010000004e740100000070740100000071740300000070686974060000006c696d69743174060000006c696d697432740100000064740300000070707074010000006574030000007a7a7a2800000000280000000073150000002f6f726967696e616c6368616c6c656e67652e7079740a0000006372656174655f6b657917000000733e000000000106010a010d0206010a010601150109010f010f04200108010e0112020601060109013c0119010601120135020e011801060112011801060105020604\" >>> code = marshal . loads ( data ) >>> code = marshal . loads ( data . decode ( 'hex' )) >>> import dis >>> dis . dis ( code ) 24 0 LOAD_GLOBAL 0 ( False ) 3 POP_JUMP_IF_FALSE 29 25 6 LOAD_CONST 1 ( 7 ) 9 LOAD_CONST 2 ( 0 ) 12 BINARY_DIVIDE 13 STOP_CODE 14 STOP_CODE 15 STOP_CODE ... 56 428 LOAD_GLOBAL 4 ( number ) 431 LOAD_ATTR 11 ( GCD ) 434 LOAD_FAST 11 ( e ) 437 LOAD_FAST 6 ( phi ) 440 CALL_FUNCTION 2 443 LOAD_CONST 5 ( 1 ) 446 COMPARE_OP 3 ( != ) 449 POP_JUMP_IF_FALSE 458 ... \u57fa\u672c\u53ef\u4ee5\u731c\u51fa\u6765\u8fd9\u662f\u5728\u751f\u6210 n\uff0ce\uff0cd\uff0c\u5176\u5b9e\u548c\u6211\u4eec\u6700\u521d\u7684\u9884\u671f\u4e5f\u5dee\u4e0d\u591a\u3002\u6211\u4eec\u6765\u76f4\u63a5\u53cd\u7f16\u8bd1\u4e00\u4e0b >>> from uncompyle6 import code_deparse >>> code_deparse ( code ) Instruction context : 25 6 LOAD_CONST 1 7 9 LOAD_CONST 2 0 12 BINARY_DIVIDE -> 13 STOP_CODE 14 STOP_CODE 15 STOP_CODE Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/local/lib/python2.7/site-packages/uncompyle6/semantics/pysource.py\" , line 2310 , in code_deparse deparsed . ast = deparsed . build_ast ( tokens , customize , isTopLevel = isTopLevel ) File \"/usr/local/lib/python2.7/site-packages/uncompyle6/semantics/pysource.py\" , line 2244 , in build_ast raise ParserError ( e , tokens ) uncompyle6 . semantics . parser_error . ParserError : --- This code section failed : --- ... 64 469 LOAD_FAST 3 'N' 472 LOAD_FAST 11 'e' 475 BUILD_TUPLE_2 2 None 478 RETURN_VALUE - 1 RETURN_LAST Parse error at or near ` STOP_CODE ' instruction at offset 13 \u53ef\u4ee5\u53d1\u73b0 STOP_CODE\uff0c\u6709\u70b9\u732b\u817b\uff0c\u5982\u679c\u4ed4\u7ec6\u770b\u6700\u521d\u7684\u53cd\u6c47\u7f16\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u6700\u524d\u9762\u7684\u90a3\u90e8\u5206\u4ee3\u7801\u662f\u5728\u6df7\u6dc6 >>> dis . dis ( code ) 24 0 LOAD_GLOBAL 0 ( False ) 3 POP_JUMP_IF_FALSE 29 25 6 LOAD_CONST 1 ( 7 ) 9 LOAD_CONST 2 ( 0 ) 12 BINARY_DIVIDE 13 STOP_CODE 14 STOP_CODE 15 STOP_CODE 26 16 STOP_CODE 17 POP_TOP 18 STOP_CODE 19 LOAD_CONST 2 ( 0 ) 22 BINARY_DIVIDE 23 STORE_FAST 0 ( x ) 26 JUMP_FORWARD 0 ( to 29 ) 28 >> 29 LOAD_GLOBAL 1 ( NSIZE ) 32 STORE_FAST 1 ( Nsize ) 29 35 LOAD_FAST 1 ( Nsize ) 38 LOAD_CONST 3 ( 2 ) 41 BINARY_DIVIDE 42 STORE_FAST 2 ( pqsize ) \u4e00\u76f4\u5230 29 35 LOAD_FAST 1 ( Nsize ) \u524d\u9762\u7684\u90fd\u6ca1\u6709\u4ec0\u4e48\u4f5c\u7528\uff0c\u611f\u89c9\u662f\u51fa\u9898\u8005\u6545\u610f\u4fee\u6539\u4e86\u4ee3\u7801\u3002\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u8fd9\u90e8\u5206\u4ee3\u7801\uff0c\u611f\u89c9\u50cf\u662f\u4e24\u90e8\u5206 # part 1 25 6 LOAD_CONST 1 ( 7 ) 9 LOAD_CONST 2 ( 0 ) 12 BINARY_DIVIDE 13 STOP_CODE 14 STOP_CODE 15 STOP_CODE # part 2 26 16 STOP_CODE 17 POP_TOP 18 STOP_CODE 19 LOAD_CONST 2 ( 0 ) 22 BINARY_DIVIDE 23 STORE_FAST 0 ( x ) 26 JUMP_FORWARD 0 ( to 29 ) \u6b63\u597d\u662f\u7b2c 25 \u884c\u548c\u7b2c 26 \u884c\uff0c\u5927\u6982\u731c\u4e00\u731c\uff0c\u611f\u89c9\u4e24\u4e2a\u90fd\u662f x=7/0\uff0c\u6240\u4ee5\u5c31\u60f3\u529e\u6cd5\u628a\u8fd9\u90e8\u5206\u7684\u4ee3\u7801\u4fee\u590d\u4e00\u4e0b\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5b9a\u4f4d\u8fd9\u90e8\u5206\u4ee3\u7801\u4e86\u3002\u6839\u636e\u624b\u518c\u53ef\u4ee5\u77e5\u9053 STOP_CODE \u662f 0\uff0c\u4ece\u800c\u6211\u4eec\u53ef\u4ee5\u5b9a\u4f4d\u7b2c 25 \u884c\u8bed\u53e5\u5230 26 \u884c\u8bed\u53e5\u4e3a t[6:26]\uff0c\u4ed6\u4eec\u5206\u522b\u90fd\u662f 10 \u5b57\u8282(6-15,16-25)\u3002 >>> t = code . co_code >>> t 't \\x00\\x00 r \\x1d\\x00 d \\x01\\x00 d \\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00 d \\x02\\x00\\x15 } \\x00\\x00 n \\x00\\x00 t \\x01\\x00 } \\x01\\x00 | \\x01\\x00 d \\x03\\x00\\x15 } \\x02\\x00 d \\x02\\x00 } \\x03\\x00 xo \\x00 | \\x03\\x00 j \\x02\\x00\\x83\\x00\\x00 | \\x01\\x00 k \\x03\\x00 r \\xa4\\x00 xL \\x00 t \\x03\\x00 r \\x96\\x00 t \\x04\\x00 j \\x05\\x00 | \\x02\\x00\\x83\\x01\\x00 } \\x04\\x00 t \\x04\\x00 j \\x05\\x00 | \\x02\\x00\\x83\\x01\\x00 } \\x05\\x00 t \\x06\\x00 | \\x04\\x00 | \\x05\\x00\\x18\\x83\\x01\\x00 j \\x02\\x00\\x83\\x00\\x00 | \\x01\\x00 d \\x04\\x00\\x14 k \\x04\\x00 rK \\x00 PqK \\x00 qK \\x00 W| \\x04\\x00 | \\x05\\x00\\x14 } \\x03\\x00 q6 \\x00 W| \\x04\\x00 d \\x05\\x00\\x18 | \\x05\\x00 d \\x05\\x00\\x18\\x14 } \\x06\\x00 d \\x06\\x00 } \\x07\\x00 d \\x07\\x00 } \\x08\\x00 x \\t\\x01 t \\x03\\x00 r \\xce\\x01 t \\x04\\x00 j \\x07\\x00 t \\x08\\x00 d \\x03\\x00 t \\t\\x00 | \\x01\\x00 | \\x07\\x00\\x14\\x83\\x01\\x00\\x83\\x02\\x00 t \\x08\\x00 d \\x03\\x00 t \\t\\x00 | \\x01\\x00 | \\x07\\x00\\x14\\x83\\x01\\x00 d \\x05\\x00\\x17\\x83\\x02\\x00\\x83\\x02\\x00 } \\t\\x00 xq \\x00 | \\t\\x00 j \\x02\\x00\\x83\\x00\\x00 | \\x01\\x00 | \\x08\\x00\\x14 k \\x00\\x00 r{ \\x01 d \\x02\\x00 } \\n\\x00 xD \\x00 t \\x04\\x00 j \\n\\x00 | \\n\\x00\\x83\\x01\\x00 sm \\x01 t \\x04\\x00 j \\x07\\x00 t \\x08\\x00 d \\x03\\x00 d \\x08\\x00\\x83\\x02\\x00 t \\x08\\x00 d \\x03\\x00 d \\x08\\x00\\x83\\x02\\x00 t \\x08\\x00 d \\x03\\x00 d \\t\\x00\\x83\\x02\\x00\\x17\\x83\\x02\\x00 } \\n\\x00 q* \\x01 W| \\t\\x00 | \\n\\x00 9} \\t\\x00 q \\x0b\\x01 Wt \\x04\\x00 j \\x0b\\x00 | \\t\\x00 | \\x06\\x00\\x83\\x02\\x00 d \\x05\\x00 k \\x03\\x00 r \\x9a\\x01 q \\xc6\\x00 n \\x00\\x00 t \\x04\\x00 j \\x0c\\x00 | \\t\\x00 | \\x06\\x00\\x83\\x02\\x00 } \\x0b\\x00 t \\x04\\x00 j \\x0b\\x00 | \\x0b\\x00 | \\x06\\x00\\x83\\x02\\x00 d \\x05\\x00 k \\x03\\x00 r \\xca\\x01 q \\xc6\\x00 n \\x00\\x00 Pq \\xc6\\x00 Wd \\n\\x00 } \\x0c\\x00 | \\x03\\x00 | \\x0b\\x00 f \\x02\\x00 S' >>> t [ 6 : 26 ] 'd \\x01\\x00 d \\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00 d \\x02\\x00\\x15 } \\x00\\x00 ' >>> t [ - 3 :] ' \\x02\\x00 S' >>> t = 'd \\x01\\x00 d \\x02\\x00\\x15\\x00\\x00\\x00\\x00\\x01\\x00 d \\x02\\x00\\x15 } \\x00\\x00 ' >>> t [ - 3 :] '} \\x00\\x00 ' >>> t [: 7 ] + t [ - 3 :] 'd \\x01\\x00 d \\x02\\x00\\x15 } \\x00\\x00 ' >>> _ . encode ( 'hex' ) '640100640200157d0000' \u4ece\u800c\u6211\u4eec\u53ef\u4ee5\u4fee\u590d\u539f code >>> data . find ( '640100' ) 56 >>> data1 = data [: 56 ] + '640100640200157d0000640100640200157d0000' + data [ 56 + 40 :] >>> code1 = marshal . loads ( data1 . decode ( 'hex' )) >>> code_deparse ( code1 ) if False : x = 7 / 0 x = 7 / 0 Nsize = NSIZE pqsize = Nsize / 2 N = 0 while N . bit_length () != Nsize : while True : p = number . getStrongPrime ( pqsize ) q = number . getStrongPrime ( pqsize ) if abs ( p - q ) . bit_length () > Nsize * 0.496 : break N = p * q phi = ( p - 1 ) * ( q - 1 ) limit1 = 0.261 limit2 = 0.293 while True : d = number . getRandomRange ( pow ( 2 , int ( Nsize * limit1 )), pow ( 2 , int ( Nsize * limit1 ) + 1 )) while d . bit_length () < Nsize * limit2 : ppp = 0 while not number . isPrime ( ppp ): ppp = number . getRandomRange ( pow ( 2 , 45 ), pow ( 2 , 45 ) + pow ( 2 , 12 )) d *= ppp if number . GCD ( d , phi ) != 1 : continue e = number . inverse ( d , phi ) if number . GCD ( e , phi ) != 1 : continue break zzz = 3 return ( N , e ) < uncompyle6 . semantics . pysource . SourceWalker object at 0x10a0ea110 > \u53ef\u4ee5\u770b\u5230\u751f\u6210\u7684 d \u662f\u6545\u610f\u8d85\u4e86 0.292 \u7684\uff0c\u4e0d\u8fc7\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 ppp \u8303\u56f4\u5f88\u5c0f\uff0c\u5b9e\u9645\u4e0a\u6211\u4eec\u53ef\u4ee5\u6d4b\u8bd5\u5f97\u5230\u8fd9\u4e2a\u8303\u56f4\u7684\u7d20\u6570\u4e3a 125 \u4e2a\u3002\u5e76\u4e14 1280 * 0.261 + 45 = 379.08000000000004 > 375.03999999999996 = 1280 * 0.293 \u6240\u4ee5\u5176\u5b9e\u8fd9\u91cc\u5c31\u4e58\u4e86\u4e00\u4e2a\u6570\uff0c\u90a3\u4e48\u6211\u4eec\u5176\u5b9e\u5c31\u53ef\u4ee5\u679a\u4e3e\u4e00\u4e0b\u4e58\u4e86\u4ec0\u4e48\uff0c\u5e76\u4fee\u6539 e1=e*ppp\uff0c\u5176\u5b9e\u5c31\u56de\u5f52\u5230\u6807\u51c6\u7684 Boneh and Durfee attack\u3002 \u4f46\u662f\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 https://github.com/mimoo/RSA-and-LLL-attacks \u7684\u811a\u672c\u4e5f\u4e0d\u884c\uff0c\u5fc5\u987b\u5f97\u63d0\u9ad8 m\uff0c\u57fa\u672c\u5f97\u63d0\u5230 8\uff0c\u8fd9\u6837\u4ecd\u7136\u4e0d\u662f\u5f88\u7a33\u5b9a\u3002 \u5982\u679c\u4ed4\u7ec6\u5c1d\u8bd5\u5c1d\u8bd5\u7684\u8bdd\uff0c\u5c31\u4f1a\u53d1\u73b0 e1>N\uff0c\u8fd9\u770b\u8d77\u6765\u95ee\u9898\u4e0d\u5927\uff0c\u4f46\u662f\u539f\u811a\u672c\u91cc\u5047\u8bbe\u7684\u6570\u503c\u662f e<N \u7684\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u8fdb\u884c\u9002\u5f53\u7684\u4fee\u6539\u9884\u4f30\u7684\u4e0a\u4e0b\u754c X = 2 * floor ( N ^ delta ) # this _might_ be too much Y = floor ( N ^ ( 1 / 2 )) # correct if p, q are ~ same size \u6839\u636e\u4e0a\u8ff0\u63a8\u5bfc\uff0c\u4e0a\u4e0b\u754c\u5e94\u8be5\u4e3a |k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta} |k|<\\frac{2ed}{\\varphi(N)}<\\frac{3ed}{N}=3*\\frac{e}{N}*d<3*\\frac{e}{N}*N^{delta} |y|<2*N^{0.5} |y|<2*N^{0.5} \u6700\u540e\u4e3b\u8981\u4fee\u6539\u4e86 m \u548c X \u7684\u4e0a\u754c delta = . 262 # this means that d < N^delta # # Lattice (tweak those values) # # you should tweak this (after a first run), (e.g. increment it until a solution is found) m = 8 # size of the lattice (bigger the better/slower) # you need to be a lattice master to tweak these t = int (( 1 - 2 * delta ) * m ) # optimization from Herrmann and May X = floor ( 3 * e / N * N ^ delta ) #4*floor(N^delta) # this _might_ be too much Y = floor ( 2 * N ^ ( 1 / 2 )) # correct if p, q are ~ same size \u6700\u540e\u53ef\u4ee5\u5f97\u5230\u7ed3\u679c [ DEBUG ] Received 0x1f bytes: 'Succcess!\\n' 'OOO{Br3akingL!mits?}\\n' OOO { Br3akingL!mits? } \u4e0d\u5f97\u4e0d\u8bf4\u8fd9\u4e2a\u9898\u76ee\uff0c\u771f\u7684\u662f\u9700\u8981 \u591a \u6838\u670d\u52a1\u5668\u3002\u3002","title":"2019 Defcon Quals ASRybaB"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_coppersmith_attack-zh/#_17","text":"Survey: Lattice Reduction Attacks on RSA An Introduction to Coppersmith\u2019s method and Applications in Cryptology","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/","text":"EN | ZH d \u6cc4\u9732\u653b\u51fb \u00b6 \u653b\u51fb\u539f\u7406 \u00b6 \u9996\u5148\u5f53 d d \u6cc4\u9732\u4e4b\u540e\uff0c\u6211\u4eec\u81ea\u7136\u53ef\u4ee5\u89e3\u5bc6\u6240\u6709\u52a0\u5bc6\u7684\u6d88\u606f\u3002\u6211\u4eec\u751a\u81f3\u8fd8\u53ef\u4ee5\u5bf9\u6a21\u6570 N \u8fdb\u884c\u5206\u89e3\u3002\u5176\u57fa\u672c\u539f\u7406\u5982\u4e0b \u6211\u4eec\u77e5\u9053 ed \\equiv 1 \\bmod \\varphi(n) ed \\equiv 1 \\bmod \\varphi(n) \uff0c\u90a3\u4e48\u5b58\u5728\u4e00\u4e2a k k \u4f7f\u5f97 ed-1=k\\varphi(n) ed-1=k\\varphi(n) \u53c8 \\forall a\\in {Z}_n^* \\forall a\\in {Z}_n^* \uff0c\u6ee1\u8db3 a^{ed-1}\\equiv1(\\bmod n) a^{ed-1}\\equiv1(\\bmod n) \u3002\u4ee4 ed-1=2^st ed-1=2^st \u5176\u4e2d\uff0c t t \u662f\u4e00\u4e2a\u5947\u6570\u3002\u7136\u540e\u53ef\u4ee5\u8bc1\u660e\u5bf9\u4e8e\u81f3\u5c11\u4e00\u534a\u7684 a\\in {Z}_n^* a\\in {Z}_n^* \uff0c\u5b58\u5728\u4e00\u4e2a i\\in[1,s] i\\in[1,s] \uff0c\u4f7f\u5f97 a^{2^{i-1}t}\\not\\equiv\\pm1(\\bmod n),a^{2^{i}t}\\equiv1(\\bmod n) a^{2^{i-1}t}\\not\\equiv\\pm1(\\bmod n),a^{2^{i}t}\\equiv1(\\bmod n) \u6210\u7acb\u3002\u5982\u679c a,i a,i \u6ee1\u8db3\u4e0a\u8ff0\u6761\u4ef6\uff0c gcd(a^{2^{i-1}t}-1,n) gcd(a^{2^{i-1}t}-1,n) \u662f n n \u7684\u4e00\u4e2a\u975e\u5e73\u51e1\u56e0\u5b50\uff0c\u6240\u4ee5\u53ef\u4ee5\u5bf9 n n \u8fdb\u884c\u66b4\u529b\u5206\u89e3\u3002 \u5de5\u5177 \u00b6 \u5229\u7528\u4ee5\u4e0b\u5de5\u5177\u53ef\u4ee5\u76f4\u63a5\u8fdb\u884c\u8ba1\u7b97 RsaConverter.exe ( https://sourceforge.net/projects/rsaconverter/ , for windows ) rsatool.py (\u5206\u89e3\u539f\u7406\u5982\u4e0a) 2017 HITB - hack in the card II \u00b6 The second smart card sent to us has been added some countermeasures by that evil company. They also changed the public key(attachments -> publickey.pem). However it seems that they missed something...... Can you decrypt the following hex-encoded ciphertext this time? 016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977 \u8fd9\u9898\u662f\u63a5\u7eed 2017 HITB - hack in the card I \u7684\u4e00\u9053\u9898\uff0c\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 openssl \u67e5\u770b publickey.pem \u7684\u516c\u94a5\uff0c\u53d1\u73b0\u5b83\u7684 N \u4e0e\u4e0a\u4e00\u9053\u9898\u7684 N \u76f8\u540c\uff0c\u5e76\u4e14\u4e0a\u9898\u7684 N\uff0ce\uff0cd \u5df2\u77e5\u3002\u7531\u6b64\u53ef\u76f4\u63a5\u4f7f\u7528\u4e0a\u9762\u7684 rsatool.py \u5f97\u5230 p\uff0cq\uff0c\u5e76\u901a\u8fc7\u672c\u9898\u7684 e \u8ba1\u7b97\u51fa e \u5f97\u5230\u660e\u6587\u3002 Wiener's Attack \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5728 d \u6bd4\u8f83\u5c0f\uff08 d<\\frac{1}{3}N^{\\frac{1}{4}} d<\\frac{1}{3}N^{\\frac{1}{4}} \uff09\u65f6\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u4f7f\u7528 Wiener's Attack \u6765\u83b7\u5f97\u79c1\u94a5\u3002 \u653b\u51fb\u539f\u7406 \u00b6 https://en.wikipedia.org/wiki/Wiener%27s_attack https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/ \u5de5\u5177 \u00b6 https://github.com/pablocelayes/rsa-wiener-attack \u7efc\u5408\u4f8b\u5b50 \u00b6 2016 HCTF RSA1 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 2016 \u5e74 HCTF \u4e2d RSA 1 - Crypto So Interesting \u4e3a\u4f8b\u8fdb\u884c\u5206\u6790\uff0c \u6e90\u4ee3\u7801\u94fe\u63a5 \u3002 \u9996\u5148\u5148\u7ed5\u8fc7\u7a0b\u5e8f\u7684 proof \u90e8\u5206\uff0c\u5dee\u4e0d\u591a\u4f7f\u7528\u4e00\u4e9b\u968f\u673a\u7684\u6570\u636e\u5c31\u53ef\u4ee5\u7ed5\u8fc7\u3002 \u5176\u6b21\uff0c\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801\u90e8\u5206\uff0c\u7a0b\u5e8f\u662f\u6839\u636e\u6211\u4eec\u7684 token \u6765\u83b7\u53d6 flag \u7684\uff0c\u8fd9\u91cc\u6211\u4eec\u5c31\u76f4\u63a5\u5229\u7528\u6e90\u4ee3\u7801\u4e2d\u63d0\u4f9b\u7684 token\u3002 print \"This is a RSA Decryption System\" print \"Please enter Your team token: \" token = raw_input () try : flag = get_flag ( token ) assert len ( flag ) == 38 except : print \"Token error!\" m_exit ( - 1 ) \u63a5\u4e0b\u6765\u6211\u4eec\u9996\u5148\u77e5\u9053 n=pq n=pq \uff0c\u6211\u4eec\u518d\u6765\u4f60\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a e\uff0cd \u662f\u5982\u4f55\u5f97\u5230\u7684\u3002 p = getPrime ( 2048 ) q = getPrime ( 2048 ) n = p * q e , d = get_ed ( p , q ) print \"n: \" , hex ( n ) print \"e: \" , hex ( e ) get_ed \u51fd\u6570\u5982\u4e0b def get_ed ( p , q ): k = cal_bit ( q * p ) phi_n = ( p - 1 ) * ( q - 1 ) r = random . randint ( 10 , 99 ) while True : u = getPrime ( k / 4 - r ) if gcd ( u , phi_n ) != 1 : continue t = invmod ( u , phi_n ) e = pi_b ( t ) if gcd ( e , phi_n ) == 1 : break d = invmod ( e , phi_n ) return ( e , d ) \u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u5f97\u5230\u7684 u \u7684\u4f4d\u6570\u6bd4 n \u7684\u4f4d\u6570\u7684\u56db\u5206\u4e4b\u4e00\u8fd8\u8981\u5c11\uff0c\u8fd9\u91cc\u5176\u5b9e\u5c31\u5dee\u4e0d\u591a\u6ee1\u8db3\u4e86 Wiener's Attack \u4e86\u3002\u800c\u4e14\u6211\u4eec\u8ba1\u7b97\u51fa\u6765\u7684 u\uff0ct\uff0ce\uff0cd \u8fd8\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 \\begin{align*} ut &\\equiv 1 \\bmod \\varphi(n) \\\\ et &\\equiv 1 \\bmod bt \\\\ ed &\\equiv 1 \\bmod \\varphi(n) \\end{align*} \\begin{align*} ut &\\equiv 1 \\bmod \\varphi(n) \\\\ et &\\equiv 1 \\bmod bt \\\\ ed &\\equiv 1 \\bmod \\varphi(n) \\end{align*} \u6839\u636e\u9898\u4e2d\u7ed9\u51fa\u7684\u6761\u4ef6\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 n\uff0ce\uff0cbt\u3002 \u6240\u4ee5\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u4e0a\u9762\u7684\u7b2c\u4e8c\u4e2a\u5f0f\u5b50\u77e5\u9053 e\u3002\u8fd9\u65f6\u5019\uff0c\u53ef\u4ee5\u5229\u7528\u7b2c\u4e00\u4e2a\u5f0f\u5b50\u8fdb\u884c Wiener's Attack\uff0c\u83b7\u53d6 u\u3002\u8fdb\u800c\u8fd9\u65f6\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u79c1\u94a5\u6307\u6570\u6cc4\u9732\u653b\u51fb\u7684\u65b9\u6cd5\u6765\u5206\u89e3 N \u4ece\u800c\u5f97\u5230 p\uff0cq\u3002\u8fdb\u800c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230 d \u4e86\u3002 \u9996\u5148\u6211\u4eec\u7ed5\u8fc7 proof \u5f97\u5230\u4e86 N\uff0ce\uff0c\u52a0\u5bc6\u540e\u7684 flag \u5982\u4e0b n: 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 e: 0x10194521505692a64d043daaef7647e0efb1503ec89220a0e4148ab53ecf708146a8893a2e700e4f2f062be14a3ab4e46339a939d5c7289904cc0ab043320d3a4d7da868bf5736ae5f787d6c0e3d9b8cc4b81314ad6c5ff643bc0d8946fea7eb09bf707a54747a39df1cfc0c30849770578cb63de86621001ce86a11874c91419a4d07373e66e94f31b988cac3aeaff88c7abaf3b78468a434990f7854e734208a7461f8245660fa8301f979e85517d705302c797dbdf2938cc442b01c228939eb73aa29651a198a332af2bb982310699684e5a0595c7413ec01eefb3613a9ea4b59f1de984ad4bf6654960613c0f8104b4e41fb33384e07f715176d68f4bb7613b1258675e70dc774f701aee053830f0be28ba9f308c9fe1707a5ba07a2027d74144b8aeb4042df3c1d73d9c38c2d7d1a890fd70d6e38c72da5d075f3811c0354dcecdd836a59112a70be22757278c5e4973906aaeeadd6f61d0845d6f9761df191b0b2527d122dd07f8bd07f5cd14268246ac2b93b778c84b5157f7eb23a8eaa9f0f885f2a38e3fb8fd1012d9b6c841cea8d9d73b232bef298afd086c1063bdd11e0777c8d2ec91ae843a67a98039cb53fad0ee25040176841a017fabf79b98de21d40bc6985f82dd84406aad26e9ac9bc5f6e12385230d9620b888c201ca9c413cbf0f36b100a6c62c5c8f065934fcf9f9f0179eea35888cb357b704441c1 flag: 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df \u5176\u6b21\u4f7f\u7528\u5982\u4e0b\u65b9\u6cd5\u8fdb\u884c Wiener's Attack \u5f97\u5230 u\uff0c\u5982\u4e0b if __name__ == \"__main__\" : bt = 536380958350616057242691418634880594502192106332317228051967064327642091297687630174183636288378234177476435270519631690543765125295554448698898712393467267006465045949611180821007306678935181142803069337672948471202242891010188677287454504933695082327796243976863378333980923047411230913909715527759877351702062345876337256220760223926254773346698839492268265110546383782370744599490250832085044856878026833181982756791595730336514399767134613980006467147592898197961789187070786602534602178082726728869941829230655559180178594489856595304902790182697751195581218334712892008282605180395912026326384913562290014629187579128041030500771670510157597682826798117937852656884106597180126028398398087318119586692935386069677459788971114075941533740462978961436933215446347246886948166247617422293043364968298176007659058279518552847235689217185712791081965260495815179909242072310545078116020998113413517429654328367707069941427368374644442366092232916196726067387582032505389946398237261580350780769275427857010543262176468343294217258086275244086292475394366278211528621216522312552812343261375050388129743012932727654986046774759567950981007877856194574274373776538888953502272879816420369255752871177234736347325263320696917012616273 L e = 0x10194521505692a64d043daaef7647e0efb1503ec89220a0e4148ab53ecf708146a8893a2e700e4f2f062be14a3ab4e46339a939d5c7289904cc0ab043320d3a4d7da868bf5736ae5f787d6c0e3d9b8cc4b81314ad6c5ff643bc0d8946fea7eb09bf707a54747a39df1cfc0c30849770578cb63de86621001ce86a11874c91419a4d07373e66e94f31b988cac3aeaff88c7abaf3b78468a434990f7854e734208a7461f8245660fa8301f979e85517d705302c797dbdf2938cc442b01c228939eb73aa29651a198a332af2bb982310699684e5a0595c7413ec01eefb3613a9ea4b59f1de984ad4bf6654960613c0f8104b4e41fb33384e07f715176d68f4bb7613b1258675e70dc774f701aee053830f0be28ba9f308c9fe1707a5ba07a2027d74144b8aeb4042df3c1d73d9c38c2d7d1a890fd70d6e38c72da5d075f3811c0354dcecdd836a59112a70be22757278c5e4973906aaeeadd6f61d0845d6f9761df191b0b2527d122dd07f8bd07f5cd14268246ac2b93b778c84b5157f7eb23a8eaa9f0f885f2a38e3fb8fd1012d9b6c841cea8d9d73b232bef298afd086c1063bdd11e0777c8d2ec91ae843a67a98039cb53fad0ee25040176841a017fabf79b98de21d40bc6985f82dd84406aad26e9ac9bc5f6e12385230d9620b888c201ca9c413cbf0f36b100a6c62c5c8f065934fcf9f9f0179eea35888cb357b704441c1 t = gmpy2 . invert ( e , bt ) n = 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 solve ( n , t ) \u5176\u4e2d solve \u51fd\u6570\u5c31\u662f\u5bf9\u5e94\u7684 Wiener's Attack \u7684\u51fd\u6570\u3002 \u6211\u4eec\u5f97\u5230\u4e86 u\uff0c\u5982\u4e0b \u279c rsa-wiener-attack git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) \u63a5\u7740\u5229\u7528 RsaConverter \u4ee5\u53ca u\uff0ct\uff0cn \u83b7\u53d6\u5bf9\u5e94\u7684 p \u548c q\u3002\u5982\u4e0b 94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 \u7136\u540e\u6211\u4eec\u76f4\u63a5\u53bb\u83b7\u5f97 d\uff0c\u8fdb\u800c\u5c31\u53ef\u4ee5\u6062\u590d\u660e\u6587 p = 0x94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 q = 0x8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 if p * q == n : print 'true' phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df flag = gmpy2 . powmod ( cipher , d , n ) print long_to_bytes ( flag ) \u5f97\u5230 flag true hctf { d8e8fca2dc0f896fd7cb4cb0031ba249 } \u53c2\u8003\u6587\u732e \u00b6 http://cacr.uwaterloo.ca/hac/about/chap8.pdf","title":"Rsa d attack zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#d","text":"","title":"d \u6cc4\u9732\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#_1","text":"\u9996\u5148\u5f53 d d \u6cc4\u9732\u4e4b\u540e\uff0c\u6211\u4eec\u81ea\u7136\u53ef\u4ee5\u89e3\u5bc6\u6240\u6709\u52a0\u5bc6\u7684\u6d88\u606f\u3002\u6211\u4eec\u751a\u81f3\u8fd8\u53ef\u4ee5\u5bf9\u6a21\u6570 N \u8fdb\u884c\u5206\u89e3\u3002\u5176\u57fa\u672c\u539f\u7406\u5982\u4e0b \u6211\u4eec\u77e5\u9053 ed \\equiv 1 \\bmod \\varphi(n) ed \\equiv 1 \\bmod \\varphi(n) \uff0c\u90a3\u4e48\u5b58\u5728\u4e00\u4e2a k k \u4f7f\u5f97 ed-1=k\\varphi(n) ed-1=k\\varphi(n) \u53c8 \\forall a\\in {Z}_n^* \\forall a\\in {Z}_n^* \uff0c\u6ee1\u8db3 a^{ed-1}\\equiv1(\\bmod n) a^{ed-1}\\equiv1(\\bmod n) \u3002\u4ee4 ed-1=2^st ed-1=2^st \u5176\u4e2d\uff0c t t \u662f\u4e00\u4e2a\u5947\u6570\u3002\u7136\u540e\u53ef\u4ee5\u8bc1\u660e\u5bf9\u4e8e\u81f3\u5c11\u4e00\u534a\u7684 a\\in {Z}_n^* a\\in {Z}_n^* \uff0c\u5b58\u5728\u4e00\u4e2a i\\in[1,s] i\\in[1,s] \uff0c\u4f7f\u5f97 a^{2^{i-1}t}\\not\\equiv\\pm1(\\bmod n),a^{2^{i}t}\\equiv1(\\bmod n) a^{2^{i-1}t}\\not\\equiv\\pm1(\\bmod n),a^{2^{i}t}\\equiv1(\\bmod n) \u6210\u7acb\u3002\u5982\u679c a,i a,i \u6ee1\u8db3\u4e0a\u8ff0\u6761\u4ef6\uff0c gcd(a^{2^{i-1}t}-1,n) gcd(a^{2^{i-1}t}-1,n) \u662f n n \u7684\u4e00\u4e2a\u975e\u5e73\u51e1\u56e0\u5b50\uff0c\u6240\u4ee5\u53ef\u4ee5\u5bf9 n n \u8fdb\u884c\u66b4\u529b\u5206\u89e3\u3002","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#_2","text":"\u5229\u7528\u4ee5\u4e0b\u5de5\u5177\u53ef\u4ee5\u76f4\u63a5\u8fdb\u884c\u8ba1\u7b97 RsaConverter.exe ( https://sourceforge.net/projects/rsaconverter/ , for windows ) rsatool.py (\u5206\u89e3\u539f\u7406\u5982\u4e0a)","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#2017-hitb-hack-in-the-card-ii","text":"The second smart card sent to us has been added some countermeasures by that evil company. They also changed the public key(attachments -> publickey.pem). However it seems that they missed something...... Can you decrypt the following hex-encoded ciphertext this time? 016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977 \u8fd9\u9898\u662f\u63a5\u7eed 2017 HITB - hack in the card I \u7684\u4e00\u9053\u9898\uff0c\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 openssl \u67e5\u770b publickey.pem \u7684\u516c\u94a5\uff0c\u53d1\u73b0\u5b83\u7684 N \u4e0e\u4e0a\u4e00\u9053\u9898\u7684 N \u76f8\u540c\uff0c\u5e76\u4e14\u4e0a\u9898\u7684 N\uff0ce\uff0cd \u5df2\u77e5\u3002\u7531\u6b64\u53ef\u76f4\u63a5\u4f7f\u7528\u4e0a\u9762\u7684 rsatool.py \u5f97\u5230 p\uff0cq\uff0c\u5e76\u901a\u8fc7\u672c\u9898\u7684 e \u8ba1\u7b97\u51fa e \u5f97\u5230\u660e\u6587\u3002","title":"2017 HITB - hack in the card II"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#wieners-attack","text":"","title":"Wiener's Attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#_3","text":"\u5728 d \u6bd4\u8f83\u5c0f\uff08 d<\\frac{1}{3}N^{\\frac{1}{4}} d<\\frac{1}{3}N^{\\frac{1}{4}} \uff09\u65f6\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u4f7f\u7528 Wiener's Attack \u6765\u83b7\u5f97\u79c1\u94a5\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#_4","text":"https://en.wikipedia.org/wiki/Wiener%27s_attack https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#_5","text":"https://github.com/pablocelayes/rsa-wiener-attack","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#_6","text":"","title":"\u7efc\u5408\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#2016-hctf-rsa1","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 2016 \u5e74 HCTF \u4e2d RSA 1 - Crypto So Interesting \u4e3a\u4f8b\u8fdb\u884c\u5206\u6790\uff0c \u6e90\u4ee3\u7801\u94fe\u63a5 \u3002 \u9996\u5148\u5148\u7ed5\u8fc7\u7a0b\u5e8f\u7684 proof \u90e8\u5206\uff0c\u5dee\u4e0d\u591a\u4f7f\u7528\u4e00\u4e9b\u968f\u673a\u7684\u6570\u636e\u5c31\u53ef\u4ee5\u7ed5\u8fc7\u3002 \u5176\u6b21\uff0c\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801\u90e8\u5206\uff0c\u7a0b\u5e8f\u662f\u6839\u636e\u6211\u4eec\u7684 token \u6765\u83b7\u53d6 flag \u7684\uff0c\u8fd9\u91cc\u6211\u4eec\u5c31\u76f4\u63a5\u5229\u7528\u6e90\u4ee3\u7801\u4e2d\u63d0\u4f9b\u7684 token\u3002 print \"This is a RSA Decryption System\" print \"Please enter Your team token: \" token = raw_input () try : flag = get_flag ( token ) assert len ( flag ) == 38 except : print \"Token error!\" m_exit ( - 1 ) \u63a5\u4e0b\u6765\u6211\u4eec\u9996\u5148\u77e5\u9053 n=pq n=pq \uff0c\u6211\u4eec\u518d\u6765\u4f60\u4ed4\u7ec6\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a e\uff0cd \u662f\u5982\u4f55\u5f97\u5230\u7684\u3002 p = getPrime ( 2048 ) q = getPrime ( 2048 ) n = p * q e , d = get_ed ( p , q ) print \"n: \" , hex ( n ) print \"e: \" , hex ( e ) get_ed \u51fd\u6570\u5982\u4e0b def get_ed ( p , q ): k = cal_bit ( q * p ) phi_n = ( p - 1 ) * ( q - 1 ) r = random . randint ( 10 , 99 ) while True : u = getPrime ( k / 4 - r ) if gcd ( u , phi_n ) != 1 : continue t = invmod ( u , phi_n ) e = pi_b ( t ) if gcd ( e , phi_n ) == 1 : break d = invmod ( e , phi_n ) return ( e , d ) \u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u5f97\u5230\u7684 u \u7684\u4f4d\u6570\u6bd4 n \u7684\u4f4d\u6570\u7684\u56db\u5206\u4e4b\u4e00\u8fd8\u8981\u5c11\uff0c\u8fd9\u91cc\u5176\u5b9e\u5c31\u5dee\u4e0d\u591a\u6ee1\u8db3\u4e86 Wiener's Attack \u4e86\u3002\u800c\u4e14\u6211\u4eec\u8ba1\u7b97\u51fa\u6765\u7684 u\uff0ct\uff0ce\uff0cd \u8fd8\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6 \\begin{align*} ut &\\equiv 1 \\bmod \\varphi(n) \\\\ et &\\equiv 1 \\bmod bt \\\\ ed &\\equiv 1 \\bmod \\varphi(n) \\end{align*} \\begin{align*} ut &\\equiv 1 \\bmod \\varphi(n) \\\\ et &\\equiv 1 \\bmod bt \\\\ ed &\\equiv 1 \\bmod \\varphi(n) \\end{align*} \u6839\u636e\u9898\u4e2d\u7ed9\u51fa\u7684\u6761\u4ef6\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 n\uff0ce\uff0cbt\u3002 \u6240\u4ee5\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u4e0a\u9762\u7684\u7b2c\u4e8c\u4e2a\u5f0f\u5b50\u77e5\u9053 e\u3002\u8fd9\u65f6\u5019\uff0c\u53ef\u4ee5\u5229\u7528\u7b2c\u4e00\u4e2a\u5f0f\u5b50\u8fdb\u884c Wiener's Attack\uff0c\u83b7\u53d6 u\u3002\u8fdb\u800c\u8fd9\u65f6\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u79c1\u94a5\u6307\u6570\u6cc4\u9732\u653b\u51fb\u7684\u65b9\u6cd5\u6765\u5206\u89e3 N \u4ece\u800c\u5f97\u5230 p\uff0cq\u3002\u8fdb\u800c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230 d \u4e86\u3002 \u9996\u5148\u6211\u4eec\u7ed5\u8fc7 proof \u5f97\u5230\u4e86 N\uff0ce\uff0c\u52a0\u5bc6\u540e\u7684 flag \u5982\u4e0b n: 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 e: 0x10194521505692a64d043daaef7647e0efb1503ec89220a0e4148ab53ecf708146a8893a2e700e4f2f062be14a3ab4e46339a939d5c7289904cc0ab043320d3a4d7da868bf5736ae5f787d6c0e3d9b8cc4b81314ad6c5ff643bc0d8946fea7eb09bf707a54747a39df1cfc0c30849770578cb63de86621001ce86a11874c91419a4d07373e66e94f31b988cac3aeaff88c7abaf3b78468a434990f7854e734208a7461f8245660fa8301f979e85517d705302c797dbdf2938cc442b01c228939eb73aa29651a198a332af2bb982310699684e5a0595c7413ec01eefb3613a9ea4b59f1de984ad4bf6654960613c0f8104b4e41fb33384e07f715176d68f4bb7613b1258675e70dc774f701aee053830f0be28ba9f308c9fe1707a5ba07a2027d74144b8aeb4042df3c1d73d9c38c2d7d1a890fd70d6e38c72da5d075f3811c0354dcecdd836a59112a70be22757278c5e4973906aaeeadd6f61d0845d6f9761df191b0b2527d122dd07f8bd07f5cd14268246ac2b93b778c84b5157f7eb23a8eaa9f0f885f2a38e3fb8fd1012d9b6c841cea8d9d73b232bef298afd086c1063bdd11e0777c8d2ec91ae843a67a98039cb53fad0ee25040176841a017fabf79b98de21d40bc6985f82dd84406aad26e9ac9bc5f6e12385230d9620b888c201ca9c413cbf0f36b100a6c62c5c8f065934fcf9f9f0179eea35888cb357b704441c1 flag: 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df \u5176\u6b21\u4f7f\u7528\u5982\u4e0b\u65b9\u6cd5\u8fdb\u884c Wiener's Attack \u5f97\u5230 u\uff0c\u5982\u4e0b if __name__ == \"__main__\" : bt = 536380958350616057242691418634880594502192106332317228051967064327642091297687630174183636288378234177476435270519631690543765125295554448698898712393467267006465045949611180821007306678935181142803069337672948471202242891010188677287454504933695082327796243976863378333980923047411230913909715527759877351702062345876337256220760223926254773346698839492268265110546383782370744599490250832085044856878026833181982756791595730336514399767134613980006467147592898197961789187070786602534602178082726728869941829230655559180178594489856595304902790182697751195581218334712892008282605180395912026326384913562290014629187579128041030500771670510157597682826798117937852656884106597180126028398398087318119586692935386069677459788971114075941533740462978961436933215446347246886948166247617422293043364968298176007659058279518552847235689217185712791081965260495815179909242072310545078116020998113413517429654328367707069941427368374644442366092232916196726067387582032505389946398237261580350780769275427857010543262176468343294217258086275244086292475394366278211528621216522312552812343261375050388129743012932727654986046774759567950981007877856194574274373776538888953502272879816420369255752871177234736347325263320696917012616273 L e = 0x10194521505692a64d043daaef7647e0efb1503ec89220a0e4148ab53ecf708146a8893a2e700e4f2f062be14a3ab4e46339a939d5c7289904cc0ab043320d3a4d7da868bf5736ae5f787d6c0e3d9b8cc4b81314ad6c5ff643bc0d8946fea7eb09bf707a54747a39df1cfc0c30849770578cb63de86621001ce86a11874c91419a4d07373e66e94f31b988cac3aeaff88c7abaf3b78468a434990f7854e734208a7461f8245660fa8301f979e85517d705302c797dbdf2938cc442b01c228939eb73aa29651a198a332af2bb982310699684e5a0595c7413ec01eefb3613a9ea4b59f1de984ad4bf6654960613c0f8104b4e41fb33384e07f715176d68f4bb7613b1258675e70dc774f701aee053830f0be28ba9f308c9fe1707a5ba07a2027d74144b8aeb4042df3c1d73d9c38c2d7d1a890fd70d6e38c72da5d075f3811c0354dcecdd836a59112a70be22757278c5e4973906aaeeadd6f61d0845d6f9761df191b0b2527d122dd07f8bd07f5cd14268246ac2b93b778c84b5157f7eb23a8eaa9f0f885f2a38e3fb8fd1012d9b6c841cea8d9d73b232bef298afd086c1063bdd11e0777c8d2ec91ae843a67a98039cb53fad0ee25040176841a017fabf79b98de21d40bc6985f82dd84406aad26e9ac9bc5f6e12385230d9620b888c201ca9c413cbf0f36b100a6c62c5c8f065934fcf9f9f0179eea35888cb357b704441c1 t = gmpy2 . invert ( e , bt ) n = 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 solve ( n , t ) \u5176\u4e2d solve \u51fd\u6570\u5c31\u662f\u5bf9\u5e94\u7684 Wiener's Attack \u7684\u51fd\u6570\u3002 \u6211\u4eec\u5f97\u5230\u4e86 u\uff0c\u5982\u4e0b \u279c rsa-wiener-attack git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) \u63a5\u7740\u5229\u7528 RsaConverter \u4ee5\u53ca u\uff0ct\uff0cn \u83b7\u53d6\u5bf9\u5e94\u7684 p \u548c q\u3002\u5982\u4e0b 94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 \u7136\u540e\u6211\u4eec\u76f4\u63a5\u53bb\u83b7\u5f97 d\uff0c\u8fdb\u800c\u5c31\u53ef\u4ee5\u6062\u590d\u660e\u6587 p = 0x94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 q = 0x8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 if p * q == n : print 'true' phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df flag = gmpy2 . powmod ( cipher , d , n ) print long_to_bytes ( flag ) \u5f97\u5230 flag true hctf { d8e8fca2dc0f896fd7cb4cb0031ba249 }","title":"2016 HCTF RSA1"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack-zh/#_7","text":"http://cacr.uwaterloo.ca/hac/about/chap8.pdf","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/","text":"EN | ZH d Leak attack \u00b6 Attack principle \u00b6 First, when d is leaked, we can naturally decrypt all encrypted messages. We can even decompose the modulus N. The basic principle is as follows We know ed \\equiv 1 \\bmod \\varphi(n) ed \\equiv 1 \\bmod \\varphi(n) , then \\varphi(n) | k=ed-1 \\varphi(n) | k=ed-1 . Obviously k is an even number, we can make k=2^tr k=2^tr , where r is odd and t is not less than 1. So for any number g that is relative to N, we have g^k \\equiv 1 \\bmod n g^k \\equiv 1 \\bmod n . Then z=g^{\\frac{k}{2}} z=g^{\\frac{k}{2}} is the quadratic root of the modulo N. Then we have $$ z^2 \\equiv 1 \\bmod p \\ z^2 \\equiv 1 \\bmod q $$ Furthermore, we know that the equation has the following four solutions, the first two are $$ x equiv PM1 N way $$ The last two are \\pm x \\pm x , where x satisfies the following conditions $$ x equiv 1 p \\ way x equiv -1 q way $$ Obviously, z=g^{\\frac{k}{2}} z=g^{\\frac{k}{2}} satisfies the latter condition, and we can calculate gcd(z-1,N) gcd(z-1,N) to decompose N. Tools \u00b6 Use the following tools to perform calculations directly RsaConverter.exe ( https://sourceforge.net/projects/rsaconverter/ , for windows ) rsatool.py 2017 HITB - hack in the card II \u00b6 The second smart card sent to us has been added some countermeasures by that evil company. They also changed the public key(attachments -> publickey.pem). However it seems that they missed something...... Can you decrypt the following hex-encoded ciphertext this time? ``` > 016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977 ``` This question is a question that follows 2017 HITB - hack in the card I. We use openssl to view the public key of publickey.pem and find that its N is the same as the N of the previous question, and the N of the previous question, e,d is known. Thus, you can directly use the above rsatool.py to get p, q, and calculate e from the e of this problem to get the plain text. Wiener's Attack \u00b6 Attack conditions \u00b6 When d is small ( d<\\frac{1}{3}N^{\\frac{1}{4}} d&lt;\\frac{1}{3}N^{\\frac{1}{4}} ), an attacker can use Wiener's Attack to get the private key. Attack principle \u00b6 https://en.wikipedia.org/wiki/Wiener%27s_attack https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/ Tools \u00b6 https://github.com/pablocelayes/rsa-wiener-attack Comprehensive example \u00b6 2016 HCTF RSA1 \u00b6 Here we take the RSA 1 - Crypto So Interesting in the 2016 HCTF as an example, [source code link] ( https://github.com/Hcamael/ctf-library/tree/master/RSA1 ). First, bypass the proof part of the program, and you can bypass it with almost random data. Second, let's analyze the specific code part. The program gets the flag according to our token. Here we directly use the token provided in the source code. print \"This is a RSA Decryption System\" print \"Please enter Your team token: \" token = raw_input () try : flag = get_flag ( token ) assert len ( flag ) == 38 except : print \"Token error!\" m_exit ( - 1 ) Next we first know n=pq n=pq , let's take a closer look at how this e, d is obtained. p = getPrime ( 2048 ) q = getPrime ( 2048 ) n = p * q e , d = get_ed ( p , q ) print \"n: \" , hex ( n ) print & quot ; e : & quot ;, hex ( e ) get_ed function is as follows def get_ed ( p , q ): k = cal_bit ( q * p ) phi_n = ( p - 1 ) * ( q - 1 ) r = random . randint ( 10 , 99 ) while True : u = getPrime ( k / 4 - r ) if gcd ( u , phi_n ) != 1 : continue t = invmod ( u , phi_n ) e = pi_b ( t ) if gcd ( e , phi_n ) == 1 : break d = invmod ( e , phi_n ) return ( e , d ) It can be seen that the number of bits we get is less than a quarter of the number of bits in n, which is almost the same as Wiener's Attack. And we calculated u, t, e, d also meet the following conditions $$ \\begin{align*} out & equals 1 bmod varphi (n) Others & equiv 1 bt \\ way ed &\\equiv 1 \\bmod \\varphi(n) \\end{align*} $$ According to the conditions given in the title, we already know n, e, bt. So first we can know e according to the second formula above. At this time, you can use the first formula for Wiener's Attack to get u. Then we can use the private key index to leak the attack to decompose N to get p, q. Then we can get d. First we bypassed proof and got N, e. The encrypted flag is as follows n: 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 is: flag: 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df Secondly, use the following method to get Wiener's Attack to get u, as follows if __name__ == \"__main__\" : bt = e = t = gmpy2 . invert ( e , bt ) n = 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 solve ( n , t ) The solve function is the function of the corresponding Wiener's Attack. We got u as follows \u279c rsa-wiener-attack git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) Then use RsaConverter and u,t,n to get the corresponding p and q. as follows 94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 Then we go directly to get d, and then we can recover the plaintext. p = 0x94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 q = 0x8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 if p * q == n : print 'true' Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df flag = gmpy2 . powmod ( cipher , d , n ) print long_to_bytes ( flag ) Get flag true hctf { d8e8fca2dc0f896fd7cb4cb0031ba249 }","title":"\u79c1\u94a5 d \u76f8\u5173\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#d-leak-attack","text":"","title":"d Leak attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#attack-principle","text":"First, when d is leaked, we can naturally decrypt all encrypted messages. We can even decompose the modulus N. The basic principle is as follows We know ed \\equiv 1 \\bmod \\varphi(n) ed \\equiv 1 \\bmod \\varphi(n) , then \\varphi(n) | k=ed-1 \\varphi(n) | k=ed-1 . Obviously k is an even number, we can make k=2^tr k=2^tr , where r is odd and t is not less than 1. So for any number g that is relative to N, we have g^k \\equiv 1 \\bmod n g^k \\equiv 1 \\bmod n . Then z=g^{\\frac{k}{2}} z=g^{\\frac{k}{2}} is the quadratic root of the modulo N. Then we have $$ z^2 \\equiv 1 \\bmod p \\ z^2 \\equiv 1 \\bmod q $$ Furthermore, we know that the equation has the following four solutions, the first two are $$ x equiv PM1 N way $$ The last two are \\pm x \\pm x , where x satisfies the following conditions $$ x equiv 1 p \\ way x equiv -1 q way $$ Obviously, z=g^{\\frac{k}{2}} z=g^{\\frac{k}{2}} satisfies the latter condition, and we can calculate gcd(z-1,N) gcd(z-1,N) to decompose N.","title":"Attack principle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#tools","text":"Use the following tools to perform calculations directly RsaConverter.exe ( https://sourceforge.net/projects/rsaconverter/ , for windows ) rsatool.py","title":"Tools"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#2017-hitb-hack-in-the-card-ii","text":"The second smart card sent to us has been added some countermeasures by that evil company. They also changed the public key(attachments -> publickey.pem). However it seems that they missed something...... Can you decrypt the following hex-encoded ciphertext this time? ``` > 016d1d26a470fad51d52e5f3e90075ab77df69d2fb39905fe634ded81d10a5fd10c35e1277035a9efabb66e4d52fd2d1eaa845a93a4e0f1c4a4b70a0509342053728e89e977cfb9920d5150393fe9dcbf86bc63914166546d5ae04d83631594703db59a628de3b945f566bdc5f0ca7bdfa819a0a3d7248286154a6cc5199b99708423d0749d4e67801dff2378561dd3b0f10c8269dbef2630819236e9b0b3d3d8910f7f7afbbed29788e965a732efc05aef3194cd1f1cff97381107f2950c935980e8954f91ed2a653c91015abea2447ee2a3488a49cc9181a3b1d44f198ff9f0141badcae6a9ae45c6c75816836fb5f331c7f2eb784129a142f88b4dc22a0a977 ``` This question is a question that follows 2017 HITB - hack in the card I. We use openssl to view the public key of publickey.pem and find that its N is the same as the N of the previous question, and the N of the previous question, e,d is known. Thus, you can directly use the above rsatool.py to get p, q, and calculate e from the e of this problem to get the plain text.","title":"2017 HITB - hack in the card II"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#wieners-attack","text":"","title":"Wiener&#39;s Attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#attack-conditions","text":"When d is small ( d<\\frac{1}{3}N^{\\frac{1}{4}} d&lt;\\frac{1}{3}N^{\\frac{1}{4}} ), an attacker can use Wiener's Attack to get the private key.","title":"Attack conditions"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#attack-principle_1","text":"https://en.wikipedia.org/wiki/Wiener%27s_attack https://sagi.io/2016/04/crypto-classics-wieners-rsa-attack/","title":"Attack principle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#tools_1","text":"https://github.com/pablocelayes/rsa-wiener-attack","title":"Tools"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#comprehensive-example","text":"","title":"Comprehensive example"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_d_attack/#2016-hctf-rsa1","text":"Here we take the RSA 1 - Crypto So Interesting in the 2016 HCTF as an example, [source code link] ( https://github.com/Hcamael/ctf-library/tree/master/RSA1 ). First, bypass the proof part of the program, and you can bypass it with almost random data. Second, let's analyze the specific code part. The program gets the flag according to our token. Here we directly use the token provided in the source code. print \"This is a RSA Decryption System\" print \"Please enter Your team token: \" token = raw_input () try : flag = get_flag ( token ) assert len ( flag ) == 38 except : print \"Token error!\" m_exit ( - 1 ) Next we first know n=pq n=pq , let's take a closer look at how this e, d is obtained. p = getPrime ( 2048 ) q = getPrime ( 2048 ) n = p * q e , d = get_ed ( p , q ) print \"n: \" , hex ( n ) print & quot ; e : & quot ;, hex ( e ) get_ed function is as follows def get_ed ( p , q ): k = cal_bit ( q * p ) phi_n = ( p - 1 ) * ( q - 1 ) r = random . randint ( 10 , 99 ) while True : u = getPrime ( k / 4 - r ) if gcd ( u , phi_n ) != 1 : continue t = invmod ( u , phi_n ) e = pi_b ( t ) if gcd ( e , phi_n ) == 1 : break d = invmod ( e , phi_n ) return ( e , d ) It can be seen that the number of bits we get is less than a quarter of the number of bits in n, which is almost the same as Wiener's Attack. And we calculated u, t, e, d also meet the following conditions $$ \\begin{align*} out & equals 1 bmod varphi (n) Others & equiv 1 bt \\ way ed &\\equiv 1 \\bmod \\varphi(n) \\end{align*} $$ According to the conditions given in the title, we already know n, e, bt. So first we can know e according to the second formula above. At this time, you can use the first formula for Wiener's Attack to get u. Then we can use the private key index to leak the attack to decompose N to get p, q. Then we can get d. First we bypassed proof and got N, e. The encrypted flag is as follows n: 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 is: flag: 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df Secondly, use the following method to get Wiener's Attack to get u, as follows if __name__ == \"__main__\" : bt = e = t = gmpy2 . invert ( e , bt ) n = 0x4b4403cd5ac8bdfaa3bbf83decdc97db1fbc7615fd52f67a8acf7588945cd8c3627211ffd3964d979cb1ab3850348a453153710337c6fe3baa15d986c87fca1c97c6d270335b8a7ecae81ae0ebde48aa957e7102ce3e679423f29775eef5935006e8bc4098a52a168e07b75e431a796e3dcd29c98dab6971d3eac5b5b19fb4d2b32f8702ef97d92da547da2e22387f7555531af4327392ef9c82227c5a2479623dde06b525969e9480a39015a3ed57828162ca67e6d41fb7e79e1b25e56f1cff487c1d0e0363dc105512d75c83ad0085b75ede688611d489c1c2ea003c3b2f81722cdb307a3647f2da01fb3ba0918cc1ab88c67e1b6467775fa412de7be0b44f2e19036471b618db1415f6b656701f692c5e841d2f58da7fd2bc33e7c3c55fcb8fd980c9e459a6df44b0ef70b4b1d813a57530446aa054cbfb9d1a86ffb6074b6b7398a83b5f0543b910dcb9f111096b07a98830a3ce6da47cd36b7c1ac1b2104ea60dc198c34f1c50faa5b697f2f195afe8af5d455e8ac7ca6eda669a5a1e3bfbd290a4480376abd1ff21298d529b26a4e614ab24c776a10f5f5d8e8809467a3e81f04cf5d5b23eb4a3412886797cab4b3c5724c077354b2d11d19ae4e301cd2ca743e56456d2a785b650c7e1a727b1bd881ee85c8d109792393cc1a92a66b0bc23b164146548f4e184b10c80ec458b776df10405b65399e32d657bc83e1451 solve ( n , t ) The solve function is the function of the corresponding Wiener's Attack. We got u as follows \u279c rsa-wiener-attack git: ( master ) \u2717 python RSAwienerHacker.py Testing Wiener Attack Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) ------------------------- Hacked! ( 'hacked_d = ' , mpz ( 404713159471231711408151571380906751680333129144247165378555186876078301457022630947986647887431519481527070603810696638453560506186951324208972060991323925955752760273325044674073649258563488270334557390141102174681693044992933206572452629140703447755138963985034199697200260653L )) Then use RsaConverter and u,t,n to get the corresponding p and q. as follows 94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 Then we go directly to get d, and then we can recover the plaintext. p = 0x94121F49C0E7A37A60FDE4D13F021675ED91032EB16CB070975A3EECECE8697ED161A27D86BCBC4F45AA6CDC128EB878802E0AD3B95B2961138C8CD04D28471B558CD816279BDCCF8FA1513A444AF364D8FDA8176A4E459B1B939EBEC6BB164F06CDDE9C203C612541E79E8B6C266436AB903209F5C63C8F0DA192F129F0272090CBE1A37E2615EF7DFBB05D8D88B9C964D5A42A7E0D6D0FF344303C4364C894AB7D912065ABC30815A3B8E0232D1B3D7F6B80ED7FE4B71C3477E4D6C2C78D733CF23C694C535DB172D2968483E63CC031DFC5B27792E2235C625EC0CFDE33FD3E53915357772975D264D24A7F31308D72E1BD7656B1C16F58372E7682660381 q = 0x8220863F1CFDA6EDE52C56B4036485DB53F57A4629F5727EDC4C5637603FE059EB44751FC49EC846C0B8B50966678DFFB1CFEB350EC44B57586A81D35E4887F1722367CE99116092463079A63E3F29D4F4BC416E7728B26248EE8CD2EFEA6925EC6F455DF966CEE13C808BC15CA2A6AAC7FEA69DB7C9EB9786B50EBD437D38B73D44F3687AEB5DF03B6F425CF3171B098AAC6708D534F4D3A9B3D43BAF70316812EF95FC7EBB7E224A7016D7692B52CB0958951BAB4FB5CB1ABB4DAC606F03FA15697CC3E9DF26DE5F6D6EC45A683CD5AAFD58D416969695067795A2CF7899F61669BC7543151AB700A593BF5A1E5C2AFBCE45A08A2A9CC1685FAF1F96B138D1 if p * q == n : print 'true' Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x2517d1866acc5b7b802a51d6251673262e9e6b2d0e0e14a87b838c2751dee91e4ea29019b0a7877b849fddf9e08580d810622db538462b529412eba9d0f8a450fe1889021c0bbd12a62ccc3fff4627b1dbdebec3a356a066adc03f7650722a34fe41ea0a247cb480a12286fffc799d66b6631a220b8401f5f50daa12943856b35e59abf8457b2269efea14f1535fb95e56398fd5f3ac153e3ea1afd7b0bb5f02832883da46343404eb44594d04bbd254a9a35749af84eaf4e35ba1c5571d41cab4d58befa79b6745d8ecf93b64dd26056a6d1e82430afbff3dbc08d6c974364b57b30c8a8230c99f0ec3168ac4813c4205d9190481282ae14f7b94400caff3786ed35863b66fefcffbef1ad1652221746a5c8da083987b2b69689cf43e86a05ce4cf059934716c455a6410560e41149fbcf5fcea3c210120f106b8f6269b9a954139350626cf4dcb497ce86264e05565ec6c6581bf28c643bb4fab8677148c8034833cedacb32172b0ff21f363ca07de0fa2882ac896954251277adc0cdd0c3bd5a3f107dbebf5f4d884e43fe9b118bdd51dc80607608670507388ae129a71e0005826c7c82efccf9c86c96777d7d3b9b5cce425e3dcf9aec0643f003c851353e36809b9202ff3b79e8f33d40967c1d36f5d585ac9eba73611152fc6d3cf36fd9a60b4c621858ed1f6d4db86054c27828e22357fa3d7c71559d175ff8e8987df flag = gmpy2 . powmod ( cipher , d , n ) print long_to_bytes ( flag ) Get flag true hctf { d8e8fca2dc0f896fd7cb4cb0031ba249 }","title":"2016 HCTF RSA1"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/","text":"EN | ZH \u5c0f\u516c\u94a5\u6307\u6570\u653b\u51fb \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 e \u7279\u522b\u5c0f\uff0c\u6bd4\u5982 e \u4e3a 3\u3002 \u653b\u51fb\u539f\u7406 \u00b6 \u5047\u8bbe\u7528\u6237\u4f7f\u7528\u7684\u5bc6\u94a5 e=3 e=3 \u3002\u8003\u8651\u5230\u52a0\u5bc6\u5173\u7cfb\u6ee1\u8db3\uff1a c\\equiv m^3 \\bmod N c\\equiv m^3 \\bmod N \u5219\uff1a \\begin{align*} m^3 &= c+k\\times N\\\\ m &= \\sqrt[3]{c+k\\times n} \\end{align*} \\begin{align*} m^3 &= c+k\\times N\\\\ m &= \\sqrt[3]{c+k\\times n} \\end{align*} \u653b\u51fb\u8005\u53ef\u4ee5\u4ece\u5c0f\u5230\u5927\u679a\u4e3e k k \uff0c\u4f9d\u6b21\u5f00\u4e09\u6b21\u6839\uff0c\u76f4\u5230\u5f00\u51fa\u6574\u6570\u4e3a\u6b62\u3002 \u8303\u4f8b \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 XMan \u4e00\u671f\u590f\u4ee4\u8425\u8bfe\u5802\u7ec3\u4e60\u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff08Jarvis OJ \u6709\u590d\u73b0\uff09\uff0c\u9644\u4ef6\u4e2d\u6709\u4e00\u4e2a flag.enc \u548c pubkey.pem \uff0c\u5f88\u660e\u663e\u662f\u5bc6\u6587\u548c\u516c\u94a5\u4e86\uff0c\u5148\u7528 openssl \u8bfb\u4e00\u4e0b\u516c\u94a5\u3002 \u279c Jarvis OJ-Extremely hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 4096 bit ) Modulus: 00 :b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18 :fc:8c:7d:7d:03:b8:2e:40:99:51:c1:82:f3:98: de:e3:10:45:80:e7:ba:70:d3:83:ae:53:11:47:56: 56 :e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db:0b:12:2c:a4:0e:42:fa:70:91:89:b7:19:a4:f0: d7:46:e2:f6:06:9b:af:11:ce:bd:65:0f:14:b9:3c: 97 :73:52:fd:13:b1:ee:a6:d6:e1:da:77:55:02:ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05 :68:48:92:84:e1:81:f6:f1:1e:27:08:91:c8:ef: 80 :01:7b:ad:23:8e:36:30:39:a4:58:47:0f:17:49: 10 :1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79 :c7:52:5a:69:98:4f:15:b5:66:7f:34:20:9b:70: eb:26:11:36:94:7f:a1:23:e5:49:df:ff:00:60:18: 83 :af:d9:36:fe:41:1e:00:6e:4e:93:d1:a0:0b:0f: ea:54:1b:bf:c8:c5:18:6c:b6:22:05:03:a9:4b:24: 13 :11:0d:64:0c:77:ea:54:ba:32:20:fc:8f:4c:c6: ce:77:15:1e:29:b3:e0:65:78:c4:78:bd:1b:eb:e0: 45 :89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02 :c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd:93:27:06:80:95:ef:a0:10:b7:f1:96:c7:4b:a8: c3:7b:12:8f:9e:14:11:75:16:33:f7:8b:7b:9e:56: f7:1f:77:a1:b4:da:ad:3f:c5:4b:5e:7e:f9:35:d9: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08 :d8:ce:47:36:ba:39:a0:35:44:26:fa:e0:06:c7: fe:52:d5:26:7d:cf:b9:c3:88:4f:51:fd:df:df:4a: 97 :94:bc:fe:0e:15:57:11:37:49:e6:c8:ef:42:1d: ba:26:3a:ff:68:73:9c:e0:0e:d8:0f:d0:02:2e:f9: 2d:34:88:f7:6d:eb:62:bd:ef:7b:ea:60:26:f2:2a: 1d:25:aa:2a:92:d1:24:41:4a:80:21:fe:0c:17:4b: 98 :03:e6:bb:5f:ad:75:e1:86:a9:46:a1:72:80:77: 0f:12:43:f4:38:74:46:cc:ce:b2:22:2a:96:5c:c3: 0b:39:29 Exponent: 3 ( 0x3 ) Modulus = B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 writing RSA key -----BEGIN PUBLIC KEY----- MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4+nlp+jQC0kzVcYY /Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff 0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH+hI+VJ3/8AYBiDr9k2/kEeAG5Ok9Gg Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP EkP0OHRGzM6yIiqWXMMLOSkCAQM = -----END PUBLIC KEY----- \u770b\u5230 e=3 e=3 \uff0c\u5f88\u660e\u663e\u662f\u5c0f\u516c\u94a5\u6307\u6570\u653b\u51fb\u4e86\u3002\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528 Crypto \u5e93\u6765\u8bfb\u53d6\u516c\u94a5\uff0c\u4f7f\u7528 multiprocessing \u6765\u52a0\u5feb\u7834\u89e3\u901f\u5ea6\u3002 #/usr/bin/python # coding=utf-8 import gmpy2 from Crypto.PublicKey import RSA from multiprocessing import Pool pool = Pool ( 4 ) with open ( './pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = int ( cipher , 16 ) def calc ( j ): print j a , b = gmpy2 . iroot ( cipher + j * N , 3 ) if b == 1 : m = a print ' {:x} ' . format ( int ( m )) . decode ( 'hex' ) pool . terminate () exit () def SmallE (): inputs = range ( 0 , 130000000 ) pool . map ( calc , inputs ) pool . close () pool . join () if __name__ == '__main__' : print 'start' SmallE () \u7206\u7834\u65f6\u95f4\u6709\u70b9\u957f\uff0c\uff0c\u62ff\u5230 flag Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: flag{Sm4ll_3xpon3nt_i5_W3ak} \u9898\u76ee \u00b6 RSA \u884d\u751f\u7b97\u6cd5\u2014\u2014Rabin \u7b97\u6cd5 \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 Rabin \u7b97\u6cd5\u7684\u7279\u5f81\u5728\u4e8e e=2 e=2 \u3002 \u653b\u51fb\u539f\u7406 \u00b6 \u5bc6\u6587\uff1a c = m^2\\bmod n c = m^2\\bmod n \u89e3\u5bc6\uff1a \u8ba1\u7b97\u51fa m_p m_p \u548c m_q m_q \uff1a \\begin{align*} m_p &= \\sqrt{c} \\bmod p\\\\ m_q &= \\sqrt{c} \\bmod q \\end{align*} \\begin{align*} m_p &= \\sqrt{c} \\bmod p\\\\ m_q &= \\sqrt{c} \\bmod q \\end{align*} \u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u8ba1\u7b97\u51fa y_p y_p \u548c y_q y_q \uff1a y_p \\cdot p + y_q \\cdot q = 1 y_p \\cdot p + y_q \\cdot q = 1 \u89e3\u51fa\u56db\u4e2a\u660e\u6587\uff1a \\begin{align*} a &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\\\ b &= n - a\\\\ c &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\\\ d &= n - c \\end{align*} \\begin{align*} a &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\\\ b &= n - a\\\\ c &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\\\ d &= n - c \\end{align*} \u6ce8\u610f\uff1a\u5982\u679c p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 \uff0c\u5219 \\begin{align*} m_p &= c^{\\frac{1}{4}(p + 1)} \\bmod p\\\\ m_q &= c^{\\frac{1}{4}(q + 1)} \\bmod q \\end{align*} \\begin{align*} m_p &= c^{\\frac{1}{4}(p + 1)} \\bmod p\\\\ m_q &= c^{\\frac{1}{4}(q + 1)} \\bmod q \\end{align*} \u800c\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 \u662f\u6ee1\u8db3\u7684\uff0c\u5bf9\u4e8e\u4e0d\u6ee1\u8db3\u7684\u60c5\u51b5\u4e0b\uff0c\u8bf7\u53c2\u8003\u76f8\u5e94\u7684\u7b97\u6cd5\u89e3\u51b3\u3002 \u4f8b\u5b50 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 XMan \u4e00\u671f\u590f\u4ee4\u8425\u8bfe\u5802\u7ec3\u4e60\uff08Jarvis OJ \u6709\u590d\u73b0\uff09\u4e3a\u4f8b\uff0c\u8bfb\u4e00\u4e0b\u516c\u94a5\u3002 \u279c Jarvis OJ-hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 :c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 2 ( 0x2 ) Modulus = C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgEC -----END PUBLIC KEY----- e=2 e=2 \uff0c\u8003\u8651 Rabin \u7b97\u6cd5\u3002\u9996\u5148\u6211\u4eec\u5148\u5206\u89e3\u4e00\u4e0b p \u548c q\uff0c\u5f97\u5230 p=275127860351348928173285174381581152299 q=319576316814478949870590164193048041239 \u7f16\u5199\u4ee3\u7801 #!/usr/bin/python # coding=utf-8 import gmpy2 import string from Crypto.PublicKey import RSA # \u8bfb\u53d6\u516c\u94a5\u53c2\u6570 with open ( 'pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = string . atoi ( cipher , base = 16 ) # print cipher print \"please input p\" p = int ( raw_input (), 10 ) print 'please input q' q = int ( raw_input (), 10 ) # \u8ba1\u7b97yp\u548cyq inv_p = gmpy2 . invert ( p , q ) inv_q = gmpy2 . invert ( q , p ) # \u8ba1\u7b97mp\u548cmq mp = pow ( cipher , ( p + 1 ) / 4 , p ) mq = pow ( cipher , ( q + 1 ) / 4 , q ) # \u8ba1\u7b97a,b,c,d a = ( inv_p * p * mq + inv_q * q * mp ) % N b = N - int ( a ) c = ( inv_p * p * mq - inv_q * q * mp ) % N d = N - int ( c ) for i in ( a , b , c , d ): s = ' %x ' % i if len ( s ) % 2 != 0 : s = '0' + s print s . decode ( 'hex' ) \u62ff\u5230 flag\uff0c PCTF{sp3ci4l_rsa} \u3002 \u9898\u76ee \u00b6","title":"Rsa e attack zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_1","text":"","title":"\u5c0f\u516c\u94a5\u6307\u6570\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_2","text":"e \u7279\u522b\u5c0f\uff0c\u6bd4\u5982 e \u4e3a 3\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_3","text":"\u5047\u8bbe\u7528\u6237\u4f7f\u7528\u7684\u5bc6\u94a5 e=3 e=3 \u3002\u8003\u8651\u5230\u52a0\u5bc6\u5173\u7cfb\u6ee1\u8db3\uff1a c\\equiv m^3 \\bmod N c\\equiv m^3 \\bmod N \u5219\uff1a \\begin{align*} m^3 &= c+k\\times N\\\\ m &= \\sqrt[3]{c+k\\times n} \\end{align*} \\begin{align*} m^3 &= c+k\\times N\\\\ m &= \\sqrt[3]{c+k\\times n} \\end{align*} \u653b\u51fb\u8005\u53ef\u4ee5\u4ece\u5c0f\u5230\u5927\u679a\u4e3e k k \uff0c\u4f9d\u6b21\u5f00\u4e09\u6b21\u6839\uff0c\u76f4\u5230\u5f00\u51fa\u6574\u6570\u4e3a\u6b62\u3002","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_4","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 XMan \u4e00\u671f\u590f\u4ee4\u8425\u8bfe\u5802\u7ec3\u4e60\u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff08Jarvis OJ \u6709\u590d\u73b0\uff09\uff0c\u9644\u4ef6\u4e2d\u6709\u4e00\u4e2a flag.enc \u548c pubkey.pem \uff0c\u5f88\u660e\u663e\u662f\u5bc6\u6587\u548c\u516c\u94a5\u4e86\uff0c\u5148\u7528 openssl \u8bfb\u4e00\u4e0b\u516c\u94a5\u3002 \u279c Jarvis OJ-Extremely hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 4096 bit ) Modulus: 00 :b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18 :fc:8c:7d:7d:03:b8:2e:40:99:51:c1:82:f3:98: de:e3:10:45:80:e7:ba:70:d3:83:ae:53:11:47:56: 56 :e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db:0b:12:2c:a4:0e:42:fa:70:91:89:b7:19:a4:f0: d7:46:e2:f6:06:9b:af:11:ce:bd:65:0f:14:b9:3c: 97 :73:52:fd:13:b1:ee:a6:d6:e1:da:77:55:02:ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05 :68:48:92:84:e1:81:f6:f1:1e:27:08:91:c8:ef: 80 :01:7b:ad:23:8e:36:30:39:a4:58:47:0f:17:49: 10 :1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79 :c7:52:5a:69:98:4f:15:b5:66:7f:34:20:9b:70: eb:26:11:36:94:7f:a1:23:e5:49:df:ff:00:60:18: 83 :af:d9:36:fe:41:1e:00:6e:4e:93:d1:a0:0b:0f: ea:54:1b:bf:c8:c5:18:6c:b6:22:05:03:a9:4b:24: 13 :11:0d:64:0c:77:ea:54:ba:32:20:fc:8f:4c:c6: ce:77:15:1e:29:b3:e0:65:78:c4:78:bd:1b:eb:e0: 45 :89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02 :c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd:93:27:06:80:95:ef:a0:10:b7:f1:96:c7:4b:a8: c3:7b:12:8f:9e:14:11:75:16:33:f7:8b:7b:9e:56: f7:1f:77:a1:b4:da:ad:3f:c5:4b:5e:7e:f9:35:d9: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08 :d8:ce:47:36:ba:39:a0:35:44:26:fa:e0:06:c7: fe:52:d5:26:7d:cf:b9:c3:88:4f:51:fd:df:df:4a: 97 :94:bc:fe:0e:15:57:11:37:49:e6:c8:ef:42:1d: ba:26:3a:ff:68:73:9c:e0:0e:d8:0f:d0:02:2e:f9: 2d:34:88:f7:6d:eb:62:bd:ef:7b:ea:60:26:f2:2a: 1d:25:aa:2a:92:d1:24:41:4a:80:21:fe:0c:17:4b: 98 :03:e6:bb:5f:ad:75:e1:86:a9:46:a1:72:80:77: 0f:12:43:f4:38:74:46:cc:ce:b2:22:2a:96:5c:c3: 0b:39:29 Exponent: 3 ( 0x3 ) Modulus = B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 writing RSA key -----BEGIN PUBLIC KEY----- MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4+nlp+jQC0kzVcYY /Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff 0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH+hI+VJ3/8AYBiDr9k2/kEeAG5Ok9Gg Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP EkP0OHRGzM6yIiqWXMMLOSkCAQM = -----END PUBLIC KEY----- \u770b\u5230 e=3 e=3 \uff0c\u5f88\u660e\u663e\u662f\u5c0f\u516c\u94a5\u6307\u6570\u653b\u51fb\u4e86\u3002\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528 Crypto \u5e93\u6765\u8bfb\u53d6\u516c\u94a5\uff0c\u4f7f\u7528 multiprocessing \u6765\u52a0\u5feb\u7834\u89e3\u901f\u5ea6\u3002 #/usr/bin/python # coding=utf-8 import gmpy2 from Crypto.PublicKey import RSA from multiprocessing import Pool pool = Pool ( 4 ) with open ( './pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = int ( cipher , 16 ) def calc ( j ): print j a , b = gmpy2 . iroot ( cipher + j * N , 3 ) if b == 1 : m = a print ' {:x} ' . format ( int ( m )) . decode ( 'hex' ) pool . terminate () exit () def SmallE (): inputs = range ( 0 , 130000000 ) pool . map ( calc , inputs ) pool . close () pool . join () if __name__ == '__main__' : print 'start' SmallE () \u7206\u7834\u65f6\u95f4\u6709\u70b9\u957f\uff0c\uff0c\u62ff\u5230 flag Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: flag{Sm4ll_3xpon3nt_i5_W3ak}","title":"\u8303\u4f8b"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_5","text":"","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#rsa-rabin","text":"","title":"RSA \u884d\u751f\u7b97\u6cd5\u2014\u2014Rabin \u7b97\u6cd5"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_6","text":"Rabin \u7b97\u6cd5\u7684\u7279\u5f81\u5728\u4e8e e=2 e=2 \u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_7","text":"\u5bc6\u6587\uff1a c = m^2\\bmod n c = m^2\\bmod n \u89e3\u5bc6\uff1a \u8ba1\u7b97\u51fa m_p m_p \u548c m_q m_q \uff1a \\begin{align*} m_p &= \\sqrt{c} \\bmod p\\\\ m_q &= \\sqrt{c} \\bmod q \\end{align*} \\begin{align*} m_p &= \\sqrt{c} \\bmod p\\\\ m_q &= \\sqrt{c} \\bmod q \\end{align*} \u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u8ba1\u7b97\u51fa y_p y_p \u548c y_q y_q \uff1a y_p \\cdot p + y_q \\cdot q = 1 y_p \\cdot p + y_q \\cdot q = 1 \u89e3\u51fa\u56db\u4e2a\u660e\u6587\uff1a \\begin{align*} a &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\\\ b &= n - a\\\\ c &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\\\ d &= n - c \\end{align*} \\begin{align*} a &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\\\ b &= n - a\\\\ c &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\\\ d &= n - c \\end{align*} \u6ce8\u610f\uff1a\u5982\u679c p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 \uff0c\u5219 \\begin{align*} m_p &= c^{\\frac{1}{4}(p + 1)} \\bmod p\\\\ m_q &= c^{\\frac{1}{4}(q + 1)} \\bmod q \\end{align*} \\begin{align*} m_p &= c^{\\frac{1}{4}(p + 1)} \\bmod p\\\\ m_q &= c^{\\frac{1}{4}(q + 1)} \\bmod q \\end{align*} \u800c\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 \u662f\u6ee1\u8db3\u7684\uff0c\u5bf9\u4e8e\u4e0d\u6ee1\u8db3\u7684\u60c5\u51b5\u4e0b\uff0c\u8bf7\u53c2\u8003\u76f8\u5e94\u7684\u7b97\u6cd5\u89e3\u51b3\u3002","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_8","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 XMan \u4e00\u671f\u590f\u4ee4\u8425\u8bfe\u5802\u7ec3\u4e60\uff08Jarvis OJ \u6709\u590d\u73b0\uff09\u4e3a\u4f8b\uff0c\u8bfb\u4e00\u4e0b\u516c\u94a5\u3002 \u279c Jarvis OJ-hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 :c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 2 ( 0x2 ) Modulus = C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDr yigb/+l/vjDdAgEC -----END PUBLIC KEY----- e=2 e=2 \uff0c\u8003\u8651 Rabin \u7b97\u6cd5\u3002\u9996\u5148\u6211\u4eec\u5148\u5206\u89e3\u4e00\u4e0b p \u548c q\uff0c\u5f97\u5230 p=275127860351348928173285174381581152299 q=319576316814478949870590164193048041239 \u7f16\u5199\u4ee3\u7801 #!/usr/bin/python # coding=utf-8 import gmpy2 import string from Crypto.PublicKey import RSA # \u8bfb\u53d6\u516c\u94a5\u53c2\u6570 with open ( 'pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = string . atoi ( cipher , base = 16 ) # print cipher print \"please input p\" p = int ( raw_input (), 10 ) print 'please input q' q = int ( raw_input (), 10 ) # \u8ba1\u7b97yp\u548cyq inv_p = gmpy2 . invert ( p , q ) inv_q = gmpy2 . invert ( q , p ) # \u8ba1\u7b97mp\u548cmq mp = pow ( cipher , ( p + 1 ) / 4 , p ) mq = pow ( cipher , ( q + 1 ) / 4 , q ) # \u8ba1\u7b97a,b,c,d a = ( inv_p * p * mq + inv_q * q * mp ) % N b = N - int ( a ) c = ( inv_p * p * mq - inv_q * q * mp ) % N d = N - int ( c ) for i in ( a , b , c , d ): s = ' %x ' % i if len ( s ) % 2 != 0 : s = '0' + s print s . decode ( 'hex' ) \u62ff\u5230 flag\uff0c PCTF{sp3ci4l_rsa} \u3002","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack-zh/#_9","text":"","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/","text":"EN | ZH Small public key index attack \u00b6 Attack conditions \u00b6 e is very small, such as e is 3. Attack principle \u00b6 Suppose the user uses the key e=3 e=3 . Considering that the encryption relationship is satisfied: $$ c\\equiv m^3 \\bmod N $$ then: $$ \\begin{align*} m^3 &= c+k\\times N\\ m &= \\sqrt[3]{c+k\\times n} \\end{align*} $$ An attacker can enumerate k k from small to large and open three roots in turn until an integer is opened. Examples \u00b6 Here we take the XMan Summer Camp class exercise as an example (Jarvis OJ has a recurrence), the attachment has a flag.enc and pubkey.pem , which is obviously a ciphertext and a public key. Openssl` Read the public key. \u279c Jarvis OJ-Extremely hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 4096 bit ) Modulus: 00 :b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18 : fc: 8c: 7d: 7d: 03 : b8: 2e: 40 : 99 : 51 : c1: 82 : f3: 98 : from: e3: 10 : 45 : 80 : e7: no: 70 : d3: 83 : yes: 53 : 11 : 47 : 56 : 56 :e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db: 0b: 12 : 2c: a4: 0e: 42 : fa: 70 : 91 : 89 : b7: 19 : d7: 46 : E2: F6: 06 : 9b: of: 11 : ce: bd: 65 : 0f: 14 : b9: 3c: 97 : 73 : 52 : fd: 13 : b1: yes: a6: d6: e1: da: 77 : 55 : 02 : ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05 : 68 : 48 : 92 : 84 : e1: 81 : f6, f1: 1E: 27 : 08 : 91 : c8: if : 80 : 01 : 7b: ad: 23 : 8e: 36 : 30 : 39 : a: 10 :1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79 : c7: 52 : 5a: 69 : 98 : 4f: 15 : b5: 66 : 7f: 34 : 20 : eb: 26 : 11 : 36 : 94 : 7f: a1: 23 : e5: 49 : df: ff: 00 : 60 : 18 : 83 : of: D9: 36 : fe: 41 : 1e: 00 : 6e: 4e: 93 : D1: A0: 0b: 0f: ea: 54 : 1b: bf: c8: c5: 18 : 6c: b6: 22 : 05 : 03 : 13 : 11 : 0d: 64 : 0c: 77 : ea: 54 : no: 32 : 20 : fc: 8f: 4c: c6: what: 77 : 15 : 1e: 29 : b3: e0: 65 : 78 : c4: 78 : 45 :89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02 :c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd: 93 : 27 : 06 : 80 : 95 : ef: a0: 10 : b7: f1: 96 : c7: 4b: c3: 7b: 12 : 8f: 9e: 14 : 11 : 75 : 16 : 33 : f7: 8b: 7b: 9e: 56 : f7: 1f: 77 : a1: b4: da: ad: 3f: c5: 4b: 5e: 7e: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08 : d8: the 47 : 36 : ba: 39 : A0: 35 : 44 : 26 : fa: e0: 06 : 7 : fe: 52 : d5: 26 : 7d: cf: b9: c3: 88 : 4f: 51 : fd: df: df: 4a: 97 : 94 : bc: fe: 0e: 15 : 57 : 11 : 37 : 49 : e6: c8: ef: 42 : 1d: You do not know how to do this. 2d: 34 : 88 : f7: 6d: eb: 62 : bd: ef: 7b: ea: 60 : 26 : f2: 2a: 1d: 25 : aa: 2a: 92 : d1: 17 : 4b: 98 : 03 : e6: bb: 5f: ad: 75 : e1: 86 : a9: 46 : a1: 0f: 12 : 43 : f4: 38 : 74 : 46 : cc: this: b2: 22 : 2a: 96 : 5c: c3: 0b:39:29 Exponent: 3 ( 0x3 ) Modulus = B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 writing RSA key -----BEGIN PUBLIC KEY----- MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4 + nlp + jQC0kzVcYY /Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff 0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH + hI + VJ3 / 8AYBiDr9k2 / kEeAG5Ok9Gg Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP EkP0OHRGzM6yIiqWXMMLOSkCAQM = -----END PUBLIC KEY----- Seeing e=3 e=3 , it is clear that the small public key index attacked. Here we use the Crypto library to read the public key and use multiprocessing to speed up the crack. #/usr/bin/python # coding=utf-8 import gmpy2 from Crypto.PublicKey import RSA from multiprocessing import Pool pool = Pool ( 4 ) with open ( './pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = int ( cipher , 16 ) def calc ( j ): print j a , b = gmpy2 . iroot ( cipher + j * N , 3 ) if b == 1 : m = a print ' {:x} ' . format ( int ( m )) . decode ( 'hex' ) pool . terminate () exit () def SmallE (): inputs = range ( 0 , 130000000 ) pool . map ( calc , inputs ) pool . close () pool . join () if __name__ == '__main__' : print 'start' SmallE () The blasting time is a bit long, get the flag Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: flag{Sm4ll_3xpon3nt_i5_W3ak} Title \u00b6 RSA Derivative Algorithm - Rabin Algorithm \u00b6 Attack conditions \u00b6 The Rabin algorithm is characterized by e=2 e=2 . Attack principle \u00b6 Ciphertext: $$ c = m ^ 2 n way $$ Decryption: Calculate m_p m_p and m_q m_q : $$ \\begin{align*} m_p & = sqrt {c} p \\ way m_q & = sqrt {c} q way \\end{align*} $$ Calculate y_p y_p and y_q y_q with extended Euclidean: $$ y_p \\cdot p + y_q \\cdot q = 1 $$ Solve four plaintexts: $$ \\begin{align*} a &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\ b &= n - a\\ c &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\ d &= n - c \\end{align*} $$ Note: If p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 , then $$ \\begin{align*} m_p & c = ^ { frac {1} {4} (p + 1)} p \\ way m_q & c = ^ { frac {1} {4} (q + 1)} q way \\end{align*} $$ In general, p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 is satisfied. For cases that are not met, please refer to the corresponding algorithm. Examples \u00b6 Here we take the XMan Summer Camp class exercise (Jarvis OJ has a recurrence) as an example, read the public key. \u279c Jarvis OJ-hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 : c2: 63 : 6a: e5: c3: d8: e4: 3f: fb: 97 : ab: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 2 ( 0x2 ) Modulus = C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ / + 5erCQKPGqxsC / bNPXDr yigb / + l / vjDdAgEC -----END PUBLIC KEY----- e=2 e=2 , consider the Rabin algorithm. First, let's break down p and q first. p=275127860351348928173285174381581152299 q=319576316814478949870590164193048041239 Write code #!/usr/bin/python # coding=utf-8 import gmpy2 import string from Crypto.PublicKey import RSA # Read public key parameters with open ( 'pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = string . atoi ( cipher , base = 16 ) # print cipher print \"please input p\" p = int ( raw_input (), 10 ) print 'please input q' q = int ( raw_input (), 10 ) #\u7b97 yp\u548cyq inv_p = gmpy2 . invert ( p , q ) inv_q = gmpy2 . invert ( q , p ) #\u7b97mp mp and mq mp = pow ( cipher , ( p + 1 ) / 4 , p ) mq = pow ( cipher , ( q + 1 ) / 4 , q ) # Calculate a, b, c, d a = ( inv_p * p * mq + inv_q * q * mp ) % N b = N - int ( a ) c = ( inv_p * p * mq - inv_q * q * mp ) % N D = N - int ( c ) for i in ( a , b , c , d ): s = ' %x ' % i if len ( s ) % 2 ! = 0 : s = '0' + s print s . decode ( 'hex' ) Get the flag, PCTF{sp3ci4l_rsa} . Title \u00b6","title":"\u516c\u94a5\u6307\u6570\u76f8\u5173\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#small-public-key-index-attack","text":"","title":"Small public key index attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#attack-conditions","text":"e is very small, such as e is 3.","title":"Attack conditions"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#attack-principle","text":"Suppose the user uses the key e=3 e=3 . Considering that the encryption relationship is satisfied: $$ c\\equiv m^3 \\bmod N $$ then: $$ \\begin{align*} m^3 &= c+k\\times N\\ m &= \\sqrt[3]{c+k\\times n} \\end{align*} $$ An attacker can enumerate k k from small to large and open three roots in turn until an integer is opened.","title":"Attack principle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#examples","text":"Here we take the XMan Summer Camp class exercise as an example (Jarvis OJ has a recurrence), the attachment has a flag.enc and pubkey.pem , which is obviously a ciphertext and a public key. Openssl` Read the public key. \u279c Jarvis OJ-Extremely hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 4096 bit ) Modulus: 00 :b0:be:e5:e3:e9:e5:a7:e8:d0:0b:49:33:55:c6: 18 : fc: 8c: 7d: 7d: 03 : b8: 2e: 40 : 99 : 51 : c1: 82 : f3: 98 : from: e3: 10 : 45 : 80 : e7: no: 70 : d3: 83 : yes: 53 : 11 : 47 : 56 : 56 :e8:a9:64:d3:80:cb:15:7f:48:c9:51:ad:fa:65: db: 0b: 12 : 2c: a4: 0e: 42 : fa: 70 : 91 : 89 : b7: 19 : d7: 46 : E2: F6: 06 : 9b: of: 11 : ce: bd: 65 : 0f: 14 : b9: 3c: 97 : 73 : 52 : fd: 13 : b1: yes: a6: d6: e1: da: 77 : 55 : 02 : ab: ff:89:d3:a8:b3:61:5f:d0:db:49:b8:8a:97:6b:c2: 05 : 68 : 48 : 92 : 84 : e1: 81 : f6, f1: 1E: 27 : 08 : 91 : c8: if : 80 : 01 : 7b: ad: 23 : 8e: 36 : 30 : 39 : a: 10 :1b:c2:99:49:d3:a4:f4:03:8d:46:39:38:85:15: 79 : c7: 52 : 5a: 69 : 98 : 4f: 15 : b5: 66 : 7f: 34 : 20 : eb: 26 : 11 : 36 : 94 : 7f: a1: 23 : e5: 49 : df: ff: 00 : 60 : 18 : 83 : of: D9: 36 : fe: 41 : 1e: 00 : 6e: 4e: 93 : D1: A0: 0b: 0f: ea: 54 : 1b: bf: c8: c5: 18 : 6c: b6: 22 : 05 : 03 : 13 : 11 : 0d: 64 : 0c: 77 : ea: 54 : no: 32 : 20 : fc: 8f: 4c: c6: what: 77 : 15 : 1e: 29 : b3: e0: 65 : 78 : c4: 78 : 45 :89:ef:9a:19:7f:6f:80:6d:b8:b3:ec:d8:26:ca: d2:4f:53:24:cc:de:c6:e8:fe:ad:2c:21:50:06:86: 02 :c8:dc:dc:59:40:2c:ca:c9:42:4b:79:00:48:cc: dd: 93 : 27 : 06 : 80 : 95 : ef: a0: 10 : b7: f1: 96 : c7: 4b: c3: 7b: 12 : 8f: 9e: 14 : 11 : 75 : 16 : 33 : f7: 8b: 7b: 9e: 56 : f7: 1f: 77 : a1: b4: da: ad: 3f: c5: 4b: 5e: 7e: a7:2f:b1:76:75:97:65:52:2b:4b:bc:02:e3:14:d5: c0:6b:64:d5:05:4b:7b:09:6c:60:12:36:e6:cc:f4: 5b:5e:61:1c:80:5d:33:5d:ba:b0:c3:5d:22:6c:c2: 08 : d8: the 47 : 36 : ba: 39 : A0: 35 : 44 : 26 : fa: e0: 06 : 7 : fe: 52 : d5: 26 : 7d: cf: b9: c3: 88 : 4f: 51 : fd: df: df: 4a: 97 : 94 : bc: fe: 0e: 15 : 57 : 11 : 37 : 49 : e6: c8: ef: 42 : 1d: You do not know how to do this. 2d: 34 : 88 : f7: 6d: eb: 62 : bd: ef: 7b: ea: 60 : 26 : f2: 2a: 1d: 25 : aa: 2a: 92 : d1: 17 : 4b: 98 : 03 : e6: bb: 5f: ad: 75 : e1: 86 : a9: 46 : a1: 0f: 12 : 43 : f4: 38 : 74 : 46 : cc: this: b2: 22 : 2a: 96 : 5c: c3: 0b:39:29 Exponent: 3 ( 0x3 ) Modulus = B0BEE5E3E9E5A7E8D00B493355C618FC8C7D7D03B82E409951C182F398DEE3104580E7BA70D383AE5311475656E8A964D380CB157F48C951ADFA65DB0B122CA40E42FA709189B719A4F0D746E2F6069BAF11CEBD650F14B93C977352FD13B1EEA6D6E1DA775502ABFF89D3A8B3615FD0DB49B88A976BC20568489284E181F6F11E270891C8EF80017BAD238E363039A458470F1749101BC29949D3A4F4038D463938851579C7525A69984F15B5667F34209B70EB261136947FA123E549DFFF00601883AFD936FE411E006E4E93D1A00B0FEA541BBFC8C5186CB6220503A94B2413110D640C77EA54BA3220FC8F4CC6CE77151E29B3E06578C478BD1BEBE04589EF9A197F6F806DB8B3ECD826CAD24F5324CCDEC6E8FEAD2C2150068602C8DCDC59402CCAC9424B790048CCDD9327068095EFA010B7F196C74BA8C37B128F9E1411751633F78B7B9E56F71F77A1B4DAAD3FC54B5E7EF935D9A72FB176759765522B4BBC02E314D5C06B64D5054B7B096C601236E6CCF45B5E611C805D335DBAB0C35D226CC208D8CE4736BA39A0354426FAE006C7FE52D5267DCFB9C3884F51FDDFDF4A9794BCFE0E1557113749E6C8EF421DBA263AFF68739CE00ED80FD0022EF92D3488F76DEB62BDEF7BEA6026F22A1D25AA2A92D124414A8021FE0C174B9803E6BB5FAD75E186A946A17280770F1243F4387446CCCEB2222A965CC30B3929 writing RSA key -----BEGIN PUBLIC KEY----- MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAsL7l4 + nlp + jQC0kzVcYY /Ix9fQO4LkCZUcGC85je4xBFgOe6cNODrlMRR1ZW6Klk04DLFX9IyVGt+mXbCxIs pA5C+nCRibcZpPDXRuL2BpuvEc69ZQ8UuTyXc1L9E7Huptbh2ndVAqv/idOos2Ff 0NtJuIqXa8IFaEiShOGB9vEeJwiRyO+AAXutI442MDmkWEcPF0kQG8KZSdOk9AON Rjk4hRV5x1JaaZhPFbVmfzQgm3DrJhE2lH + hI + VJ3 / 8AYBiDr9k2 / kEeAG5Ok9Gg Cw/qVBu/yMUYbLYiBQOpSyQTEQ1kDHfqVLoyIPyPTMbOdxUeKbPgZXjEeL0b6+BF ie+aGX9vgG24s+zYJsrST1MkzN7G6P6tLCFQBoYCyNzcWUAsyslCS3kASMzdkycG gJXvoBC38ZbHS6jDexKPnhQRdRYz94t7nlb3H3ehtNqtP8VLXn75NdmnL7F2dZdl UitLvALjFNXAa2TVBUt7CWxgEjbmzPRbXmEcgF0zXbqww10ibMII2M5HNro5oDVE JvrgBsf+UtUmfc+5w4hPUf3f30qXlLz+DhVXETdJ5sjvQh26Jjr/aHOc4A7YD9AC LvktNIj3betive976mAm8iodJaoqktEkQUqAIf4MF0uYA+a7X6114YapRqFygHcP EkP0OHRGzM6yIiqWXMMLOSkCAQM = -----END PUBLIC KEY----- Seeing e=3 e=3 , it is clear that the small public key index attacked. Here we use the Crypto library to read the public key and use multiprocessing to speed up the crack. #/usr/bin/python # coding=utf-8 import gmpy2 from Crypto.PublicKey import RSA from multiprocessing import Pool pool = Pool ( 4 ) with open ( './pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = int ( cipher , 16 ) def calc ( j ): print j a , b = gmpy2 . iroot ( cipher + j * N , 3 ) if b == 1 : m = a print ' {:x} ' . format ( int ( m )) . decode ( 'hex' ) pool . terminate () exit () def SmallE (): inputs = range ( 0 , 130000000 ) pool . map ( calc , inputs ) pool . close () pool . join () if __name__ == '__main__' : print 'start' SmallE () The blasting time is a bit long, get the flag Didn't you know RSA padding is really important? Now you see a non-padding message is so dangerous. And you should notice this in future.Fl4g: flag{Sm4ll_3xpon3nt_i5_W3ak}","title":"Examples"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#title","text":"","title":"Title"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#rsa-derivative-algorithm-rabin-algorithm","text":"","title":"RSA Derivative Algorithm - Rabin Algorithm"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#attack-conditions_1","text":"The Rabin algorithm is characterized by e=2 e=2 .","title":"Attack conditions"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#attack-principle_1","text":"Ciphertext: $$ c = m ^ 2 n way $$ Decryption: Calculate m_p m_p and m_q m_q : $$ \\begin{align*} m_p & = sqrt {c} p \\ way m_q & = sqrt {c} q way \\end{align*} $$ Calculate y_p y_p and y_q y_q with extended Euclidean: $$ y_p \\cdot p + y_q \\cdot q = 1 $$ Solve four plaintexts: $$ \\begin{align*} a &= (y_p \\cdot p \\cdot m_q + y_q \\cdot q \\cdot m_p) \\bmod n\\ b &= n - a\\ c &= (y_p \\cdot p \\cdot m_q - y_q \\cdot q \\cdot m_p) \\bmod n\\ d &= n - c \\end{align*} $$ Note: If p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 , then $$ \\begin{align*} m_p & c = ^ { frac {1} {4} (p + 1)} p \\ way m_q & c = ^ { frac {1} {4} (q + 1)} q way \\end{align*} $$ In general, p \\equiv q \\equiv 3 \\pmod 4 p \\equiv q \\equiv 3 \\pmod 4 is satisfied. For cases that are not met, please refer to the corresponding algorithm.","title":"Attack principle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#examples_1","text":"Here we take the XMan Summer Camp class exercise (Jarvis OJ has a recurrence) as an example, read the public key. \u279c Jarvis OJ-hard RSA git: ( master ) \u2717 openssl rsa -pubin -in pubkey.pem -text -modulus Public-Key: ( 256 bit ) Modulus: 00 : c2: 63 : 6a: e5: c3: d8: e4: 3f: fb: 97 : ab: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:dd Exponent: 2 ( 0x2 ) Modulus = C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD writing RSA key -----BEGIN PUBLIC KEY----- MDowDQYJKoZIhvcNAQEBBQADKQAwJgIhAMJjauXD2OQ / + 5erCQKPGqxsC / bNPXDr yigb / + l / vjDdAgEC -----END PUBLIC KEY----- e=2 e=2 , consider the Rabin algorithm. First, let's break down p and q first. p=275127860351348928173285174381581152299 q=319576316814478949870590164193048041239 Write code #!/usr/bin/python # coding=utf-8 import gmpy2 import string from Crypto.PublicKey import RSA # Read public key parameters with open ( 'pubkey.pem' , 'r' ) as f : key = RSA . importKey ( f ) N = key . n e = key . e with open ( 'flag.enc' , 'r' ) as f : cipher = f . read () . encode ( 'hex' ) cipher = string . atoi ( cipher , base = 16 ) # print cipher print \"please input p\" p = int ( raw_input (), 10 ) print 'please input q' q = int ( raw_input (), 10 ) #\u7b97 yp\u548cyq inv_p = gmpy2 . invert ( p , q ) inv_q = gmpy2 . invert ( q , p ) #\u7b97mp mp and mq mp = pow ( cipher , ( p + 1 ) / 4 , p ) mq = pow ( cipher , ( q + 1 ) / 4 , q ) # Calculate a, b, c, d a = ( inv_p * p * mq + inv_q * q * mp ) % N b = N - int ( a ) c = ( inv_p * p * mq - inv_q * q * mp ) % N D = N - int ( c ) for i in ( a , b , c , d ): s = ' %x ' % i if len ( s ) % 2 ! = 0 : s = '0' + s print s . decode ( 'hex' ) Get the flag, PCTF{sp3ci4l_rsa} .","title":"Examples"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_e_attack/#title_1","text":"","title":"Title"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/","text":"EN | ZH \u66b4\u529b\u5206\u89e3 N \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5728 N \u7684\u6bd4\u7279\u4f4d\u6570\u5c0f\u4e8e 512 \u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u91c7\u7528\u5927\u6574\u6570\u5206\u89e3\u7684\u7b56\u7565\u83b7\u53d6 p \u548c q\u3002 JarvisOJ - Medium RSA \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 JarvisOJ - Medium RSA \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9898\u76ee\u5982\u4e0b \u8fd8\u8bb0\u5f97 veryeasy RSA \u5417\uff1f\u662f\u4e0d\u662f\u4e0d\u96be\uff1f\u90a3\u7ee7\u7eed\u6765\u770b\u770b\u8fd9\u9898\u5427\uff0c\u8fd9\u9898\u4e5f\u4e0d\u96be\u3002 \u5df2\u77e5\u4e00\u6bb5 RSA \u52a0\u5bc6\u7684\u4fe1\u606f\u4e3a\uff1a0xdc2eeeb2782c \u4e14\u5df2\u77e5\u52a0\u5bc6\u6240\u7528\u7684\u516c\u94a5\uff1a N=322831561921859 e = 23 \u8bf7\u89e3\u5bc6\u51fa\u660e\u6587\uff0c\u63d0\u4ea4\u65f6\u8bf7\u5c06\u6570\u5b57\u8f6c\u5316\u4e3a ascii \u7801\u63d0\u4ea4 \u6bd4\u5982\u4f60\u89e3\u51fa\u7684\u660e\u6587\u662f 0x6162\uff0c\u90a3\u4e48\u8bf7\u63d0\u4ea4\u5b57\u7b26\u4e32 ab \u63d0\u4ea4\u683c\u5f0f\uff1a PCTF{\u660e\u6587\u5b57\u7b26\u4e32} \u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u7684 N \u6bd4\u8f83\u5c0f\uff0c\u8fd9\u91cc\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 factordb \u8fdb\u884c\u5206\u89e3\uff0c\u53ef\u4ee5\u5f97\u5230 322831561921859 = 13574881 \\times 23781539 322831561921859 = 13574881 \\times 23781539 \u8fdb\u800c\u6211\u4eec\u7b80\u5355\u7f16\u5199\u7a0b\u5e8f\u5982\u4e0b import gmpy2 p = 13574881 q = 23781539 n = p * q e = 23 c = 0xdc2eeeb2782c phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) p = gmpy2 . powmod ( c , d , n ) tmp = hex ( p ) print tmp , tmp [ 2 :] . decode ( 'hex' ) \u7ed3\u679c\u5982\u4e0b \u279c Jarvis OJ-Basic-easyRSA git: ( master ) \u2717 python exp.py 0x33613559 3a5Y p & q \u4e0d\u5f53\u5206\u89e3 N \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5f53 RSA \u4e2d p \u548c q \u9009\u53d6\u4e0d\u5f53\u65f6\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u8fdb\u884c\u653b\u51fb\u3002 |p-q| \u5f88\u5927 \u00b6 \u5f53 p-q \u5f88\u5927\u65f6\uff0c\u4e00\u5b9a\u5b58\u5728\u67d0\u4e00\u4e2a\u53c2\u6570\u8f83\u5c0f\uff0c\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u4e3a p\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u7a77\u4e3e\u7684\u65b9\u6cd5\u5bf9\u6a21\u6570\u8fdb\u884c\u8bd5\u9664\uff0c\u4ece\u800c\u5206\u89e3\u6a21\u6570\uff0c\u5f97\u5230\u4fdd\u5bc6\u53c2\u6570\u4e0e\u660e\u6587\u4fe1\u606f\u3002\u57fa\u672c\u6765\u8bf4\uff0c\u4e0d\u600e\u4e48\u53ef\u884c\u3002 |p-q| \u8f83\u5c0f \u00b6 \u9996\u5148 \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4} \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4} \u65e2\u7136 |p-q| \u8f83\u5c0f\uff0c\u90a3\u4e48 \\frac{(p-q)^2}{4} \\frac{(p-q)^2}{4} \u81ea\u7136\u4e5f\u6bd4\u8f83\u5c0f\uff0c\u8fdb\u800c \\frac{(p+q)^2}{4} \\frac{(p+q)^2}{4} \u53ea\u662f\u6bd4 N \u7a0d\u5fae\u5927\u4e00\u70b9\uff0c\u6240\u4ee5 \\frac{p+q}{2} \\frac{p+q}{2} \u4e0e \\sqrt{n} \\sqrt{n} \u76f8\u8fd1\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u6cd5\u6765\u5206\u89e3 \u987a\u5e8f\u68c0\u67e5 \\sqrt{n} \\sqrt{n} \u7684\u6bcf\u4e00\u4e2a\u6574\u6570 x\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a x \u4f7f\u5f97 x^2-n x^2-n \u662f\u5e73\u65b9\u6570\uff0c\u8bb0\u4e3a y^2 y^2 \u90a3\u4e48 x^2-n=y^2 x^2-n=y^2 \uff0c\u8fdb\u800c\u6839\u636e\u5e73\u65b9\u5dee\u516c\u5f0f\u5373\u53ef\u5206\u89e3 N p - 1 \u5149\u6ed1 \u00b6 \u5f53 p \u662f N \u7684\u56e0\u6570\uff0c\u5e76\u4e14 p - 1 \u662f\u5149\u6ed1\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u53ef\u4ee5\u4f7f\u7528 Pollard's p \u2212 1 \u7b97\u6cd5\u6765\u5206\u89e3 N\uff0c\u4f46\u662f\u4e5f\u4e0d\u662f\u5b8c\u5168\u53ef\u4ee5\u6210\u529f\u7684\u3002 Warning \u539f\u7406\u5206\u6790\u5f85\u5b8c\u6210 p + 1 \u5149\u6ed1 \u00b6 \u5f53 p \u662f n \u7684\u56e0\u6570\uff0c\u5e76\u4e14 p + 1 \u662f\u5149\u6ed1\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u53ef\u4ee5\u4f7f\u7528 Williams's p + 1 \u7b97\u6cd5\u6765\u5206\u89e3 N\uff0c\u4f46\u662f\u4e5f\u4e0d\u662f\u5b8c\u5168\u53ef\u4ee5\u6210\u529f\u7684\u3002 2017 SECCON very smooth \u00b6 \u8be5\u7a0b\u5e8f\u7ed9\u4e86\u4e00\u4e2a HTTPS \u52a0\u5bc6\u7684\u6d41\u91cf\u5305\uff0c\u9996\u5148\u4ece\u5176\u4e2d\u62ff\u5230\u8bc1\u4e66 \u279c 2017_SECCON_verysmooth git: ( master ) binwalk -e s.pcap DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 2292 0x8F4 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 4038 0xFC6 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 5541 0x15A5 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 \u279c 2017_SECCON_verysmooth git: ( master ) ls s.pcap _s.pcap.extracted very_smooth.zip \u8fd9\u91cc\u5206\u522b\u67e5\u770b\u4e09\u4e2a\u8bc1\u4e66\uff0c\u4e09\u4e2a\u6a21\u6570\u90fd\u4e00\u6837\uff0c\u8fd9\u91cc\u53ea\u7ed9\u4e00\u4e2a\u4f8b\u5b50 \u279c _s.pcap.extracted git:(master) openssl x509 -inform DER -in FC6.crt -pubkey -text -modulus -noout -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy 8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj DUddp+4X8C9jtvCaLTgd+baSjo2eB0f+uiSL/9/4nN+vR3FliRm2mByeFCjppTQl yioxCqbXYIMxGO4NcQIDAQAB -----END PUBLIC KEY----- Certificate: Data: Version: 1 (0x0) Serial Number: 11640506567126718943 (0xa18b630c7b3099df) Signature Algorithm: sha256WithRSAEncryption Issuer: C=JP, ST=Kawasaki, O=SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C=JP, ST=Kawasaki, O=SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5:c2:7b:67:03:5a:ec:19:2b:37:41:dd:1f:4d:12: 75:31:b0:7a:b0:12:eb:86:24:1c:09:c0:81:49:9e: 69:ef:5a:ea:c7:8d:c6:23:0d:47:5d:a7:ee:17:f0: 2f:63:b6:f0:9a:2d:38:1d:f9:b6:92:8e:8d:9e:07: 47:fe:ba:24:8b:ff:df:f8:9c:df:af:47:71:65:89: 19:b6:98:1c:9e:14:28:e9:a5:34:25:ca:2a:31:0a: a6:d7:60:83:31:18:ee:0d:71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78:92:11:fb:6c:e1:7a:f7:2a:33:b8:8b:08:a7:f7:5b:de:cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf:5b:a7:ee:8b:1e:48:a7:d2:43:06:0e:4f:5a:86:62:69:05: e2:c0:bd:4e:89:c9:af:04:4a:77:a2:34:86:6a:b8:d2:3b:32: b7:39 Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71 \u53ef\u4ee5\u770b\u51fa\u6a21\u6570\u53ea\u6709 1024 \u6bd4\u7279\u3002\u800c\u4e14\uff0c\u6839\u636e\u9898\u76ee\u540d very smooth\uff0c\u5e94\u8be5\u662f\u5176\u4e2d\u4e00\u4e2a\u56e0\u5b50\u6bd4\u8f83 smooth\uff0c\u8fd9\u91cc\u6211\u4eec\u5229\u7528 primefac \u5206\u522b\u5c1d\u8bd5 Pollard's p \u2212 1 \u4e0e Williams's p + 1 \u7b97\u6cd5\uff0c\u5982\u4e0b \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs -m = p+1 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 : p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 Z309 = P155 x P155 = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 \u53ef\u4ee5\u53d1\u73b0\u5f53\u4f7f\u7528 Williams's p + 1 \u7b97\u6cd5\u65f6\uff0c\u5c31\u76f4\u63a5\u5206\u89e3\u51fa\u6765\u4e86\u3002\u6309\u9053\u7406\u8fd9\u4e2a\u56e0\u5b50\u662f p-1 \u4f3c\u4e4e\u66f4\u5149\u6ed1\uff0c\u4f46\u662f\u5374\u5e76\u4e0d\u80fd\u4f7f\u7528 Pollard's p \u2212 1 \u7b97\u6cd5\u5206\u89e3\uff0c\u8fd9\u91cc\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u6d4b\u8bd5 \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 : 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 Z154 = P1 x P1 x P2 x P3 x P6 x P142 = 2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 : 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 Z154 = P1^185 x P1^62 x P1^97 = 2 ^185 x 3 ^62 x 5 ^97 \u53ef\u4ee5\u770b\u51fa\uff0c\u5bf9\u4e8e p-1 \u786e\u5b9e\u6709\u5f88\u591a\u5c0f\u56e0\u5b50\uff0c\u4f46\u662f\u4e2a\u6570\u592a\u591a\uff0c\u8fd9\u5c31\u4f1a\u4f7f\u5f97\u8fdb\u884c\u679a\u4e3e\u7684\u65f6\u5019\u51fa\u73b0\u6307\u6570\u7206\u70b8\u7684\u60c5\u51b5\uff0c\u56e0\u6b64\u6ca1\u6709\u5206\u89e3\u51fa\u6765\u3002 \u8fdb\u800c\u6839\u636e\u5206\u89e3\u51fa\u6765\u7684\u6570\u6784\u9020\u79c1\u94a5 from Crypto.PublicKey import RSA import gmpy2 def main (): n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 L q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L e = 65537 L priv = RSA . construct (( n , e , long ( gmpy2 . invert ( e , ( p - 1 ) * ( q - 1 ))))) open ( 'private.pem' , 'w' ) . write ( priv . exportKey ( 'PEM' )) main () \u6700\u540e\uff0c\u5c06\u79c1\u94a5\u5bfc\u5165\u5230 wireshark \u4e2d\u5373\u53ef\u5f97\u5230\u660e\u6587\uff08Edit -> Preferences -> Protocols -> SSL -> RSA Key List\uff09\u3002 < html > < head >< title > Very smooth </ title ></ head > < body > < h1 > Answer: One of these primes is very smooth. </ h1 > </ body > </ html > \u6269\u5c55 \u00b6 \u5173\u4e8e\u66f4\u591a\u7684\u4e00\u4e9b\u5206\u89e3\u6a21\u6570 N \u7684\u65b9\u6cd5\u53ef\u4ee5\u53c2\u8003 https://en.wikipedia.org/wiki/Integer_factorization \u3002 \u6a21\u4e0d\u4e92\u7d20 \u00b6 \u653b\u51fb\u539f\u7406 \u00b6 \u5f53\u5b58\u5728\u4e24\u4e2a\u516c\u94a5\u7684 N \u4e0d\u4e92\u7d20\u65f6\uff0c\u6211\u4eec\u663e\u7136\u53ef\u4ee5\u76f4\u63a5\u5bf9\u8fd9\u4e24\u4e2a\u6570\u6c42\u6700\u5927\u516c\u56e0\u6570\uff0c\u7136\u540e\u76f4\u63a5\u83b7\u5f97 p\uff0cq\uff0c\u8fdb\u800c\u83b7\u5f97\u76f8\u5e94\u7684\u79c1\u94a5\u3002 SCTF RSA2 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 SCTF rsa2 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002\u76f4\u63a5\u6253\u5f00 pcap \u5305\uff0c\u53d1\u73b0\u6709\u4e00\u5806\u7684\u6d88\u606f\uff0c\u5305\u542b N \u548c e\uff0c\u7136\u540e\u8bd5\u4e86\u8bd5\u4e0d\u540c\u7684 N \u662f\u5426\u4e92\u7d20\uff0c\u6211\u8bd5\u4e86\u524d\u4e24\u4e2a import gmpy2 n1 = 20823369114556260762913588844471869725762985812215987993867783630051420241057912385055482788016327978468318067078233844052599750813155644341123314882762057524098732961382833215291266591824632392867716174967906544356144072051132659339140155889569810885013851467056048003672165059640408394953573072431523556848077958005971533618912219793914524077919058591586451716113637770245067687598931071827344740936982776112986104051191922613616045102859044234789636058568396611030966639561922036712001911238552391625658741659644888069244729729297927279384318252191421446283531524990762609975988147922688946591302181753813360518031 n2 = 19083821613736429958432024980074405375408953269276839696319265596855426189256865650651460460079819368923576109723079906759410116999053050999183058013281152153221170931725172009360565530214701693693990313074253430870625982998637645030077199119183041314493288940590060575521928665131467548955951797198132001987298869492894105525970519287000775477095816742582753228905458466705932162641076343490086247969277673809512472546919489077884464190676638450684714880196854445469562733561723325588433285405495368807600668761929378526978417102735864613562148766250350460118131749533517869691858933617013731291337496943174343464943 print gmpy2 . gcd ( n1 , n2 ) \u7ed3\u679c\u53d1\u73b0\u7adf\u7136\u4e0d\u4e92\u7d20\u3002 \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py 122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u6765\u89e3\u5bc6\u4e86\uff0c\u8fd9\u91cc\u6211\u4eec\u5229\u7528\u7b2c\u4e00\u5bf9\u516c\u94a5\u5bc6\u7801\u3002\u4ee3\u7801\u5982\u4e0b from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode n1 = 20823369114556260762913588844471869725762985812215987993867783630051420241057912385055482788016327978468318067078233844052599750813155644341123314882762057524098732961382833215291266591824632392867716174967906544356144072051132659339140155889569810885013851467056048003672165059640408394953573072431523556848077958005971533618912219793914524077919058591586451716113637770245067687598931071827344740936982776112986104051191922613616045102859044234789636058568396611030966639561922036712001911238552391625658741659644888069244729729297927279384318252191421446283531524990762609975988147922688946591302181753813360518031 n2 = 19083821613736429958432024980074405375408953269276839696319265596855426189256865650651460460079819368923576109723079906759410116999053050999183058013281152153221170931725172009360565530214701693693990313074253430870625982998637645030077199119183041314493288940590060575521928665131467548955951797198132001987298869492894105525970519287000775477095816742582753228905458466705932162641076343490086247969277673809512472546919489077884464190676638450684714880196854445469562733561723325588433285405495368807600668761929378526978417102735864613562148766250350460118131749533517869691858933617013731291337496943174343464943 p1 = gmpy2 . gcd ( n1 , n2 ) q1 = n1 / p1 e = 65537 phin = ( p1 - 1 ) * ( q1 - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7 plain = gmpy2 . powmod ( cipher , d , n1 ) plain = hex ( plain )[ 2 :] if len ( plain ) % 2 != 0 : plain = '0' + plain print plain . decode ( 'hex' ) \u6700\u540e\u89e3\u5bc6\u5982\u4e0b \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py sH1R3_PRlME_1N_rsA_iS_4ulnEra5le \u89e3\u538b\u538b\u7f29\u5305\u5373\u53ef\u3002 \u5171\u6a21\u653b\u51fb \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5f53\u4e24\u4e2a\u7528\u6237\u4f7f\u7528\u76f8\u540c\u7684\u6a21\u6570 N\u3001\u4e0d\u540c\u7684\u79c1\u94a5\u65f6\uff0c\u52a0\u5bc6\u540c\u4e00\u660e\u6587\u6d88\u606f\u65f6\u5373\u5b58\u5728\u5171\u6a21\u653b\u51fb\u3002 \u653b\u51fb\u539f\u7406 \u00b6 \u8bbe\u4e24\u4e2a\u7528\u6237\u7684\u516c\u94a5\u5206\u522b\u4e3a e_1 e_1 \u548c e_2 e_2 \uff0c\u4e14\u4e24\u8005\u4e92\u8d28\u3002\u660e\u6587\u6d88\u606f\u4e3a m m \uff0c\u5bc6\u6587\u5206\u522b\u4e3a\uff1a c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N \u5f53\u653b\u51fb\u8005\u622a\u83b7 c_1 c_1 \u548c c_2 c_2 \u540e\uff0c\u5c31\u53ef\u4ee5\u6062\u590d\u51fa\u660e\u6587\u3002\u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u6c42\u51fa re_1+se_2=1\\bmod n re_1+se_2=1\\bmod n \u7684\u4e24\u4e2a\u6574\u6570 r r \u548c s s \uff0c\u7531\u6b64\u53ef\u5f97\uff1a \\begin{align*} c_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &\\equiv m\\bmod n \\end{align*} \\begin{align*} c_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &\\equiv m\\bmod n \\end{align*} XMan \u4e00\u671f\u590f\u4ee4\u8425\u8bfe\u5802\u7ec3\u4e60 \u00b6 \u9898\u76ee\u63cf\u8ff0\uff1a {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,773} {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,839} message1=3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2=5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 \u9898\u76ee\u6765\u6e90\uff1aXMan \u4e00\u671f\u590f\u4ee4\u8425\u8bfe\u5802\u7ec3\u4e60 \u53ef\u4ee5\u770b\u51fa\u4e24\u4e2a\u516c\u94a5\u7684 N \u662f\u4e00\u6837\u7684\uff0c\u5e76\u4e14\u4e24\u8005\u7684 e \u4e92\u7d20\u3002\u5199\u4e00\u4e2a\u811a\u672c\u8dd1\u4e00\u4e0b\uff1a import gmpy2 n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249 e1 = 773 e2 = 839 message1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 # s & t gcd , s , t = gmpy2 . gcdext ( e1 , e2 ) if s < 0 : s = - s message1 = gmpy2 . invert ( message1 , n ) if t < 0 : t = - t message2 = gmpy2 . invert ( message2 , n ) plain = gmpy2 . powmod ( message1 , s , n ) * gmpy2 . powmod ( message2 , t , n ) % n print plain \u5f97\u5230 \u279c Xman-1-class-exercise git: ( master ) \u2717 python exp.py 1021089710312311910410111011910111610410511010710511610511511211111511510598108101125 \u8fd9\u65f6\u5019\u9700\u8981\u8003\u8651\u5f53\u65f6\u660e\u6587\u662f\u5982\u4f55\u8f6c\u5316\u4e3a\u8fd9\u4e2a\u6570\u5b57\u4e86\uff0c\u4e00\u822c\u6765\u8bf4\u662f 16 \u8fdb\u5236\u8f6c\u6362\uff0cASCII \u5b57\u7b26\u8f6c\u6362\uff0c\u6216\u8005 Base64 \u89e3\u5bc6\u3002\u8fd9\u4e2a\u5e94\u8be5\u662f ASCII \u5b57\u7b26\u8f6c\u6362\uff0c\u8fdb\u800c\u6211\u4eec\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u5f97\u5230 flag i = 0 flag = \"\" plain = str ( plain ) while i < len ( plain ): if plain [ i ] == '1' : flag += chr ( int ( plain [ i : i + 3 ])) i += 3 else : flag += chr ( int ( plain [ i : i + 2 ])) i += 2 print flag \u8fd9\u91cc\u4e4b\u6240\u4ee5\u4f7f\u7528 1 \u6765\u5224\u65ad\u662f\u5426\u4e3a\u4e09\u4f4d\u957f\u5ea6\uff0c\u662f\u56e0\u4e3a flag \u4e00\u822c\u90fd\u662f\u660e\u6587\u5b57\u7b26\uff0c\u800c 1 \u5f00\u5934\u7684\u957f\u5ea6\u4e3a 1 \u6216\u8005 2 \u7684\u6570\u5b57\uff0c\u4e00\u822c\u90fd\u662f\u4e0d\u53ef\u89c1\u5b57\u7b26\u3002 flag \u279c Xman-1-class-exercise git: ( master ) \u2717 python exp.py flag { whenwethinkitispossible } \u9898\u76ee \u00b6 Jarvis OJ very hard RSA","title":"Rsa module attack zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#n","text":"","title":"\u66b4\u529b\u5206\u89e3 N"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_1","text":"\u5728 N \u7684\u6bd4\u7279\u4f4d\u6570\u5c0f\u4e8e 512 \u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u91c7\u7528\u5927\u6574\u6570\u5206\u89e3\u7684\u7b56\u7565\u83b7\u53d6 p \u548c q\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#jarvisoj-medium-rsa","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 JarvisOJ - Medium RSA \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9898\u76ee\u5982\u4e0b \u8fd8\u8bb0\u5f97 veryeasy RSA \u5417\uff1f\u662f\u4e0d\u662f\u4e0d\u96be\uff1f\u90a3\u7ee7\u7eed\u6765\u770b\u770b\u8fd9\u9898\u5427\uff0c\u8fd9\u9898\u4e5f\u4e0d\u96be\u3002 \u5df2\u77e5\u4e00\u6bb5 RSA \u52a0\u5bc6\u7684\u4fe1\u606f\u4e3a\uff1a0xdc2eeeb2782c \u4e14\u5df2\u77e5\u52a0\u5bc6\u6240\u7528\u7684\u516c\u94a5\uff1a N=322831561921859 e = 23 \u8bf7\u89e3\u5bc6\u51fa\u660e\u6587\uff0c\u63d0\u4ea4\u65f6\u8bf7\u5c06\u6570\u5b57\u8f6c\u5316\u4e3a ascii \u7801\u63d0\u4ea4 \u6bd4\u5982\u4f60\u89e3\u51fa\u7684\u660e\u6587\u662f 0x6162\uff0c\u90a3\u4e48\u8bf7\u63d0\u4ea4\u5b57\u7b26\u4e32 ab \u63d0\u4ea4\u683c\u5f0f\uff1a PCTF{\u660e\u6587\u5b57\u7b26\u4e32} \u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u7684 N \u6bd4\u8f83\u5c0f\uff0c\u8fd9\u91cc\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 factordb \u8fdb\u884c\u5206\u89e3\uff0c\u53ef\u4ee5\u5f97\u5230 322831561921859 = 13574881 \\times 23781539 322831561921859 = 13574881 \\times 23781539 \u8fdb\u800c\u6211\u4eec\u7b80\u5355\u7f16\u5199\u7a0b\u5e8f\u5982\u4e0b import gmpy2 p = 13574881 q = 23781539 n = p * q e = 23 c = 0xdc2eeeb2782c phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) p = gmpy2 . powmod ( c , d , n ) tmp = hex ( p ) print tmp , tmp [ 2 :] . decode ( 'hex' ) \u7ed3\u679c\u5982\u4e0b \u279c Jarvis OJ-Basic-easyRSA git: ( master ) \u2717 python exp.py 0x33613559 3a5Y","title":"JarvisOJ - Medium RSA"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#p-q-n","text":"","title":"p &amp; q \u4e0d\u5f53\u5206\u89e3 N"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_2","text":"\u5f53 RSA \u4e2d p \u548c q \u9009\u53d6\u4e0d\u5f53\u65f6\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u8fdb\u884c\u653b\u51fb\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#p-q","text":"\u5f53 p-q \u5f88\u5927\u65f6\uff0c\u4e00\u5b9a\u5b58\u5728\u67d0\u4e00\u4e2a\u53c2\u6570\u8f83\u5c0f\uff0c\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u4e3a p\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u7a77\u4e3e\u7684\u65b9\u6cd5\u5bf9\u6a21\u6570\u8fdb\u884c\u8bd5\u9664\uff0c\u4ece\u800c\u5206\u89e3\u6a21\u6570\uff0c\u5f97\u5230\u4fdd\u5bc6\u53c2\u6570\u4e0e\u660e\u6587\u4fe1\u606f\u3002\u57fa\u672c\u6765\u8bf4\uff0c\u4e0d\u600e\u4e48\u53ef\u884c\u3002","title":"|p-q| \u5f88\u5927"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#p-q_1","text":"\u9996\u5148 \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4} \\frac{(p+q)^2}{4}-n=\\frac{(p+q)^2}{4}-pq=\\frac{(p-q)^2}{4} \u65e2\u7136 |p-q| \u8f83\u5c0f\uff0c\u90a3\u4e48 \\frac{(p-q)^2}{4} \\frac{(p-q)^2}{4} \u81ea\u7136\u4e5f\u6bd4\u8f83\u5c0f\uff0c\u8fdb\u800c \\frac{(p+q)^2}{4} \\frac{(p+q)^2}{4} \u53ea\u662f\u6bd4 N \u7a0d\u5fae\u5927\u4e00\u70b9\uff0c\u6240\u4ee5 \\frac{p+q}{2} \\frac{p+q}{2} \u4e0e \\sqrt{n} \\sqrt{n} \u76f8\u8fd1\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u6cd5\u6765\u5206\u89e3 \u987a\u5e8f\u68c0\u67e5 \\sqrt{n} \\sqrt{n} \u7684\u6bcf\u4e00\u4e2a\u6574\u6570 x\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a x \u4f7f\u5f97 x^2-n x^2-n \u662f\u5e73\u65b9\u6570\uff0c\u8bb0\u4e3a y^2 y^2 \u90a3\u4e48 x^2-n=y^2 x^2-n=y^2 \uff0c\u8fdb\u800c\u6839\u636e\u5e73\u65b9\u5dee\u516c\u5f0f\u5373\u53ef\u5206\u89e3 N","title":"|p-q| \u8f83\u5c0f"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#p-1","text":"\u5f53 p \u662f N \u7684\u56e0\u6570\uff0c\u5e76\u4e14 p - 1 \u662f\u5149\u6ed1\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u53ef\u4ee5\u4f7f\u7528 Pollard's p \u2212 1 \u7b97\u6cd5\u6765\u5206\u89e3 N\uff0c\u4f46\u662f\u4e5f\u4e0d\u662f\u5b8c\u5168\u53ef\u4ee5\u6210\u529f\u7684\u3002 Warning \u539f\u7406\u5206\u6790\u5f85\u5b8c\u6210","title":"p - 1 \u5149\u6ed1"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#p-1_1","text":"\u5f53 p \u662f n \u7684\u56e0\u6570\uff0c\u5e76\u4e14 p + 1 \u662f\u5149\u6ed1\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u53ef\u4ee5\u4f7f\u7528 Williams's p + 1 \u7b97\u6cd5\u6765\u5206\u89e3 N\uff0c\u4f46\u662f\u4e5f\u4e0d\u662f\u5b8c\u5168\u53ef\u4ee5\u6210\u529f\u7684\u3002","title":"p + 1 \u5149\u6ed1"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#2017-seccon-very-smooth","text":"\u8be5\u7a0b\u5e8f\u7ed9\u4e86\u4e00\u4e2a HTTPS \u52a0\u5bc6\u7684\u6d41\u91cf\u5305\uff0c\u9996\u5148\u4ece\u5176\u4e2d\u62ff\u5230\u8bc1\u4e66 \u279c 2017_SECCON_verysmooth git: ( master ) binwalk -e s.pcap DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 2292 0x8F4 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 4038 0xFC6 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 5541 0x15A5 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 \u279c 2017_SECCON_verysmooth git: ( master ) ls s.pcap _s.pcap.extracted very_smooth.zip \u8fd9\u91cc\u5206\u522b\u67e5\u770b\u4e09\u4e2a\u8bc1\u4e66\uff0c\u4e09\u4e2a\u6a21\u6570\u90fd\u4e00\u6837\uff0c\u8fd9\u91cc\u53ea\u7ed9\u4e00\u4e2a\u4f8b\u5b50 \u279c _s.pcap.extracted git:(master) openssl x509 -inform DER -in FC6.crt -pubkey -text -modulus -noout -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy 8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj DUddp+4X8C9jtvCaLTgd+baSjo2eB0f+uiSL/9/4nN+vR3FliRm2mByeFCjppTQl yioxCqbXYIMxGO4NcQIDAQAB -----END PUBLIC KEY----- Certificate: Data: Version: 1 (0x0) Serial Number: 11640506567126718943 (0xa18b630c7b3099df) Signature Algorithm: sha256WithRSAEncryption Issuer: C=JP, ST=Kawasaki, O=SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C=JP, ST=Kawasaki, O=SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5:c2:7b:67:03:5a:ec:19:2b:37:41:dd:1f:4d:12: 75:31:b0:7a:b0:12:eb:86:24:1c:09:c0:81:49:9e: 69:ef:5a:ea:c7:8d:c6:23:0d:47:5d:a7:ee:17:f0: 2f:63:b6:f0:9a:2d:38:1d:f9:b6:92:8e:8d:9e:07: 47:fe:ba:24:8b:ff:df:f8:9c:df:af:47:71:65:89: 19:b6:98:1c:9e:14:28:e9:a5:34:25:ca:2a:31:0a: a6:d7:60:83:31:18:ee:0d:71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78:92:11:fb:6c:e1:7a:f7:2a:33:b8:8b:08:a7:f7:5b:de:cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf:5b:a7:ee:8b:1e:48:a7:d2:43:06:0e:4f:5a:86:62:69:05: e2:c0:bd:4e:89:c9:af:04:4a:77:a2:34:86:6a:b8:d2:3b:32: b7:39 Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71 \u53ef\u4ee5\u770b\u51fa\u6a21\u6570\u53ea\u6709 1024 \u6bd4\u7279\u3002\u800c\u4e14\uff0c\u6839\u636e\u9898\u76ee\u540d very smooth\uff0c\u5e94\u8be5\u662f\u5176\u4e2d\u4e00\u4e2a\u56e0\u5b50\u6bd4\u8f83 smooth\uff0c\u8fd9\u91cc\u6211\u4eec\u5229\u7528 primefac \u5206\u522b\u5c1d\u8bd5 Pollard's p \u2212 1 \u4e0e Williams's p + 1 \u7b97\u6cd5\uff0c\u5982\u4e0b \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs -m = p+1 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 : p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 Z309 = P155 x P155 = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 \u53ef\u4ee5\u53d1\u73b0\u5f53\u4f7f\u7528 Williams's p + 1 \u7b97\u6cd5\u65f6\uff0c\u5c31\u76f4\u63a5\u5206\u89e3\u51fa\u6765\u4e86\u3002\u6309\u9053\u7406\u8fd9\u4e2a\u56e0\u5b50\u662f p-1 \u4f3c\u4e4e\u66f4\u5149\u6ed1\uff0c\u4f46\u662f\u5374\u5e76\u4e0d\u80fd\u4f7f\u7528 Pollard's p \u2212 1 \u7b97\u6cd5\u5206\u89e3\uff0c\u8fd9\u91cc\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u6d4b\u8bd5 \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 : 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 Z154 = P1 x P1 x P2 x P3 x P6 x P142 = 2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 : 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 Z154 = P1^185 x P1^62 x P1^97 = 2 ^185 x 3 ^62 x 5 ^97 \u53ef\u4ee5\u770b\u51fa\uff0c\u5bf9\u4e8e p-1 \u786e\u5b9e\u6709\u5f88\u591a\u5c0f\u56e0\u5b50\uff0c\u4f46\u662f\u4e2a\u6570\u592a\u591a\uff0c\u8fd9\u5c31\u4f1a\u4f7f\u5f97\u8fdb\u884c\u679a\u4e3e\u7684\u65f6\u5019\u51fa\u73b0\u6307\u6570\u7206\u70b8\u7684\u60c5\u51b5\uff0c\u56e0\u6b64\u6ca1\u6709\u5206\u89e3\u51fa\u6765\u3002 \u8fdb\u800c\u6839\u636e\u5206\u89e3\u51fa\u6765\u7684\u6570\u6784\u9020\u79c1\u94a5 from Crypto.PublicKey import RSA import gmpy2 def main (): n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 L q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L e = 65537 L priv = RSA . construct (( n , e , long ( gmpy2 . invert ( e , ( p - 1 ) * ( q - 1 ))))) open ( 'private.pem' , 'w' ) . write ( priv . exportKey ( 'PEM' )) main () \u6700\u540e\uff0c\u5c06\u79c1\u94a5\u5bfc\u5165\u5230 wireshark \u4e2d\u5373\u53ef\u5f97\u5230\u660e\u6587\uff08Edit -> Preferences -> Protocols -> SSL -> RSA Key List\uff09\u3002 < html > < head >< title > Very smooth </ title ></ head > < body > < h1 > Answer: One of these primes is very smooth. </ h1 > </ body > </ html >","title":"2017 SECCON very smooth"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_3","text":"\u5173\u4e8e\u66f4\u591a\u7684\u4e00\u4e9b\u5206\u89e3\u6a21\u6570 N \u7684\u65b9\u6cd5\u53ef\u4ee5\u53c2\u8003 https://en.wikipedia.org/wiki/Integer_factorization \u3002","title":"\u6269\u5c55"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_4","text":"","title":"\u6a21\u4e0d\u4e92\u7d20"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_5","text":"\u5f53\u5b58\u5728\u4e24\u4e2a\u516c\u94a5\u7684 N \u4e0d\u4e92\u7d20\u65f6\uff0c\u6211\u4eec\u663e\u7136\u53ef\u4ee5\u76f4\u63a5\u5bf9\u8fd9\u4e24\u4e2a\u6570\u6c42\u6700\u5927\u516c\u56e0\u6570\uff0c\u7136\u540e\u76f4\u63a5\u83b7\u5f97 p\uff0cq\uff0c\u8fdb\u800c\u83b7\u5f97\u76f8\u5e94\u7684\u79c1\u94a5\u3002","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#sctf-rsa2","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 SCTF rsa2 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002\u76f4\u63a5\u6253\u5f00 pcap \u5305\uff0c\u53d1\u73b0\u6709\u4e00\u5806\u7684\u6d88\u606f\uff0c\u5305\u542b N \u548c e\uff0c\u7136\u540e\u8bd5\u4e86\u8bd5\u4e0d\u540c\u7684 N \u662f\u5426\u4e92\u7d20\uff0c\u6211\u8bd5\u4e86\u524d\u4e24\u4e2a import gmpy2 n1 = 20823369114556260762913588844471869725762985812215987993867783630051420241057912385055482788016327978468318067078233844052599750813155644341123314882762057524098732961382833215291266591824632392867716174967906544356144072051132659339140155889569810885013851467056048003672165059640408394953573072431523556848077958005971533618912219793914524077919058591586451716113637770245067687598931071827344740936982776112986104051191922613616045102859044234789636058568396611030966639561922036712001911238552391625658741659644888069244729729297927279384318252191421446283531524990762609975988147922688946591302181753813360518031 n2 = 19083821613736429958432024980074405375408953269276839696319265596855426189256865650651460460079819368923576109723079906759410116999053050999183058013281152153221170931725172009360565530214701693693990313074253430870625982998637645030077199119183041314493288940590060575521928665131467548955951797198132001987298869492894105525970519287000775477095816742582753228905458466705932162641076343490086247969277673809512472546919489077884464190676638450684714880196854445469562733561723325588433285405495368807600668761929378526978417102735864613562148766250350460118131749533517869691858933617013731291337496943174343464943 print gmpy2 . gcd ( n1 , n2 ) \u7ed3\u679c\u53d1\u73b0\u7adf\u7136\u4e0d\u4e92\u7d20\u3002 \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py 122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u6765\u89e3\u5bc6\u4e86\uff0c\u8fd9\u91cc\u6211\u4eec\u5229\u7528\u7b2c\u4e00\u5bf9\u516c\u94a5\u5bc6\u7801\u3002\u4ee3\u7801\u5982\u4e0b from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode n1 = 20823369114556260762913588844471869725762985812215987993867783630051420241057912385055482788016327978468318067078233844052599750813155644341123314882762057524098732961382833215291266591824632392867716174967906544356144072051132659339140155889569810885013851467056048003672165059640408394953573072431523556848077958005971533618912219793914524077919058591586451716113637770245067687598931071827344740936982776112986104051191922613616045102859044234789636058568396611030966639561922036712001911238552391625658741659644888069244729729297927279384318252191421446283531524990762609975988147922688946591302181753813360518031 n2 = 19083821613736429958432024980074405375408953269276839696319265596855426189256865650651460460079819368923576109723079906759410116999053050999183058013281152153221170931725172009360565530214701693693990313074253430870625982998637645030077199119183041314493288940590060575521928665131467548955951797198132001987298869492894105525970519287000775477095816742582753228905458466705932162641076343490086247969277673809512472546919489077884464190676638450684714880196854445469562733561723325588433285405495368807600668761929378526978417102735864613562148766250350460118131749533517869691858933617013731291337496943174343464943 p1 = gmpy2 . gcd ( n1 , n2 ) q1 = n1 / p1 e = 65537 phin = ( p1 - 1 ) * ( q1 - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7 plain = gmpy2 . powmod ( cipher , d , n1 ) plain = hex ( plain )[ 2 :] if len ( plain ) % 2 != 0 : plain = '0' + plain print plain . decode ( 'hex' ) \u6700\u540e\u89e3\u5bc6\u5982\u4e0b \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py sH1R3_PRlME_1N_rsA_iS_4ulnEra5le \u89e3\u538b\u538b\u7f29\u5305\u5373\u53ef\u3002","title":"SCTF RSA2"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_6","text":"","title":"\u5171\u6a21\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_7","text":"\u5f53\u4e24\u4e2a\u7528\u6237\u4f7f\u7528\u76f8\u540c\u7684\u6a21\u6570 N\u3001\u4e0d\u540c\u7684\u79c1\u94a5\u65f6\uff0c\u52a0\u5bc6\u540c\u4e00\u660e\u6587\u6d88\u606f\u65f6\u5373\u5b58\u5728\u5171\u6a21\u653b\u51fb\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_8","text":"\u8bbe\u4e24\u4e2a\u7528\u6237\u7684\u516c\u94a5\u5206\u522b\u4e3a e_1 e_1 \u548c e_2 e_2 \uff0c\u4e14\u4e24\u8005\u4e92\u8d28\u3002\u660e\u6587\u6d88\u606f\u4e3a m m \uff0c\u5bc6\u6587\u5206\u522b\u4e3a\uff1a c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N c_1 = m^{e_1}\\bmod N \\\\ c_2 = m^{e_2}\\bmod N \u5f53\u653b\u51fb\u8005\u622a\u83b7 c_1 c_1 \u548c c_2 c_2 \u540e\uff0c\u5c31\u53ef\u4ee5\u6062\u590d\u51fa\u660e\u6587\u3002\u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u7b97\u6cd5\u6c42\u51fa re_1+se_2=1\\bmod n re_1+se_2=1\\bmod n \u7684\u4e24\u4e2a\u6574\u6570 r r \u548c s s \uff0c\u7531\u6b64\u53ef\u5f97\uff1a \\begin{align*} c_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &\\equiv m\\bmod n \\end{align*} \\begin{align*} c_{1}^{r}c_{2}^{s} &\\equiv m^{re_1}m^{se_2}\\bmod n\\\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\\\ &\\equiv m\\bmod n \\end{align*}","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#xman","text":"\u9898\u76ee\u63cf\u8ff0\uff1a {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,773} {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,839} message1=3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2=5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 \u9898\u76ee\u6765\u6e90\uff1aXMan \u4e00\u671f\u590f\u4ee4\u8425\u8bfe\u5802\u7ec3\u4e60 \u53ef\u4ee5\u770b\u51fa\u4e24\u4e2a\u516c\u94a5\u7684 N \u662f\u4e00\u6837\u7684\uff0c\u5e76\u4e14\u4e24\u8005\u7684 e \u4e92\u7d20\u3002\u5199\u4e00\u4e2a\u811a\u672c\u8dd1\u4e00\u4e0b\uff1a import gmpy2 n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249 e1 = 773 e2 = 839 message1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 # s & t gcd , s , t = gmpy2 . gcdext ( e1 , e2 ) if s < 0 : s = - s message1 = gmpy2 . invert ( message1 , n ) if t < 0 : t = - t message2 = gmpy2 . invert ( message2 , n ) plain = gmpy2 . powmod ( message1 , s , n ) * gmpy2 . powmod ( message2 , t , n ) % n print plain \u5f97\u5230 \u279c Xman-1-class-exercise git: ( master ) \u2717 python exp.py 1021089710312311910410111011910111610410511010710511610511511211111511510598108101125 \u8fd9\u65f6\u5019\u9700\u8981\u8003\u8651\u5f53\u65f6\u660e\u6587\u662f\u5982\u4f55\u8f6c\u5316\u4e3a\u8fd9\u4e2a\u6570\u5b57\u4e86\uff0c\u4e00\u822c\u6765\u8bf4\u662f 16 \u8fdb\u5236\u8f6c\u6362\uff0cASCII \u5b57\u7b26\u8f6c\u6362\uff0c\u6216\u8005 Base64 \u89e3\u5bc6\u3002\u8fd9\u4e2a\u5e94\u8be5\u662f ASCII \u5b57\u7b26\u8f6c\u6362\uff0c\u8fdb\u800c\u6211\u4eec\u4f7f\u7528\u5982\u4e0b\u4ee3\u7801\u5f97\u5230 flag i = 0 flag = \"\" plain = str ( plain ) while i < len ( plain ): if plain [ i ] == '1' : flag += chr ( int ( plain [ i : i + 3 ])) i += 3 else : flag += chr ( int ( plain [ i : i + 2 ])) i += 2 print flag \u8fd9\u91cc\u4e4b\u6240\u4ee5\u4f7f\u7528 1 \u6765\u5224\u65ad\u662f\u5426\u4e3a\u4e09\u4f4d\u957f\u5ea6\uff0c\u662f\u56e0\u4e3a flag \u4e00\u822c\u90fd\u662f\u660e\u6587\u5b57\u7b26\uff0c\u800c 1 \u5f00\u5934\u7684\u957f\u5ea6\u4e3a 1 \u6216\u8005 2 \u7684\u6570\u5b57\uff0c\u4e00\u822c\u90fd\u662f\u4e0d\u53ef\u89c1\u5b57\u7b26\u3002 flag \u279c Xman-1-class-exercise git: ( master ) \u2717 python exp.py flag { whenwethinkitispossible }","title":"XMan \u4e00\u671f\u590f\u4ee4\u8425\u8bfe\u5802\u7ec3\u4e60"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack-zh/#_9","text":"Jarvis OJ very hard RSA","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/","text":"EN | ZH Violence breakdown N \u00b6 Attack conditions \u00b6 When the number of bits in N is less than 512, p and q can be obtained using a strategy of large integer decomposition. JarvisOJ - Medium RSA \u00b6 Here we take JarvisOJ - Medium RSA as an example, the topic is as follows > Remember the veryeasy RSA? Is it not difficult? Then continue to look at this question, this question is not difficult. > Known piece of RSA encrypted information is: 0xdc2eeeb2782c and the public key used for encryption is known: > N = 322831561921859 and = 23 > Please decrypt the plaintext, please convert the number into ascii code submission when submitting > For example, if the plaintext you solved is 0x6162, please submit the string ab > Submit format: PCTF{clear text string} It can be seen that our N is relatively small, here we directly use factordb to decompose, you can get $$ 322831561921859 = 13574881 \\times 23781539 $$ Then we simply write the program as follows import gmpy2 p = 13574881 q = 23781539 n = p * q e = 23 c = 0xdc2eeeb2782c Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) p = gmpy2 . powmod ( c , d , n ) tmp = hex ( p ) print tmp , tmp [ 2 :] . decode ( 'hex' ) Results are as follows \u279c Jarvis OJ-Basic-easyRSA git: ( master ) \u2717 python exp.py 0x3613559 3a5Y p & q Improper decomposition N \u00b6 Attack conditions \u00b6 We can also attack when p and q are not selected properly in RSA. |pq| Very large \u00b6 When pq is large, there must be a certain parameter is small, here we assume p, then we can try to divide the modulus by exhaustive method, and then decompose the modulus, get the confidential parameters and plaintext information. Basically, it is not very feasible. |pq| Smaller \u00b6 First of all $$ \\frac{(p+q) 2}{4}-n=\\frac{(p+q) 2}{4}-pq=\\frac{(p-q)^2}{4} $$ Since |pq| is small, \\frac{(pq)^2}{4} \\frac{(pq)^2}{4} is naturally small, and \\frac{(p+q)^2}{4} \\frac{(p+q)^2}{4} is only slightly larger than N. , so \\frac{p+q}{2} \\frac{p+q}{2} is similar to \\sqrt{n} \\sqrt{n} . Then we can decompose as follows Check each integer x of \\sqrt{n} \\sqrt{n} in sequence until you find an x such that x^2-n x^2-n is the square number, denoted as y^2 y^2 Then x^2-n=y^2 x^2-n=y^2 , and then decompose N according to the squared difference formula p - 1 Smooth \u00b6 When p is a factor of N and p - 1 is smooth, it is possible to use the Pollard's p \u2212 1 algorithm to decompose N, but it is not entirely successful. Warning Principle analysis to be completed p + 1 Smooth \u00b6 When p is a factor of n and p + 1 is smooth, it may be possible to use the Williams's p + 1 algorithm to decompose N, but it is not entirely successful. 2017 SECCON very smooth \u00b6 The program gives an HTTPS encrypted traffic packet, first getting the certificate from it. \u279c 2017_SECCON_verysmooth git: ( master ) binwalk -e s.pcap DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 2292 0x8F4 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 4038 0xFC6 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 5541 0x15A5 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 \u279c 2017_SECCON_verysmooth git: ( master ) ls s.pcap _s.pcap.extracted very_smooth.zip Here are three certificates, three modules are the same, only one example is given here. \u279c _s.pcap.extracted git:(master) openssl x509 -inform DER -in FC6.crt -pubkey -text -modulus -noout -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy 8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj DUddp + 4X8C9jtvCaLTgd + baSjo2eB0f + uiSL / 9 / 4NN + vR3FliRm2mByeFCjppTQl yioxCqbXYIMxGO4NcQIDAQAB -----END PUBLIC KEY----- Certificate: Data: Version: 1 (0x0) Serial Number: 11640506567126718943 (0xa18b630c7b3099df) Signature Algorithm: sha256WithRSAEncryption Issuer: C=JP, ST=Kawasaki, O=SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C=JP, ST=Kawasaki, O=SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5: c2: 7b: 67: 03: 5a: ec: 19: 2b: 37: 41: dd: 1f: 4d: 12: 75: 31: b0: 7a: b0: 12: eb: 86: 24: 1c: 09: c0: 81: 49: 9e: 69: ef: 5a: ea: c7: 8d: c6: 23: 0d: 47: 5d: a7: ee: 17: f0: 2f: 63: b6: f0: 9a: 2d: 38: 1d: f9: b6: 92: 8e: 8d: 9e:47: fe: ba: 24: 8b: ff: df: f8: 9c: df: af: 47: 71: 65: 89: 19: b6: 98: 1: 9e: 14: 28: e9: a5: 34: 25: ca: 2a: 31: 0a: a6: d7: 60: 83: 31: 18: in: 0d: 71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78: 92: 11: fb: 6c: e1: 7a: f7: 2a: 33: b8: 8b: 08: a7: f7: 5b: de: cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf: 5b: a7: ee: 8b: 1e: 48: a7: d2: 43: 06: 0e: 4f: 5a: 86: 62: 69: e2: c0: bd: 4e: 89: c9: af: 04: 4a: 77: a2: b7: 39 Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71 It can be seen that the modulus is only 1024 bits. Moreover, according to the title name very smooth, it should be one of the factors comparing smooth, here we use the primaryfac to try Pollard's p \u2212 1 and Williams's p + 1 algorithm respectively, as follows \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs -m = p+1 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 : p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 Z309 = P155 x P155 = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 It can be found that when using the Williams's p + 1 algorithm, it is directly decomposed. It is reasonable to say that this factor is p-1 seems to be smoother, but it cannot be decomposed using the Pollard's p \u2212 1 algorithm. Further testing is done here. \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 : 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 Z154 = P1 x P1 x P2 x P3 x P6 x P142 = 2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 : 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 Z154 = P1^185 x P1^62 x P1^97 = 2 ^185 x 3 ^62 x 5 ^97 It can be seen that there are indeed many small factors for p-1, but the number is too large, which will cause an exponential explosion when enumerating, so it is not decomposed. And construct a private key based on the decomposed number from Crypto.PublicKey import RSA import gmpy2 def main (): n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 L q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L e = 65537 L priv = RSA . construct (( n , e , long ( gmpy2 . invert ( e , ( p - 1 ) * ( q - 1 ))))) open ( 'private.pem' , 'w' ) . write ( priv . exportKey ( 'PEM' )) main () Finally, import the private key into wireshark to get the plain text (Edit -> Preferences -> Protocols -> SSL -> RSA Key List). < html > < head >< title > Very smooth </ title ></ head > < body > < h1 > Answer: One of these primes is very smooth. </ h1 > </ body > </ html > Extension \u00b6 For more on some methods of decomposing the modulus N, please refer to https://en.wikipedia.org/wiki/Integer_factorization . \u6a21\u4e0d\u7d20\u7d20 \u00b6 Attack principle \u00b6 When there are two public keys, N is not mutually prime, we can obviously obtain the greatest common factor directly for these two numbers, and then directly obtain p, q, and then obtain the corresponding private key. SCTF RSA2 \u00b6 Here we take SCTF rsa2 as an example. Open the pcap package directly and find that there are a bunch of messages, including N and e, and then try to test whether the different N is mutual. I tried the first two. import gmpy2 n1 = n2 = print gmpy2 . gcd ( n1 , n2 ) The results found that they were not mutually exclusive. \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py 122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137 Then we can decrypt it directly, here we use the first pair of public key ciphers. code show as below from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode n1 = n2 = p1 = gmpy2 . gcd ( n1 , n2 ) q1 = n1 / p1 e = 65537 phin = ( p1 - 1 ) * ( q1 - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7 plain = gmpy2 . powmod ( cipher , d , n1 ) plain = hex ( plain )[ 2 :] if len ( plain ) % 2 ! = 0 : plain = '0' + plain print plain . decode ( 'hex' ) Finally decrypted as follows \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py sH1R3_PRlME_1N_rsA_iS_4ulnEra5le Unzip the package. Common mode attack \u00b6 Attack conditions \u00b6 When two users use the same modulus N and different private keys, there is a common mode attack when encrypting the same plaintext message. Attack principle \u00b6 Let the public keys of the two users be e_1 e_1 and e_2 e_2 , respectively, and they are mutually prime. The plain text message is m m and the ciphertext is: $$ c_1 = m ^ {} e_1 N \\ way c_2 = m ^ {} e_2 N way $$ When the attacker intercepts c_1 c_1 and c_2 c_2 , the plaintext can be recovered. Use the extended Euclidean algorithm to find the two integers r r and s s of re_1+se_2=1\\bmod n re_1+se_2=1\\bmod n , which gives you: $$ \\begin{align*} c_{1} {r}c_{2} {s} &\\equiv m {re_1}m {se_2}\\bmod n\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\ &\\equiv m\\bmod n \\end{align*} $$ XMan Phase I Summer Camp Classroom Exercise \u00b6 Description of the topic: {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,773} {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,839} message1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 > Source: XMan Summer Camp Class Exercise It can be seen that the N of the two public keys are the same, and the e of the two are mutually prime. Write a script to run: import gmpy2 n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249 e1 = 773 e2 = 839 message1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 # s & t gcd , s , t = gmpy2 . gcdext ( e1 , e2 ) if s < 0 : s = - s message1 = gmpy2 . invert ( message1 , n ) if t < 0 : t = - t message2 = gmpy2 . invert ( message2 , n ) plain = gmpy2 . powmod ( message1 , s , n ) * gmpy2 . powmod ( message2 , t , n ) % n print plain get \u279c Xman-1-class-exercise git: ( master ) \u2717 python exp.py 1021089710312311910410111011910111610410511010710511610511511211111511510598108101125 At this time, you need to consider how the plaintext was converted to this number, which is generally a hexadecimal conversion, ASCII character conversion, or Base64 decryption. This should be an ASCII character conversion, and then we use the following code to get the flag i = 0 flag = \"\" plain = str ( plain ) while i < len ( plain ): if plain [ i ] == '1' : flag += chr ( int ( plain [ i : i + 3 ])) i += 3 else : flag += chr ( int ( plain [ i : i + 2 ])) i += 2 print flag The reason why 1 is used to determine whether it is three-bit length is because the flag is usually a plain text character, and the number starting with 1 is 1 or 2, which is generally an invisible character. flag \u279c Xman-1-class-exercise git: ( master ) \u2717 python exp.py flag { whenwethinkitispossible } topic \u00b6 Jarvis OJ very hard RSA","title":"\u6a21\u6570\u76f8\u5173\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#violence-breakdown-n","text":"","title":"Violence breakdown N"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#attack-conditions","text":"When the number of bits in N is less than 512, p and q can be obtained using a strategy of large integer decomposition.","title":"Attack conditions"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#jarvisoj-medium-rsa","text":"Here we take JarvisOJ - Medium RSA as an example, the topic is as follows > Remember the veryeasy RSA? Is it not difficult? Then continue to look at this question, this question is not difficult. > Known piece of RSA encrypted information is: 0xdc2eeeb2782c and the public key used for encryption is known: > N = 322831561921859 and = 23 > Please decrypt the plaintext, please convert the number into ascii code submission when submitting > For example, if the plaintext you solved is 0x6162, please submit the string ab > Submit format: PCTF{clear text string} It can be seen that our N is relatively small, here we directly use factordb to decompose, you can get $$ 322831561921859 = 13574881 \\times 23781539 $$ Then we simply write the program as follows import gmpy2 p = 13574881 q = 23781539 n = p * q e = 23 c = 0xdc2eeeb2782c Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) p = gmpy2 . powmod ( c , d , n ) tmp = hex ( p ) print tmp , tmp [ 2 :] . decode ( 'hex' ) Results are as follows \u279c Jarvis OJ-Basic-easyRSA git: ( master ) \u2717 python exp.py 0x3613559 3a5Y","title":"JarvisOJ - Medium RSA"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#p-q-improper-decomposition-n","text":"","title":"p &amp; q Improper decomposition N"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#attack-conditions_1","text":"We can also attack when p and q are not selected properly in RSA.","title":"Attack conditions"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#pq-very-large","text":"When pq is large, there must be a certain parameter is small, here we assume p, then we can try to divide the modulus by exhaustive method, and then decompose the modulus, get the confidential parameters and plaintext information. Basically, it is not very feasible.","title":"|pq| Very large"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#pq-smaller","text":"First of all $$ \\frac{(p+q) 2}{4}-n=\\frac{(p+q) 2}{4}-pq=\\frac{(p-q)^2}{4} $$ Since |pq| is small, \\frac{(pq)^2}{4} \\frac{(pq)^2}{4} is naturally small, and \\frac{(p+q)^2}{4} \\frac{(p+q)^2}{4} is only slightly larger than N. , so \\frac{p+q}{2} \\frac{p+q}{2} is similar to \\sqrt{n} \\sqrt{n} . Then we can decompose as follows Check each integer x of \\sqrt{n} \\sqrt{n} in sequence until you find an x such that x^2-n x^2-n is the square number, denoted as y^2 y^2 Then x^2-n=y^2 x^2-n=y^2 , and then decompose N according to the squared difference formula","title":"|pq| Smaller"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#p-1-smooth","text":"When p is a factor of N and p - 1 is smooth, it is possible to use the Pollard's p \u2212 1 algorithm to decompose N, but it is not entirely successful. Warning Principle analysis to be completed","title":"p - 1 Smooth"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#p-1-smooth_1","text":"When p is a factor of n and p + 1 is smooth, it may be possible to use the Williams's p + 1 algorithm to decompose N, but it is not entirely successful.","title":"p + 1 Smooth"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#2017-seccon-very-smooth","text":"The program gives an HTTPS encrypted traffic packet, first getting the certificate from it. \u279c 2017_SECCON_verysmooth git: ( master ) binwalk -e s.pcap DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 2292 0x8F4 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 4038 0xFC6 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 5541 0x15A5 Certificate in DER format ( x509 v3 ) , header length: 4 , sequence length: 467 \u279c 2017_SECCON_verysmooth git: ( master ) ls s.pcap _s.pcap.extracted very_smooth.zip Here are three certificates, three modules are the same, only one example is given here. \u279c _s.pcap.extracted git:(master) openssl x509 -inform DER -in FC6.crt -pubkey -text -modulus -noout -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDVRqqCXPYd6Xdl9GT7/kiJrYvy 8lohddAsi28qwMXCe2cDWuwZKzdB3R9NEnUxsHqwEuuGJBwJwIFJnmnvWurHjcYj DUddp + 4X8C9jtvCaLTgd + baSjo2eB0f + uiSL / 9 / 4NN + vR3FliRm2mByeFCjppTQl yioxCqbXYIMxGO4NcQIDAQAB -----END PUBLIC KEY----- Certificate: Data: Version: 1 (0x0) Serial Number: 11640506567126718943 (0xa18b630c7b3099df) Signature Algorithm: sha256WithRSAEncryption Issuer: C=JP, ST=Kawasaki, O=SRL Validity Not Before: Oct 8 02:47:17 2017 GMT Not After : Oct 8 02:47:17 2018 GMT Subject: C=JP, ST=Kawasaki, O=SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption Public-Key: (1024 bit) Modulus: 00:d5:46:aa:82:5c:f6:1d:e9:77:65:f4:64:fb:fe: 48:89:ad:8b:f2:f2:5a:21:75:d0:2c:8b:6f:2a:c0: c5: c2: 7b: 67: 03: 5a: ec: 19: 2b: 37: 41: dd: 1f: 4d: 12: 75: 31: b0: 7a: b0: 12: eb: 86: 24: 1c: 09: c0: 81: 49: 9e: 69: ef: 5a: ea: c7: 8d: c6: 23: 0d: 47: 5d: a7: ee: 17: f0: 2f: 63: b6: f0: 9a: 2d: 38: 1d: f9: b6: 92: 8e: 8d: 9e:47: fe: ba: 24: 8b: ff: df: f8: 9c: df: af: 47: 71: 65: 89: 19: b6: 98: 1: 9e: 14: 28: e9: a5: 34: 25: ca: 2a: 31: 0a: a6: d7: 60: 83: 31: 18: in: 0d: 71 Exponent: 65537 (0x10001) Signature Algorithm: sha256WithRSAEncryption 78: 92: 11: fb: 6c: e1: 7a: f7: 2a: 33: b8: 8b: 08: a7: f7: 5b: de: cf: 62:0b:a0:ed:be:d0:69:88:38:93:94:9d:05:41:73:bd:7e:b3: 32:ec:8e:10:bc:3a:62:b0:56:c7:c1:3f:60:66:a7:be:b9:46: f7:46:22:6a:f3:5a:25:d5:66:94:57:0e:fc:b5:16:33:05:1c: 6f:f5:85:74:57:a4:a0:c6:ce:4f:fd:64:53:94:a9:83:b8:96: bf: 5b: a7: ee: 8b: 1e: 48: a7: d2: 43: 06: 0e: 4f: 5a: 86: 62: 69: e2: c0: bd: 4e: 89: c9: af: 04: 4a: 77: a2: b7: 39 Modulus=D546AA825CF61DE97765F464FBFE4889AD8BF2F25A2175D02C8B6F2AC0C5C27B67035AEC192B3741DD1F4D127531B07AB012EB86241C09C081499E69EF5AEAC78DC6230D475DA7EE17F02F63B6F09A2D381DF9B6928E8D9E0747FEBA248BFFDFF89CDFAF4771658919B6981C9E1428E9A53425CA2A310AA6D760833118EE0D71 It can be seen that the modulus is only 1024 bits. Moreover, according to the title name very smooth, it should be one of the factors comparing smooth, here we use the primaryfac to try Pollard's p \u2212 1 and Williams's p + 1 algorithm respectively, as follows \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs -m = p+1 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 : p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 Z309 = P155 x P155 = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 It can be found that when using the Williams's p + 1 algorithm, it is directly decomposed. It is reasonable to say that this factor is p-1 seems to be smoother, but it cannot be decomposed using the Pollard's p \u2212 1 algorithm. Further testing is done here. \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002 : 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 Z154 = P1 x P1 x P2 x P3 x P6 x P142 = 2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823 \u279c _s.pcap.extracted git: ( master ) python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 : 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 Z154 = P1^185 x P1^62 x P1^97 = 2 ^185 x 3 ^62 x 5 ^97 It can be seen that there are indeed many small factors for p-1, but the number is too large, which will cause an exponential explosion when enumerating, so it is not decomposed. And construct a private key based on the decomposed number from Crypto.PublicKey import RSA import gmpy2 def main (): n = 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L p = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 L q = 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 L e = 65537 L priv = RSA . construct (( n , e , long ( gmpy2 . invert ( e , ( p - 1 ) * ( q - 1 ))))) open ( 'private.pem' , 'w' ) . write ( priv . exportKey ( 'PEM' )) main () Finally, import the private key into wireshark to get the plain text (Edit -> Preferences -> Protocols -> SSL -> RSA Key List). < html > < head >< title > Very smooth </ title ></ head > < body > < h1 > Answer: One of these primes is very smooth. </ h1 > </ body > </ html >","title":"2017 SECCON very smooth"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#extension","text":"For more on some methods of decomposing the modulus N, please refer to https://en.wikipedia.org/wiki/Integer_factorization .","title":"Extension"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#_1","text":"","title":"\u6a21\u4e0d\u7d20\u7d20"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#attack-principle","text":"When there are two public keys, N is not mutually prime, we can obviously obtain the greatest common factor directly for these two numbers, and then directly obtain p, q, and then obtain the corresponding private key.","title":"Attack principle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#sctf-rsa2","text":"Here we take SCTF rsa2 as an example. Open the pcap package directly and find that there are a bunch of messages, including N and e, and then try to test whether the different N is mutual. I tried the first two. import gmpy2 n1 = n2 = print gmpy2 . gcd ( n1 , n2 ) The results found that they were not mutually exclusive. \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py 122281872221091773923842091258531471948886120336284482555605167683829690073110898673260712865021244633908982705290201598907538975692920305239961645109897081011524485706755794882283892011824006117276162119331970728229108731696164377808170099285659797066904706924125871571157672409051718751812724929680249712137 Then we can decrypt it directly, here we use the first pair of public key ciphers. code show as below from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 , PKCS1_OAEP import gmpy2 from base64 import b64decode n1 = n2 = p1 = gmpy2 . gcd ( n1 , n2 ) q1 = n1 / p1 e = 65537 phin = ( p1 - 1 ) * ( q1 - 1 ) d = gmpy2 . invert ( e , phin ) cipher = 0x68d5702b70d18238f9d4a3ac355b2a8934328250efd4efda39a4d750d80818e6fe228ba3af471b27cc529a4b0bef70a2598b80dd251b15952e6a6849d366633ed7bb716ed63c6febd4cd0621b0c4ebfe5235de03d4ee016448de1afbbe61144845b580eed8be8127a8d92b37f9ef670b3cdd5af613c76f58ca1a9f6f03f1bc11addba30b61bb191efe0015e971b8f78375faa257a60b355050f6435d94b49eab07075f40cb20bb8723d02f5998d5538e8dafc80cc58643c91f6c0868a7a7bf3bf6a9b4b6e79e0a80e89d430f0c049e1db4883c50db066a709b89d74038c34764aac286c36907b392bc299ab8288f9d7e372868954a92cdbf634678f7294096c7 plain = gmpy2 . powmod ( cipher , d , n1 ) plain = hex ( plain )[ 2 :] if len ( plain ) % 2 ! = 0 : plain = '0' + plain print plain . decode ( 'hex' ) Finally decrypted as follows \u279c scaf-rsa2 git: ( master ) \u2717 python exp.py sH1R3_PRlME_1N_rsA_iS_4ulnEra5le Unzip the package.","title":"SCTF RSA2"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#common-mode-attack","text":"","title":"Common mode attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#attack-conditions_2","text":"When two users use the same modulus N and different private keys, there is a common mode attack when encrypting the same plaintext message.","title":"Attack conditions"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#attack-principle_1","text":"Let the public keys of the two users be e_1 e_1 and e_2 e_2 , respectively, and they are mutually prime. The plain text message is m m and the ciphertext is: $$ c_1 = m ^ {} e_1 N \\ way c_2 = m ^ {} e_2 N way $$ When the attacker intercepts c_1 c_1 and c_2 c_2 , the plaintext can be recovered. Use the extended Euclidean algorithm to find the two integers r r and s s of re_1+se_2=1\\bmod n re_1+se_2=1\\bmod n , which gives you: $$ \\begin{align*} c_{1} {r}c_{2} {s} &\\equiv m {re_1}m {se_2}\\bmod n\\ &\\equiv m^{(re_1+se_2)} \\bmod n\\ &\\equiv m\\bmod n \\end{align*} $$","title":"Attack principle"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#xman-phase-i-summer-camp-classroom-exercise","text":"Description of the topic: {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,773} {6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249,839} message1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 > Source: XMan Summer Camp Class Exercise It can be seen that the N of the two public keys are the same, and the e of the two are mutually prime. Write a script to run: import gmpy2 n = 6266565720726907265997241358331585417095726146341989755538017122981360742813498401533594757088796536341941659691259323065631249 e1 = 773 e2 = 839 message1 = 3453520592723443935451151545245025864232388871721682326408915024349804062041976702364728660682912396903968193981131553111537349 message2 = 5672818026816293344070119332536629619457163570036305296869053532293105379690793386019065754465292867769521736414170803238309535 # s & t gcd , s , t = gmpy2 . gcdext ( e1 , e2 ) if s < 0 : s = - s message1 = gmpy2 . invert ( message1 , n ) if t < 0 : t = - t message2 = gmpy2 . invert ( message2 , n ) plain = gmpy2 . powmod ( message1 , s , n ) * gmpy2 . powmod ( message2 , t , n ) % n print plain get \u279c Xman-1-class-exercise git: ( master ) \u2717 python exp.py 1021089710312311910410111011910111610410511010710511610511511211111511510598108101125 At this time, you need to consider how the plaintext was converted to this number, which is generally a hexadecimal conversion, ASCII character conversion, or Base64 decryption. This should be an ASCII character conversion, and then we use the following code to get the flag i = 0 flag = \"\" plain = str ( plain ) while i < len ( plain ): if plain [ i ] == '1' : flag += chr ( int ( plain [ i : i + 3 ])) i += 3 else : flag += chr ( int ( plain [ i : i + 2 ])) i += 2 print flag The reason why 1 is used to determine whether it is three-bit length is because the flag is usually a plain text character, and the number starting with 1 is 1 or 2, which is generally an invisible character. flag \u279c Xman-1-class-exercise git: ( master ) \u2717 python exp.py flag { whenwethinkitispossible }","title":"XMan Phase I Summer Camp Classroom Exercise"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_module_attack/#topic","text":"Jarvis OJ very hard RSA","title":"topic"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_pkcs_attack-zh/","text":"EN | ZH Bleichenbacher's attack \u00b6 PKCS 1.5 \u6807\u51c6\u4e2d\u53ef\u4ee5\u4f2a\u9020 RSA \u7b7e\u540d\u200b Warning \u5f85\u8865\u5145\u3002 http://ddaa.tw/gctf_crypto_201_rsa_ctf_challenge.html","title":"Rsa pkcs attack zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_pkcs_attack-zh/#bleichenbachers-attack","text":"PKCS 1.5 \u6807\u51c6\u4e2d\u53ef\u4ee5\u4f2a\u9020 RSA \u7b7e\u540d\u200b Warning \u5f85\u8865\u5145\u3002 http://ddaa.tw/gctf_crypto_201_rsa_ctf_challenge.html","title":"Bleichenbacher's attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_pkcs_attack/","text":"EN | ZH Bleichenbacher's attack \u00b6 RSA signature can be forged in the PKCS 1.5 standard Warning To be added. http://ddaa.tw/gctf_crypto_201_rsa_ctf_challenge.html","title":"Bleichenbacher \u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_pkcs_attack/#bleichenbachers-attack","text":"RSA signature can be forged in the PKCS 1.5 standard Warning To be added. http://ddaa.tw/gctf_crypto_201_rsa_ctf_challenge.html","title":"Bleichenbacher&#39;s attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel-zh/","text":"EN | ZH RSA \u4fa7\u4fe1\u9053\u653b\u51fb \u00b6 \u80fd\u91cf\u5206\u6790\u653b\u51fb\uff08\u4fa7\u4fe1\u9053\u653b\u51fb\uff09\u662f\u4e00\u79cd\u80fd\u591f\u4ece\u5bc6\u7801\u8bbe\u5907\u4e2d\u83b7\u53d6\u79d8\u5bc6\u4fe1\u606f\u7684\u5bc6\u7801\u653b\u51fb\u65b9\u6cd5\uff0e\u4e0e\u5176 \u4ed6\u653b\u51fb\u65b9\u6cd5\u4e0d\u540c\uff1a\u8fd9\u79cd\u653b\u51fb\u5229\u7528\u7684\u662f\u5bc6\u7801\u8bbe\u5907\u7684\u80fd\u91cf\u6d88\u8017\u7279\u5f81\uff0c\u800c\u975e\u5bc6\u7801\u7b97\u6cd5\u7684\u6570\u5b66\u7279\u6027\uff0e\u80fd\u91cf\u5206\u6790\u653b\u51fb\u662f\u4e00\u79cd\u975e\u5165\u4fb5\u5f0f\u653b\u51fb\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u65b9\u4fbf\u5730\u8d2d\u4e70\u5b9e\u65bd\u653b\u51fb\u6240\u9700\u8981\u7684\u8bbe\u5907\uff1a\u6240\u4ee5\u8fd9\u79cd\u653b\u51fb\u5bf9\u667a\u80fd\u5361\u4e4b\u7c7b\u7684\u5bc6\u7801\u8bbe\u5907\u7684\u5b89\u5168\u6027\u9020\u6210\u4e86\u4e25\u91cd\u5a01\u80c1\u3002 \u80fd\u91cf\u5206\u6790\u653b\u51fb\u662f\u5b89\u5168\u9886\u57df\u5185\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u90e8\u5206\uff0c\u6211\u4eec\u53ea\u5728\u8fd9\u91cc\u7b80\u5355\u8ba8\u8bba\u4e0b\u3002 \u80fd\u91cf\u5206\u6790\u653b\u51fb\u5206\u4e3a\uff1a - \u7b80\u5355\u80fd\u91cf\u5206\u6790\u653b\u51fb\uff08SPA\uff09\uff0c\u5373\u5bf9\u80fd\u91cf\u8ff9\u8fdb\u884c\u76f4\u89c2\u5206\u6790\uff0c\u8089\u773c\u770b\u5373\u53ef\u3002 - \u5dee\u5206\u80fd\u91cf\u5206\u6790\u653b\u51fb\uff08DPA\uff09\uff0c\u57fa\u4e8e\u80fd\u91cf\u8ff9\u4e4b\u95f4\u7684\u76f8\u5173\u7cfb\u6570\u8fdb\u884c\u5206\u6790\u3002 \u653b\u51fb\u6761\u4ef6 \u00b6 \u653b\u51fb\u8005\u53ef\u83b7\u53d6\u4e0e\u52a0\u89e3\u5bc6\u76f8\u5173\u7684\u4fa7\u4fe1\u9053\u4fe1\u606f\uff0c\u4f8b\u5982\u80fd\u91cf\u6d88\u8017\u3001\u8fd0\u7b97\u65f6\u95f4\u3001\u7535\u78c1\u8f90\u5c04\u7b49\u7b49\u3002 \u4f8b\u5b50 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 HITB 2017 \u7684 Hack in the card I \u4f5c\u4e3a\u4f8b\u5b50\u3002 \u9898\u76ee\u7ed9\u51fa\u4e86\u516c\u94a5\u6587\u4ef6 publickey.pem \uff0c\u5bc6\u6587\uff0c\u6d4b\u91cf\u667a\u80fd\u5361\u529f\u7387\u7684\u7535\u8def\u56fe\uff0c\u548c \u89e3\u5bc6 \u8fc7\u7a0b\u4e2d\u667a\u80fd\u5361\u6d88\u8017\u7684\u529f\u7387\u53d8\u5316\uff08\u901a\u8fc7\u5728\u7ebf\u7f51\u7ad9\u7ed9\u51fa trace \uff09\u3002 \u5bc6\u6587\uff1a 014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046 \u5206\u6790 \u00b6 \u7531\u4e8e\u7f51\u7ad9\u53ea\u7ed9\u51fa\u4e86\u4e00\u6761\u80fd\u91cf\u8ff9\uff0c\u6240\u4ee5\u53ef\u4ee5\u65ad\u5b9a\u8fd9\u662f Simple channel analysis\uff08SPA\uff09\u653b\u51fb\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u901a\u8fc7\u89c2\u5bdf\u80fd\u91cf\u8ff9\u7684\u9ad8\u4f4e\u7535\u5e73\u6765\u83b7\u5f97 RSA \u89e3\u5bc6\u8fc7\u7a0b\u7684\u5bc6\u94a5 d\u3002 RSA \u53ef\u88ab SPA \u653b\u51fb\u7684\u7406\u8bba\u57fa\u7840\u6765\u81ea\u4e8e RSA \u4e2d\u5305\u542b\u7684\u5feb\u901f\u5e42\u53d6\u4f59\u7b97\u6cd5\u3002 \u5feb\u901f\u5e42\u7b97\u6cd5\u5982\u4e0b b \u4e3a\u5076\u6570\u65f6\uff0c a^b \\bmod c = ({a^2}^{b/2}) \\bmod c a^b \\bmod c = ({a^2}^{b/2}) \\bmod c \u3002 b \u4e3a\u5947\u6570\u65f6\uff0c a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c \u3002 \u76f8\u5e94\u7684 C \u4ee3\u7801\u5b9e\u73b0\u4e3a\uff1a int PowerMod ( int a , int b , int c ) { int ans = 1 ; a = a % c ; while ( b > 0 ) { if ( b % 2 == 1 ) // \u5f53b\u4e3a\u5947\u6570\u65f6\u4f1a\u591a\u6267\u884c\u4e0b\u9762\u7684\u6307\u4ee4 ans = ( ans * a ) % c ; b = b / 2 ; a = ( a * a ) % c ; } return ans ; } \u7531\u4e8e\u5feb\u901f\u5e42\u7684\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\u4f1a\u9010\u4f4d\u5224\u65ad\u6307\u6570\u7684\u53d6\u503c\uff0c\u5e76\u4f1a\u91c7\u53d6\u4e0d\u540c\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u53ef\u4ece\u80fd\u91cf\u8ff9\u4e2d\u8fd8\u539f\u51fa d \u7684\u53d6\u503c\uff08\u4ece\u4e0a\u9762\u53ef\u77e5\uff0c\u76f4\u63a5\u5f97\u5230\u7684\u503c\u662f d \u7684\u4e8c\u8fdb\u5236\u53d6\u503c\u7684 \u9006\u5e8f \uff09\u3002 \u6ce8\u610f \uff1a \u6709\u65f6\u5019\u6a21\u4e58\u4e5f\u53ef\u80fd\u4f1a\u4ece\u9ad8\u4f4d\u5411\u4f4e\u4f4d\u8fdb\u884c\u6a21\u4e58\u3002\u8fd9\u91cc\u662f\u4ece\u4f4e\u4f4d\u5411\u9ad8\u4f4d\u6a21\u4e58\u3002 \u7531\u6b64\u53ef\u7ed9\u51fa\u8fd8\u539f d \u7684\u811a\u672c\u5982\u4e0b\uff1a f = open ( './data.txt' ) data = f . read () . split ( \",\" ) print ( 'point number:' , len ( data )) start_point = 225 # \u5f00\u59cb\u5206\u6790\u7684\u70b9 mid = 50 # \u91c7\u6837\u70b9\u95f4\u9694 fence = 228 # \u9ad8\u4f4e\u7535\u5e73\u5206\u754c\u7ebf bin_array = [] for point_index in range ( start_point , len ( data ), mid ): if float ( data [ point_index ]) > fence : bin_array . append ( 1 ) else : bin_array . append ( 0 ) bin_array2 = [] flag1 = 0 flag2 = 0 for x in bin_array : if x : if flag1 : flag2 = 1 else : flag1 = 1 else : if flag2 : bin_array2 . append ( 1 ) else : bin_array2 . append ( 0 ) flag1 = 0 flag2 = 0 # d_bin = bin_array2[::-1] d_bin = bin_array2 d = \"\" . join ( str ( x ) for x in d_bin )[:: - 1 ] print ( d ) d_int = int ( d , 2 ) print ( d_int ) \u53c2\u8003\u8d44\u6599 \u00b6 Mangard, S., Oswald, E., Popp, T., \u51af\u767b\u56fd, \u5468\u6c38\u5f6c, & \u5218\u7ee7\u4e1a. (2010). \u80fd\u91cf\u5206\u6790\u653b\u51fb.","title":"Rsa side channel zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel-zh/#rsa","text":"\u80fd\u91cf\u5206\u6790\u653b\u51fb\uff08\u4fa7\u4fe1\u9053\u653b\u51fb\uff09\u662f\u4e00\u79cd\u80fd\u591f\u4ece\u5bc6\u7801\u8bbe\u5907\u4e2d\u83b7\u53d6\u79d8\u5bc6\u4fe1\u606f\u7684\u5bc6\u7801\u653b\u51fb\u65b9\u6cd5\uff0e\u4e0e\u5176 \u4ed6\u653b\u51fb\u65b9\u6cd5\u4e0d\u540c\uff1a\u8fd9\u79cd\u653b\u51fb\u5229\u7528\u7684\u662f\u5bc6\u7801\u8bbe\u5907\u7684\u80fd\u91cf\u6d88\u8017\u7279\u5f81\uff0c\u800c\u975e\u5bc6\u7801\u7b97\u6cd5\u7684\u6570\u5b66\u7279\u6027\uff0e\u80fd\u91cf\u5206\u6790\u653b\u51fb\u662f\u4e00\u79cd\u975e\u5165\u4fb5\u5f0f\u653b\u51fb\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u65b9\u4fbf\u5730\u8d2d\u4e70\u5b9e\u65bd\u653b\u51fb\u6240\u9700\u8981\u7684\u8bbe\u5907\uff1a\u6240\u4ee5\u8fd9\u79cd\u653b\u51fb\u5bf9\u667a\u80fd\u5361\u4e4b\u7c7b\u7684\u5bc6\u7801\u8bbe\u5907\u7684\u5b89\u5168\u6027\u9020\u6210\u4e86\u4e25\u91cd\u5a01\u80c1\u3002 \u80fd\u91cf\u5206\u6790\u653b\u51fb\u662f\u5b89\u5168\u9886\u57df\u5185\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u90e8\u5206\uff0c\u6211\u4eec\u53ea\u5728\u8fd9\u91cc\u7b80\u5355\u8ba8\u8bba\u4e0b\u3002 \u80fd\u91cf\u5206\u6790\u653b\u51fb\u5206\u4e3a\uff1a - \u7b80\u5355\u80fd\u91cf\u5206\u6790\u653b\u51fb\uff08SPA\uff09\uff0c\u5373\u5bf9\u80fd\u91cf\u8ff9\u8fdb\u884c\u76f4\u89c2\u5206\u6790\uff0c\u8089\u773c\u770b\u5373\u53ef\u3002 - \u5dee\u5206\u80fd\u91cf\u5206\u6790\u653b\u51fb\uff08DPA\uff09\uff0c\u57fa\u4e8e\u80fd\u91cf\u8ff9\u4e4b\u95f4\u7684\u76f8\u5173\u7cfb\u6570\u8fdb\u884c\u5206\u6790\u3002","title":"RSA \u4fa7\u4fe1\u9053\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel-zh/#_1","text":"\u653b\u51fb\u8005\u53ef\u83b7\u53d6\u4e0e\u52a0\u89e3\u5bc6\u76f8\u5173\u7684\u4fa7\u4fe1\u9053\u4fe1\u606f\uff0c\u4f8b\u5982\u80fd\u91cf\u6d88\u8017\u3001\u8fd0\u7b97\u65f6\u95f4\u3001\u7535\u78c1\u8f90\u5c04\u7b49\u7b49\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel-zh/#_2","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 HITB 2017 \u7684 Hack in the card I \u4f5c\u4e3a\u4f8b\u5b50\u3002 \u9898\u76ee\u7ed9\u51fa\u4e86\u516c\u94a5\u6587\u4ef6 publickey.pem \uff0c\u5bc6\u6587\uff0c\u6d4b\u91cf\u667a\u80fd\u5361\u529f\u7387\u7684\u7535\u8def\u56fe\uff0c\u548c \u89e3\u5bc6 \u8fc7\u7a0b\u4e2d\u667a\u80fd\u5361\u6d88\u8017\u7684\u529f\u7387\u53d8\u5316\uff08\u901a\u8fc7\u5728\u7ebf\u7f51\u7ad9\u7ed9\u51fa trace \uff09\u3002 \u5bc6\u6587\uff1a 014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel-zh/#_3","text":"\u7531\u4e8e\u7f51\u7ad9\u53ea\u7ed9\u51fa\u4e86\u4e00\u6761\u80fd\u91cf\u8ff9\uff0c\u6240\u4ee5\u53ef\u4ee5\u65ad\u5b9a\u8fd9\u662f Simple channel analysis\uff08SPA\uff09\u653b\u51fb\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u901a\u8fc7\u89c2\u5bdf\u80fd\u91cf\u8ff9\u7684\u9ad8\u4f4e\u7535\u5e73\u6765\u83b7\u5f97 RSA \u89e3\u5bc6\u8fc7\u7a0b\u7684\u5bc6\u94a5 d\u3002 RSA \u53ef\u88ab SPA \u653b\u51fb\u7684\u7406\u8bba\u57fa\u7840\u6765\u81ea\u4e8e RSA \u4e2d\u5305\u542b\u7684\u5feb\u901f\u5e42\u53d6\u4f59\u7b97\u6cd5\u3002 \u5feb\u901f\u5e42\u7b97\u6cd5\u5982\u4e0b b \u4e3a\u5076\u6570\u65f6\uff0c a^b \\bmod c = ({a^2}^{b/2}) \\bmod c a^b \\bmod c = ({a^2}^{b/2}) \\bmod c \u3002 b \u4e3a\u5947\u6570\u65f6\uff0c a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c \u3002 \u76f8\u5e94\u7684 C \u4ee3\u7801\u5b9e\u73b0\u4e3a\uff1a int PowerMod ( int a , int b , int c ) { int ans = 1 ; a = a % c ; while ( b > 0 ) { if ( b % 2 == 1 ) // \u5f53b\u4e3a\u5947\u6570\u65f6\u4f1a\u591a\u6267\u884c\u4e0b\u9762\u7684\u6307\u4ee4 ans = ( ans * a ) % c ; b = b / 2 ; a = ( a * a ) % c ; } return ans ; } \u7531\u4e8e\u5feb\u901f\u5e42\u7684\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\u4f1a\u9010\u4f4d\u5224\u65ad\u6307\u6570\u7684\u53d6\u503c\uff0c\u5e76\u4f1a\u91c7\u53d6\u4e0d\u540c\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u53ef\u4ece\u80fd\u91cf\u8ff9\u4e2d\u8fd8\u539f\u51fa d \u7684\u53d6\u503c\uff08\u4ece\u4e0a\u9762\u53ef\u77e5\uff0c\u76f4\u63a5\u5f97\u5230\u7684\u503c\u662f d \u7684\u4e8c\u8fdb\u5236\u53d6\u503c\u7684 \u9006\u5e8f \uff09\u3002 \u6ce8\u610f \uff1a \u6709\u65f6\u5019\u6a21\u4e58\u4e5f\u53ef\u80fd\u4f1a\u4ece\u9ad8\u4f4d\u5411\u4f4e\u4f4d\u8fdb\u884c\u6a21\u4e58\u3002\u8fd9\u91cc\u662f\u4ece\u4f4e\u4f4d\u5411\u9ad8\u4f4d\u6a21\u4e58\u3002 \u7531\u6b64\u53ef\u7ed9\u51fa\u8fd8\u539f d \u7684\u811a\u672c\u5982\u4e0b\uff1a f = open ( './data.txt' ) data = f . read () . split ( \",\" ) print ( 'point number:' , len ( data )) start_point = 225 # \u5f00\u59cb\u5206\u6790\u7684\u70b9 mid = 50 # \u91c7\u6837\u70b9\u95f4\u9694 fence = 228 # \u9ad8\u4f4e\u7535\u5e73\u5206\u754c\u7ebf bin_array = [] for point_index in range ( start_point , len ( data ), mid ): if float ( data [ point_index ]) > fence : bin_array . append ( 1 ) else : bin_array . append ( 0 ) bin_array2 = [] flag1 = 0 flag2 = 0 for x in bin_array : if x : if flag1 : flag2 = 1 else : flag1 = 1 else : if flag2 : bin_array2 . append ( 1 ) else : bin_array2 . append ( 0 ) flag1 = 0 flag2 = 0 # d_bin = bin_array2[::-1] d_bin = bin_array2 d = \"\" . join ( str ( x ) for x in d_bin )[:: - 1 ] print ( d ) d_int = int ( d , 2 ) print ( d_int )","title":"\u5206\u6790"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel-zh/#_4","text":"Mangard, S., Oswald, E., Popp, T., \u51af\u767b\u56fd, \u5468\u6c38\u5f6c, & \u5218\u7ee7\u4e1a. (2010). \u80fd\u91cf\u5206\u6790\u653b\u51fb.","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel/","text":"EN | ZH RSA Side Channel Attack \u00b6 An energy analysis attack (side channel attack) is a password attack method that can obtain secret information from a cryptographic device. Instead of His attack method is different: this attack uses the energy consumption characteristics of the cryptographic device, not the mathematical characteristics of the cryptographic algorithm. An energy analysis attack is a non-intrusive attack that allows an attacker to easily purchase the equipment needed to implement an attack: this type of attack poses a serious threat to the security of cryptographic devices such as smart cards. Energy analysis attacks are a very important part of the security arena, and we will only discuss them briefly here. Energy analysis attacks are divided into: - Simple Energy Analysis Attack (SPA), which allows visual analysis of energy traces, which can be viewed with the naked eye. - Differential Energy Analysis Attack (DPA), based on correlation coefficients between energy traces. Attack conditions \u00b6 The attacker can obtain side channel information related to encryption and decryption, such as energy consumption, computing time, electromagnetic radiation, and the like. example \u00b6 Here we take the Hack in the card I of HITB 2017 as an example. The topic gives the public key file publickey.pem , ciphertext, the circuit diagram for measuring the smart card power, and the power consumption consumed by the smart card during the decryption (given [trace] via the online website ( http://47.74 .147.53:20015/index.html)). Ciphertext: 014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046 Analysis \u00b6 Since the site only gives an energy trace, it can be concluded that this is a Simple channel analysis (SPA) attack. Then we can directly obtain the key d of the RSA decryption process by observing the high and low levels of the energy trace. The theoretical basis for RSA attacks by SPA comes from the fast power remainder algorithm included in RSA. The fast power algorithm is as follows When b is even, a^b \\bmod c = ({a^2}^{b/2}) \\bmod c a^b \\bmod c = ({a^2}^{b/2}) \\bmod c . When b is an odd number, a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c . The corresponding C code is implemented as: int PowerMod ( int a , int b , int c ) { int ans = 1 ; a = a % c ; while ( b > 0 ) { If ( b % 2 == 1 ) // When b is odd, the following instructions will be executed more years = ( years * a ) % c ; b = b / 2 ; a = ( a * a ) % c ; } return years ; } Since the value of the exponent is judged bit by bit during the calculation of the fast power, and different operations are taken, the value of d can be restored from the energy trace (from the above, the directly obtained value is the binary value of d) reverse order ). note : > Sometimes modular multiplication may also be multiplied from high to low. Here is the multiplication from the low to the high. The script that restores d can be given as follows: f = open ( './data.txt' ) data = f . read () . split ( \",\" ) print ( 'point number:' , len ( data )) Start_point = 225 # Point to start analysis Mid = 50 # sampling point interval Fence = 228 # high and low level dividing line bin_array = [] for point_index in range ( start_point , len ( data ), mid ): if float ( data [ point_index ]) > fence : bin_array . append ( 1 ) else : bin_array . append ( 0 ) bin_array2 = [] flag1 = 0 flag2 = 0 for x in bin_array : if x : if flag1 : flag2 = 1 else : flag1 = 1 else : if flag2 : bin_array2 . append ( 1 ) else : bin_array2 . append ( 0 ) flag1 = 0 flag2 = 0 # d_bin = bin_array2 [:: - 1] d_bin = bin_array2 d = \"\" . join ( str ( x ) for x in d_bin )[:: - 1 ] print ( d ) d_int = int ( d , 2 ) print ( d_int ) References \u00b6 Mangard, S., Oswald, E., Popp, T., Feng Dengguo, Zhou Yongbin, & Liu Jiye. (2010). Energy Analysis Attack.","title":"\u4fa7\u4fe1\u9053\u653b\u51fb"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel/#rsa-side-channel-attack","text":"An energy analysis attack (side channel attack) is a password attack method that can obtain secret information from a cryptographic device. Instead of His attack method is different: this attack uses the energy consumption characteristics of the cryptographic device, not the mathematical characteristics of the cryptographic algorithm. An energy analysis attack is a non-intrusive attack that allows an attacker to easily purchase the equipment needed to implement an attack: this type of attack poses a serious threat to the security of cryptographic devices such as smart cards. Energy analysis attacks are a very important part of the security arena, and we will only discuss them briefly here. Energy analysis attacks are divided into: - Simple Energy Analysis Attack (SPA), which allows visual analysis of energy traces, which can be viewed with the naked eye. - Differential Energy Analysis Attack (DPA), based on correlation coefficients between energy traces.","title":"RSA Side Channel Attack"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel/#attack-conditions","text":"The attacker can obtain side channel information related to encryption and decryption, such as energy consumption, computing time, electromagnetic radiation, and the like.","title":"Attack conditions"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel/#example","text":"Here we take the Hack in the card I of HITB 2017 as an example. The topic gives the public key file publickey.pem , ciphertext, the circuit diagram for measuring the smart card power, and the power consumption consumed by the smart card during the decryption (given [trace] via the online website ( http://47.74 .147.53:20015/index.html)). Ciphertext: 014b05e1a09668c83e13fda8be28d148568a2342aed833e0ad646bd45461da2decf9d538c2d3ab245b272873beb112586bb7b17dc4b30f0c5408d8b03cfbc8388b2bd579fb419a1cac38798da1c3da75dc9a74a90d98c8f986fd8ab8b2dc539768beb339cadc13383c62b5223a50e050cb9c6b759072962c2b2cf21b4421ca73394d9e12cfbc958fc5f6b596da368923121e55a3c6a7b12fdca127ecc0e8470463f6e04f27cd4bb3de30555b6c701f524c8c032fa51d719901e7c75cc72764ac00976ac6427a1f483779f61cee455ed319ee9071abefae4473e7c637760b4b3131f25e5eb9950dd9d37666e129640c82a4b01b8bdc1a78b007f8ec71e7bad48046","title":"example"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel/#analysis","text":"Since the site only gives an energy trace, it can be concluded that this is a Simple channel analysis (SPA) attack. Then we can directly obtain the key d of the RSA decryption process by observing the high and low levels of the energy trace. The theoretical basis for RSA attacks by SPA comes from the fast power remainder algorithm included in RSA. The fast power algorithm is as follows When b is even, a^b \\bmod c = ({a^2}^{b/2}) \\bmod c a^b \\bmod c = ({a^2}^{b/2}) \\bmod c . When b is an odd number, a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c a^b \\bmod c = ({a^2}^{b/2} \\times a) \\bmod c . The corresponding C code is implemented as: int PowerMod ( int a , int b , int c ) { int ans = 1 ; a = a % c ; while ( b > 0 ) { If ( b % 2 == 1 ) // When b is odd, the following instructions will be executed more years = ( years * a ) % c ; b = b / 2 ; a = ( a * a ) % c ; } return years ; } Since the value of the exponent is judged bit by bit during the calculation of the fast power, and different operations are taken, the value of d can be restored from the energy trace (from the above, the directly obtained value is the binary value of d) reverse order ). note : > Sometimes modular multiplication may also be multiplied from high to low. Here is the multiplication from the low to the high. The script that restores d can be given as follows: f = open ( './data.txt' ) data = f . read () . split ( \",\" ) print ( 'point number:' , len ( data )) Start_point = 225 # Point to start analysis Mid = 50 # sampling point interval Fence = 228 # high and low level dividing line bin_array = [] for point_index in range ( start_point , len ( data ), mid ): if float ( data [ point_index ]) > fence : bin_array . append ( 1 ) else : bin_array . append ( 0 ) bin_array2 = [] flag1 = 0 flag2 = 0 for x in bin_array : if x : if flag1 : flag2 = 1 else : flag1 = 1 else : if flag2 : bin_array2 . append ( 1 ) else : bin_array2 . append ( 0 ) flag1 = 0 flag2 = 0 # d_bin = bin_array2 [:: - 1] d_bin = bin_array2 d = \"\" . join ( str ( x ) for x in d_bin )[:: - 1 ] print ( d ) d_int = int ( d , 2 ) print ( d_int )","title":"Analysis"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_side_channel/#references","text":"Mangard, S., Oswald, E., Popp, T., Feng Dengguo, Zhou Yongbin, & Liu Jiye. (2010). Energy Analysis Attack.","title":"References"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/","text":"EN | ZH RSA \u4ecb\u7ecd \u00b6 RSA \u52a0\u5bc6\u7b97\u6cd5\u662f\u4e00\u79cd\u975e\u5bf9\u79f0\u52a0\u5bc6\u7b97\u6cd5\u3002\u5728\u516c\u5f00\u5bc6\u94a5\u52a0\u5bc6\u548c\u7535\u5b50\u5546\u4e1a\u4e2d RSA \u88ab\u5e7f\u6cdb\u4f7f\u7528\u3002RSA \u662f 1977 \u5e74\u7531\u7f57\u7eb3\u5fb7\u00b7\u674e\u7ef4\u65af\u7279\uff08Ron Rivest\uff09\u3001\u963f\u8fea\u00b7\u8428\u83ab\u5c14\uff08Adi Shamir\uff09\u548c\u4f26\u7eb3\u5fb7\u00b7\u963f\u5fb7\u66fc\uff08Leonard Adleman\uff09\u4e00\u8d77\u63d0\u51fa\u7684\u3002RSA \u5c31\u662f\u4ed6\u4eec\u4e09\u4eba\u59d3\u6c0f\u5f00\u5934\u5b57\u6bcd\u62fc\u5728\u4e00\u8d77\u7ec4\u6210\u7684\u3002 RSA \u7b97\u6cd5\u7684\u53ef\u9760\u6027\u7531\u6781\u5927\u6574\u6570\u56e0\u6570\u5206\u89e3\u7684\u96be\u5ea6\u51b3\u5b9a\u3002\u6362\u8a00\u4e4b\uff0c\u5bf9\u4e00\u6781\u5927\u6574\u6570\u505a\u56e0\u6570\u5206\u89e3\u6108\u56f0\u96be\uff0cRSA \u7b97\u6cd5\u6108\u53ef\u9760\u3002\u5047\u5982\u6709\u4eba\u627e\u5230\u4e00\u79cd\u5feb\u901f\u56e0\u6570\u5206\u89e3\u7684\u7b97\u6cd5\u7684\u8bdd\uff0c\u90a3\u4e48\u7528 RSA \u52a0\u5bc6\u7684\u4fe1\u606f\u7684\u53ef\u9760\u6027\u5c31\u80af\u5b9a\u4f1a\u6781\u5ea6\u4e0b\u964d\u3002\u4f46\u627e\u5230\u8fd9\u6837\u7684\u7b97\u6cd5\u7684\u53ef\u80fd\u6027\u662f\u975e\u5e38\u5c0f\u7684\u3002\u5982\u4eca\uff0c\u53ea\u6709\u77ed\u7684 RSA \u5bc6\u94a5\u624d\u53ef\u80fd\u88ab\u5f3a\u529b\u65b9\u5f0f\u89e3\u7834\u3002\u5230 2017 \u5e74\u4e3a\u6b62\uff0c\u8fd8\u6ca1\u6709\u4efb\u4f55\u53ef\u9760\u7684\u653b\u51fb RSA \u7b97\u6cd5\u7684\u65b9\u5f0f\u3002 \u57fa\u672c\u539f\u7406 \u00b6 \u516c\u94a5\u4e0e\u79c1\u94a5\u7684\u4ea7\u751f \u00b6 \u968f\u673a\u9009\u62e9\u4e24\u4e2a\u4e0d\u540c\u5927\u8d28\u6570 p p \u548c q q \uff0c\u8ba1\u7b97 N = p \\times q N = p \\times q \u6839\u636e\u6b27\u62c9\u51fd\u6570\uff0c\u6c42\u5f97 \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \u9009\u62e9\u4e00\u4e2a\u5c0f\u4e8e \\varphi (N) \\varphi (N) \u7684\u6574\u6570 e e \uff0c\u4f7f e e \u548c \\varphi (N) \\varphi (N) \u4e92\u8d28\u3002\u5e76\u6c42\u5f97 e e \u5173\u4e8e \\varphi (N) \\varphi (N) \u7684\u6a21\u53cd\u5143\u7d20\uff0c\u547d\u540d\u4e3a d d \uff0c\u6709 ed\\equiv 1 \\pmod {\\varphi (N)} ed\\equiv 1 \\pmod {\\varphi (N)} \u5c06 p\u200b p\u200b \u548c q\u200b q\u200b \u7684\u8bb0\u5f55\u9500\u6bc1 \u6b64\u65f6\uff0c (N,e) (N,e) \u662f\u516c\u94a5\uff0c (N,d) (N,d) \u662f\u79c1\u94a5\u3002 \u6d88\u606f\u52a0\u5bc6 \u00b6 \u9996\u5148\u9700\u8981\u5c06\u6d88\u606f \u4ee5\u4e00\u4e2a\u53cc\u65b9\u7ea6\u5b9a\u597d\u7684\u683c\u5f0f\u8f6c\u5316\u4e3a\u4e00\u4e2a\u5c0f\u4e8e N N \uff0c\u4e14\u4e0e N N \u4e92\u8d28\u7684\u6574\u6570 m m \u3002\u5982\u679c\u6d88\u606f\u592a\u957f\uff0c\u53ef\u4ee5\u5c06\u6d88\u606f\u5206\u4e3a\u51e0\u6bb5\uff0c\u8fd9\u4e5f\u5c31\u662f\u6211\u4eec\u6240\u8bf4\u7684\u5757\u52a0\u5bc6\uff0c\u540e\u5bf9\u4e8e\u6bcf\u4e00\u90e8\u5206\u5229\u7528\u5982\u4e0b\u516c\u5f0f\u52a0\u5bc6\uff1a m^{e}\\equiv c\\pmod N m^{e}\\equiv c\\pmod N \u6d88\u606f\u89e3\u5bc6 \u00b6 \u5229\u7528\u5bc6\u94a5 d\u200b d\u200b \u8fdb\u884c\u89e3\u5bc6\u3002 c^{d}\\equiv m\\pmod N c^{d}\\equiv m\\pmod N \u6b63\u786e\u6027\u8bc1\u660e \u00b6 \u5373\u6211\u4eec\u8981\u8bc1 m^{ed} \\equiv m \\bmod N m^{ed} \\equiv m \\bmod N \uff0c\u5df2\u77e5 ed \\equiv 1 \\bmod \\phi(N) ed \\equiv 1 \\bmod \\phi(N) \uff0c\u90a3\u4e48 ed=k\\phi(N)+1 ed=k\\phi(N)+1 \uff0c\u5373\u9700\u8981\u8bc1\u660e m^{k\\phi(N)+1} \\equiv m \\bmod N m^{k\\phi(N)+1} \\equiv m \\bmod N \u8fd9\u91cc\u6211\u4eec\u5206\u4e24\u79cd\u60c5\u51b5\u8bc1\u660e \u7b2c\u4e00\u79cd\u60c5\u51b5 gcd(m,N)=1\u200b gcd(m,N)=1\u200b \uff0c\u90a3\u4e48 m^{\\phi(N)} \\equiv 1 \\bmod N\u200b m^{\\phi(N)} \\equiv 1 \\bmod N\u200b \uff0c\u56e0\u6b64\u539f\u5f0f\u6210\u7acb\u3002 \u7b2c\u4e8c\u79cd\u60c5\u51b5 gcd(m,N)\\neq 1 gcd(m,N)\\neq 1 \uff0c\u90a3\u4e48 m m \u5fc5\u7136\u662f p p \u6216\u8005 q q \u7684\u500d\u6570\uff0c\u5e76\u4e14 n=m n=m \u5c0f\u4e8e N N \u3002\u6211\u4eec\u5047\u8bbe m=xp m=xp \u90a3\u4e48 x x \u5fc5\u7136\u5c0f\u4e8e q q \uff0c\u53c8\u7531\u4e8e q q \u662f\u7d20\u6570\u3002\u90a3\u4e48 m^{\\phi(q)} \\equiv 1 \\bmod q m^{\\phi(q)} \\equiv 1 \\bmod q \u8fdb\u800c m^{k\\phi(N)}=m^{k(p-1)(q-1)}=(m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)}=m^{k(p-1)(q-1)}=(m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q \u90a3\u4e48 m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqm \u8fdb\u800c m^{k\\phi(N)+1}=m+uqxp=m+uxN m^{k\\phi(N)+1}=m+uqxp=m+uxN \u6240\u4ee5\u539f\u5f0f\u6210\u7acb\u3002 \u57fa\u672c\u5de5\u5177 \u00b6 RSAtool \u00b6 \u5b89\u88c5 git clone https://github.com/ius/rsatool.git cd rsatool python rsatool.py -h \u751f\u6210\u79c1\u94a5 python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321 RSA Converter \u00b6 \u6839\u636e\u7ed9\u5b9a\u5bc6\u94a5\u5bf9\uff0c\u751f\u6210 pem \u6587\u4ef6 \u6839\u636e n n \uff0c e e \uff0c d d \u5f97\u51fa p p \uff0c q q openssl \u00b6 \u67e5\u770b\u516c\u94a5\u6587\u4ef6 openssl rsa -pubin -in pubkey.pem -text -modulus \u89e3\u5bc6 rsautl -decrypt -inkey private.pem -in flag.enc -out flag \u66f4\u52a0\u5177\u4f53\u7684\u7ec6\u8282\u8bf7\u53c2\u8003 openssl --help \u3002 \u5206\u89e3\u6574\u6570\u5de5\u5177 \u00b6 \u7f51\u7ad9\u5206\u89e3\uff0c factor.db \u547d\u4ee4\u884c\u5206\u89e3\uff0c factordb-pycli \uff0c\u501f\u7528 factordb \u6570\u636e\u5e93\u3002 yafu python \u5e93 \u00b6 primefac \u00b6 \u6574\u6570\u5206\u89e3\u5e93\uff0c\u5305\u542b\u4e86\u5f88\u591a\u6574\u6570\u5206\u89e3\u7684\u7b97\u6cd5\u3002 gmpy \u00b6 gmpy.root(a, b) \uff0c\u8fd4\u56de\u4e00\u4e2a\u5143\u7ec4 (x, y) \uff0c\u5176\u4e2d x \u4e3a a \u5f00 b \u6b21\u65b9\u7684\u503c\uff0c y \u662f\u5224\u65ad x \u662f\u5426\u4e3a\u6574\u6570\u7684\u5e03\u5c14\u578b\u53d8\u91cf gmpy2 \u00b6 \u5b89\u88c5\u65f6\uff0c\u53ef\u80fd\u4f1a\u9700\u8981\u81ea\u5df1\u53e6\u884c\u5b89\u88c5 mfpr \u4e0e mpc \u5e93\u3002 gmpy2.iroot(a, b) \uff0c\u7c7b\u4f3c\u4e8e gmpy.root(a,b) pycrypto \u00b6 \u5b89\u88c5 sudo pip install pycrypto \u4f7f\u7528 import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 msg = 'crypto here' p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) key = PKCS1_v1_5 . new ( privatekey ) msg = key . decrypt ( enc . decode ( 'base64' ), e ) Jarvis OJ - Basic - veryeasyRSA \u00b6 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 \u6c42 d = \u8bf7\u63d0\u4ea4 PCTF{d} \u76f4\u63a5\u6839\u636e ed\\equiv 1 \\pmod{\\varphi (N)} ed\\equiv 1 \\pmod{\\varphi (N)} \uff0c\u5176\u4e2d \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \uff0c\u53ef\u5f97 d d \u3002 import gmpy2 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phin = ( p - 1 ) * ( q - 1 ) print gmpy2 . invert ( e , phin ) \u279c Jarvis OJ-Basic-veryeasyRSA git: ( master ) \u2717 python exp.py 19178568796155560423675975774142829153827883709027717723363077606260717434369 2018 CodeGate CTF Rsababy \u00b6 \u7a0b\u5e8f\u5c31\u662f\u4e00\u4e2a\u7b80\u5355\u7684 RSA\uff0c\u4e0d\u8fc7\u7a0b\u5e8f\u8fd8\u751f\u6210\u4e86\u4e24\u4e2a\u5947\u602a\u7684\u6570 e = 65537 n = p * q pi_n = ( p - 1 ) * ( q - 1 ) d = mulinv ( e , pi_n ) h = ( d + p ) ^ ( d - p ) g = d * ( p - 0xdeadbeef ) \u6240\u4ee5\uff0c\u95ee\u9898\u5e94\u8be5\u51fa\u81ea\u8fd9\u91cc\uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u4ece\u6b64\u4e0b\u624b\uff0c\u4e0d\u653e\u8fd9\u91cc\u5148\u5047\u8bbe const = 0xdeadbeef \u3002\u90a3\u4e48 eg = ed * (p-const) eg = ed * (p-const) \u8fdb\u800c\uff0c\u6839\u636e RSA \u53ef\u77e5 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n \u6240\u4ee5 2^{p-1} = 2^{eg} * 2^{const-1}+kn 2^{p-1} = 2^{eg} * 2^{const-1}+kn \u800c\u4e0e\u6b64\u540c\u65f6\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff0c\u6211\u4eec\u77e5\u9053 2^{p-1} \\equiv 1 \\pmod p 2^{p-1} \\equiv 1 \\pmod p \u6240\u4ee5 p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{p-1}-1 | 2^{eg+const-1}-1+kn \u8fdb\u800c p|2^{eg+const-1}-1 p|2^{eg+const-1}-1 \u6240\u4ee5 p|gcd(2^{eg+const-1}-1,n) p|gcd(2^{eg+const-1}-1,n) \u56e0\u6b64\uff0c\u4ee3\u7801\u5982\u4e0b tmp = gmpy2 . powmod ( 2 , e * g + const - 1 , n ) - 1 p = gmpy2 . gcd ( tmp , n ) q = n / p phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) plain = gmpy2 . powmod ( data , d , n ) print hex ( plain )[ 2 :] . decode ( 'hex' ) 2018 \u56fd\u5bb6\u5b89\u5168\u5468 pure math \u00b6 \u9898\u76ee\u7684\u57fa\u672c\u63cf\u8ff0\u662f\u8fd9\u4e2a\u6837\u5b50\u7684 1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279 5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Now, what\u2019s the FLAG??? \u6211\u4eec\u7684\u76ee\u7684\u57fa\u672c\u4e0a\u5c31\u662f\u6c42\u5f97 FLAG\uff0c\u90a3\u4e48\u600e\u4e48\u505a\u5462?\u8fd9\u4e2a\u9898\u76ee\u9700\u8981\u6211\u4eec\u5177\u6709\u8f83\u597d\u7684\u6570\u8bba\u529f\u5e95\u3002 \u6839\u636e\u9898\u76ee\u4e2d\u8fd9\u6837\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe p p \uff0c q q \u90fd\u662f\u5927\u7d20\u6570\uff0c\u90a3\u4e48 p^{q-1} \\equiv 1\\bmod q p^{q-1} \\equiv 1\\bmod q \u90a3\u4e48 p^{q} \\equiv p \\bmod pq p^{q} \\equiv p \\bmod pq \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6839\u636e 3\uff09\u77e5\u9053 p^q+q^p \\equiv p+q \\bmod pq p^q+q^p \\equiv p+q \\bmod pq \u800c p+q p+q \u53c8\u663e\u7136\u5c0f\u4e8e pq pq \uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u77e5\u9053 p+q p+q \u7684\u6570\u503c\u3002 \u8fdb\u4e00\u6b65\uff0c\u6211\u4eec\u5047\u8bbe1\uff09\uff0c2\uff09\uff0c3\uff09\uff0c4\uff09\uff0c5\uff09\u5bf9\u5e94\u7684\u503c\u5206\u522b\u4e3a x_1 x_1 , x_2 x_2 , x_3 x_3 , x_4 x_4 , x_5 x_5 \u5219 \u6839\u636e4\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053 (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq \u53c8\u56e0\u4e3a1\uff09\u548c 2\uff09\uff0c\u5219 p^pp \\equiv px_1\\bmod pq p^pp \\equiv px_1\\bmod pq q^qq \\equiv qx_2 \\bmod pq q^qq \\equiv qx_2 \\bmod pq \u56e0\u6b64 px_1+qx_2 \\equiv x_4 \\bmod pq px_1+qx_2 \\equiv x_4 \\bmod pq \u6839\u636e x_1 x_1 \u548c x_2 x_2 \u7684\u6c42\u5f97\u65b9\u5f0f\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\u8fd9\u91cc\u4e5f\u662f\u7b49\u53f7\uff0c\u56e0\u6b64\u6211\u4eec\u5f97\u5230\u4e86\u4e00\u4e2a\u4e8c\u5143\u4e00\u6b21\u65b9\u7a0b\u7ec4\uff0c\u76f4\u63a5\u6c42\u89e3\u5373\u53ef\u3002 import gmpy2 x1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 x2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 p_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 x4 = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279 if ( x4 - x1 * p_q ) % ( x2 - x1 ) == 0 : print 'True' q = ( x4 - x1 * p_q ) / ( x2 - x1 ) print q p = p_q - q c = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 31337 , phin ) flag = gmpy2 . powmod ( c , d , p * q ) flag = hex ( flag )[ 2 :] print flag . decode ( 'hex' ) flag \u5982\u4e0b \u279c 2018 -\u56fd\u5bb6\u5b89\u5168\u5468\u7b2c\u4e00\u573a-puremath git: ( master ) \u2717 python exp.py True 7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417 flag { 6a66b8d5-6047-4299-a48e-4c4d1f874d12 } 2018 Pwnhub LHY \u00b6 \u9996\u5148\u5206\u6790\u8fd9\u6bb5\u4ee3\u7801 assert gmpy . is_prime ( y ) ** 2016 + gmpy . is_prime ( x + 1 ) ** 2017 + ( ( x ** 2 - 1 ) ** 2 % ( 2 * x * y - 1 ) + 2 ) ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 \u7531\u4e8e gmpy.is_prime \u8981\u4e48\u8fd4\u56de1\uff0c\u8981\u4e48\u8fd4\u56de 0\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u8bd5\u51fa\u6765 y \u662f\u7d20\u6570\uff0c x+1 \u4e5f\u662f\u7d20\u6570\uff0c\u5e76\u4e14 (x^2-1)^2\\equiv 0 \\bmod (2xy-1) (x^2-1)^2\\equiv 0 \\bmod (2xy-1) \u4e3a\u4e86\u5f0f\u5b50\u80fd\u591f\u6574\u9664\uff0c\u731c\u6d4b x=2y x=2y \u3002 \u4e8e\u662f\uff0c\u5bf9\u4e8e\u4e0b\u9762\u7684\u5185\u5bb9 p = gmpy . next_prime ( x ** 3 + y ** 3 ) q = gmpy . next_prime ( x ** 2 * y + y ** 2 * x ) n = p * q phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( 0x10001 , phi ) enc = pow ( bytes_to_long ( flag ), 0x10001 , n ) print 'n =' , n print 'enc =' , enc p p \u548c q q \u81ea\u7136\u4e3a p=next\\_prime(9y^3) p=next\\_prime(9y^3) q=next\\_prime(6y^3) q=next\\_prime(6y^3) \u6839\u636e\u7d20\u6570\u7684\u95f4\u9694\uff0c\u53ef\u4ee5\u77e5\u9053 p p \u548c q q \u6700\u591a\u6bd4\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5927\u4e00\u70b9\uff0c\u8fd9\u91cc\u4e00\u822c\u4e0d\u4f1a\u8d85\u8fc7 1000 1000 \u3002 \u90a3\u4e48 n \\geq 54y^6 n \\geq 54y^6 \u6240\u4ee5\u6211\u4eec\u77e5\u9053\u4e86 y y \u7684\u4e0a\u754c\uff0c\u800c\u5bf9\u4e8e y y \u7684\u4e0b\u754c\u5176\u5b9e\u4e5f\u4e0d\u4f1a\u79bb\u4e0a\u754c\u592a\u8fdc\uff0c\u6211\u4eec\u5927\u6982\u51cf\u4e2a\u51e0\u5341\u4e07\u3002\u8fdb\u800c\uff0c\u6211\u4eec\u5229\u7528\u4e8c\u5206\u67e5\u627e\u7684\u65b9\u5f0f\u6765\u5bfb\u627e p p \u548c q q \uff0c\u5982\u4e0b import gmpy2 tmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 print gmpy2 . iroot ( tmp , 2018 ) print gmpy2 . iroot ( tmp - 1 , 2018 ) print gmpy2 . iroot ( tmp - 2 , 2018 ) n = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741 y = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000 L y = gmpy2 . next_prime ( y ) enc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612 end = gmpy2 . iroot ( n / 54 , 6 )[ 0 ] beg = end - 2000000 mid = 1 while beg < end : mid = ( beg + end ) / 2 if gmpy2 . is_prime ( mid ) != 1 : mid = gmpy2 . next_prime ( mid ) p = gmpy2 . next_prime ( 9 * mid ** 3 ) q = gmpy2 . next_prime ( 6 * mid ** 3 ) n1 = p * q if n1 == n : print p , q phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 0x10001 , phin ) m = gmpy2 . powmod ( enc , d , n ) print hex ( m )[ 2 :] . strip ( 'L' ) . decode ( 'hex' ) print 'ok' exit ( 0 ) elif n1 < n : beg = mid else : end = mid print beg , end","title":"Rsa theory zh"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#rsa","text":"RSA \u52a0\u5bc6\u7b97\u6cd5\u662f\u4e00\u79cd\u975e\u5bf9\u79f0\u52a0\u5bc6\u7b97\u6cd5\u3002\u5728\u516c\u5f00\u5bc6\u94a5\u52a0\u5bc6\u548c\u7535\u5b50\u5546\u4e1a\u4e2d RSA \u88ab\u5e7f\u6cdb\u4f7f\u7528\u3002RSA \u662f 1977 \u5e74\u7531\u7f57\u7eb3\u5fb7\u00b7\u674e\u7ef4\u65af\u7279\uff08Ron Rivest\uff09\u3001\u963f\u8fea\u00b7\u8428\u83ab\u5c14\uff08Adi Shamir\uff09\u548c\u4f26\u7eb3\u5fb7\u00b7\u963f\u5fb7\u66fc\uff08Leonard Adleman\uff09\u4e00\u8d77\u63d0\u51fa\u7684\u3002RSA \u5c31\u662f\u4ed6\u4eec\u4e09\u4eba\u59d3\u6c0f\u5f00\u5934\u5b57\u6bcd\u62fc\u5728\u4e00\u8d77\u7ec4\u6210\u7684\u3002 RSA \u7b97\u6cd5\u7684\u53ef\u9760\u6027\u7531\u6781\u5927\u6574\u6570\u56e0\u6570\u5206\u89e3\u7684\u96be\u5ea6\u51b3\u5b9a\u3002\u6362\u8a00\u4e4b\uff0c\u5bf9\u4e00\u6781\u5927\u6574\u6570\u505a\u56e0\u6570\u5206\u89e3\u6108\u56f0\u96be\uff0cRSA \u7b97\u6cd5\u6108\u53ef\u9760\u3002\u5047\u5982\u6709\u4eba\u627e\u5230\u4e00\u79cd\u5feb\u901f\u56e0\u6570\u5206\u89e3\u7684\u7b97\u6cd5\u7684\u8bdd\uff0c\u90a3\u4e48\u7528 RSA \u52a0\u5bc6\u7684\u4fe1\u606f\u7684\u53ef\u9760\u6027\u5c31\u80af\u5b9a\u4f1a\u6781\u5ea6\u4e0b\u964d\u3002\u4f46\u627e\u5230\u8fd9\u6837\u7684\u7b97\u6cd5\u7684\u53ef\u80fd\u6027\u662f\u975e\u5e38\u5c0f\u7684\u3002\u5982\u4eca\uff0c\u53ea\u6709\u77ed\u7684 RSA \u5bc6\u94a5\u624d\u53ef\u80fd\u88ab\u5f3a\u529b\u65b9\u5f0f\u89e3\u7834\u3002\u5230 2017 \u5e74\u4e3a\u6b62\uff0c\u8fd8\u6ca1\u6709\u4efb\u4f55\u53ef\u9760\u7684\u653b\u51fb RSA \u7b97\u6cd5\u7684\u65b9\u5f0f\u3002","title":"RSA \u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#_1","text":"","title":"\u57fa\u672c\u539f\u7406"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#_2","text":"\u968f\u673a\u9009\u62e9\u4e24\u4e2a\u4e0d\u540c\u5927\u8d28\u6570 p p \u548c q q \uff0c\u8ba1\u7b97 N = p \\times q N = p \\times q \u6839\u636e\u6b27\u62c9\u51fd\u6570\uff0c\u6c42\u5f97 \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \u9009\u62e9\u4e00\u4e2a\u5c0f\u4e8e \\varphi (N) \\varphi (N) \u7684\u6574\u6570 e e \uff0c\u4f7f e e \u548c \\varphi (N) \\varphi (N) \u4e92\u8d28\u3002\u5e76\u6c42\u5f97 e e \u5173\u4e8e \\varphi (N) \\varphi (N) \u7684\u6a21\u53cd\u5143\u7d20\uff0c\u547d\u540d\u4e3a d d \uff0c\u6709 ed\\equiv 1 \\pmod {\\varphi (N)} ed\\equiv 1 \\pmod {\\varphi (N)} \u5c06 p\u200b p\u200b \u548c q\u200b q\u200b \u7684\u8bb0\u5f55\u9500\u6bc1 \u6b64\u65f6\uff0c (N,e) (N,e) \u662f\u516c\u94a5\uff0c (N,d) (N,d) \u662f\u79c1\u94a5\u3002","title":"\u516c\u94a5\u4e0e\u79c1\u94a5\u7684\u4ea7\u751f"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#_3","text":"\u9996\u5148\u9700\u8981\u5c06\u6d88\u606f \u4ee5\u4e00\u4e2a\u53cc\u65b9\u7ea6\u5b9a\u597d\u7684\u683c\u5f0f\u8f6c\u5316\u4e3a\u4e00\u4e2a\u5c0f\u4e8e N N \uff0c\u4e14\u4e0e N N \u4e92\u8d28\u7684\u6574\u6570 m m \u3002\u5982\u679c\u6d88\u606f\u592a\u957f\uff0c\u53ef\u4ee5\u5c06\u6d88\u606f\u5206\u4e3a\u51e0\u6bb5\uff0c\u8fd9\u4e5f\u5c31\u662f\u6211\u4eec\u6240\u8bf4\u7684\u5757\u52a0\u5bc6\uff0c\u540e\u5bf9\u4e8e\u6bcf\u4e00\u90e8\u5206\u5229\u7528\u5982\u4e0b\u516c\u5f0f\u52a0\u5bc6\uff1a m^{e}\\equiv c\\pmod N m^{e}\\equiv c\\pmod N","title":"\u6d88\u606f\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#_4","text":"\u5229\u7528\u5bc6\u94a5 d\u200b d\u200b \u8fdb\u884c\u89e3\u5bc6\u3002 c^{d}\\equiv m\\pmod N c^{d}\\equiv m\\pmod N","title":"\u6d88\u606f\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#_5","text":"\u5373\u6211\u4eec\u8981\u8bc1 m^{ed} \\equiv m \\bmod N m^{ed} \\equiv m \\bmod N \uff0c\u5df2\u77e5 ed \\equiv 1 \\bmod \\phi(N) ed \\equiv 1 \\bmod \\phi(N) \uff0c\u90a3\u4e48 ed=k\\phi(N)+1 ed=k\\phi(N)+1 \uff0c\u5373\u9700\u8981\u8bc1\u660e m^{k\\phi(N)+1} \\equiv m \\bmod N m^{k\\phi(N)+1} \\equiv m \\bmod N \u8fd9\u91cc\u6211\u4eec\u5206\u4e24\u79cd\u60c5\u51b5\u8bc1\u660e \u7b2c\u4e00\u79cd\u60c5\u51b5 gcd(m,N)=1\u200b gcd(m,N)=1\u200b \uff0c\u90a3\u4e48 m^{\\phi(N)} \\equiv 1 \\bmod N\u200b m^{\\phi(N)} \\equiv 1 \\bmod N\u200b \uff0c\u56e0\u6b64\u539f\u5f0f\u6210\u7acb\u3002 \u7b2c\u4e8c\u79cd\u60c5\u51b5 gcd(m,N)\\neq 1 gcd(m,N)\\neq 1 \uff0c\u90a3\u4e48 m m \u5fc5\u7136\u662f p p \u6216\u8005 q q \u7684\u500d\u6570\uff0c\u5e76\u4e14 n=m n=m \u5c0f\u4e8e N N \u3002\u6211\u4eec\u5047\u8bbe m=xp m=xp \u90a3\u4e48 x x \u5fc5\u7136\u5c0f\u4e8e q q \uff0c\u53c8\u7531\u4e8e q q \u662f\u7d20\u6570\u3002\u90a3\u4e48 m^{\\phi(q)} \\equiv 1 \\bmod q m^{\\phi(q)} \\equiv 1 \\bmod q \u8fdb\u800c m^{k\\phi(N)}=m^{k(p-1)(q-1)}=(m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)}=m^{k(p-1)(q-1)}=(m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q \u90a3\u4e48 m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqm \u8fdb\u800c m^{k\\phi(N)+1}=m+uqxp=m+uxN m^{k\\phi(N)+1}=m+uqxp=m+uxN \u6240\u4ee5\u539f\u5f0f\u6210\u7acb\u3002","title":"\u6b63\u786e\u6027\u8bc1\u660e"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#_6","text":"","title":"\u57fa\u672c\u5de5\u5177"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#rsatool","text":"\u5b89\u88c5 git clone https://github.com/ius/rsatool.git cd rsatool python rsatool.py -h \u751f\u6210\u79c1\u94a5 python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321","title":"RSAtool"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#rsa-converter","text":"\u6839\u636e\u7ed9\u5b9a\u5bc6\u94a5\u5bf9\uff0c\u751f\u6210 pem \u6587\u4ef6 \u6839\u636e n n \uff0c e e \uff0c d d \u5f97\u51fa p p \uff0c q q","title":"RSA Converter"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#openssl","text":"\u67e5\u770b\u516c\u94a5\u6587\u4ef6 openssl rsa -pubin -in pubkey.pem -text -modulus \u89e3\u5bc6 rsautl -decrypt -inkey private.pem -in flag.enc -out flag \u66f4\u52a0\u5177\u4f53\u7684\u7ec6\u8282\u8bf7\u53c2\u8003 openssl --help \u3002","title":"openssl"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#_7","text":"\u7f51\u7ad9\u5206\u89e3\uff0c factor.db \u547d\u4ee4\u884c\u5206\u89e3\uff0c factordb-pycli \uff0c\u501f\u7528 factordb \u6570\u636e\u5e93\u3002 yafu","title":"\u5206\u89e3\u6574\u6570\u5de5\u5177"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#python","text":"","title":"python \u5e93"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#primefac","text":"\u6574\u6570\u5206\u89e3\u5e93\uff0c\u5305\u542b\u4e86\u5f88\u591a\u6574\u6570\u5206\u89e3\u7684\u7b97\u6cd5\u3002","title":"primefac"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#gmpy","text":"gmpy.root(a, b) \uff0c\u8fd4\u56de\u4e00\u4e2a\u5143\u7ec4 (x, y) \uff0c\u5176\u4e2d x \u4e3a a \u5f00 b \u6b21\u65b9\u7684\u503c\uff0c y \u662f\u5224\u65ad x \u662f\u5426\u4e3a\u6574\u6570\u7684\u5e03\u5c14\u578b\u53d8\u91cf","title":"gmpy"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#gmpy2","text":"\u5b89\u88c5\u65f6\uff0c\u53ef\u80fd\u4f1a\u9700\u8981\u81ea\u5df1\u53e6\u884c\u5b89\u88c5 mfpr \u4e0e mpc \u5e93\u3002 gmpy2.iroot(a, b) \uff0c\u7c7b\u4f3c\u4e8e gmpy.root(a,b)","title":"gmpy2"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#pycrypto","text":"\u5b89\u88c5 sudo pip install pycrypto \u4f7f\u7528 import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 msg = 'crypto here' p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) key = PKCS1_v1_5 . new ( privatekey ) msg = key . decrypt ( enc . decode ( 'base64' ), e )","title":"pycrypto"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#jarvis-oj-basic-veryeasyrsa","text":"p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 \u6c42 d = \u8bf7\u63d0\u4ea4 PCTF{d} \u76f4\u63a5\u6839\u636e ed\\equiv 1 \\pmod{\\varphi (N)} ed\\equiv 1 \\pmod{\\varphi (N)} \uff0c\u5176\u4e2d \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \uff0c\u53ef\u5f97 d d \u3002 import gmpy2 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phin = ( p - 1 ) * ( q - 1 ) print gmpy2 . invert ( e , phin ) \u279c Jarvis OJ-Basic-veryeasyRSA git: ( master ) \u2717 python exp.py 19178568796155560423675975774142829153827883709027717723363077606260717434369","title":"Jarvis OJ - Basic - veryeasyRSA"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#2018-codegate-ctf-rsababy","text":"\u7a0b\u5e8f\u5c31\u662f\u4e00\u4e2a\u7b80\u5355\u7684 RSA\uff0c\u4e0d\u8fc7\u7a0b\u5e8f\u8fd8\u751f\u6210\u4e86\u4e24\u4e2a\u5947\u602a\u7684\u6570 e = 65537 n = p * q pi_n = ( p - 1 ) * ( q - 1 ) d = mulinv ( e , pi_n ) h = ( d + p ) ^ ( d - p ) g = d * ( p - 0xdeadbeef ) \u6240\u4ee5\uff0c\u95ee\u9898\u5e94\u8be5\u51fa\u81ea\u8fd9\u91cc\uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u4ece\u6b64\u4e0b\u624b\uff0c\u4e0d\u653e\u8fd9\u91cc\u5148\u5047\u8bbe const = 0xdeadbeef \u3002\u90a3\u4e48 eg = ed * (p-const) eg = ed * (p-const) \u8fdb\u800c\uff0c\u6839\u636e RSA \u53ef\u77e5 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n \u6240\u4ee5 2^{p-1} = 2^{eg} * 2^{const-1}+kn 2^{p-1} = 2^{eg} * 2^{const-1}+kn \u800c\u4e0e\u6b64\u540c\u65f6\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff0c\u6211\u4eec\u77e5\u9053 2^{p-1} \\equiv 1 \\pmod p 2^{p-1} \\equiv 1 \\pmod p \u6240\u4ee5 p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{p-1}-1 | 2^{eg+const-1}-1+kn \u8fdb\u800c p|2^{eg+const-1}-1 p|2^{eg+const-1}-1 \u6240\u4ee5 p|gcd(2^{eg+const-1}-1,n) p|gcd(2^{eg+const-1}-1,n) \u56e0\u6b64\uff0c\u4ee3\u7801\u5982\u4e0b tmp = gmpy2 . powmod ( 2 , e * g + const - 1 , n ) - 1 p = gmpy2 . gcd ( tmp , n ) q = n / p phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) plain = gmpy2 . powmod ( data , d , n ) print hex ( plain )[ 2 :] . decode ( 'hex' )","title":"2018 CodeGate CTF Rsababy"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#2018-pure-math","text":"\u9898\u76ee\u7684\u57fa\u672c\u63cf\u8ff0\u662f\u8fd9\u4e2a\u6837\u5b50\u7684 1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279 5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Now, what\u2019s the FLAG??? \u6211\u4eec\u7684\u76ee\u7684\u57fa\u672c\u4e0a\u5c31\u662f\u6c42\u5f97 FLAG\uff0c\u90a3\u4e48\u600e\u4e48\u505a\u5462?\u8fd9\u4e2a\u9898\u76ee\u9700\u8981\u6211\u4eec\u5177\u6709\u8f83\u597d\u7684\u6570\u8bba\u529f\u5e95\u3002 \u6839\u636e\u9898\u76ee\u4e2d\u8fd9\u6837\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe p p \uff0c q q \u90fd\u662f\u5927\u7d20\u6570\uff0c\u90a3\u4e48 p^{q-1} \\equiv 1\\bmod q p^{q-1} \\equiv 1\\bmod q \u90a3\u4e48 p^{q} \\equiv p \\bmod pq p^{q} \\equiv p \\bmod pq \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6839\u636e 3\uff09\u77e5\u9053 p^q+q^p \\equiv p+q \\bmod pq p^q+q^p \\equiv p+q \\bmod pq \u800c p+q p+q \u53c8\u663e\u7136\u5c0f\u4e8e pq pq \uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u77e5\u9053 p+q p+q \u7684\u6570\u503c\u3002 \u8fdb\u4e00\u6b65\uff0c\u6211\u4eec\u5047\u8bbe1\uff09\uff0c2\uff09\uff0c3\uff09\uff0c4\uff09\uff0c5\uff09\u5bf9\u5e94\u7684\u503c\u5206\u522b\u4e3a x_1 x_1 , x_2 x_2 , x_3 x_3 , x_4 x_4 , x_5 x_5 \u5219 \u6839\u636e4\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053 (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq \u53c8\u56e0\u4e3a1\uff09\u548c 2\uff09\uff0c\u5219 p^pp \\equiv px_1\\bmod pq p^pp \\equiv px_1\\bmod pq q^qq \\equiv qx_2 \\bmod pq q^qq \\equiv qx_2 \\bmod pq \u56e0\u6b64 px_1+qx_2 \\equiv x_4 \\bmod pq px_1+qx_2 \\equiv x_4 \\bmod pq \u6839\u636e x_1 x_1 \u548c x_2 x_2 \u7684\u6c42\u5f97\u65b9\u5f0f\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\u8fd9\u91cc\u4e5f\u662f\u7b49\u53f7\uff0c\u56e0\u6b64\u6211\u4eec\u5f97\u5230\u4e86\u4e00\u4e2a\u4e8c\u5143\u4e00\u6b21\u65b9\u7a0b\u7ec4\uff0c\u76f4\u63a5\u6c42\u89e3\u5373\u53ef\u3002 import gmpy2 x1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 x2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 p_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 x4 = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279 if ( x4 - x1 * p_q ) % ( x2 - x1 ) == 0 : print 'True' q = ( x4 - x1 * p_q ) / ( x2 - x1 ) print q p = p_q - q c = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 31337 , phin ) flag = gmpy2 . powmod ( c , d , p * q ) flag = hex ( flag )[ 2 :] print flag . decode ( 'hex' ) flag \u5982\u4e0b \u279c 2018 -\u56fd\u5bb6\u5b89\u5168\u5468\u7b2c\u4e00\u573a-puremath git: ( master ) \u2717 python exp.py True 7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417 flag { 6a66b8d5-6047-4299-a48e-4c4d1f874d12 }","title":"2018 \u56fd\u5bb6\u5b89\u5168\u5468 pure math"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory-zh/#2018-pwnhub-lhy","text":"\u9996\u5148\u5206\u6790\u8fd9\u6bb5\u4ee3\u7801 assert gmpy . is_prime ( y ) ** 2016 + gmpy . is_prime ( x + 1 ) ** 2017 + ( ( x ** 2 - 1 ) ** 2 % ( 2 * x * y - 1 ) + 2 ) ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 \u7531\u4e8e gmpy.is_prime \u8981\u4e48\u8fd4\u56de1\uff0c\u8981\u4e48\u8fd4\u56de 0\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u8bd5\u51fa\u6765 y \u662f\u7d20\u6570\uff0c x+1 \u4e5f\u662f\u7d20\u6570\uff0c\u5e76\u4e14 (x^2-1)^2\\equiv 0 \\bmod (2xy-1) (x^2-1)^2\\equiv 0 \\bmod (2xy-1) \u4e3a\u4e86\u5f0f\u5b50\u80fd\u591f\u6574\u9664\uff0c\u731c\u6d4b x=2y x=2y \u3002 \u4e8e\u662f\uff0c\u5bf9\u4e8e\u4e0b\u9762\u7684\u5185\u5bb9 p = gmpy . next_prime ( x ** 3 + y ** 3 ) q = gmpy . next_prime ( x ** 2 * y + y ** 2 * x ) n = p * q phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( 0x10001 , phi ) enc = pow ( bytes_to_long ( flag ), 0x10001 , n ) print 'n =' , n print 'enc =' , enc p p \u548c q q \u81ea\u7136\u4e3a p=next\\_prime(9y^3) p=next\\_prime(9y^3) q=next\\_prime(6y^3) q=next\\_prime(6y^3) \u6839\u636e\u7d20\u6570\u7684\u95f4\u9694\uff0c\u53ef\u4ee5\u77e5\u9053 p p \u548c q q \u6700\u591a\u6bd4\u62ec\u53f7\u91cc\u7684\u6570\u5b57\u5927\u4e00\u70b9\uff0c\u8fd9\u91cc\u4e00\u822c\u4e0d\u4f1a\u8d85\u8fc7 1000 1000 \u3002 \u90a3\u4e48 n \\geq 54y^6 n \\geq 54y^6 \u6240\u4ee5\u6211\u4eec\u77e5\u9053\u4e86 y y \u7684\u4e0a\u754c\uff0c\u800c\u5bf9\u4e8e y y \u7684\u4e0b\u754c\u5176\u5b9e\u4e5f\u4e0d\u4f1a\u79bb\u4e0a\u754c\u592a\u8fdc\uff0c\u6211\u4eec\u5927\u6982\u51cf\u4e2a\u51e0\u5341\u4e07\u3002\u8fdb\u800c\uff0c\u6211\u4eec\u5229\u7528\u4e8c\u5206\u67e5\u627e\u7684\u65b9\u5f0f\u6765\u5bfb\u627e p p \u548c q q \uff0c\u5982\u4e0b import gmpy2 tmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 print gmpy2 . iroot ( tmp , 2018 ) print gmpy2 . iroot ( tmp - 1 , 2018 ) print gmpy2 . iroot ( tmp - 2 , 2018 ) n = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741 y = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000 L y = gmpy2 . next_prime ( y ) enc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612 end = gmpy2 . iroot ( n / 54 , 6 )[ 0 ] beg = end - 2000000 mid = 1 while beg < end : mid = ( beg + end ) / 2 if gmpy2 . is_prime ( mid ) != 1 : mid = gmpy2 . next_prime ( mid ) p = gmpy2 . next_prime ( 9 * mid ** 3 ) q = gmpy2 . next_prime ( 6 * mid ** 3 ) n1 = p * q if n1 == n : print p , q phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 0x10001 , phin ) m = gmpy2 . powmod ( enc , d , n ) print hex ( m )[ 2 :] . strip ( 'L' ) . decode ( 'hex' ) print 'ok' exit ( 0 ) elif n1 < n : beg = mid else : end = mid print beg , end","title":"2018 Pwnhub LHY"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/","text":"EN | ZH RSA Introduction \u00b6 The RSA encryption algorithm is an asymmetric encryption algorithm. RSA is widely used in public key encryption and electronic commerce. The RSA was proposed in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA is composed of the letters of the three names of the three of them. The reliability of the RSA algorithm is determined by the difficulty of maximizing integer factorization. In other words, the more difficult it is to factorize a very large integer, the more reliable the RSA algorithm is. If someone finds a fast factorization algorithm, the reliability of the information encrypted with RSA will definitely drop. But the possibility of finding such an algorithm is very small. Today, only short RSA keys can be broken down in a powerful way. As of 2017, there is no reliable way to attack the RSA algorithm. Fundamental \u00b6 Public key and private key generation \u00b6 Randomly select two different large prime numbers p p and q q to calculate N = p \\times q N = p \\times q According to the Euler function, find \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) Select an integer e e that is less than \\varphi (N) \\varphi (N) to make e e and \\varphi (N) \\varphi (N) mutually prime. And ask for e e about the inverse of \\varphi (N) \\varphi (N) , named d d , with ed\\equiv 1 \\pmod {\\varphi (N)} ed\\equiv 1 \\pmod {\\varphi (N)} Destroy records of p p and q q At this point, (N,e) (N,e) is the public key and (N,d) (N,d) is the private key. Message Encryption \u00b6 First, we need to convert the message into an integer m m using an agreed-upon protocol, such than m m is less than N N and m m is coprime to N N . If the message is too long, we can divide the message into several segments, which is what we call block encryption, and then encrypt each part with the following formula: m^{e}\\equiv c\\pmod N m^{e}\\equiv c\\pmod N Message decryption \u00b6 Use the private key d d to decrypt the message. c^{d}\\equiv m\\pmod N c^{d}\\equiv m\\pmod N Verification \u00b6 To verify m^{ed} \\equiv m \\bmod N m^{ed} \\equiv m \\bmod N , we use the fact that ed \\equiv 1 \\bmod \\phi(N) ed \\equiv 1 \\bmod \\phi(N) , then ed=k\\phi(N)+1 ed=k\\phi(N)+1 , it is sufficient to prove that m^{k\\phi(N)+1} \\equiv m \\bmod N m^{k\\phi(N)+1} \\equiv m \\bmod N We will prove it by considering two seperate cases In the first case, gcd(m,N)=1 gcd(m,N)=1 , hence m^{\\phi(N)} \\equiv 1 \\bmod N m^{\\phi(N)} \\equiv 1 \\bmod N , so the original claim is true. In the second case, gcd(m,N)\\neq 1 gcd(m,N)\\neq 1 , so m m must be a multiple of p p or q q , and since n=m n=m is less than N N , we can assume that m = xp m = xp Where x x must be less than q q . Since q q is a prime number, m^{\\phi(q)}\\equiv 1 \\bmod q m^{\\phi(q)}\\equiv 1 \\bmod q m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqxp=m+uxN m^{k\\phi(N)+1}=m+uqxp=m+uxN Hence it is proven to be correct. Basic Tools \u00b6 RSAtool \u00b6 Installation git clone https://github.com/ius/rsatool.git cd rsatool python rsatool.py -h Generate private key Python rsatool.py f FEM private.pem o p q 1234567 7654321 RSA Converter \u00b6 Generate a pem file based on a given key pair Obtain p p and q q from n n , e e , d d openssl \u00b6 View public key file openssl rsa -pubin -in pubkey.pem -text -modulus Decryption rsautl -decrypt -inkey private.pem -in flag.enc -out flag For more specific details, please refer to openssl --help . Decomposition Integer Tool \u00b6 Website decomposition, factor.db Command line decomposition, factordb-pycli , borrowing the factordb database. yafu python\u5e93 \u00b6 primefac \u00b6 The integer decomposition library contains many algorithms for integer decomposition. gmpy \u00b6 gmpy.root(a, b) , returns a tuple (x, y) , where x is the value of a open b power, y is the judgment x whether Boolean variable that is an integer gmpy2 \u00b6 When installing, you may need to install the mfpr and mpc libraries separately. gmpy2.iroot(a, b) , similar to gmpy.root(a,b) pycrypto \u00b6 Installation sudo pip install pycrypto use import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 msg = 'crypto here' p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) key = PKCS1_v1_5 . new ( privatekey ) msg = key . decrypt ( enc . decode ( 'base64' ), e ) Jarvis OJ - Basic - veryeasyRSA \u00b6 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 Find d = Please submit PCTF{d} Using ed\\equiv 1 \\pmod{\\varphi(N)} ed\\equiv 1 \\pmod{\\varphi(N)} , we can obtain d d from \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) . import gmpy2 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phin = ( p - 1 ) * ( q - 1 ) print gmpy2 . invert ( e , phin ) \u279c Jarvis OJ-Basic-veryeasyRSA git: ( master ) \u2717 python exp.py 19178568796155560423675975774142829153827883709027717723363077606260717434369 2018 CodeGate CTF Rsababy \u00b6 The program is a simple RSA, but the program also generates two strange numbers. e = 65537 n = p * q pi_n = ( p - 1 ) * ( q - 1 ) d = mulinv ( e , pi_n ) h = ( d + p ) ^ ( d - p ) g = d * ( p - 0xdeadbeef ) So, the problem should come from here, so let's start with it, let's assume that const = 0xdeadbeef . Then eg = ed * (p-const) eg = ed * (p-const) Furthermore, according to RSA 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n So 2^{p-1} = 2^{eg} * 2^{const-1}+kn 2^{p-1} = 2^{eg} * 2^{const-1}+kn At the same time, according to Fermat's little theorem, we know 2^{p-1} \\equiv 1 \\pmod p 2^{p-1} \\equiv 1 \\pmod p So p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{eg+const-1}-1 p|2^{eg+const-1}-1 p|gcd(2^{eg+const-1}-1,n) p|gcd(2^{eg+const-1}-1,n) Hence the code is as follows tmp = gmpy2 . powmod ( 2 , e * g + const - 1 , n ) - 1 p = gmpy2 . gcd ( tmp , n ) q = n / p Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) plain = gmpy2 . powmod ( data , d , n ) print hex ( plain )[ 2 :] . decode ( 'hex' ) 2018 National Security Week pure math \u00b6 The basic description of the topic is like this 1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279 5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Now, what\u2019s the FLAG??? Our goal is basically to find FLAG, but how can we find it? This question requires us to be more familiar with number theory. From the content of the question, we can assume that p p , q q are both large prime numbers, so p^{q-1} \\equiv 1\\bmod q p^{q-1} \\equiv 1\\bmod q Then p^{q} \\equiv p \\bmod pq p^{q} \\equiv p \\bmod pq From 3), we know that p^q+q^p \\equiv p+q \\bmod pq p^q+q^p \\equiv p+q \\bmod pq And p+q p+q is obviously smaller than pq pq , so we know the value of p+q p+q . We let x_1 x_1 , x_2 x_2 , x_3 x_3 , x_4 x_4 , x_5 x_5 take the values of 1) to 5) respectively. From 4), we have (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq And because of 1) and 2), then p^pp \\equiv px_1\\bmod pq p^pp \\equiv px_1\\bmod pq q^qq \\equiv qx_2 \\bmod pq q^qq \\equiv qx_2 \\bmod pq therefore px_1+qx_2 \\equiv x_4 \\bmod pq px_1+qx_2 \\equiv x_4 \\bmod pq From the way x_1 x_1 and x_2 x_2 are obtained, we know that px_1+qx_2 px_1+qx_2 is also equal to x_4 x_4 , so we get a system of linear equations in two variables and can solve it directly. import gmpy2 x1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 X2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 p_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 x4 = 63112211860889153729 0034062380936348635813582583974823274634293429254290729072907052006074920060749 s729Readingly 97297499258793650 s 8392407 3105245 94071857 531058007 518 764 579 54 0 0 0 0 0 0 0 0 0 0 0 0 if ( x4 - x1 * p_q ) % ( x2 - x1 ) == 0 : print 'True' q = ( x4 - x1 * p_q ) / ( x2 - x1 ) print q p = p_q - q c = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 31337 , phin ) flag = gmpy2 . powmod ( c , d , p * q ) flag = hex ( flag )[ 2 :] print flag . decode ( 'hex' ) Flag is as follows \u279c 2018 -National Security Week first game-puremath git: ( master ) \u2717 python exp.py True 7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417 flag { 6a66b8d5-6047-4299-a48e-4c4d1f874d12 } 2018 Pwnhub LHY \u00b6 First analyze this code assert gmpy . is_prime ( y ) ** 2016 + gmpy . is_prime ( x + 1 ) ** 2017 + ( ( x ** 2 - 1 ) ** 2 % ( 2 * x * y - 1 ) + 2 ) ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 Since gmpy.is_prime either returns 1 or returns 0, we can easily try out that y y is a prime number, x+1 x+1 is also a prime number, and (x^2-1)^2 \\equiv 0 \\bmod(2xy-1) (x^2-1)^2 \\equiv 0 \\bmod(2xy-1) In order for the expression to be divisible, we guess that x=2y x=2y . So for the following code p = gmpy . next_prime ( x ** 3 + y ** 3 ) q = gmpy . next_prime ( x ** 2 * y + y ** 2 * x ) n = p * q phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( 0x10001 , phi ) enc = pow ( bytes_to_long ( flag ), 0x10001 , n ) print 'n =' , n print 'enc =' , enc p p and q q are naturally p=next\\_prime(9y^3) p=next\\_prime(9y^3) q=next\\_prime(6y^3) q=next\\_prime(6y^3) According to the interval of prime numbers, we know that p p and q q are at most a little larger than the numbers in parentheses, and generally would not exceed 1000 1000 here. Then n \\geq 54y^6 n \\geq 54y^6 So we know the upper bound of y y , and the lower bound of y y is actually not too far from the upper bound, we probably reduce hundreds of thousands. Hence, we use binary search to find p p and q q , as follows import gmpy2 tmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 print gmpy2 . iroot ( tmp , 2018 ) print gmpy2 . iroot ( tmp - 1 , 2018 ) print gmpy2 . iroot ( tmp - 2 , 2018 ) n = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741 y = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000 L y = gmpy2 . next_prime ( y ) enc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612 end = gmpy2 . iroot ( n / 54 , 6 )[ 0 ] beg = end - 2000000 mid = 1 while beg < end : mid = ( beg + end ) / 2 if gmpy2 . is_prime ( mid ) != 1 : mid = gmpy2 . next_prime ( mid ) p = gmpy2 . next_prime ( 9 * mid ** 3 ) q = gmpy2 . next_prime ( 6 * mid ** 3 ) n1 = p * q if n1 == n : print p , q phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 0x10001 , phin ) m = gmpy2 . powmod ( enc , d , n ) print hex ( m )[ 2 :] . strip ( 'L' ) . decode ( 'hex' ) print 'ok' exit ( 0 ) elif n1 < n : beg = mid else : end = mid print beg , end","title":"RSA \u57fa\u672c\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#rsa-introduction","text":"The RSA encryption algorithm is an asymmetric encryption algorithm. RSA is widely used in public key encryption and electronic commerce. The RSA was proposed in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA is composed of the letters of the three names of the three of them. The reliability of the RSA algorithm is determined by the difficulty of maximizing integer factorization. In other words, the more difficult it is to factorize a very large integer, the more reliable the RSA algorithm is. If someone finds a fast factorization algorithm, the reliability of the information encrypted with RSA will definitely drop. But the possibility of finding such an algorithm is very small. Today, only short RSA keys can be broken down in a powerful way. As of 2017, there is no reliable way to attack the RSA algorithm.","title":"RSA Introduction"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#fundamental","text":"","title":"Fundamental"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#public-key-and-private-key-generation","text":"Randomly select two different large prime numbers p p and q q to calculate N = p \\times q N = p \\times q According to the Euler function, find \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) Select an integer e e that is less than \\varphi (N) \\varphi (N) to make e e and \\varphi (N) \\varphi (N) mutually prime. And ask for e e about the inverse of \\varphi (N) \\varphi (N) , named d d , with ed\\equiv 1 \\pmod {\\varphi (N)} ed\\equiv 1 \\pmod {\\varphi (N)} Destroy records of p p and q q At this point, (N,e) (N,e) is the public key and (N,d) (N,d) is the private key.","title":"Public key and private key generation"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#message-encryption","text":"First, we need to convert the message into an integer m m using an agreed-upon protocol, such than m m is less than N N and m m is coprime to N N . If the message is too long, we can divide the message into several segments, which is what we call block encryption, and then encrypt each part with the following formula: m^{e}\\equiv c\\pmod N m^{e}\\equiv c\\pmod N","title":"Message Encryption"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#message-decryption","text":"Use the private key d d to decrypt the message. c^{d}\\equiv m\\pmod N c^{d}\\equiv m\\pmod N","title":"Message decryption"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#verification","text":"To verify m^{ed} \\equiv m \\bmod N m^{ed} \\equiv m \\bmod N , we use the fact that ed \\equiv 1 \\bmod \\phi(N) ed \\equiv 1 \\bmod \\phi(N) , then ed=k\\phi(N)+1 ed=k\\phi(N)+1 , it is sufficient to prove that m^{k\\phi(N)+1} \\equiv m \\bmod N m^{k\\phi(N)+1} \\equiv m \\bmod N We will prove it by considering two seperate cases In the first case, gcd(m,N)=1 gcd(m,N)=1 , hence m^{\\phi(N)} \\equiv 1 \\bmod N m^{\\phi(N)} \\equiv 1 \\bmod N , so the original claim is true. In the second case, gcd(m,N)\\neq 1 gcd(m,N)\\neq 1 , so m m must be a multiple of p p or q q , and since n=m n=m is less than N N , we can assume that m = xp m = xp Where x x must be less than q q . Since q q is a prime number, m^{\\phi(q)}\\equiv 1 \\bmod q m^{\\phi(q)}\\equiv 1 \\bmod q m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)} = m {k(p-1)(q-1)} = (m^{\\phi(q)})^{k(p-1)} \\equiv 1 \\bmod q m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqm m^{k\\phi(N)+1}=m+uqxp=m+uxN m^{k\\phi(N)+1}=m+uqxp=m+uxN Hence it is proven to be correct.","title":"Verification"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#basic-tools","text":"","title":"Basic Tools"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#rsatool","text":"Installation git clone https://github.com/ius/rsatool.git cd rsatool python rsatool.py -h Generate private key Python rsatool.py f FEM private.pem o p q 1234567 7654321","title":"RSAtool"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#rsa-converter","text":"Generate a pem file based on a given key pair Obtain p p and q q from n n , e e , d d","title":"RSA Converter"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#openssl","text":"View public key file openssl rsa -pubin -in pubkey.pem -text -modulus Decryption rsautl -decrypt -inkey private.pem -in flag.enc -out flag For more specific details, please refer to openssl --help .","title":"openssl"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#decomposition-integer-tool","text":"Website decomposition, factor.db Command line decomposition, factordb-pycli , borrowing the factordb database. yafu","title":"Decomposition Integer Tool"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#python","text":"","title":"python\u5e93"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#primefac","text":"The integer decomposition library contains many algorithms for integer decomposition.","title":"primefac"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#gmpy","text":"gmpy.root(a, b) , returns a tuple (x, y) , where x is the value of a open b power, y is the judgment x whether Boolean variable that is an integer","title":"gmpy"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#gmpy2","text":"When installing, you may need to install the mfpr and mpc libraries separately. gmpy2.iroot(a, b) , similar to gmpy.root(a,b)","title":"gmpy2"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#pycrypto","text":"Installation sudo pip install pycrypto use import gmpy from Crypto.Util.number import * from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_v1_5 msg = 'crypto here' p = getPrime ( 128 ) q = getPrime ( 128 ) n = p * q e = getPrime ( 64 ) pubkey = RSA . construct (( long ( n ), long ( e ))) privatekey = RSA . construct (( long ( n ), long ( e ), long ( d ), long ( p ), long ( q ))) key = PKCS1_v1_5 . new ( pubkey ) enc = key . encrypt ( msg ) . encode ( 'base64' ) key = PKCS1_v1_5 . new ( privatekey ) msg = key . decrypt ( enc . decode ( 'base64' ), e )","title":"pycrypto"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#jarvis-oj-basic-veryeasyrsa","text":"p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 Find d = Please submit PCTF{d} Using ed\\equiv 1 \\pmod{\\varphi(N)} ed\\equiv 1 \\pmod{\\varphi(N)} , we can obtain d d from \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) \\varphi (N)=\\varphi (p)\\varphi (q)=(p-1)(q-1) . import gmpy2 p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 phin = ( p - 1 ) * ( q - 1 ) print gmpy2 . invert ( e , phin ) \u279c Jarvis OJ-Basic-veryeasyRSA git: ( master ) \u2717 python exp.py 19178568796155560423675975774142829153827883709027717723363077606260717434369","title":"Jarvis OJ - Basic - veryeasyRSA"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#2018-codegate-ctf-rsababy","text":"The program is a simple RSA, but the program also generates two strange numbers. e = 65537 n = p * q pi_n = ( p - 1 ) * ( q - 1 ) d = mulinv ( e , pi_n ) h = ( d + p ) ^ ( d - p ) g = d * ( p - 0xdeadbeef ) So, the problem should come from here, so let's start with it, let's assume that const = 0xdeadbeef . Then eg = ed * (p-const) eg = ed * (p-const) Furthermore, according to RSA 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{eg}=2^{ed * (p-const)}=2^{p-const} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n 2^{p-const} * 2^{const-1} = 2^{p-1} \\pmod n So 2^{p-1} = 2^{eg} * 2^{const-1}+kn 2^{p-1} = 2^{eg} * 2^{const-1}+kn At the same time, according to Fermat's little theorem, we know 2^{p-1} \\equiv 1 \\pmod p 2^{p-1} \\equiv 1 \\pmod p So p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{p-1}-1 | 2^{eg+const-1}-1+kn p|2^{eg+const-1}-1 p|2^{eg+const-1}-1 p|gcd(2^{eg+const-1}-1,n) p|gcd(2^{eg+const-1}-1,n) Hence the code is as follows tmp = gmpy2 . powmod ( 2 , e * g + const - 1 , n ) - 1 p = gmpy2 . gcd ( tmp , n ) q = n / p Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( e , phin ) plain = gmpy2 . powmod ( data , d , n ) print hex ( plain )[ 2 :] . decode ( 'hex' )","title":"2018 CodeGate CTF Rsababy"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#2018-national-security-week-pure-math","text":"The basic description of the topic is like this 1) p ** p % q = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 2) q ** q % p = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 3) (p ** q + q ** p) % (p*q) = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 4) (p+q) ** (p+q) % (p*q) = 63112211860889153729003401381621068190906433969243079543438386686621389392583849748240273643614258173423474299387234175508649197780206757067354426424570586101908571600743792328163163458500138799976944702155779196849585083397395750018148652864158388247163109077215394538930498877175474225571393901460434679279 5) FLAG ** 31337 % (p*q) = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Now, what\u2019s the FLAG??? Our goal is basically to find FLAG, but how can we find it? This question requires us to be more familiar with number theory. From the content of the question, we can assume that p p , q q are both large prime numbers, so p^{q-1} \\equiv 1\\bmod q p^{q-1} \\equiv 1\\bmod q Then p^{q} \\equiv p \\bmod pq p^{q} \\equiv p \\bmod pq From 3), we know that p^q+q^p \\equiv p+q \\bmod pq p^q+q^p \\equiv p+q \\bmod pq And p+q p+q is obviously smaller than pq pq , so we know the value of p+q p+q . We let x_1 x_1 , x_2 x_2 , x_3 x_3 , x_4 x_4 , x_5 x_5 take the values of 1) to 5) respectively. From 4), we have (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq (p+q)^{p+q} \\equiv p^{p+q}+q^{p+q} \\bmod pq And because of 1) and 2), then p^pp \\equiv px_1\\bmod pq p^pp \\equiv px_1\\bmod pq q^qq \\equiv qx_2 \\bmod pq q^qq \\equiv qx_2 \\bmod pq therefore px_1+qx_2 \\equiv x_4 \\bmod pq px_1+qx_2 \\equiv x_4 \\bmod pq From the way x_1 x_1 and x_2 x_2 are obtained, we know that px_1+qx_2 px_1+qx_2 is also equal to x_4 x_4 , so we get a system of linear equations in two variables and can solve it directly. import gmpy2 x1 = 1137973316343089029387365135250835133803975869258714714790597743585251681751361684698632609164883988455302237641489036138661596754239799122081528662395492 X2 = 6901383184477756324584651464895743132603115552606852729050186289748558760692261058141015199261946483809004373728135568483701274908717004197776113227815323 p_q = 16791287391494893024031688699360885996180880807427715700800644759680986120242383930558410147341340225420991368114858791447699399702390358184412301644459406 x4 = 63112211860889153729 0034062380936348635813582583974823274634293429254290729072907052006074920060749 s729Readingly 97297499258793650 s 8392407 3105245 94071857 531058007 518 764 579 54 0 0 0 0 0 0 0 0 0 0 0 0 if ( x4 - x1 * p_q ) % ( x2 - x1 ) == 0 : print 'True' q = ( x4 - x1 * p_q ) / ( x2 - x1 ) print q p = p_q - q c = 6931243291746179589612148118911670244427928875888377273917973305632621316868302667641610838193899081089153471883271406133321321416064760200919958612671379845738048938060512995550639898688604592620908415248701721672948126507753670027043162669545932921683579001870526727737212722417683610956855529996310258030 Phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 31337 , phin ) flag = gmpy2 . powmod ( c , d , p * q ) flag = hex ( flag )[ 2 :] print flag . decode ( 'hex' ) Flag is as follows \u279c 2018 -National Security Week first game-puremath git: ( master ) \u2717 python exp.py True 7635093784603905632817000902311635311970645531806863592697496927519352405158721310359124595712780726701027634372170535318453656286180828724079479352052417 flag { 6a66b8d5-6047-4299-a48e-4c4d1f874d12 }","title":"2018 National Security Week pure math"},{"location":"crypto/ctf-wiki/asymmetric/rsa/rsa_theory/#2018-pwnhub-lhy","text":"First analyze this code assert gmpy . is_prime ( y ) ** 2016 + gmpy . is_prime ( x + 1 ) ** 2017 + ( ( x ** 2 - 1 ) ** 2 % ( 2 * x * y - 1 ) + 2 ) ** 2018 == 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 Since gmpy.is_prime either returns 1 or returns 0, we can easily try out that y y is a prime number, x+1 x+1 is also a prime number, and (x^2-1)^2 \\equiv 0 \\bmod(2xy-1) (x^2-1)^2 \\equiv 0 \\bmod(2xy-1) In order for the expression to be divisible, we guess that x=2y x=2y . So for the following code p = gmpy . next_prime ( x ** 3 + y ** 3 ) q = gmpy . next_prime ( x ** 2 * y + y ** 2 * x ) n = p * q phi = ( p - 1 ) * ( q - 1 ) d = gmpy . invert ( 0x10001 , phi ) enc = pow ( bytes_to_long ( flag ), 0x10001 , n ) print 'n =' , n print 'enc =' , enc p p and q q are naturally p=next\\_prime(9y^3) p=next\\_prime(9y^3) q=next\\_prime(6y^3) q=next\\_prime(6y^3) According to the interval of prime numbers, we know that p p and q q are at most a little larger than the numbers in parentheses, and generally would not exceed 1000 1000 here. Then n \\geq 54y^6 n \\geq 54y^6 So we know the upper bound of y y , and the lower bound of y y is actually not too far from the upper bound, we probably reduce hundreds of thousands. Hence, we use binary search to find p p and q q , as follows import gmpy2 tmp = 30097557298197417800049182668952226601954645169633891463401117760245367082644152355564014438095421962150109895432272944128252155287648477680131934943095113263121691874508742328500559321036238322775864636883202538152031804102118831278605474474352011895348919417742923873371980983336517409056008233804190890418285814476821890492630167665485823056526646050928460488168341721716361299816947722947465808004305806687049198633489997459201469227952552870291934919760829984421958853221330987033580524592596407485826446284220272614663464267135596497185086055090126893989371261962903295313304735911034185619611156742146 print gmpy2 . iroot ( tmp , 2018 ) print gmpy2 . iroot ( tmp - 1 , 2018 ) print gmpy2 . iroot ( tmp - 2 , 2018 ) n = 260272753019642842691231717156206014402348296256668058656902033827190888150939144319270903947159599144884859205368557385941127216969379550487700198771513118894125094678559478972591331182960004648132846372455712958337042783083099376871113795475285658106058675217077803768944674144803250791799957440111855021945690877200606577646234107957498370758707097662736662439460472126493593605957225541979181422479704018055731221681621886820626215670393536343427267329350730257979042198593215747542270975288047196483958369426727778580292311145109908665004662296440533724591193527886702374790526322791818523938910660223971454070731594803459613066617828657725704376475527288174777197739360634209448477565044519733575375490101670974499385760735451471034271880800081246883157088501597655371430353965493264345172541221268942926210055390568364981514774743693528424196241142665685211916330254113610598390909248626686397970038848966187547231199741 y = 191904757378974300059526915134037747982760255307942501070454569331878491189601823952845623286161325306079772871025816081849039036850918375408172174102720702781463514549851887084613000000 L y = gmpy2 . next_prime ( y ) enc = 73933313646416156737449236838459526871566017180178176765840447023088664788672323530940171469589918772272559607026808711216932468486201094786991159096267208480969757088208089800600731106685561375522764783335332964711981392251568543122418192877756299395774738176188452197889668610818741062203831272066261677731889616150485770623945568369493256759711422067551058418926344060504112146971937651406886327429318390247733970549845424064244469193626197360072341969574784310397213033860597822010667926563087858301337091484951760613299203587677078666096526093414014637559237148644939541419075479462431789925219269815364529507771308181435591670281081465439913711912925412078002618729159141400730636976744132429329651487292506365655834202469178066850282850374067239317928012461993443785247524500680257923687511378073703423047348824611101206633407452837948194591695712958510124436821151767823443033286425729473563002691262316964646014201612 end = gmpy2 . iroot ( n / 54 , 6 )[ 0 ] beg = end - 2000000 mid = 1 while beg < end : mid = ( beg + end ) / 2 if gmpy2 . is_prime ( mid ) != 1 : mid = gmpy2 . next_prime ( mid ) p = gmpy2 . next_prime ( 9 * mid ** 3 ) q = gmpy2 . next_prime ( 6 * mid ** 3 ) n1 = p * q if n1 == n : print p , q phin = ( p - 1 ) * ( q - 1 ) d = gmpy2 . invert ( 0x10001 , phin ) m = gmpy2 . powmod ( enc , d , n ) print hex ( m )[ 2 :] . strip ( 'L' ) . decode ( 'hex' ) print 'ok' exit ( 0 ) elif n1 < n : beg = mid else : end = mid print beg , end","title":"2018 Pwnhub LHY"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode-zh/","text":"EN | ZH \u7b80\u4ecb \u00b6 \u653b\u51fb\u6a21\u5f0f \u00b6 \u5728\u6211\u4eec\u653b\u51fb\u4e00\u4e2a\u5bc6\u7801\u5b66\u7cfb\u7edf\u65f6\uff0c\u6211\u4eec\u6216\u591a\u6216\u5c11\u4f1a\u5f97\u5230\u5173\u4e8e\u8fd9\u4e2a\u7cfb\u7edf\u7684\u4e00\u4e9b\u4fe1\u606f\u3002\u6839\u636e\u5f97\u5230\u4fe1\u606f\u91cf\u7684\u4e0d\u540c\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u7684\u65b9\u6cd5\u5c31\u53ef\u80fd\u4e0d\u540c\u3002\u5728\u5f53\u4eca\u7684\u5bc6\u7801\u5b66\u5206\u6790\u65f6\uff0c\u4e00\u822c\u6211\u4eec\u90fd\u4f1a\u5047\u8bbe\u653b\u51fb\u8005\u77e5\u9053\u5bc6\u7801\u5b66\u7b97\u6cd5\uff0c\u8fd9\u4e2a\u5047\u8bbe\u662f\u5408\u7406\u7684\uff0c\u56e0\u4e3a\u5386\u53f2\u4e0a\u6709\u5f88\u591a\u4fdd\u5bc6\u7684\u7b97\u6cd5\u6700\u540e\u90fd\u88ab\u4eba\u6240\u77e5\uff0c\u6bd4\u5982 RC4\u3002\u88ab\u77e5\u9053\u7684\u65b9\u5f0f\u591a\u91cd\u591a\u6837\uff0c\u6bd4\u5982\u95f4\u8c0d\uff0c\u9006\u5411\u5de5\u7a0b\u7b49\u3002 \u8fd9\u91cc\u6211\u4eec\u6839\u636e\u653b\u51fb\u8005\u83b7\u53d6\u5bc6\u7801\u5b66\u7cfb\u7edf\u7684\u4fe1\u606f\u7684\u591a\u5c11\u5c06\u653b\u51fb\u6a21\u5f0f\u5206\u4e3a\u4ee5\u4e0b\u51e0\u7c7b \u552f\u5bc6\u6587\u653b\u51fb \uff1a\u653b\u51fb\u8005\u4ec5\u80fd\u83b7\u5f97\u4e00\u4e9b\u52a0\u5bc6\u8fc7\u7684\u5bc6\u6587\u3002 \u5df2\u77e5\u660e\u6587\u653b\u51fb \uff1a\u653b\u51fb\u8005\u6709\u4e00\u4e9b\u5bc6\u6587\u5bf9\u5e94\u7684\u660e\u6587\u3002 \u9009\u62e9\u660e\u6587\u653b\u51fb \uff1a\u653b\u51fb\u8005\u5728\u5f00\u59cb\u653b\u51fb\u65f6\u53ef\u4ee5\u9009\u62e9\u4e00\u4e9b\u660e\u6587\uff0c\u5e76\u83b7\u53d6\u52a0\u5bc6\u540e\u7684\u5bc6\u6587\u3002\u5982\u679c\u653b\u51fb\u8005\u5728\u653b\u51fb\u4e2d\u9014\u53ef\u4ee5\u6839\u636e\u5df2\u7ecf\u83b7\u53d6\u7684\u4fe1\u606f\u9009\u62e9\u65b0\u7684\u660e\u6587\u5e76\u83b7\u53d6\u5bf9\u5e94\u7684\u5bc6\u6587\uff0c\u5219\u79f0\u4e3a\u9002\u5e94\u6027\u9009\u62e9\u660e\u6587\u653b\u51fb\u3002 \u9009\u62e9\u5bc6\u6587\u653b\u51fb \uff1a\u653b\u51fb\u8005\u5728\u5f00\u59cb\u653b\u51fb\u4e4b\u524d\u53ef\u4ee5\u9009\u62e9\u4e00\u4e9b\u5bc6\u6587\uff0c\u5e76\u83b7\u53d6\u89e3\u5bc6\u540e\u7684\u660e\u6587\u3002\u5982\u679c\u653b\u51fb\u8005\u5728\u653b\u51fb\u56fe\u4e2d\u53ef\u4ee5\u6839\u636e\u5df2\u7ecf\u83b7\u53d6\u7684\u4fe1\u606f\u9009\u62e9\u4e00\u4e9b\u65b0\u7684\u5bc6\u6587\u5e76\u83b7\u53d6\u5bf9\u5e94\u7684\u660e\u6587\uff0c\u5219\u79f0\u4e3a\u9002\u5e94\u6027\u9009\u62e9\u5bc6\u6587\u653b\u51fb\u3002 \u76f8\u5173\u5bc6\u94a5\u653b\u51fb \uff1a\u653b\u51fb\u8005\u53ef\u4ee5\u83b7\u5f97\u4e24\u4e2a\u6216\u591a\u4e2a\u76f8\u5173\u5bc6\u94a5\u7684\u52a0\u5bc6\u6216\u89e3\u5bc6\u540e\u7684\u5bc6\u6587\u6216\u660e\u6587\u3002\u4f46\u662f\u653b\u51fb\u8005\u4e0d\u77e5\u9053\u8fd9\u4e9b\u5bc6\u94a5\u3002 \u5e38\u89c1\u653b\u51fb\u65b9\u6cd5 \u00b6 \u6839\u636e\u4e0d\u540c\u7684\u653b\u51fb\u6a21\u5f0f\uff0c\u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\u7684\u653b\u51fb\u65b9\u6cd5\uff0c\u76ee\u524d\u5e38\u89c1\u7684\u653b\u51fb\u65b9\u6cd5\u4e3b\u8981\u6709 \u66b4\u529b\u653b\u51fb \u4e2d\u95f4\u76f8\u9047\u653b\u51fb \u7ebf\u6027\u5206\u6790 \u5dee\u5206\u5206\u6790 \u4e0d\u53ef\u80fd\u5dee\u5206\u5206\u6790 \u79ef\u5206\u5206\u6790 \u4ee3\u6570\u5206\u6790 \u76f8\u5173\u5bc6\u94a5\u653b\u51fb \u4fa7\u4fe1\u9053\u653b\u51fb \u53c2\u8003\u6587\u732e \u00b6 https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90","title":"Attack mode zh"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode-zh/#_1","text":"","title":"\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode-zh/#_2","text":"\u5728\u6211\u4eec\u653b\u51fb\u4e00\u4e2a\u5bc6\u7801\u5b66\u7cfb\u7edf\u65f6\uff0c\u6211\u4eec\u6216\u591a\u6216\u5c11\u4f1a\u5f97\u5230\u5173\u4e8e\u8fd9\u4e2a\u7cfb\u7edf\u7684\u4e00\u4e9b\u4fe1\u606f\u3002\u6839\u636e\u5f97\u5230\u4fe1\u606f\u91cf\u7684\u4e0d\u540c\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u7684\u65b9\u6cd5\u5c31\u53ef\u80fd\u4e0d\u540c\u3002\u5728\u5f53\u4eca\u7684\u5bc6\u7801\u5b66\u5206\u6790\u65f6\uff0c\u4e00\u822c\u6211\u4eec\u90fd\u4f1a\u5047\u8bbe\u653b\u51fb\u8005\u77e5\u9053\u5bc6\u7801\u5b66\u7b97\u6cd5\uff0c\u8fd9\u4e2a\u5047\u8bbe\u662f\u5408\u7406\u7684\uff0c\u56e0\u4e3a\u5386\u53f2\u4e0a\u6709\u5f88\u591a\u4fdd\u5bc6\u7684\u7b97\u6cd5\u6700\u540e\u90fd\u88ab\u4eba\u6240\u77e5\uff0c\u6bd4\u5982 RC4\u3002\u88ab\u77e5\u9053\u7684\u65b9\u5f0f\u591a\u91cd\u591a\u6837\uff0c\u6bd4\u5982\u95f4\u8c0d\uff0c\u9006\u5411\u5de5\u7a0b\u7b49\u3002 \u8fd9\u91cc\u6211\u4eec\u6839\u636e\u653b\u51fb\u8005\u83b7\u53d6\u5bc6\u7801\u5b66\u7cfb\u7edf\u7684\u4fe1\u606f\u7684\u591a\u5c11\u5c06\u653b\u51fb\u6a21\u5f0f\u5206\u4e3a\u4ee5\u4e0b\u51e0\u7c7b \u552f\u5bc6\u6587\u653b\u51fb \uff1a\u653b\u51fb\u8005\u4ec5\u80fd\u83b7\u5f97\u4e00\u4e9b\u52a0\u5bc6\u8fc7\u7684\u5bc6\u6587\u3002 \u5df2\u77e5\u660e\u6587\u653b\u51fb \uff1a\u653b\u51fb\u8005\u6709\u4e00\u4e9b\u5bc6\u6587\u5bf9\u5e94\u7684\u660e\u6587\u3002 \u9009\u62e9\u660e\u6587\u653b\u51fb \uff1a\u653b\u51fb\u8005\u5728\u5f00\u59cb\u653b\u51fb\u65f6\u53ef\u4ee5\u9009\u62e9\u4e00\u4e9b\u660e\u6587\uff0c\u5e76\u83b7\u53d6\u52a0\u5bc6\u540e\u7684\u5bc6\u6587\u3002\u5982\u679c\u653b\u51fb\u8005\u5728\u653b\u51fb\u4e2d\u9014\u53ef\u4ee5\u6839\u636e\u5df2\u7ecf\u83b7\u53d6\u7684\u4fe1\u606f\u9009\u62e9\u65b0\u7684\u660e\u6587\u5e76\u83b7\u53d6\u5bf9\u5e94\u7684\u5bc6\u6587\uff0c\u5219\u79f0\u4e3a\u9002\u5e94\u6027\u9009\u62e9\u660e\u6587\u653b\u51fb\u3002 \u9009\u62e9\u5bc6\u6587\u653b\u51fb \uff1a\u653b\u51fb\u8005\u5728\u5f00\u59cb\u653b\u51fb\u4e4b\u524d\u53ef\u4ee5\u9009\u62e9\u4e00\u4e9b\u5bc6\u6587\uff0c\u5e76\u83b7\u53d6\u89e3\u5bc6\u540e\u7684\u660e\u6587\u3002\u5982\u679c\u653b\u51fb\u8005\u5728\u653b\u51fb\u56fe\u4e2d\u53ef\u4ee5\u6839\u636e\u5df2\u7ecf\u83b7\u53d6\u7684\u4fe1\u606f\u9009\u62e9\u4e00\u4e9b\u65b0\u7684\u5bc6\u6587\u5e76\u83b7\u53d6\u5bf9\u5e94\u7684\u660e\u6587\uff0c\u5219\u79f0\u4e3a\u9002\u5e94\u6027\u9009\u62e9\u5bc6\u6587\u653b\u51fb\u3002 \u76f8\u5173\u5bc6\u94a5\u653b\u51fb \uff1a\u653b\u51fb\u8005\u53ef\u4ee5\u83b7\u5f97\u4e24\u4e2a\u6216\u591a\u4e2a\u76f8\u5173\u5bc6\u94a5\u7684\u52a0\u5bc6\u6216\u89e3\u5bc6\u540e\u7684\u5bc6\u6587\u6216\u660e\u6587\u3002\u4f46\u662f\u653b\u51fb\u8005\u4e0d\u77e5\u9053\u8fd9\u4e9b\u5bc6\u94a5\u3002","title":"\u653b\u51fb\u6a21\u5f0f"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode-zh/#_3","text":"\u6839\u636e\u4e0d\u540c\u7684\u653b\u51fb\u6a21\u5f0f\uff0c\u53ef\u80fd\u4f1a\u6709\u4e0d\u540c\u7684\u653b\u51fb\u65b9\u6cd5\uff0c\u76ee\u524d\u5e38\u89c1\u7684\u653b\u51fb\u65b9\u6cd5\u4e3b\u8981\u6709 \u66b4\u529b\u653b\u51fb \u4e2d\u95f4\u76f8\u9047\u653b\u51fb \u7ebf\u6027\u5206\u6790 \u5dee\u5206\u5206\u6790 \u4e0d\u53ef\u80fd\u5dee\u5206\u5206\u6790 \u79ef\u5206\u5206\u6790 \u4ee3\u6570\u5206\u6790 \u76f8\u5173\u5bc6\u94a5\u653b\u51fb \u4fa7\u4fe1\u9053\u653b\u51fb","title":"\u5e38\u89c1\u653b\u51fb\u65b9\u6cd5"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode-zh/#_4","text":"https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode/","text":"EN | ZH Introduction \u00b6 Attack mode \u00b6 When we attack a cryptography system, we get more or less information about the system. Depending on the amount of information we receive, the methods we can use may vary. In today's cryptanalysis, we generally assume that the attacker knows the cryptographic algorithm. This assumption is reasonable because there are many secret algorithms in history that are finally known, such as RC4. There are many ways to be known, such as spying, reverse engineering, etc. Here we divide the attack mode into the following categories based on how much information the attacker obtains from the cryptography system. ciphertext attack only : The attacker can only get some encrypted ciphertext. Known plaintext attack : The attacker has some plaintext corresponding to the ciphertext. Select plaintext attack : The attacker can choose some plaintext when starting the attack and get the encrypted ciphertext. If an attacker can select a new plaintext based on the acquired information and obtain the corresponding ciphertext in the middle of the attack, it is called an adaptive selective plaintext attack. Select ciphertext attack : The attacker can select some ciphertexts and get the decrypted plaintext before starting the attack. If an attacker can select some new ciphertexts based on the information that has been acquired and obtain the corresponding plaintext, the attacker is called adaptive ciphertext attack. Related key attack : An attacker can obtain encrypted or decrypted ciphertext or plaintext of two or more related keys. But the attacker does not know these keys. Common attack methods \u00b6 According to different attack modes, there may be different attack methods. Currently, common attack methods mainly include violent attacks Intercommunication attack Linear analysis Differential analysis Impossible differential analysis Integration analysis Algebraic analysis Related key attack Side channel attack references \u00b6 https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90","title":"\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode/#introduction","text":"","title":"Introduction"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode/#attack-mode","text":"When we attack a cryptography system, we get more or less information about the system. Depending on the amount of information we receive, the methods we can use may vary. In today's cryptanalysis, we generally assume that the attacker knows the cryptographic algorithm. This assumption is reasonable because there are many secret algorithms in history that are finally known, such as RC4. There are many ways to be known, such as spying, reverse engineering, etc. Here we divide the attack mode into the following categories based on how much information the attacker obtains from the cryptography system. ciphertext attack only : The attacker can only get some encrypted ciphertext. Known plaintext attack : The attacker has some plaintext corresponding to the ciphertext. Select plaintext attack : The attacker can choose some plaintext when starting the attack and get the encrypted ciphertext. If an attacker can select a new plaintext based on the acquired information and obtain the corresponding ciphertext in the middle of the attack, it is called an adaptive selective plaintext attack. Select ciphertext attack : The attacker can select some ciphertexts and get the decrypted plaintext before starting the attack. If an attacker can select some new ciphertexts based on the information that has been acquired and obtain the corresponding plaintext, the attacker is called adaptive ciphertext attack. Related key attack : An attacker can obtain encrypted or decrypted ciphertext or plaintext of two or more related keys. But the attacker does not know these keys.","title":"Attack mode"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode/#common-attack-methods","text":"According to different attack modes, there may be different attack methods. Currently, common attack methods mainly include violent attacks Intercommunication attack Linear analysis Differential analysis Impossible differential analysis Integration analysis Algebraic analysis Related key attack Side channel attack","title":"Common attack methods"},{"location":"crypto/ctf-wiki/attack-summary/attack-mode/#references","text":"https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90","title":"references"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack-zh/","text":"EN | ZH \u6bd4\u7279\u653b\u51fb \u00b6 \u6982\u8ff0 \u00b6 \u7b80\u5355\u5730\u8bf4\uff0c\u5c31\u662f\u5229\u7528\u6bd4\u7279\u4f4d\u4e4b\u95f4\u7684\u5173\u7cfb\u8fdb\u884c\u653b\u51fb\u3002 2018 Plaid CTF transducipher \u00b6 \u9898\u76ee\u5982\u4e0b #!/usr/bin/env python3.6 import os BLOCK_SIZE = 64 T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def block2bin ( b , length = BLOCK_SIZE ): return list ( map ( int , bin ( b )[ 2 :] . rjust ( length , '0' ))) def bin2block ( b ): return int ( \"\" . join ( map ( str , b )), 2 ) def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) def transduceblock ( b ): return bin2block ( transduce ( block2bin ( b ))) def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) class Transducipher : def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b if __name__ == \"__main__\" : flag = bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )) k = int ( flag , 16 ) C = Transducipher ( k ) print ( \"Your flag is PCTF{ %s }\" % flag ) with open ( \"data1.txt\" , \"w\" ) as f : for i in range ( 16 ): pt = int ( bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )), 16 ) ct = C . encrypt ( pt ) f . write ( str (( pt , ct )) + \" \\n \" ) \u9898\u76ee\u7ed9\u4e86 16 \u7ec4\u660e\u5bc6\u6587\u5bf9 \u660e\u6587\u5927\u5c0f 8 \u4e2a\u5b57\u8282 \u5bc6\u6587\u5927\u5c0f 8 \u4e2a\u5b57\u8282 \u5bc6\u94a5\u5927\u5c0f\u4e5f\u662f 8 \u4e2a\u5b57\u8282 \u6211\u4eec\u6240\u9700\u8981\u6c42\u89e3\u7684\u5c31\u662f\u5bc6\u94a5\u3002 \u53ef\u4ee5\u770b\u5230\u8fd9\u91cc\u4e3b\u8981\u6709\u4e24\u79cd\u57fa\u672c\u64cd\u4f5c swap def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) \u5c06\u7ed9\u5b9a\u7684\u6570\u636e\u7684\u9ad8 32 \u4f4d\u4e0e\u4f4e 32 \u4f4d\u4ea4\u6362\u3002 transduce T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) \u5176\u4e2d\uff0c b \u662f\u4e00\u4e2a 01 \u6570\u7ec4\uff0c\u521d\u59cb\u65f6\u523b\u5927\u5c0f\u4e3a 64\u3002 s \u662f\u4e00\u4e2a\u4e0b\u6807\u3002 \u57fa\u672c\u6d41\u7a0b\u5982\u4e0b \u6839\u636e s \u9009\u62e9\u4f7f\u7528 T \u7684\u54ea\u4e2a\u5143\u7d20\uff0c\u8fdb\u800c\u5c06\u5176\u5206\u4e3a d \u548c t\u3002 \u5c06 b \u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u4e00\u90e8\u5206\u53ea\u5305\u542b\u5934\u5143\u7d20\uff0c\u53e6\u4e00\u90e8\u5206\u5305\u542b\u5176\u5b83\u7684\u5143\u7d20\u3002 \u5c06\u5934\u5143\u7d20\u4e0e t \u5f02\u6216\u4f5c\u4e3a\u5f53\u524d\u7684\u5934\u5143\u7d20\uff0c\u7136\u540e\u7ee7\u7eed\u8f6c\u6362\u5269\u4e0b\u7684\u90e8\u5206\u3002 \u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u5c06\u8be5\u51fd\u6570\u8f6c\u6362\u4e3a\u8fed\u4ee3\u51fd\u6570 def transduce_iter ( b , s = 0 ): ans = [] for c in b : d , t = T [ s ] ans += [ c ^ t ] s = d [ c ] return ans \u8fdb\u800c\u7531\u4e8e\u6bcf\u6b21\u5904\u7406\u7684\u662f\u5217\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\uff0c\u5176\u5b9e\u8be5\u51fd\u6570\u662f\u53ef\u9006\u7684\uff0c\u5982\u4e0b def invtransduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ^ t ]) \u4e0b\u9762\u5206\u6790\u7a0b\u5e8f\u7684\u6838\u5fc3\u6d41\u7a0b\uff0c\u9996\u5148\u662f\u751f\u6210\u5bc6\u94a5\u90e8\u5206\uff0c\u8be5\u52a0\u5bc6\u7b97\u6cd5\u751f\u6210\u4e86 6 \u4e2a\u5bc6\u94a5\uff0c\u6bcf\u6b21\u751f\u6210\u7684\u65b9\u6cd5 transduce \u5148\u524d\u7684\u5bc6\u94a5\u5f97\u5230\u4e2d\u95f4\u503c t \u5bf9 t \u8fdb\u884c swap \u8fde\u7eed\u8fed\u4ee3 5 \u6b21 def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) \u52a0\u5bc6\u7b97\u6cd5\u5982\u4e0b\uff0c\u4e00\u5171\u8fed\u4ee3 6 \u8f6e\uff0c\u57fa\u672c\u6d41\u7a0b \u5f02\u6216\u5bc6\u94a5 transduce \u4ea4\u6362 def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b \u901a\u8fc7\u5206\u6790\u7a0b\u5e8f\uff0c\u53ef\u77e5\u8be5\u52a0\u5bc6\u7b97\u6cd5\u662f\u4e00\u4e2a\u5757\u52a0\u5bc6\uff0c\u57fa\u672c\u4fe1\u606f\u5982\u4e0b \u5757\u5927\u5c0f\u4e3a 8 \u4e2a\u5b57\u8282 \u8f6e\u6570\u4e3a 6 \u8f6e \u52a0\u5bc6\u7b97\u6cd5\u7684\u6bcf\u8f6e\u7684\u57fa\u672c\u64cd\u4f5c\u4e3a transduce \u548c swap\u3002 \u5bc6\u94a5\u7684\u6269\u5c55\u4e5f\u662f\u4e0e transduce \u548c swap \u76f8\u5173\u3002 \u66f4\u5177\u4f53\u7684 swap \u662f\u5c06 8 \u5b57\u8282\u7684\u9ad8 32 \u4f4d\u4e0e\u4f4e 32 \u4f4d\u8fdb\u884c\u8c03\u6362\u3002 transduce \u662f\u5bf9\u4e8e 8 \u5b57\u8282\u7684\u6bcf\u4e2a\u6bd4\u7279\uff0c\u9010\u6bd4\u7279\u4e0e\u67d0\u4e2a\u503c\u8fdb\u884c\u5f02\u6216\u3002\u8fd9\u4e2a\u503c\u4e0e T \u6709\u5173\u3002 \u901a\u8fc7\u8fdb\u4e00\u6b65\u5730\u5206\u6790\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e24\u4e2a\u51fd\u6570\u90fd\u662f\u53ef\u9006\u7684\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86\u6700\u540e\u7684\u5bc6\u6587\uff0c\u90a3\u4e48\u6211\u4eec\u5176\u5b9e\u53ef\u4ee5\u5c06\u539f\u6765\u7684\u8f6e\u6570\u7f29\u77ed\u4e3a\u5dee\u4e0d\u591a 5 \u8f6e\uff0c\u56e0\u4e3a\u6700\u540e\u4e00\u8f6e\u7684 transduce \u548c swap \u6ca1\u6709\u4f5c\u7528\u4e86\u3002 \u6211\u4eec\u53ef\u4ee5\u5b9a\u4e49\u5982\u4e0b\u53d8\u91cf \u540d\u5b57 \u542b\u4e49 k_{i,0} k_{i,0} \u7b2c i \u8f6e\u4f7f\u7528\u7684\u5bc6\u94a5\u7684\u9ad8 32 \u4f4d k_{i,1} k_{i,1} \u7b2c i \u8f6e\u4f7f\u7528\u7684\u5bc6\u94a5\u7684\u4f4e 32 \u4f4d d_{i,0} d_{i,0} \u7b2c i \u8f6e\u4f7f\u7528\u7684\u8f93\u5165\u7684\u9ad8 32 \u4f4d d_{i,1} d_{i,1} \u7b2c i \u8f6e\u4f7f\u7528\u7684\u8f93\u5165\u7684\u4f4e 32 \u4f4d \u7531\u4e8e\u5176\u4e2d\u6709\u4e00\u4e2a\u6838\u5fc3\u64cd\u4f5c\u662f swap\uff0c\u53ea\u4f1a\u64cd\u7eb5\u9ad8\u6216\u4f4e 32 \u4f4d\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\u8003\u8651\u3002\u7b80\u5316\u5b9a\u4e49\u5982\u4e0b Transduce \u7b80\u5316\u4e3a T\uff0c\u8fd9\u91cc\u867d\u7136\u4e0e\u6e90\u4ee3\u7801\u91cc\u51b2\u7a81\uff0c\u4e0d\u8fc7\u6211\u4eec\u53ef\u4ee5\u6682\u65f6\u7406\u89e3\u4e00\u4e0b\u3002 Swap \u7b80\u5316\u4e3a S\u3002 \u5219\u6bcf\u4e00\u8f6e\u7684\u660e\u5bc6\u6587\uff0c\u5bc6\u94a5\u5982\u4e0b \u8f6e\u6570 \u5de6\u4fa7\u5bc6\u94a5 \u5de6\u4fa7\u5bc6\u6587 \u53f3\u4fa7\u5bc6\u94a5 \u53f3\u4fa7\u5bc6\u6587 0 k_{0,0} k_{0,0} d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) k_{0,1} k_{0,1} d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) 1 k_{1,0}=T(k_{0,1},s) k_{1,0}=T(k_{0,1},s) d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) k_{1,1}=T(k_{0,0}) k_{1,1}=T(k_{0,0}) d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) 2 k_{2,0}=T(k_{1,1},s) k_{2,0}=T(k_{1,1},s) d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) k_{2,1}=T(k_{1,0}) k_{2,1}=T(k_{1,0}) d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) 3 k_{3,0}=T(k_{2,1},s) k_{3,0}=T(k_{2,1},s) d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) k_{3,1}=T(k_{2,0}) k_{3,1}=T(k_{2,0}) d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) 4 k_{4,0}=T(k_{3,1},s) k_{4,0}=T(k_{3,1},s) d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) k_{4,1}=T(k_{3,0}) k_{4,1}=T(k_{3,0}) d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) 5 k_{5,0}=T(k_{4,1},s) k_{5,0}=T(k_{4,1},s) d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) k_{5,1}=T(k_{4,0}) k_{5,1}=T(k_{4,0}) d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) \u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u9010\u6bd4\u7279\u4f4d\u679a\u4e3e k \u7684\u9ad8 32 \u4f4d\uff0c\u540c\u65f6\u679a\u4e3e\u5728\u8fdb\u884c T \u64cd\u4f5c\u65f6\u7684\u53ef\u80fd\u7684 s \u72b6\u6001\u4f4d\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u83b7\u53d6\u9ad8 32 \u4f4d\u5bc6\u94a5\u3002\u5728\u8fdb\u884c\u9010\u4f4d\u7206\u7834\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u83b7\u53d6\u4e24\u4e2a\u53ef\u80fd\u7ed3\u679c [2659900894, 2659900895] \u518d\u6839\u636e\u5de6\u8fb9\u7684\u7ed3\u679c\uff0c\u53ef\u4ee5\u53bb\u83b7\u53d6\u53f3\u8fb9\u53ef\u80fd\u7684\u7ed3\u679c\uff0c\u5229\u7528 2659900894 \u83b7\u53d6\u7684\u53ef\u80fd\u7684\u7ed3\u679c\u5982\u4e0b # \u7b2c\u4e00\u7ec4\u660e\u5bc6\u6587\u5bf9\u5bf9\u5e94\u7684\u5bc6\u94a5\u53ef\u80fd\u592a\u591a\u3002 # \u7b2c\u4e8c\u7ec4\u4e00\u5171 6 \u4e2a\u3002 [2764038144, 2764038145, 2764038152, 2764038153, 2764038154, 2764038155] # \u7b2c\u4e09\u7ec4 [2764038144, 2764038145] \u7136\u540e\u5176\u5b9e\u6211\u4eec\u5c31\u53ef\u4ee5\u624b\u5de5\u8bd5\u4e00\u4e0b\u52a0\u5bc6\u6240\u6709\u7684\u660e\u5bc6\u6587\uff0c\u5982\u679c\u4e0d\u5bf9\uff0c\u5c31\u76f4\u63a5\u5224\u65ad\u9519\u8bef\u5373\u53ef\u4e86\u3002\u8fd9\u6837\u5176\u5b9e\u53ef\u4ee5\u5f88\u5feb\u53ef\u4ee5\u8fc7\u6ee4\u3002\u6700\u540e\u53ef\u4ee5\u53d1\u73b0\u5bc6\u94a5\u662f 2659900894|2764038145 \u4e5f\u5c31\u662f11424187353095200769\u3002\u4e5f\u5c31\u62ff\u5230\u4e86 flag\u3002 \u5f53\u7136\uff0c\u672c\u9898\u76ee\u4e5f\u53ef\u4ee5\u4f7f\u7528\u4e2d\u95f4\u76f8\u9047\u7684\u653b\u51fb\u65b9\u6cd5\uff0c\u4e5f\u5c31\u662f\u8bf4\u5206\u522b\u679a\u4e3e\u7b2c 0 \u8f6e\u4f7f\u7528\u7684\u5bc6\u94a5\u548c\u6700\u540e\u4e00\u8f6e\u4f7f\u7528\u7684\u5bc6\u94a5\u4f7f\u5176\u5728\u7b2c\u4e09\u8f6e\u76f8\u9047\u4ea7\u751f\u78b0\u649e\u3002 \u53c2\u8003 \u00b6 http://blog.rb-tree.xyz/2018/05/07/plaidctf-2018-transducipher/","title":"Bit attack zh"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack-zh/#_1","text":"","title":"\u6bd4\u7279\u653b\u51fb"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack-zh/#_2","text":"\u7b80\u5355\u5730\u8bf4\uff0c\u5c31\u662f\u5229\u7528\u6bd4\u7279\u4f4d\u4e4b\u95f4\u7684\u5173\u7cfb\u8fdb\u884c\u653b\u51fb\u3002","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack-zh/#2018-plaid-ctf-transducipher","text":"\u9898\u76ee\u5982\u4e0b #!/usr/bin/env python3.6 import os BLOCK_SIZE = 64 T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def block2bin ( b , length = BLOCK_SIZE ): return list ( map ( int , bin ( b )[ 2 :] . rjust ( length , '0' ))) def bin2block ( b ): return int ( \"\" . join ( map ( str , b )), 2 ) def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) def transduceblock ( b ): return bin2block ( transduce ( block2bin ( b ))) def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) class Transducipher : def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b if __name__ == \"__main__\" : flag = bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )) k = int ( flag , 16 ) C = Transducipher ( k ) print ( \"Your flag is PCTF{ %s }\" % flag ) with open ( \"data1.txt\" , \"w\" ) as f : for i in range ( 16 ): pt = int ( bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )), 16 ) ct = C . encrypt ( pt ) f . write ( str (( pt , ct )) + \" \\n \" ) \u9898\u76ee\u7ed9\u4e86 16 \u7ec4\u660e\u5bc6\u6587\u5bf9 \u660e\u6587\u5927\u5c0f 8 \u4e2a\u5b57\u8282 \u5bc6\u6587\u5927\u5c0f 8 \u4e2a\u5b57\u8282 \u5bc6\u94a5\u5927\u5c0f\u4e5f\u662f 8 \u4e2a\u5b57\u8282 \u6211\u4eec\u6240\u9700\u8981\u6c42\u89e3\u7684\u5c31\u662f\u5bc6\u94a5\u3002 \u53ef\u4ee5\u770b\u5230\u8fd9\u91cc\u4e3b\u8981\u6709\u4e24\u79cd\u57fa\u672c\u64cd\u4f5c swap def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) \u5c06\u7ed9\u5b9a\u7684\u6570\u636e\u7684\u9ad8 32 \u4f4d\u4e0e\u4f4e 32 \u4f4d\u4ea4\u6362\u3002 transduce T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) \u5176\u4e2d\uff0c b \u662f\u4e00\u4e2a 01 \u6570\u7ec4\uff0c\u521d\u59cb\u65f6\u523b\u5927\u5c0f\u4e3a 64\u3002 s \u662f\u4e00\u4e2a\u4e0b\u6807\u3002 \u57fa\u672c\u6d41\u7a0b\u5982\u4e0b \u6839\u636e s \u9009\u62e9\u4f7f\u7528 T \u7684\u54ea\u4e2a\u5143\u7d20\uff0c\u8fdb\u800c\u5c06\u5176\u5206\u4e3a d \u548c t\u3002 \u5c06 b \u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u4e00\u90e8\u5206\u53ea\u5305\u542b\u5934\u5143\u7d20\uff0c\u53e6\u4e00\u90e8\u5206\u5305\u542b\u5176\u5b83\u7684\u5143\u7d20\u3002 \u5c06\u5934\u5143\u7d20\u4e0e t \u5f02\u6216\u4f5c\u4e3a\u5f53\u524d\u7684\u5934\u5143\u7d20\uff0c\u7136\u540e\u7ee7\u7eed\u8f6c\u6362\u5269\u4e0b\u7684\u90e8\u5206\u3002 \u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u5c06\u8be5\u51fd\u6570\u8f6c\u6362\u4e3a\u8fed\u4ee3\u51fd\u6570 def transduce_iter ( b , s = 0 ): ans = [] for c in b : d , t = T [ s ] ans += [ c ^ t ] s = d [ c ] return ans \u8fdb\u800c\u7531\u4e8e\u6bcf\u6b21\u5904\u7406\u7684\u662f\u5217\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\uff0c\u5176\u5b9e\u8be5\u51fd\u6570\u662f\u53ef\u9006\u7684\uff0c\u5982\u4e0b def invtransduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ^ t ]) \u4e0b\u9762\u5206\u6790\u7a0b\u5e8f\u7684\u6838\u5fc3\u6d41\u7a0b\uff0c\u9996\u5148\u662f\u751f\u6210\u5bc6\u94a5\u90e8\u5206\uff0c\u8be5\u52a0\u5bc6\u7b97\u6cd5\u751f\u6210\u4e86 6 \u4e2a\u5bc6\u94a5\uff0c\u6bcf\u6b21\u751f\u6210\u7684\u65b9\u6cd5 transduce \u5148\u524d\u7684\u5bc6\u94a5\u5f97\u5230\u4e2d\u95f4\u503c t \u5bf9 t \u8fdb\u884c swap \u8fde\u7eed\u8fed\u4ee3 5 \u6b21 def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) \u52a0\u5bc6\u7b97\u6cd5\u5982\u4e0b\uff0c\u4e00\u5171\u8fed\u4ee3 6 \u8f6e\uff0c\u57fa\u672c\u6d41\u7a0b \u5f02\u6216\u5bc6\u94a5 transduce \u4ea4\u6362 def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b \u901a\u8fc7\u5206\u6790\u7a0b\u5e8f\uff0c\u53ef\u77e5\u8be5\u52a0\u5bc6\u7b97\u6cd5\u662f\u4e00\u4e2a\u5757\u52a0\u5bc6\uff0c\u57fa\u672c\u4fe1\u606f\u5982\u4e0b \u5757\u5927\u5c0f\u4e3a 8 \u4e2a\u5b57\u8282 \u8f6e\u6570\u4e3a 6 \u8f6e \u52a0\u5bc6\u7b97\u6cd5\u7684\u6bcf\u8f6e\u7684\u57fa\u672c\u64cd\u4f5c\u4e3a transduce \u548c swap\u3002 \u5bc6\u94a5\u7684\u6269\u5c55\u4e5f\u662f\u4e0e transduce \u548c swap \u76f8\u5173\u3002 \u66f4\u5177\u4f53\u7684 swap \u662f\u5c06 8 \u5b57\u8282\u7684\u9ad8 32 \u4f4d\u4e0e\u4f4e 32 \u4f4d\u8fdb\u884c\u8c03\u6362\u3002 transduce \u662f\u5bf9\u4e8e 8 \u5b57\u8282\u7684\u6bcf\u4e2a\u6bd4\u7279\uff0c\u9010\u6bd4\u7279\u4e0e\u67d0\u4e2a\u503c\u8fdb\u884c\u5f02\u6216\u3002\u8fd9\u4e2a\u503c\u4e0e T \u6709\u5173\u3002 \u901a\u8fc7\u8fdb\u4e00\u6b65\u5730\u5206\u6790\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e24\u4e2a\u51fd\u6570\u90fd\u662f\u53ef\u9006\u7684\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86\u6700\u540e\u7684\u5bc6\u6587\uff0c\u90a3\u4e48\u6211\u4eec\u5176\u5b9e\u53ef\u4ee5\u5c06\u539f\u6765\u7684\u8f6e\u6570\u7f29\u77ed\u4e3a\u5dee\u4e0d\u591a 5 \u8f6e\uff0c\u56e0\u4e3a\u6700\u540e\u4e00\u8f6e\u7684 transduce \u548c swap \u6ca1\u6709\u4f5c\u7528\u4e86\u3002 \u6211\u4eec\u53ef\u4ee5\u5b9a\u4e49\u5982\u4e0b\u53d8\u91cf \u540d\u5b57 \u542b\u4e49 k_{i,0} k_{i,0} \u7b2c i \u8f6e\u4f7f\u7528\u7684\u5bc6\u94a5\u7684\u9ad8 32 \u4f4d k_{i,1} k_{i,1} \u7b2c i \u8f6e\u4f7f\u7528\u7684\u5bc6\u94a5\u7684\u4f4e 32 \u4f4d d_{i,0} d_{i,0} \u7b2c i \u8f6e\u4f7f\u7528\u7684\u8f93\u5165\u7684\u9ad8 32 \u4f4d d_{i,1} d_{i,1} \u7b2c i \u8f6e\u4f7f\u7528\u7684\u8f93\u5165\u7684\u4f4e 32 \u4f4d \u7531\u4e8e\u5176\u4e2d\u6709\u4e00\u4e2a\u6838\u5fc3\u64cd\u4f5c\u662f swap\uff0c\u53ea\u4f1a\u64cd\u7eb5\u9ad8\u6216\u4f4e 32 \u4f4d\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\u8003\u8651\u3002\u7b80\u5316\u5b9a\u4e49\u5982\u4e0b Transduce \u7b80\u5316\u4e3a T\uff0c\u8fd9\u91cc\u867d\u7136\u4e0e\u6e90\u4ee3\u7801\u91cc\u51b2\u7a81\uff0c\u4e0d\u8fc7\u6211\u4eec\u53ef\u4ee5\u6682\u65f6\u7406\u89e3\u4e00\u4e0b\u3002 Swap \u7b80\u5316\u4e3a S\u3002 \u5219\u6bcf\u4e00\u8f6e\u7684\u660e\u5bc6\u6587\uff0c\u5bc6\u94a5\u5982\u4e0b \u8f6e\u6570 \u5de6\u4fa7\u5bc6\u94a5 \u5de6\u4fa7\u5bc6\u6587 \u53f3\u4fa7\u5bc6\u94a5 \u53f3\u4fa7\u5bc6\u6587 0 k_{0,0} k_{0,0} d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) k_{0,1} k_{0,1} d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) 1 k_{1,0}=T(k_{0,1},s) k_{1,0}=T(k_{0,1},s) d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) k_{1,1}=T(k_{0,0}) k_{1,1}=T(k_{0,0}) d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) 2 k_{2,0}=T(k_{1,1},s) k_{2,0}=T(k_{1,1},s) d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) k_{2,1}=T(k_{1,0}) k_{2,1}=T(k_{1,0}) d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) 3 k_{3,0}=T(k_{2,1},s) k_{3,0}=T(k_{2,1},s) d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) k_{3,1}=T(k_{2,0}) k_{3,1}=T(k_{2,0}) d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) 4 k_{4,0}=T(k_{3,1},s) k_{4,0}=T(k_{3,1},s) d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) k_{4,1}=T(k_{3,0}) k_{4,1}=T(k_{3,0}) d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) 5 k_{5,0}=T(k_{4,1},s) k_{5,0}=T(k_{4,1},s) d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) k_{5,1}=T(k_{4,0}) k_{5,1}=T(k_{4,0}) d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) \u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u9010\u6bd4\u7279\u4f4d\u679a\u4e3e k \u7684\u9ad8 32 \u4f4d\uff0c\u540c\u65f6\u679a\u4e3e\u5728\u8fdb\u884c T \u64cd\u4f5c\u65f6\u7684\u53ef\u80fd\u7684 s \u72b6\u6001\u4f4d\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u83b7\u53d6\u9ad8 32 \u4f4d\u5bc6\u94a5\u3002\u5728\u8fdb\u884c\u9010\u4f4d\u7206\u7834\u4e4b\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u83b7\u53d6\u4e24\u4e2a\u53ef\u80fd\u7ed3\u679c [2659900894, 2659900895] \u518d\u6839\u636e\u5de6\u8fb9\u7684\u7ed3\u679c\uff0c\u53ef\u4ee5\u53bb\u83b7\u53d6\u53f3\u8fb9\u53ef\u80fd\u7684\u7ed3\u679c\uff0c\u5229\u7528 2659900894 \u83b7\u53d6\u7684\u53ef\u80fd\u7684\u7ed3\u679c\u5982\u4e0b # \u7b2c\u4e00\u7ec4\u660e\u5bc6\u6587\u5bf9\u5bf9\u5e94\u7684\u5bc6\u94a5\u53ef\u80fd\u592a\u591a\u3002 # \u7b2c\u4e8c\u7ec4\u4e00\u5171 6 \u4e2a\u3002 [2764038144, 2764038145, 2764038152, 2764038153, 2764038154, 2764038155] # \u7b2c\u4e09\u7ec4 [2764038144, 2764038145] \u7136\u540e\u5176\u5b9e\u6211\u4eec\u5c31\u53ef\u4ee5\u624b\u5de5\u8bd5\u4e00\u4e0b\u52a0\u5bc6\u6240\u6709\u7684\u660e\u5bc6\u6587\uff0c\u5982\u679c\u4e0d\u5bf9\uff0c\u5c31\u76f4\u63a5\u5224\u65ad\u9519\u8bef\u5373\u53ef\u4e86\u3002\u8fd9\u6837\u5176\u5b9e\u53ef\u4ee5\u5f88\u5feb\u53ef\u4ee5\u8fc7\u6ee4\u3002\u6700\u540e\u53ef\u4ee5\u53d1\u73b0\u5bc6\u94a5\u662f 2659900894|2764038145 \u4e5f\u5c31\u662f11424187353095200769\u3002\u4e5f\u5c31\u62ff\u5230\u4e86 flag\u3002 \u5f53\u7136\uff0c\u672c\u9898\u76ee\u4e5f\u53ef\u4ee5\u4f7f\u7528\u4e2d\u95f4\u76f8\u9047\u7684\u653b\u51fb\u65b9\u6cd5\uff0c\u4e5f\u5c31\u662f\u8bf4\u5206\u522b\u679a\u4e3e\u7b2c 0 \u8f6e\u4f7f\u7528\u7684\u5bc6\u94a5\u548c\u6700\u540e\u4e00\u8f6e\u4f7f\u7528\u7684\u5bc6\u94a5\u4f7f\u5176\u5728\u7b2c\u4e09\u8f6e\u76f8\u9047\u4ea7\u751f\u78b0\u649e\u3002","title":"2018 Plaid CTF transducipher"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack-zh/#_3","text":"http://blog.rb-tree.xyz/2018/05/07/plaidctf-2018-transducipher/","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack/","text":"EN | ZH \u6bd4\u7279\u653b \u00b6 Overview \u00b6 Simply put, it is to use the relationship between the bits to attack. 2018 Plaid CTF transducipher \u00b6 The title is as follows #!/usr/bin/env python3.6 import BLOCK_SIZE = 64 T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def block2bin ( b , length = BLOCK_SIZE ): return list ( map ( int , bin ( b )[ 2 :] . rjust ( length , '0' ))) def bin2block ( b ): return int ( \"\" . join ( map ( str , b )), 2 ) def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) def transduceblock ( b ): return bin2block ( transduce ( block2bin ( b ))) def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) class Transducipher : def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b if __name__ == \"__main__\" : flag = bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )) k = int ( flag , 16 ) C = Transducipher ( k ) print ( \"Your flag is PCTF{ %s }\" % flag ) with open ( \"data1.txt\" , \"w\" ) as f : for i in range ( 16 ): pt = int ( bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )), 16 ) ct = C . encrypt ( pt ) f . write ( str (( pt , ct )) + \" \\n \" ) The topic gave 16 groups of ciphertext pairs. Clear text size 8 bytes cipher text size 8 bytes The key size is also 8 bytes The key we need to solve is the key. It can be seen that there are two main operations here. swap def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) Swaps the upper 32 bits of the given data with the lower 32 bits. transduce T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) among them, b is an array of 01 with an initial time size of 64. s is a subscript. The basic process is as follows Select which element of T to use based on s and divide it into d and t. Divide b into two parts, one containing only the head element and the other containing the other elements. XOR the header element with t as the current header element and continue to convert the rest. In fact, we can convert this function into an iterative function. def transduce_iter ( b , s = 0 ): ans = [] for c in b : d , t = T [ s ] years + = [ ct ] s = d [ c ] return years And since each time the first element of the list is processed, the function is actually reversible, as follows def invtransduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ^ t ]) The following is the core flow of the analysis program. The first is to generate the key part. The encryption algorithm generates 6 keys, each time the method is generated. transduce the previous key to get the intermediate value t Swap t Continuous iteration 5 times def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) The encryption algorithm is as follows, a total of 6 iterations, the basic process XOR key transduce 2. Exchange def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b Through the analysis program, it can be known that the encryption algorithm is a block encryption, and the basic information is as follows Block size is 8 bytes Rounds of 6 rounds The basic operations of each round of the encryption algorithm are transduce and swap. The extension of the key is also related to transduce and swap. more specific swap is to swap the upper 32 bits of the 8 bytes with the lower 32 bits. transduce is XORed to a value bit by bit for each bit of 8 bytes. This value is related to T. Through further analysis, we can find that these two functions are all reversible. That is to say, if we know the final ciphertext, then we can actually shorten the original number of rounds to almost 5 rounds, because the last round of transduce and swap have no effect. We can define the following variables Name Meaning | k_{i,0} k_{i,0} | The upper 32 bits of the key used in the i-th round | | k_{i,1} k_{i,1} | The lower 32 bits of the key used in the i-th round | | d_{i,0} d_{i,0} | The upper 32 bits of the input used by the i-th wheel | | d_{i,1} d_{i,1} | The lower 32 bits of the input used by the i-th wheel | Since one of the core operations is swap, only high or low 32 bits are manipulated, so we can consider it in two parts. The simplified definition is as follows Transduce is simplified to T, although it conflicts with the source code, but we can temporarily understand it. Swap is reduced to S. Then each round of the ciphertext, the key is as follows Number of rounds Left key Left ciphertext Right key Right ciphertext | 0 | k_{0,0} k_{0,0} | d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) | k_{0,1} k_{0,1} | d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) | | 1 | k_{1,0}=T(k_{0,1},s) k_{1,0}=T(k_{0,1},s) | d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) | k_{1,1}=T(k_{0,0}) k_{1,1}=T(k_{0,0}) | d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) | | 2 | k_{2,0}=T(k_{1,1},s) k_{2,0}=T(k_{1,1},s) | d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) | k_{2,1}=T(k_{1,0}) k_{2,1}=T(k_{1,0}) | d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) | | 3 | k_{3,0}=T(k_{2,1},s) k_{3,0}=T(k_{2,1},s) | d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) | k_{3,1}=T(k_{2,0}) k_{3,1}=T(k_{2,0}) | d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) | | 4 | k_{4,0}=T(k_{3,1},s) k_{4,0}=T(k_{3,1},s) | d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) | k_{4,1}=T(k_{3,0}) k_{4,1}=T(k_{3,0}) | d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) | | 5 | k_{5,0}=T(k_{4,1},s) k_{5,0}=T(k_{4,1},s) | d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) | k_{5,1}=T(k_{4,0}) k_{5,1}=T(k_{4,0}) | d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) | Then, we can enumerate the upper 32 bits of k bit by bit and enumerate the possible s status bits when performing the T operation, so that we can get the high 32-bit key. After performing a bit-by-bit blast, we can get two possible results [2659900894, 2659900895] According to the results on the left, you can get the possible results on the right. The possible results obtained with 2659900894 are as follows: # The first set of ciphertexts may have too many corresponding keys. # The second group has a total of 6. [2764038144, 2764038145, 2764038152, 2764038153, 2764038154, 2764038155] # The third group [2764038144, 2764038145] Then in fact, we can manually try to encrypt all the ciphertext, if not, just judge the error directly. This can actually be filtered very quickly. Finally, you can find that the key is 2659900894|2764038145 That is 11624187353095200769. Also got the flag. Of course, this problem can also use the attack method of the middle encounter, that is, the key used in the 0 th round and the key used in the last round are respectively enumerated to make a collision in the third round. Reference \u00b6 http://blog.rb-tree.xyz/2018/05/07/plaidctf-2018-transducipher/","title":"\u6bd4\u7279\u653b\u51fb"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack/#_1","text":"","title":"\u6bd4\u7279\u653b"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack/#overview","text":"Simply put, it is to use the relationship between the bits to attack.","title":"Overview"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack/#2018-plaid-ctf-transducipher","text":"The title is as follows #!/usr/bin/env python3.6 import BLOCK_SIZE = 64 T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def block2bin ( b , length = BLOCK_SIZE ): return list ( map ( int , bin ( b )[ 2 :] . rjust ( length , '0' ))) def bin2block ( b ): return int ( \"\" . join ( map ( str , b )), 2 ) def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) def transduceblock ( b ): return bin2block ( transduce ( block2bin ( b ))) def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) class Transducipher : def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b if __name__ == \"__main__\" : flag = bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )) k = int ( flag , 16 ) C = Transducipher ( k ) print ( \"Your flag is PCTF{ %s }\" % flag ) with open ( \"data1.txt\" , \"w\" ) as f : for i in range ( 16 ): pt = int ( bytes . hex ( os . urandom ( BLOCK_SIZE // 8 )), 16 ) ct = C . encrypt ( pt ) f . write ( str (( pt , ct )) + \" \\n \" ) The topic gave 16 groups of ciphertext pairs. Clear text size 8 bytes cipher text size 8 bytes The key size is also 8 bytes The key we need to solve is the key. It can be seen that there are two main operations here. swap def swap ( b ): l = BLOCK_SIZE // 2 m = ( 1 << l ) - 1 return ( b >> l ) | (( b & m ) << l ) Swaps the upper 32 bits of the given data with the lower 32 bits. transduce T = [ (( 2 , 1 ), 1 ), (( 5 , 0 ), 0 ), (( 3 , 4 ), 0 ), (( 1 , 5 ), 1 ), (( 0 , 3 ), 1 ), (( 4 , 2 ), 0 ), ] def transduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ]) among them, b is an array of 01 with an initial time size of 64. s is a subscript. The basic process is as follows Select which element of T to use based on s and divide it into d and t. Divide b into two parts, one containing only the head element and the other containing the other elements. XOR the header element with t as the current header element and continue to convert the rest. In fact, we can convert this function into an iterative function. def transduce_iter ( b , s = 0 ): ans = [] for c in b : d , t = T [ s ] years + = [ ct ] s = d [ c ] return years And since each time the first element of the list is processed, the function is actually reversible, as follows def invtransduce ( b , s = 0 ): if len ( b ) == 0 : return b d , t = T [ s ] b0 , bp = b [ 0 ], b [ 1 :] return [ b0 ^ t ] + transduce ( bp , s = d [ b0 ^ t ]) The following is the core flow of the analysis program. The first is to generate the key part. The encryption algorithm generates 6 keys, each time the method is generated. transduce the previous key to get the intermediate value t Swap t Continuous iteration 5 times def __init__ ( self , k ): self . k = [ k ] for i in range ( 1 , len ( T )): k = swap ( transduceblock ( k )) self . k . append ( k ) The encryption algorithm is as follows, a total of 6 iterations, the basic process XOR key transduce 2. Exchange def encrypt ( self , b ): for i in range ( len ( T )): b ^= self . k [ i ] b = transduceblock ( b ) b = swap ( b ) return b Through the analysis program, it can be known that the encryption algorithm is a block encryption, and the basic information is as follows Block size is 8 bytes Rounds of 6 rounds The basic operations of each round of the encryption algorithm are transduce and swap. The extension of the key is also related to transduce and swap. more specific swap is to swap the upper 32 bits of the 8 bytes with the lower 32 bits. transduce is XORed to a value bit by bit for each bit of 8 bytes. This value is related to T. Through further analysis, we can find that these two functions are all reversible. That is to say, if we know the final ciphertext, then we can actually shorten the original number of rounds to almost 5 rounds, because the last round of transduce and swap have no effect. We can define the following variables Name Meaning | k_{i,0} k_{i,0} | The upper 32 bits of the key used in the i-th round | | k_{i,1} k_{i,1} | The lower 32 bits of the key used in the i-th round | | d_{i,0} d_{i,0} | The upper 32 bits of the input used by the i-th wheel | | d_{i,1} d_{i,1} | The lower 32 bits of the input used by the i-th wheel | Since one of the core operations is swap, only high or low 32 bits are manipulated, so we can consider it in two parts. The simplified definition is as follows Transduce is simplified to T, although it conflicts with the source code, but we can temporarily understand it. Swap is reduced to S. Then each round of the ciphertext, the key is as follows Number of rounds Left key Left ciphertext Right key Right ciphertext | 0 | k_{0,0} k_{0,0} | d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) d_{1,0}=T(k_{0,1} \\oplus d_{0,1} ,s) | k_{0,1} k_{0,1} | d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) d_{1,1}=T(k_{0,0} \\oplus d_{0,0}) | | 1 | k_{1,0}=T(k_{0,1},s) k_{1,0}=T(k_{0,1},s) | d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) d_{2,0}=T(k_{1,1} \\oplus d_{1,1} ,s) | k_{1,1}=T(k_{0,0}) k_{1,1}=T(k_{0,0}) | d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) d_{2,1}=T(k_{1,0} \\oplus d_{1,0}) | | 2 | k_{2,0}=T(k_{1,1},s) k_{2,0}=T(k_{1,1},s) | d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) d_{3,0}=T(k_{2,1} \\oplus d_{2,1} ,s) | k_{2,1}=T(k_{1,0}) k_{2,1}=T(k_{1,0}) | d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) d_{3,1}=T(k_{2,0} \\oplus d_{2,0}) | | 3 | k_{3,0}=T(k_{2,1},s) k_{3,0}=T(k_{2,1},s) | d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) d_{4,0}=T(k_{3,1} \\oplus d_{3,1} ,s) | k_{3,1}=T(k_{2,0}) k_{3,1}=T(k_{2,0}) | d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) d_{4,1}=T(k_{3,0} \\oplus d_{3,0}) | | 4 | k_{4,0}=T(k_{3,1},s) k_{4,0}=T(k_{3,1},s) | d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) d_{5,0}=T(k_{4,1} \\oplus d_{4,1} ,s) | k_{4,1}=T(k_{3,0}) k_{4,1}=T(k_{3,0}) | d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) d_{5,1}=T(k_{4,0} \\oplus d_{4,0}) | | 5 | k_{5,0}=T(k_{4,1},s) k_{5,0}=T(k_{4,1},s) | d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) d_{6,0}=T(k_{5,1} \\oplus d_{5,1} ,s) | k_{5,1}=T(k_{4,0}) k_{5,1}=T(k_{4,0}) | d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) d_{6,1}=T(k_{5,0} \\oplus d_{5,0}) | Then, we can enumerate the upper 32 bits of k bit by bit and enumerate the possible s status bits when performing the T operation, so that we can get the high 32-bit key. After performing a bit-by-bit blast, we can get two possible results [2659900894, 2659900895] According to the results on the left, you can get the possible results on the right. The possible results obtained with 2659900894 are as follows: # The first set of ciphertexts may have too many corresponding keys. # The second group has a total of 6. [2764038144, 2764038145, 2764038152, 2764038153, 2764038154, 2764038155] # The third group [2764038144, 2764038145] Then in fact, we can manually try to encrypt all the ciphertext, if not, just judge the error directly. This can actually be filtered very quickly. Finally, you can find that the key is 2659900894|2764038145 That is 11624187353095200769. Also got the flag. Of course, this problem can also use the attack method of the middle encounter, that is, the key used in the 0 th round and the key used in the last round are respectively enumerated to make a collision in the third round.","title":"2018 Plaid CTF transducipher"},{"location":"crypto/ctf-wiki/attack-summary/bit-attack/#reference","text":"http://blog.rb-tree.xyz/2018/05/07/plaidctf-2018-transducipher/","title":"Reference"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle-zh/","text":"EN | ZH \u4e2d\u95f4\u76f8\u9047\u653b\u51fb - MITM \u00b6 \u6982\u8ff0 \u00b6 \u4e2d\u95f4\u76f8\u9047\u653b\u51fb\u662f\u4e00\u79cd\u4ee5\u7a7a\u95f4\u6362\u53d6\u65f6\u95f4\u7684\u4e00\u79cd\u653b\u51fb\u65b9\u6cd5\uff0c1977\u5e74\u7531 Diffie \u4e0e Hellman \u63d0\u51fa\u3002\u4ece\u4e2a\u4eba\u89d2\u5ea6\u770b\uff0c\u8005\u66f4\u591a\u5730\u6307\u4e00\u79cd\u601d\u60f3\uff0c\u4e0d\u4ec5\u4ec5\u9002\u7528\u4e8e\u5bc6\u7801\u5b66\u653b\u51fb\uff0c\u4e5f\u9002\u7528\u4e8e\u5176\u4ed6\u65b9\u9762\uff0c\u53ef\u4ee5\u964d\u4f4e\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u3002 \u57fa\u672c\u539f\u7406\u5982\u4e0b \u5047\u8bbe E \u548c D \u5206\u522b\u662f\u52a0\u5bc6\u51fd\u6570\u548c\u89e3\u5bc6\u51fd\u6570\uff0ck1 \u548c k2 \u5206\u522b\u662f\u4e24\u6b21\u52a0\u5bc6\u4f7f\u7528\u7684\u5bc6\u94a5\uff0c\u5219\u6211\u4eec\u6709 C=E_{k_2}(E_{k_1}(P)) C=E_{k_2}(E_{k_1}(P)) P=D_{k_2}(D_{k_1}(C)) P=D_{k_2}(D_{k_1}(C)) \u5219\u6211\u4eec\u53ef\u4ee5\u63a8\u51fa E_{k_1}(P)=D_{k_2}(C) E_{k_1}(P)=D_{k_2}(C) \u90a3\u4e48\uff0c\u5f53\u7528\u6237\u77e5\u9053\u4e00\u5bf9\u660e\u6587\u548c\u5bc6\u6587\u65f6 \u653b\u51fb\u8005\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u7684 k1\uff0c\u5c06 P \u6240\u6709\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u5b58\u50a8\u8d77\u6765\uff0c\u5e76\u6309\u7167\u5bc6\u6587\u7684\u5927\u5c0f\u8fdb\u884c\u6392\u5e8f\u3002 \u653b\u51fb\u8005\u8fdb\u4e00\u6b65\u679a\u4e3e\u6240\u6709\u7684k2\uff0c\u5c06\u5bc6\u6587 C \u8fdb\u884c\u89e3\u5bc6\u5f97\u5230 C1\uff0c\u5728\u7b2c\u4e00\u6b65\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u4e2d\u641c\u7d22 C1\uff0c\u5982\u679c\u641c\u7d22\u5230\uff0c\u5219\u6211\u4eec\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u53ef\u4ee5\u8ba4\u4e3a\u6211\u4eec\u627e\u5230\u4e86\u6b63\u786e\u7684 k1 \u548c k2\u3002 \u5982\u679c\u89c9\u5f97\u7b2c\u4e8c\u6b65\u4e2d\u5f97\u5230\u7684\u7ed3\u679c\u4e0d\u4fdd\u9669\uff0c\u5219\u6211\u4eec\u8fd8\u53ef\u4ee5\u518d\u627e\u4e00\u4e9b\u660e\u5bc6\u6587\u5bf9\u8fdb\u884c\u9a8c\u8bc1\u3002 \u5047\u8bbe k1 \u548c k2 \u7684\u5bc6\u94a5\u957f\u5ea6\u90fd\u4e3a n\uff0c\u5219\u539f\u5148\u6211\u4eec\u66b4\u529b\u679a\u4e3e\u9700\u8981 O(n^2) O(n^2) \uff0c\u73b0\u5728\u6211\u4eec\u53ea\u9700\u8981 O(n log_2n) O(n log_2n) \u3002 \u8fd9\u4e0e 2DES \u7684\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\u7c7b\u4f3c\u3002 \u9898\u76ee \u00b6 2018 \u56fd\u8d5b Crackmec\uff0c\u53c2\u89c1 Wiki AES \u90e8\u5206 2018 Plaid CTF Transducipher\uff0c\u53c2\u89c1\u6bd4\u7279\u653b\u51fb\u90e8\u5206\u7684\u539f\u7406\u3002 2018 \u56fd\u8d5b Crackme java\uff0c\u53c2\u89c1 Wiki \u6574\u6570\u57df\u4e0a\u7684\u79bb\u6563\u5bf9\u6570\u90e8\u5206 2018 WCTF RSA\uff0c\u53c2\u89c1 wiki RSA Complex \u90e8\u5206 \u53c2\u8003\u6587\u732e \u00b6 https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A","title":"Meet in the middle zh"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle-zh/#-mitm","text":"","title":"\u4e2d\u95f4\u76f8\u9047\u653b\u51fb - MITM"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle-zh/#_1","text":"\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\u662f\u4e00\u79cd\u4ee5\u7a7a\u95f4\u6362\u53d6\u65f6\u95f4\u7684\u4e00\u79cd\u653b\u51fb\u65b9\u6cd5\uff0c1977\u5e74\u7531 Diffie \u4e0e Hellman \u63d0\u51fa\u3002\u4ece\u4e2a\u4eba\u89d2\u5ea6\u770b\uff0c\u8005\u66f4\u591a\u5730\u6307\u4e00\u79cd\u601d\u60f3\uff0c\u4e0d\u4ec5\u4ec5\u9002\u7528\u4e8e\u5bc6\u7801\u5b66\u653b\u51fb\uff0c\u4e5f\u9002\u7528\u4e8e\u5176\u4ed6\u65b9\u9762\uff0c\u53ef\u4ee5\u964d\u4f4e\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u3002 \u57fa\u672c\u539f\u7406\u5982\u4e0b \u5047\u8bbe E \u548c D \u5206\u522b\u662f\u52a0\u5bc6\u51fd\u6570\u548c\u89e3\u5bc6\u51fd\u6570\uff0ck1 \u548c k2 \u5206\u522b\u662f\u4e24\u6b21\u52a0\u5bc6\u4f7f\u7528\u7684\u5bc6\u94a5\uff0c\u5219\u6211\u4eec\u6709 C=E_{k_2}(E_{k_1}(P)) C=E_{k_2}(E_{k_1}(P)) P=D_{k_2}(D_{k_1}(C)) P=D_{k_2}(D_{k_1}(C)) \u5219\u6211\u4eec\u53ef\u4ee5\u63a8\u51fa E_{k_1}(P)=D_{k_2}(C) E_{k_1}(P)=D_{k_2}(C) \u90a3\u4e48\uff0c\u5f53\u7528\u6237\u77e5\u9053\u4e00\u5bf9\u660e\u6587\u548c\u5bc6\u6587\u65f6 \u653b\u51fb\u8005\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u7684 k1\uff0c\u5c06 P \u6240\u6709\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u5b58\u50a8\u8d77\u6765\uff0c\u5e76\u6309\u7167\u5bc6\u6587\u7684\u5927\u5c0f\u8fdb\u884c\u6392\u5e8f\u3002 \u653b\u51fb\u8005\u8fdb\u4e00\u6b65\u679a\u4e3e\u6240\u6709\u7684k2\uff0c\u5c06\u5bc6\u6587 C \u8fdb\u884c\u89e3\u5bc6\u5f97\u5230 C1\uff0c\u5728\u7b2c\u4e00\u6b65\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u4e2d\u641c\u7d22 C1\uff0c\u5982\u679c\u641c\u7d22\u5230\uff0c\u5219\u6211\u4eec\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u53ef\u4ee5\u8ba4\u4e3a\u6211\u4eec\u627e\u5230\u4e86\u6b63\u786e\u7684 k1 \u548c k2\u3002 \u5982\u679c\u89c9\u5f97\u7b2c\u4e8c\u6b65\u4e2d\u5f97\u5230\u7684\u7ed3\u679c\u4e0d\u4fdd\u9669\uff0c\u5219\u6211\u4eec\u8fd8\u53ef\u4ee5\u518d\u627e\u4e00\u4e9b\u660e\u5bc6\u6587\u5bf9\u8fdb\u884c\u9a8c\u8bc1\u3002 \u5047\u8bbe k1 \u548c k2 \u7684\u5bc6\u94a5\u957f\u5ea6\u90fd\u4e3a n\uff0c\u5219\u539f\u5148\u6211\u4eec\u66b4\u529b\u679a\u4e3e\u9700\u8981 O(n^2) O(n^2) \uff0c\u73b0\u5728\u6211\u4eec\u53ea\u9700\u8981 O(n log_2n) O(n log_2n) \u3002 \u8fd9\u4e0e 2DES \u7684\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\u7c7b\u4f3c\u3002","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle-zh/#_2","text":"2018 \u56fd\u8d5b Crackmec\uff0c\u53c2\u89c1 Wiki AES \u90e8\u5206 2018 Plaid CTF Transducipher\uff0c\u53c2\u89c1\u6bd4\u7279\u653b\u51fb\u90e8\u5206\u7684\u539f\u7406\u3002 2018 \u56fd\u8d5b Crackme java\uff0c\u53c2\u89c1 Wiki \u6574\u6570\u57df\u4e0a\u7684\u79bb\u6563\u5bf9\u6570\u90e8\u5206 2018 WCTF RSA\uff0c\u53c2\u89c1 wiki RSA Complex \u90e8\u5206","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle-zh/#_3","text":"https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle/","text":"EN | ZH \u4e2d\u9047\u9047\u653b\u51fb- MITM \u00b6 Overview \u00b6 The middle encounter attack is an attack method that exchanges space for time. It was proposed by Diffie and Hellman in 1977. From a personal point of view, people refer more to an idea, not only for cryptographic attacks, but also for other aspects, which can reduce the complexity of the algorithm. The basic principle is as follows Suppose E and D are encryption functions and decryption functions, respectively, k1 and k2 are the keys used for two encryptions respectively, then we have $ C = E k_2 (E k_1 (P)) $ P=D_{k_2}(D_{k_1}(C)) P=D_{k_2}(D_{k_1}(C)) Then we can launch E_{k_1}(P)=D_{k_2}(C) E_{k_1}(P)=D_{k_2}(C) Then, when the user knows a pair of plaintext and ciphertext An attacker can enumerate all k1s, store all the encrypted results of P, and sort them according to the size of the ciphertext. The attacker further enumerates all k2, decrypts ciphertext C to get C1, and searches for C1 in the result of the first step of encryption. If we search, we can think that we have found the correct k1. And k2. If you feel that the results obtained in the second step are not insured, we can also find some clear cipher pairs to verify. Assuming that the key lengths for both k1 and k2 are n, then our violent enumeration would require O(n^2) O(n^2) , now we only need O(n log_2n) O(n log_2n) . This is similar to the middle encounter attack of 2DES. topic \u00b6 2018 National Crackmec, see the Wiki AES section 2018 Plaid CTF Transducipher, see the principle of the bit attack section. 2018 National CrackMe, see the discrete logarithmic part of the Wiki integer field 2018 WCTF RSA, see wiki RSA Complex section references \u00b6 https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A","title":"\u4e2d\u95f4\u76f8\u9047\u653b\u51fb"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle/#-mitm","text":"","title":"\u4e2d\u9047\u9047\u653b\u51fb- MITM"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle/#overview","text":"The middle encounter attack is an attack method that exchanges space for time. It was proposed by Diffie and Hellman in 1977. From a personal point of view, people refer more to an idea, not only for cryptographic attacks, but also for other aspects, which can reduce the complexity of the algorithm. The basic principle is as follows Suppose E and D are encryption functions and decryption functions, respectively, k1 and k2 are the keys used for two encryptions respectively, then we have $ C = E k_2 (E k_1 (P)) $ P=D_{k_2}(D_{k_1}(C)) P=D_{k_2}(D_{k_1}(C)) Then we can launch E_{k_1}(P)=D_{k_2}(C) E_{k_1}(P)=D_{k_2}(C) Then, when the user knows a pair of plaintext and ciphertext An attacker can enumerate all k1s, store all the encrypted results of P, and sort them according to the size of the ciphertext. The attacker further enumerates all k2, decrypts ciphertext C to get C1, and searches for C1 in the result of the first step of encryption. If we search, we can think that we have found the correct k1. And k2. If you feel that the results obtained in the second step are not insured, we can also find some clear cipher pairs to verify. Assuming that the key lengths for both k1 and k2 are n, then our violent enumeration would require O(n^2) O(n^2) , now we only need O(n log_2n) O(n log_2n) . This is similar to the middle encounter attack of 2DES.","title":"Overview"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle/#topic","text":"2018 National Crackmec, see the Wiki AES section 2018 Plaid CTF Transducipher, see the principle of the bit attack section. 2018 National CrackMe, see the discrete logarithmic part of the Wiki integer field 2018 WCTF RSA, see wiki RSA Complex section","title":"topic"},{"location":"crypto/ctf-wiki/attack-summary/meet-in-the-middle/#references","text":"https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%80%94%E7%9B%B8%E9%81%87%E6%94%BB%E6%93%8A","title":"references"},{"location":"crypto/ctf-wiki/basic/introduction-zh/","text":"EN | ZH \u57fa\u7840\u6570\u5b66\u77e5\u8bc6 \u00b6 \u672c\u90e8\u5206\u4f1a\u4ecb\u7ecd\u201c\u57fa\u7840\u6570\u5b66\u77e5\u8bc6\u201c\uff0c\u8fd9\u91cc\u52a0\u4e86\u5f15\u53f7\uff0c\u6240\u4ee5\u5e76\u4e0d\u89c1\u5f97\u771f\u7684\u5f88\u57fa\u7840\u3002\u3002","title":"Introduction zh"},{"location":"crypto/ctf-wiki/basic/introduction-zh/#_1","text":"\u672c\u90e8\u5206\u4f1a\u4ecb\u7ecd\u201c\u57fa\u7840\u6570\u5b66\u77e5\u8bc6\u201c\uff0c\u8fd9\u91cc\u52a0\u4e86\u5f15\u53f7\uff0c\u6240\u4ee5\u5e76\u4e0d\u89c1\u5f97\u771f\u7684\u5f88\u57fa\u7840\u3002\u3002","title":"\u57fa\u7840\u6570\u5b66\u77e5\u8bc6"},{"location":"crypto/ctf-wiki/basic/introduction/","text":"EN | ZH \u57fa\u7840\u6570\u5b66\u77e5\u8bc6 \u00b6 This section will introduce \"Basic Mathematical Knowledge\", which is quoted here, so it is not really true. .","title":"\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/basic/introduction/#_1","text":"This section will introduce \"Basic Mathematical Knowledge\", which is quoted here, so it is not really true. .","title":"\u57fa\u7840\u6570\u5b66\u77e5\u8bc6"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/","text":"EN | ZH AES \u00b6 \u57fa\u672c\u4ecb\u7ecd \u00b6 Advanced Encryption Standard\uff08AES\uff09\uff0c\u9ad8\u7ea7\u52a0\u5bc6\u6807\u51c6\uff0c\u662f\u5178\u578b\u7684\u5757\u52a0\u5bc6\uff0c\u88ab\u8bbe\u8ba1\u6765\u53d6\u4ee3 DES\uff0c\u7531 Joan Daemen \u548c Vincent Rijmen \u6240\u8bbe\u8ba1\u3002\u5176\u57fa\u672c\u4fe1\u606f\u5982\u4e0b \u8f93\u5165\uff1a128 \u6bd4\u7279\u3002 \u8f93\u51fa\uff1a128 \u6bd4\u7279\u3002 SPN \u7f51\u7edc\u7ed3\u6784\u3002 \u5176\u8fed\u4ee3\u8f6e\u6570\u4e0e\u5bc6\u94a5\u957f\u5ea6\u6709\u5173\u7cfb\uff0c\u5982\u4e0b \u5bc6\u94a5\u957f\u5ea6\uff08\u6bd4\u7279\uff09 \u8fed\u4ee3\u8f6e\u6570 128 10 192 12 256 14 \u57fa\u672c\u6d41\u7a0b \u00b6 \u57fa\u672c\u6982\u5ff5 \u00b6 \u5728 AES \u52a0\u89e3\u5bc6\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u4e00\u5757\u90fd\u662f 128 \u6bd4\u7279\uff0c\u6240\u4ee5\u6211\u4eec\u8fd9\u91cc\u660e\u786e\u4e00\u4e9b\u57fa\u672c\u6982\u5ff5\u3002 \u5728 AES \u4e2d\uff0c\u5757\u4e0e State \u4e4b\u95f4\u7684\u8f6c\u6362\u8fc7\u7a0b\u5982\u4e0b \u6240\u4ee5\uff0c\u53ef\u4ee5\u770b\u51fa\uff0c\u6bcf\u4e00\u4e2a block \u4e2d\u7684\u5b57\u8282\u662f\u6309\u7167\u5217\u6392\u5217\u8fdb\u5165\u5230\u72b6\u6001\u6570\u7ec4\u7684\u3002 \u800c\u5bf9\u4e8e\u660e\u6587\u6765\u8bf4\uff0c\u4e00\u822c\u6211\u4eec\u4f1a\u9009\u62e9\u4f7f\u7528\u5176\u5341\u516d\u8fdb\u5236\u8fdb\u884c\u7f16\u7801\u3002 \u52a0\u89e3\u5bc6\u8fc7\u7a0b \u00b6 \u8fd9\u91cc\u7ed9\u4e2a\u770b\u96ea\u4e0a\u6bd4\u8f83\u597d\u7684 \u56fe\u4f8b \uff0c\u4ee5\u4fbf\u4e8e\u4ecb\u7ecd\u57fa\u672c\u7684\u6d41\u7a0b\uff0c\u6bcf\u4e00\u8f6e\u4e3b\u8981\u5305\u62ec \u8f6e\u5bc6\u94a5\u52a0\uff0cAddRoundKey \u5b57\u8282\u66ff\u6362\uff0cSubBytes \u884c\u79fb\u4f4d\uff0cShiftRows \u5217\u6df7\u6dc6\uff0cMixColumns \u4e0a\u9762\u7684\u5217\u6df7\u6dc6\u7684\u77e9\u9635\u4e58\u6cd5\u7b49\u53f7\u5de6\u8fb9\u7684\u5217\u5411\u91cf\u5e94\u8be5\u5728\u53f3\u8fb9\u3002 \u8fd9\u91cc\u518d\u7ed9\u4e00\u5f20\u5176\u52a0\u89e3\u5bc6\u7684\u5168\u56fe\uff0c\u5176\u89e3\u5bc6\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u5f88\u663e\u7136\u3002 \u6211\u4eec\u8fd9\u91cc\u91cd\u70b9\u5173\u6ce8\u4e00\u4e0b\u4ee5\u4e0b\u3002 \u5b57\u8282\u66ff\u6362 \u00b6 \u5728\u5b57\u8282\u66ff\u6362\u7684\u80cc\u540e\uff0c\u5176\u5b9e\u662f\u6709\u5bf9\u5e94\u7684\u6570\u5b66\u89c4\u5219\u6765\u5b9a\u4e49\u5bf9\u5e94\u7684\u66ff\u6362\u8868\u7684\uff0c\u5982\u4e0b \u8fd9\u91cc\u7684\u8fd0\u7b97\u5747\u5b9a\u4e49\u5728 GF(2^8) GF(2^8) \u5185\u3002 \u5217\u6df7\u6dc6 \u00b6 \u8fd9\u91cc\u7684\u8fd0\u7b97\u4e5f\u662f\u5b9a\u4e49\u5728 GF(2^8) GF(2^8) \u4e0a\uff0c\u4f7f\u7528\u7684\u6a21\u591a\u9879\u5f0f\u4e3a x^8+x^4+x^3+1 x^8+x^4+x^3+1 \u3002 \u5bc6\u94a5\u6269\u5c55 \u00b6 \u7b49\u4ef7\u89e3\u5bc6\u7b97\u6cd5 \u00b6 \u7b80\u5355\u5206\u6790\u4e00\u4e0b\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 \u4ea4\u6362\u9006\u5411\u884c\u79fb\u4f4d\u548c\u9006\u5411\u5b57\u8282\u4ee3\u66ff\u5e76\u4e0d\u5f71\u54cd\u7ed3\u679c\u3002 \u4ea4\u6362\u8f6e\u5bc6\u94a5\u52a0\u548c\u9006\u5411\u5217\u6df7\u6dc6\u5e76\u4e0d\u5f71\u54cd\u7ed3\u679c\uff0c\u5173\u952e\u5728\u4e8e \u9996\u5148\u53ef\u4ee5\u628a\u5f02\u6216\u770b\u6210\u57df\u4e0a\u7684\u591a\u9879\u5f0f\u52a0\u6cd5 \u7136\u540e\u591a\u9879\u5f0f\u4e2d\u4e58\u6cd5\u5bf9\u52a0\u6cd5\u5177\u6709\u5206\u914d\u7387\u3002 \u653b\u51fb\u65b9\u6cd5 \u00b6 \u79ef\u5206\u653b\u51fb 2018 \u56fd\u8d5b Crackmec \u00b6 \u901a\u8fc7\u7b80\u5355\u5206\u6790\u8fd9\u4e2a\u7b97\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e2a\u7b97\u6cd5\u662f\u4e00\u4e2a\u7b80\u5316\u7248\u7684 AES\uff0c\u5176\u57fa\u672c\u64cd\u4f5c\u4e3a 9 \u8f6e\u8fed\u4ee3 \u884c\u79fb\u4f4d \u53d8\u79cd\u5b57\u8282\u66ff\u6362 \u5982\u4e0b memcpy ( cipher , plain , 0x10uLL ); for ( i = 0LL ; i <= 8 ; ++ i ) { shift_row ( cipher ); for ( j = 0LL ; j <= 3 ; ++ j ) * ( _DWORD * ) & cipher [ 4 * j ] = box [(( 4 * j + 3 + 16 * i ) << 8 ) + ( unsigned __int8 ) cipher [ 4 * j + 3 ]] ^ box [(( 4 * j + 2 + 16 * i ) << 8 ) + ( unsigned __int8 ) cipher [ 4 * j + 2 ]] ^ box [(( 4 * j + 1 + 16 * i ) << 8 ) + ( unsigned __int8 ) cipher [ 4 * j + 1 ]] ^ box [(( 4 * j + 16 * i ) << 8 ) + ( unsigned __int8 ) cipher [ 4 * j ]]; } result = shift_row ( cipher ); for ( k = 0LL ; k <= 0xF ; ++ k ) { result = subbytes [ 256 * k + ( unsigned __int8 ) cipher [ k ]]; cipher [ k ] = result ; } return result ; \u6839\u636e\u7a0b\u5e8f\u6d41\u7a0b\uff0c\u6211\u4eec\u5df2\u77e5\u7a0b\u5e8f\u52a0\u5bc6\u7684\u7ed3\u679c\uff0c\u800c subbytes \u548c shift_row \u53c8\u662f\u53ef\u9006\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6\u6700\u540e\u4e00\u8f6e\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u3002\u6b64\u65f6\uff0c\u6211\u4eec\u8fd8\u77e5\u9053 box \u5bf9\u5e94\u7684\u5e38\u6570\uff0c\u6211\u4eec\u53ea\u662f\u4e0d\u77e5\u9053\u4e0a\u4e00\u8f6e\u4e2d cipher[4*j] \u5bf9\u5e94\u7684\u503c\uff0c\u4e00\u5171 32 \u4f4d\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u7206\u7834\u7684\u8bdd\uff0c\u663e\u7136\u4e0d\u53ef\u53d6\uff0c\u56e0\u4e3a\u6bcf\u4e00\u8f6e\u90fd\u9700\u8981\u8fd9\u4e48\u7206\u7834\uff0c\u65f6\u95f4\u4e0d\u53ef\u63a5\u53d7\u3002\u90a3\u4e48\u6709\u6ca1\u6709\u5176\u5b83\u529e\u6cd5\u5462\uff1f\u5176\u5b9e\u6709\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\uff0c\u5373\u9996\u5148\u679a\u4e3e\u6240\u6709\u7684 cipher[4*j] \u4e0e cipher[4*j+1] \u7684\u5b57\u8282\u7ec4\u5408\uff0c\u4e00\u5171256*256 \u79cd\u3002\u5728\u679a\u4e3e\u5269\u4e0b\u4e24\u4e2a\u5b57\u8282\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u8ba1\u7b97\u51fa\u5176\u4e0e\u5bc6\u6587\u7684\u5f02\u6216\u503c\uff0c\u7136\u540e\u53bb\u4e4b\u524d\u7684\u7ec4\u5408\u4e2d\u627e\uff0c\u5982\u679c\u627e\u5230\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u8ba4\u4e3a\u662f\u6b63\u786e\u7684\u3002\u8fd9\u6837\u590d\u6742\u5ea6\u77ac\u95f4\u964d\u5230 O(2^{16}) O(2^{16}) \u3002 \u4ee3\u7801\u5982\u4e0b encflag = [ 0x16 , 0xEA , 0xCA , 0xCC , 0xDA , 0xC8 , 0xDE , 0x1B , 0x16 , 0x03 , 0xF8 , 0x84 , 0x69 , 0x23 , 0xB2 , 0x25 ] subbytebox = eval ( open ( './subbytes' ) . read ()) box = eval ( open ( './box' ) . read ()) print subbytebox [ - 1 ], box [ - 1 ] def inv_shift_row ( now ): tmp = now [ 13 ] now [ 13 ] = now [ 9 ] now [ 9 ] = now [ 5 ] now [ 5 ] = now [ 1 ] now [ 1 ] = tmp tmp = now [ 10 ] now [ 10 ] = now [ 2 ] now [ 2 ] = tmp tmp = now [ 14 ] now [ 14 ] = now [ 6 ] now [ 6 ] = tmp tmp = now [ 15 ] now [ 15 ] = now [ 3 ] now [ 3 ] = now [ 7 ] now [ 7 ] = now [ 11 ] now [ 11 ] = tmp return now def byte2num ( a ): num = 0 for i in range ( 3 , - 1 , - 1 ): num = num * 256 num += a [ i ] return num def getbytes ( i , j , target ): \"\"\" box[((4 * j + 3 + 16 * i) << 8) + a2[4 * j + 3]] box[((4 * j + 2 + 16 * i) << 8 )+ a2[4 * j + 2]] box[((4 * j + 1 + 16 * i) << 8) + a2[4 * j + 1]] box[((4 * j + 16 * i) << 8) + a2[4 * j]]; \"\"\" box01 = dict () for c0 in range ( 256 ): for c1 in range ( 256 ): num0 = (( 4 * j + 16 * i ) << 8 ) + c0 num1 = (( 4 * j + 1 + 16 * i ) << 8 ) + c1 num = box [ num0 ] ^ box [ num1 ] box01 [ num ] = ( c0 , c1 ) for c2 in range ( 256 ): for c3 in range ( 256 ): num2 = (( 4 * j + 2 + 16 * i ) << 8 ) + c2 num3 = (( 4 * j + 3 + 16 * i ) << 8 ) + c3 num = box [ num2 ] ^ box [ num3 ] calc = num ^ target if calc in box01 : c0 , c1 = box01 [ calc ] return c0 , c1 , c2 , c3 print 'not found' print i , j , target , calc exit ( 0 ) def solve (): a2 = [ 0 ] * 16 \"\"\" for ( k = 0LL; k <= 0xF; ++k ) { result = subbytesbox[256 * k + a2[k]]; a2[k] = result; } \"\"\" for i in range ( 15 , - 1 , - 1 ): tag = 0 for j in range ( 256 ): if subbytebox [ 256 * i + j ] == encflag [ i ]: # j = a2[k] tag += 1 a2 [ i ] = j if tag == 2 : print 'two number' , i exit ( 0 ) \"\"\" result = shift_row(a2); \"\"\" a2 = inv_shift_row ( a2 ) \"\"\" for ( i = 0LL; i <= 8; ++i ) { shift_row(a2); for ( j = 0LL; j <= 3; ++j ) *(_DWORD *)&a2[4 * j] = box[((4 * j + 3 + 16 * i) << 8) + a2[4 * j + 3]] ^ box[((4 * j + 2 + 16 * i) << 8) + a2[4 * j + 2]] ^ box[((4 * j + 1 + 16 * i) << 8) + a2[4 * j + 1]] ^ box[((4 * j + 16 * i) << 8) + a2[4 * j]]; } \"\"\" for i in range ( 8 , - 1 , - 1 ): tmp = [ 0 ] * 16 print 'round ' , i for j in range ( 0 , 4 ): num = byte2num ( a2 [ 4 * j : 4 * j + 4 ]) #print num, a2[4 * j:4 * j + 4] tmp [ 4 * j ], tmp [ 4 * j + 1 ], tmp [ 4 * j + 2 ], tmp [ 4 * j + 3 ] = getbytes ( i , j , num ) a2 = inv_shift_row ( tmp ) print a2 print '' . join ( chr ( c ) for c in a2 ) if __name__ == \"__main__\" : solve () \u8fd0\u884c\u7ed3\u679c \u279c cracemec git: ( master ) \u2717 python exp.py 211 3549048324 round 8 round 7 round 6 round 5 round 4 round 3 round 2 round 1 round 0 [ 67 , 73 , 83 , 67 , 78 , 98 , 35 , 97 , 100 , 102 , 115 , 64 , 70 , 122 , 57 , 51 ] CISCNb#adfs@Fz93 \u9898\u76ee \u00b6 2018 \u5f3a\u7f51\u676f \u51b3\u8d5b revolver \u53c2\u8003\u6587\u732e \u00b6 https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86 Cryptography and Network Security\uff0c Advanced Encryption Standard ppt","title":"Aes zh"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#aes","text":"","title":"AES"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_1","text":"Advanced Encryption Standard\uff08AES\uff09\uff0c\u9ad8\u7ea7\u52a0\u5bc6\u6807\u51c6\uff0c\u662f\u5178\u578b\u7684\u5757\u52a0\u5bc6\uff0c\u88ab\u8bbe\u8ba1\u6765\u53d6\u4ee3 DES\uff0c\u7531 Joan Daemen \u548c Vincent Rijmen \u6240\u8bbe\u8ba1\u3002\u5176\u57fa\u672c\u4fe1\u606f\u5982\u4e0b \u8f93\u5165\uff1a128 \u6bd4\u7279\u3002 \u8f93\u51fa\uff1a128 \u6bd4\u7279\u3002 SPN \u7f51\u7edc\u7ed3\u6784\u3002 \u5176\u8fed\u4ee3\u8f6e\u6570\u4e0e\u5bc6\u94a5\u957f\u5ea6\u6709\u5173\u7cfb\uff0c\u5982\u4e0b \u5bc6\u94a5\u957f\u5ea6\uff08\u6bd4\u7279\uff09 \u8fed\u4ee3\u8f6e\u6570 128 10 192 12 256 14","title":"\u57fa\u672c\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_2","text":"","title":"\u57fa\u672c\u6d41\u7a0b"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_3","text":"\u5728 AES \u52a0\u89e3\u5bc6\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u4e00\u5757\u90fd\u662f 128 \u6bd4\u7279\uff0c\u6240\u4ee5\u6211\u4eec\u8fd9\u91cc\u660e\u786e\u4e00\u4e9b\u57fa\u672c\u6982\u5ff5\u3002 \u5728 AES \u4e2d\uff0c\u5757\u4e0e State \u4e4b\u95f4\u7684\u8f6c\u6362\u8fc7\u7a0b\u5982\u4e0b \u6240\u4ee5\uff0c\u53ef\u4ee5\u770b\u51fa\uff0c\u6bcf\u4e00\u4e2a block \u4e2d\u7684\u5b57\u8282\u662f\u6309\u7167\u5217\u6392\u5217\u8fdb\u5165\u5230\u72b6\u6001\u6570\u7ec4\u7684\u3002 \u800c\u5bf9\u4e8e\u660e\u6587\u6765\u8bf4\uff0c\u4e00\u822c\u6211\u4eec\u4f1a\u9009\u62e9\u4f7f\u7528\u5176\u5341\u516d\u8fdb\u5236\u8fdb\u884c\u7f16\u7801\u3002","title":"\u57fa\u672c\u6982\u5ff5"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_4","text":"\u8fd9\u91cc\u7ed9\u4e2a\u770b\u96ea\u4e0a\u6bd4\u8f83\u597d\u7684 \u56fe\u4f8b \uff0c\u4ee5\u4fbf\u4e8e\u4ecb\u7ecd\u57fa\u672c\u7684\u6d41\u7a0b\uff0c\u6bcf\u4e00\u8f6e\u4e3b\u8981\u5305\u62ec \u8f6e\u5bc6\u94a5\u52a0\uff0cAddRoundKey \u5b57\u8282\u66ff\u6362\uff0cSubBytes \u884c\u79fb\u4f4d\uff0cShiftRows \u5217\u6df7\u6dc6\uff0cMixColumns \u4e0a\u9762\u7684\u5217\u6df7\u6dc6\u7684\u77e9\u9635\u4e58\u6cd5\u7b49\u53f7\u5de6\u8fb9\u7684\u5217\u5411\u91cf\u5e94\u8be5\u5728\u53f3\u8fb9\u3002 \u8fd9\u91cc\u518d\u7ed9\u4e00\u5f20\u5176\u52a0\u89e3\u5bc6\u7684\u5168\u56fe\uff0c\u5176\u89e3\u5bc6\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u5f88\u663e\u7136\u3002 \u6211\u4eec\u8fd9\u91cc\u91cd\u70b9\u5173\u6ce8\u4e00\u4e0b\u4ee5\u4e0b\u3002","title":"\u52a0\u89e3\u5bc6\u8fc7\u7a0b"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_5","text":"\u5728\u5b57\u8282\u66ff\u6362\u7684\u80cc\u540e\uff0c\u5176\u5b9e\u662f\u6709\u5bf9\u5e94\u7684\u6570\u5b66\u89c4\u5219\u6765\u5b9a\u4e49\u5bf9\u5e94\u7684\u66ff\u6362\u8868\u7684\uff0c\u5982\u4e0b \u8fd9\u91cc\u7684\u8fd0\u7b97\u5747\u5b9a\u4e49\u5728 GF(2^8) GF(2^8) \u5185\u3002","title":"\u5b57\u8282\u66ff\u6362"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_6","text":"\u8fd9\u91cc\u7684\u8fd0\u7b97\u4e5f\u662f\u5b9a\u4e49\u5728 GF(2^8) GF(2^8) \u4e0a\uff0c\u4f7f\u7528\u7684\u6a21\u591a\u9879\u5f0f\u4e3a x^8+x^4+x^3+1 x^8+x^4+x^3+1 \u3002","title":"\u5217\u6df7\u6dc6"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_7","text":"","title":"\u5bc6\u94a5\u6269\u5c55"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_8","text":"\u7b80\u5355\u5206\u6790\u4e00\u4e0b\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 \u4ea4\u6362\u9006\u5411\u884c\u79fb\u4f4d\u548c\u9006\u5411\u5b57\u8282\u4ee3\u66ff\u5e76\u4e0d\u5f71\u54cd\u7ed3\u679c\u3002 \u4ea4\u6362\u8f6e\u5bc6\u94a5\u52a0\u548c\u9006\u5411\u5217\u6df7\u6dc6\u5e76\u4e0d\u5f71\u54cd\u7ed3\u679c\uff0c\u5173\u952e\u5728\u4e8e \u9996\u5148\u53ef\u4ee5\u628a\u5f02\u6216\u770b\u6210\u57df\u4e0a\u7684\u591a\u9879\u5f0f\u52a0\u6cd5 \u7136\u540e\u591a\u9879\u5f0f\u4e2d\u4e58\u6cd5\u5bf9\u52a0\u6cd5\u5177\u6709\u5206\u914d\u7387\u3002","title":"\u7b49\u4ef7\u89e3\u5bc6\u7b97\u6cd5"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_9","text":"\u79ef\u5206\u653b\u51fb","title":"\u653b\u51fb\u65b9\u6cd5"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#2018-crackmec","text":"\u901a\u8fc7\u7b80\u5355\u5206\u6790\u8fd9\u4e2a\u7b97\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e2a\u7b97\u6cd5\u662f\u4e00\u4e2a\u7b80\u5316\u7248\u7684 AES\uff0c\u5176\u57fa\u672c\u64cd\u4f5c\u4e3a 9 \u8f6e\u8fed\u4ee3 \u884c\u79fb\u4f4d \u53d8\u79cd\u5b57\u8282\u66ff\u6362 \u5982\u4e0b memcpy ( cipher , plain , 0x10uLL ); for ( i = 0LL ; i <= 8 ; ++ i ) { shift_row ( cipher ); for ( j = 0LL ; j <= 3 ; ++ j ) * ( _DWORD * ) & cipher [ 4 * j ] = box [(( 4 * j + 3 + 16 * i ) << 8 ) + ( unsigned __int8 ) cipher [ 4 * j + 3 ]] ^ box [(( 4 * j + 2 + 16 * i ) << 8 ) + ( unsigned __int8 ) cipher [ 4 * j + 2 ]] ^ box [(( 4 * j + 1 + 16 * i ) << 8 ) + ( unsigned __int8 ) cipher [ 4 * j + 1 ]] ^ box [(( 4 * j + 16 * i ) << 8 ) + ( unsigned __int8 ) cipher [ 4 * j ]]; } result = shift_row ( cipher ); for ( k = 0LL ; k <= 0xF ; ++ k ) { result = subbytes [ 256 * k + ( unsigned __int8 ) cipher [ k ]]; cipher [ k ] = result ; } return result ; \u6839\u636e\u7a0b\u5e8f\u6d41\u7a0b\uff0c\u6211\u4eec\u5df2\u77e5\u7a0b\u5e8f\u52a0\u5bc6\u7684\u7ed3\u679c\uff0c\u800c subbytes \u548c shift_row \u53c8\u662f\u53ef\u9006\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6\u6700\u540e\u4e00\u8f6e\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u3002\u6b64\u65f6\uff0c\u6211\u4eec\u8fd8\u77e5\u9053 box \u5bf9\u5e94\u7684\u5e38\u6570\uff0c\u6211\u4eec\u53ea\u662f\u4e0d\u77e5\u9053\u4e0a\u4e00\u8f6e\u4e2d cipher[4*j] \u5bf9\u5e94\u7684\u503c\uff0c\u4e00\u5171 32 \u4f4d\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u7206\u7834\u7684\u8bdd\uff0c\u663e\u7136\u4e0d\u53ef\u53d6\uff0c\u56e0\u4e3a\u6bcf\u4e00\u8f6e\u90fd\u9700\u8981\u8fd9\u4e48\u7206\u7834\uff0c\u65f6\u95f4\u4e0d\u53ef\u63a5\u53d7\u3002\u90a3\u4e48\u6709\u6ca1\u6709\u5176\u5b83\u529e\u6cd5\u5462\uff1f\u5176\u5b9e\u6709\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\uff0c\u5373\u9996\u5148\u679a\u4e3e\u6240\u6709\u7684 cipher[4*j] \u4e0e cipher[4*j+1] \u7684\u5b57\u8282\u7ec4\u5408\uff0c\u4e00\u5171256*256 \u79cd\u3002\u5728\u679a\u4e3e\u5269\u4e0b\u4e24\u4e2a\u5b57\u8282\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u8ba1\u7b97\u51fa\u5176\u4e0e\u5bc6\u6587\u7684\u5f02\u6216\u503c\uff0c\u7136\u540e\u53bb\u4e4b\u524d\u7684\u7ec4\u5408\u4e2d\u627e\uff0c\u5982\u679c\u627e\u5230\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u8ba4\u4e3a\u662f\u6b63\u786e\u7684\u3002\u8fd9\u6837\u590d\u6742\u5ea6\u77ac\u95f4\u964d\u5230 O(2^{16}) O(2^{16}) \u3002 \u4ee3\u7801\u5982\u4e0b encflag = [ 0x16 , 0xEA , 0xCA , 0xCC , 0xDA , 0xC8 , 0xDE , 0x1B , 0x16 , 0x03 , 0xF8 , 0x84 , 0x69 , 0x23 , 0xB2 , 0x25 ] subbytebox = eval ( open ( './subbytes' ) . read ()) box = eval ( open ( './box' ) . read ()) print subbytebox [ - 1 ], box [ - 1 ] def inv_shift_row ( now ): tmp = now [ 13 ] now [ 13 ] = now [ 9 ] now [ 9 ] = now [ 5 ] now [ 5 ] = now [ 1 ] now [ 1 ] = tmp tmp = now [ 10 ] now [ 10 ] = now [ 2 ] now [ 2 ] = tmp tmp = now [ 14 ] now [ 14 ] = now [ 6 ] now [ 6 ] = tmp tmp = now [ 15 ] now [ 15 ] = now [ 3 ] now [ 3 ] = now [ 7 ] now [ 7 ] = now [ 11 ] now [ 11 ] = tmp return now def byte2num ( a ): num = 0 for i in range ( 3 , - 1 , - 1 ): num = num * 256 num += a [ i ] return num def getbytes ( i , j , target ): \"\"\" box[((4 * j + 3 + 16 * i) << 8) + a2[4 * j + 3]] box[((4 * j + 2 + 16 * i) << 8 )+ a2[4 * j + 2]] box[((4 * j + 1 + 16 * i) << 8) + a2[4 * j + 1]] box[((4 * j + 16 * i) << 8) + a2[4 * j]]; \"\"\" box01 = dict () for c0 in range ( 256 ): for c1 in range ( 256 ): num0 = (( 4 * j + 16 * i ) << 8 ) + c0 num1 = (( 4 * j + 1 + 16 * i ) << 8 ) + c1 num = box [ num0 ] ^ box [ num1 ] box01 [ num ] = ( c0 , c1 ) for c2 in range ( 256 ): for c3 in range ( 256 ): num2 = (( 4 * j + 2 + 16 * i ) << 8 ) + c2 num3 = (( 4 * j + 3 + 16 * i ) << 8 ) + c3 num = box [ num2 ] ^ box [ num3 ] calc = num ^ target if calc in box01 : c0 , c1 = box01 [ calc ] return c0 , c1 , c2 , c3 print 'not found' print i , j , target , calc exit ( 0 ) def solve (): a2 = [ 0 ] * 16 \"\"\" for ( k = 0LL; k <= 0xF; ++k ) { result = subbytesbox[256 * k + a2[k]]; a2[k] = result; } \"\"\" for i in range ( 15 , - 1 , - 1 ): tag = 0 for j in range ( 256 ): if subbytebox [ 256 * i + j ] == encflag [ i ]: # j = a2[k] tag += 1 a2 [ i ] = j if tag == 2 : print 'two number' , i exit ( 0 ) \"\"\" result = shift_row(a2); \"\"\" a2 = inv_shift_row ( a2 ) \"\"\" for ( i = 0LL; i <= 8; ++i ) { shift_row(a2); for ( j = 0LL; j <= 3; ++j ) *(_DWORD *)&a2[4 * j] = box[((4 * j + 3 + 16 * i) << 8) + a2[4 * j + 3]] ^ box[((4 * j + 2 + 16 * i) << 8) + a2[4 * j + 2]] ^ box[((4 * j + 1 + 16 * i) << 8) + a2[4 * j + 1]] ^ box[((4 * j + 16 * i) << 8) + a2[4 * j]]; } \"\"\" for i in range ( 8 , - 1 , - 1 ): tmp = [ 0 ] * 16 print 'round ' , i for j in range ( 0 , 4 ): num = byte2num ( a2 [ 4 * j : 4 * j + 4 ]) #print num, a2[4 * j:4 * j + 4] tmp [ 4 * j ], tmp [ 4 * j + 1 ], tmp [ 4 * j + 2 ], tmp [ 4 * j + 3 ] = getbytes ( i , j , num ) a2 = inv_shift_row ( tmp ) print a2 print '' . join ( chr ( c ) for c in a2 ) if __name__ == \"__main__\" : solve () \u8fd0\u884c\u7ed3\u679c \u279c cracemec git: ( master ) \u2717 python exp.py 211 3549048324 round 8 round 7 round 6 round 5 round 4 round 3 round 2 round 1 round 0 [ 67 , 73 , 83 , 67 , 78 , 98 , 35 , 97 , 100 , 102 , 115 , 64 , 70 , 122 , 57 , 51 ] CISCNb#adfs@Fz93","title":"2018 \u56fd\u8d5b Crackmec"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_10","text":"2018 \u5f3a\u7f51\u676f \u51b3\u8d5b revolver","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/blockcipher/aes-zh/#_11","text":"https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86 Cryptography and Network Security\uff0c Advanced Encryption Standard ppt","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/","text":"EN | ZH Add-Rotate-Xor \u00b6 \u6982\u8ff0 \u00b6 ARX \u8fd0\u7b97\u662f\u5982\u4e0b 3 \u79cd\u57fa\u672c\u8fd0\u7b97\u7684\u7edf\u79f0 - Add \u6709\u9650\u57df\u4e0a\u7684\u6a21\u52a0 - Rotate \u5faa\u73af\u79fb\u4f4d - Xor \u5f02\u6216 \u6709\u8bb8\u591a\u5e38\u89c1\u7684\u5757\u52a0\u5bc6\u7b97\u6cd5\u5728\u8f6e\u51fd\u6570\u4e2d\u53ea\u7528\u5230\u4e86\u8fd9 3 \u79cd\u57fa\u672c\u8fd0\u7b97\uff0c\u5178\u578b\u4f8b\u5b50\u5982 Salsa20\u3001Speck \u7b49\u3002\u53e6\u5916 IDEA \u4e5f\u91c7\u7528\u4e86\u7c7b\u4f3c\u7684\u57fa\u672c\u8fd0\u7b97\u6765\u6784\u5efa\u52a0\u89e3\u5bc6\u64cd\u4f5c\uff0c\u4e0d\u8fc7\u4ee5\u4e58\u6cd5\u4ee3\u66ff\u4e86\u79fb\u4f4d\u3002 \u4f18\u7f3a\u70b9 \u00b6 \u4f18\u70b9 \u00b6 \u64cd\u4f5c\u7b80\u5355\uff0c\u8fd0\u7b97\u901f\u5ea6\u5feb \u6267\u884c\u65f6\u95f4\u4e3a\u5e38\u6570\uff0c\u53ef\u4ee5\u907f\u514d\u57fa\u4e8e\u65f6\u95f4\u7684\u6d4b\u4fe1\u9053\u653b\u51fb \u7ec4\u5408\u540e\u7684\u51fd\u6570\u8868\u8fbe\u80fd\u529b\u8db3\u591f\u5f3a\uff08\u53c2\u89c1\u4e0b\u65b9\u4f8b\u9898\uff09 \u7f3a\u70b9 \u00b6 \u5728\u4e09\u79cd\u57fa\u672c\u8fd0\u7b97\u5f53\u4e2d\uff0cRotate\u3001Xor \u5bf9\u4e8e\u5355\u4e2a bit \u6765\u8bf4\u5747\u662f\u5b8c\u5168\u7ebf\u6027\u7684\u8fd0\u7b97\uff0c\u53ef\u80fd\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u8106\u5f31\u6027(\u53c2\u89c1 Rotational cryptanalysis ) \u9898\u76ee \u00b6 2018 *ctf primitive \u00b6 \u5206\u6790 \u00b6 \u672c\u9898\u8981\u6c42\u6211\u4eec\u7ec4\u5408\u4e00\u5b9a\u6570\u76ee\u4ee5\u5185\u7684 Add-Rotate-Xor \u8fd0\u7b97\uff0c\u4f7f\u5f97\u83b7\u5f97\u7684\u52a0\u5bc6\u7b97\u6cd5\u80fd\u591f\u5c06\u56fa\u5b9a\u660e\u6587\u52a0\u5bc6\u6210\u6307\u5b9a\u7684\u968f\u673a\u5bc6\u6587\uff0c\u5373\u901a\u8fc7\u57fa\u7840\u8fd0\u7b97\u6765\u6784\u5efa\u4efb\u610f\u7f6e\u6362\u51fd\u6570\u3002\u6210\u529f\u6784\u5efa 3 \u6b21\u4e4b\u540e\u5373\u53ef\u83b7\u5f97 flag\u3002 \u89e3\u9898\u601d\u8def \u00b6 \u5bf9\u4e8e\u6a21 256 \u4e0b\u7684\u8fd0\u7b97\uff0c\u4e00\u79cd\u5178\u578b\u7684\u57fa\u4e8e ARX \u7684\u6362\u4f4d\u64cd\u4f5c\u53ef\u4ee5\u8868\u793a\u4e3a\u5982\u4e0b\u7ec4\u5408 RotateLeft_1(Add_255(RotateLeft_7(Add_2(x)))) \u4e0a\u8ff0\u51fd\u6570\u5bf9\u5e94\u4e86\u4e00\u4e2a\u5c06 254 \u548c 255 \u8fdb\u884c\u4ea4\u6362\uff0c\u540c\u65f6\u4fdd\u6301\u5176\u5b83\u6570\u5b57\u4e0d\u53d8\u7684\u7f6e\u6362\u8fd0\u7b97\u3002 \u76f4\u89c9\u4e0a\u6765\u8bf4\uff0c\u7531\u4e8e\u5728\u7b2c\u4e00\u6b65\u7684\u6a21\u52a0 2 \u8fd0\u7b97\u4e2d\uff0c\u4ec5\u6709\u8f93\u5165\u4e3a 254\u3001255 \u65f6\u4f1a\u53d1\u751f\u8fdb\u4f4d\uff0c\u8be5\u7ec4\u5408\u51fd\u6570\u5f97\u4ee5\u533a\u522b\u5bf9\u5f85\u8fd9\u4e00\u60c5\u51b5\u3002 \u5229\u7528\u4e0a\u8ff0\u539f\u5b50\u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u6784\u9020\u51fa\u4efb\u610f\u4e24\u4e2a\u6570\u5b57 a,b \u7684\u7f6e\u6362\uff0c\u7ed3\u5408 Xor \u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u51cf\u5c11\u6240\u9700\u7684\u57fa\u672c\u64cd\u4f5c\u6570\u76ee\uff0c\u4f7f\u5176\u6ee1\u8db3\u9898\u76ee\u7ed9\u51fa\u7684\u9650\u5236\u3002\u4e00\u79cd\u53ef\u80fd\u7684\u64cd\u4f5c\u6b65\u9aa4\u5982\u4e0b\uff1a \u5bf9\u4e8e a,b \uff0c\u901a\u8fc7\u6a21\u52a0\u64cd\u4f5c\u4f7f\u5f97 a \u4e3a0 \u901a\u8fc7\u53f3\u79fb\u4f7f\u5f97b\u7684\u6700\u4f4e\u4f4d\u4e3a 1 \u82e5 b \u4e0d\u4e3a 1\uff0c\u8fdb\u884c Xor 1, Add 255 \u64cd\u4f5c\uff0c\u4fdd\u6301 a \u4ecd\u7136\u4e3a0\uff0c\u540c\u65f6 b \u7684\u6570\u503c\u51cf\u5c0f \u91cd\u590d\u64cd\u4f5c2-3\u76f4\u81f3 b \u4e3a1 \u8fdb\u884c Add 254 \u53ca\u6362\u4f4d\u64cd\u4f5c\uff0c\u4ea4\u6362 a,b \u5bf9\u4e8e\u6362\u4f4d\u4ee5\u5916\u7684\u6240\u6709\u64cd\u4f5c\uff0c\u52a0\u5165\u5bf9\u5e94\u7684\u9006\u8fd0\u7b97\uff0c\u786e\u4fdd a,b \u4ee5\u5916\u7684\u6570\u503c\u4e0d\u53d8 \u5b8c\u6574\u7684\u89e3\u9898\u811a\u672c\u5982\u4e0b\uff1a from pwn import * import string from hashlib import sha256 #context.log_level='debug' def dopow (): chal = c . recvline () post = chal [ 12 : 28 ] tar = chal [ 33 : - 1 ] c . recvuntil ( ':' ) found = iters . bruteforce ( lambda x : sha256 ( x + post ) . hexdigest () == tar , string . ascii_letters + string . digits , 4 ) c . sendline ( found ) #c = remote('127.0.0.1',10001) c = remote ( '47.75.4.252' , 10001 ) dopow () pt = 'GoodCipher' def doswap ( a , b ): if a == b : return if a > b : tmp = b b = a a = tmp ans = [] ans . append (( 0 , 256 - a )) b -= a a = 0 while b != 1 : tmp = 0 lo = 1 while b & lo == 0 : lo <<= 1 tmp += 1 if b == lo : ans . append (( 1 , 8 - tmp )) break if tmp != 0 : ans . append (( 1 , 8 - tmp )) b >>= tmp ans . append (( 2 , 1 )) b ^= 1 ans . append (( 0 , 255 )) b -= 1 ans . append (( 0 , 254 )) for a , b in ans : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in [( 0 , 2 ),( 1 , 7 ),( 0 , 255 ),( 1 , 1 )]: c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in ans [:: - 1 ]: if a == 0 : c . sendline ( ' %d %d ' % ( a , 256 - b )) elif a == 1 : c . sendline ( ' %d %d ' % ( a , 8 - b )) elif a == 2 : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for i in range ( 3 ): print i m = range ( 256 ) c . recvuntil ( 'ciphertext is ' ) ct = c . recvline () . strip () ct = ct . decode ( 'hex' ) assert len ( ct ) == 10 for i in range ( 10 ): a = ord ( ct [ i ]) b = ord ( pt [ i ]) #print m[a],b doswap ( m [ a ], b ) for j in range ( 256 ): if m [ j ] == b : m [ j ] = m [ a ] m [ a ] = b break c . sendline ( '-1' ) c . recvuntil ( 'Your flag here. \\n ' ) print c . recvline ()","title":"Arx operations zh"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#add-rotate-xor","text":"","title":"Add-Rotate-Xor"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#_1","text":"ARX \u8fd0\u7b97\u662f\u5982\u4e0b 3 \u79cd\u57fa\u672c\u8fd0\u7b97\u7684\u7edf\u79f0 - Add \u6709\u9650\u57df\u4e0a\u7684\u6a21\u52a0 - Rotate \u5faa\u73af\u79fb\u4f4d - Xor \u5f02\u6216 \u6709\u8bb8\u591a\u5e38\u89c1\u7684\u5757\u52a0\u5bc6\u7b97\u6cd5\u5728\u8f6e\u51fd\u6570\u4e2d\u53ea\u7528\u5230\u4e86\u8fd9 3 \u79cd\u57fa\u672c\u8fd0\u7b97\uff0c\u5178\u578b\u4f8b\u5b50\u5982 Salsa20\u3001Speck \u7b49\u3002\u53e6\u5916 IDEA \u4e5f\u91c7\u7528\u4e86\u7c7b\u4f3c\u7684\u57fa\u672c\u8fd0\u7b97\u6765\u6784\u5efa\u52a0\u89e3\u5bc6\u64cd\u4f5c\uff0c\u4e0d\u8fc7\u4ee5\u4e58\u6cd5\u4ee3\u66ff\u4e86\u79fb\u4f4d\u3002","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#_2","text":"","title":"\u4f18\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#_3","text":"\u64cd\u4f5c\u7b80\u5355\uff0c\u8fd0\u7b97\u901f\u5ea6\u5feb \u6267\u884c\u65f6\u95f4\u4e3a\u5e38\u6570\uff0c\u53ef\u4ee5\u907f\u514d\u57fa\u4e8e\u65f6\u95f4\u7684\u6d4b\u4fe1\u9053\u653b\u51fb \u7ec4\u5408\u540e\u7684\u51fd\u6570\u8868\u8fbe\u80fd\u529b\u8db3\u591f\u5f3a\uff08\u53c2\u89c1\u4e0b\u65b9\u4f8b\u9898\uff09","title":"\u4f18\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#_4","text":"\u5728\u4e09\u79cd\u57fa\u672c\u8fd0\u7b97\u5f53\u4e2d\uff0cRotate\u3001Xor \u5bf9\u4e8e\u5355\u4e2a bit \u6765\u8bf4\u5747\u662f\u5b8c\u5168\u7ebf\u6027\u7684\u8fd0\u7b97\uff0c\u53ef\u80fd\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u8106\u5f31\u6027(\u53c2\u89c1 Rotational cryptanalysis )","title":"\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#_5","text":"","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#2018-ctf-primitive","text":"","title":"2018 *ctf primitive"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#_6","text":"\u672c\u9898\u8981\u6c42\u6211\u4eec\u7ec4\u5408\u4e00\u5b9a\u6570\u76ee\u4ee5\u5185\u7684 Add-Rotate-Xor \u8fd0\u7b97\uff0c\u4f7f\u5f97\u83b7\u5f97\u7684\u52a0\u5bc6\u7b97\u6cd5\u80fd\u591f\u5c06\u56fa\u5b9a\u660e\u6587\u52a0\u5bc6\u6210\u6307\u5b9a\u7684\u968f\u673a\u5bc6\u6587\uff0c\u5373\u901a\u8fc7\u57fa\u7840\u8fd0\u7b97\u6765\u6784\u5efa\u4efb\u610f\u7f6e\u6362\u51fd\u6570\u3002\u6210\u529f\u6784\u5efa 3 \u6b21\u4e4b\u540e\u5373\u53ef\u83b7\u5f97 flag\u3002","title":"\u5206\u6790"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations-zh/#_7","text":"\u5bf9\u4e8e\u6a21 256 \u4e0b\u7684\u8fd0\u7b97\uff0c\u4e00\u79cd\u5178\u578b\u7684\u57fa\u4e8e ARX \u7684\u6362\u4f4d\u64cd\u4f5c\u53ef\u4ee5\u8868\u793a\u4e3a\u5982\u4e0b\u7ec4\u5408 RotateLeft_1(Add_255(RotateLeft_7(Add_2(x)))) \u4e0a\u8ff0\u51fd\u6570\u5bf9\u5e94\u4e86\u4e00\u4e2a\u5c06 254 \u548c 255 \u8fdb\u884c\u4ea4\u6362\uff0c\u540c\u65f6\u4fdd\u6301\u5176\u5b83\u6570\u5b57\u4e0d\u53d8\u7684\u7f6e\u6362\u8fd0\u7b97\u3002 \u76f4\u89c9\u4e0a\u6765\u8bf4\uff0c\u7531\u4e8e\u5728\u7b2c\u4e00\u6b65\u7684\u6a21\u52a0 2 \u8fd0\u7b97\u4e2d\uff0c\u4ec5\u6709\u8f93\u5165\u4e3a 254\u3001255 \u65f6\u4f1a\u53d1\u751f\u8fdb\u4f4d\uff0c\u8be5\u7ec4\u5408\u51fd\u6570\u5f97\u4ee5\u533a\u522b\u5bf9\u5f85\u8fd9\u4e00\u60c5\u51b5\u3002 \u5229\u7528\u4e0a\u8ff0\u539f\u5b50\u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u6784\u9020\u51fa\u4efb\u610f\u4e24\u4e2a\u6570\u5b57 a,b \u7684\u7f6e\u6362\uff0c\u7ed3\u5408 Xor \u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u51cf\u5c11\u6240\u9700\u7684\u57fa\u672c\u64cd\u4f5c\u6570\u76ee\uff0c\u4f7f\u5176\u6ee1\u8db3\u9898\u76ee\u7ed9\u51fa\u7684\u9650\u5236\u3002\u4e00\u79cd\u53ef\u80fd\u7684\u64cd\u4f5c\u6b65\u9aa4\u5982\u4e0b\uff1a \u5bf9\u4e8e a,b \uff0c\u901a\u8fc7\u6a21\u52a0\u64cd\u4f5c\u4f7f\u5f97 a \u4e3a0 \u901a\u8fc7\u53f3\u79fb\u4f7f\u5f97b\u7684\u6700\u4f4e\u4f4d\u4e3a 1 \u82e5 b \u4e0d\u4e3a 1\uff0c\u8fdb\u884c Xor 1, Add 255 \u64cd\u4f5c\uff0c\u4fdd\u6301 a \u4ecd\u7136\u4e3a0\uff0c\u540c\u65f6 b \u7684\u6570\u503c\u51cf\u5c0f \u91cd\u590d\u64cd\u4f5c2-3\u76f4\u81f3 b \u4e3a1 \u8fdb\u884c Add 254 \u53ca\u6362\u4f4d\u64cd\u4f5c\uff0c\u4ea4\u6362 a,b \u5bf9\u4e8e\u6362\u4f4d\u4ee5\u5916\u7684\u6240\u6709\u64cd\u4f5c\uff0c\u52a0\u5165\u5bf9\u5e94\u7684\u9006\u8fd0\u7b97\uff0c\u786e\u4fdd a,b \u4ee5\u5916\u7684\u6570\u503c\u4e0d\u53d8 \u5b8c\u6574\u7684\u89e3\u9898\u811a\u672c\u5982\u4e0b\uff1a from pwn import * import string from hashlib import sha256 #context.log_level='debug' def dopow (): chal = c . recvline () post = chal [ 12 : 28 ] tar = chal [ 33 : - 1 ] c . recvuntil ( ':' ) found = iters . bruteforce ( lambda x : sha256 ( x + post ) . hexdigest () == tar , string . ascii_letters + string . digits , 4 ) c . sendline ( found ) #c = remote('127.0.0.1',10001) c = remote ( '47.75.4.252' , 10001 ) dopow () pt = 'GoodCipher' def doswap ( a , b ): if a == b : return if a > b : tmp = b b = a a = tmp ans = [] ans . append (( 0 , 256 - a )) b -= a a = 0 while b != 1 : tmp = 0 lo = 1 while b & lo == 0 : lo <<= 1 tmp += 1 if b == lo : ans . append (( 1 , 8 - tmp )) break if tmp != 0 : ans . append (( 1 , 8 - tmp )) b >>= tmp ans . append (( 2 , 1 )) b ^= 1 ans . append (( 0 , 255 )) b -= 1 ans . append (( 0 , 254 )) for a , b in ans : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in [( 0 , 2 ),( 1 , 7 ),( 0 , 255 ),( 1 , 1 )]: c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in ans [:: - 1 ]: if a == 0 : c . sendline ( ' %d %d ' % ( a , 256 - b )) elif a == 1 : c . sendline ( ' %d %d ' % ( a , 8 - b )) elif a == 2 : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for i in range ( 3 ): print i m = range ( 256 ) c . recvuntil ( 'ciphertext is ' ) ct = c . recvline () . strip () ct = ct . decode ( 'hex' ) assert len ( ct ) == 10 for i in range ( 10 ): a = ord ( ct [ i ]) b = ord ( pt [ i ]) #print m[a],b doswap ( m [ a ], b ) for j in range ( 256 ): if m [ j ] == b : m [ j ] = m [ a ] m [ a ] = b break c . sendline ( '-1' ) c . recvuntil ( 'Your flag here. \\n ' ) print c . recvline ()","title":"\u89e3\u9898\u601d\u8def"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/","text":"EN | ZH Add-Rotate-Xor \u00b6 Overview \u00b6 The ARX operation is a general term for the following three basic operations. - Add Modification on the finite field - Rotate circular shift - Xor XOR There are many common block cipher algorithms that use only these three basic operations in a round function. Typical examples are Salsa20, Speck, and so on. In addition, [IDEA] (./idea.md) also uses a similar basic operation to construct the encryption and decryption operation, but replaces the shift by multiplication. Advantages and disadvantages \u00b6 Advantages \u00b6 Easy operation and fast operation Execution time is constant to avoid time-based channel attack The combined function is sufficiently expressive (see example below) Disadvantages \u00b6 Among the three basic operations, Rotate and Xor are completely linear operations for a single bit, which may cause some vulnerability (see [Rotational cryptanalysis] ( https://en.wikipedia.org/wiki/ Rotational_cryptanalysis)) topic \u00b6 2018 *ctf primitive \u00b6 Analysis \u00b6 This problem requires us to combine a certain number of Add-Rotate-Xor operations, so that the obtained encryption algorithm can encrypt the fixed plaintext into a specified random ciphertext, that is, construct an arbitrary permutation function through the basic operation. The flag is obtained after 3 successful builds. Problem Solving \u00b6 For the operation under modulo 256, a typical ARX-based transposition operation can be expressed as the following combination RotateLeft_1(Add_255(RotateLeft_7(Add_2(x)))) The above function corresponds to a permutation operation that swaps 254 and 255 while keeping other numbers unchanged. Intuitively, since the carry occurs in the modulo plus 2 operation of the first step, only the input is 254, 255, the combined function can treat this situation differently. Using the above atomic operations, we can construct a permutation of any two numbers 'a, b`. Combined with the Xor operation, we can reduce the number of basic operations required to meet the limitations given by the title. One possible operational step is as follows: For a, b , make a 0 by modular operation Move to the right by making the lowest bit of b If b is not 1, perform the Xor 1, Add 255 operation, keeping a still 0 and decreasing the value of b Repeat operation 2-3 until b is 1 Perform Add 254 and transposition operations, exchanging a, b For all operations except transposition, add the corresponding inverse operation to ensure that the values other than a, b are unchanged. The complete solution script is as follows: from pwn import * import string from hashlib import sha256 #context.log_level='debug' def dopow (): chal = c . recvline () post = chal [ 12 : 28 ] tar = chal [ 33 : - 1 ] c . recvuntil ( ':' ) found = iters . bruteforce ( lambda x : sha256 ( x + post ) . hexdigest () == tar , string . ascii_letters + string . digits , 4 ) c . sendline ( found ) #c = remote('127.0.0.1',10001) c = remote ( '47.75.4.252' , 10001 ) doped () pt = 'GoodCipher' def doswap ( a , b ): if a == b : return if a > b : tmp = b b = a a = tmp years = [] ans . append (( 0.256 - a )) b -= a a = 0 while b != 1 : tmp = 0 lo = 1 while b & lo == 0 : what & lt ; & lt ; = 1 tmp += 1 if b == lo : ans . append (( 1 , 8 - tmp )) break if tmp != 0 : ans . append (( 1 , 8 - tmp )) b >>= tmp ans . append (( 2 , 1 )) b ^= 1 ans . append (( 0.255 )) b -= 1 ans . append (( 0.254 )) for a , b in ans : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in [( 0 , 2 ),( 1 , 7 ),( 0 , 255 ),( 1 , 1 )]: c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in ans [:: - 1 ]: if a == 0 : c . sendline ( ' %d %d ' % ( a , 256 - b )) elif a == 1 : c . sendline ( ' %d %d ' % ( a , 8 - b )) elif a == 2 : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for i in range ( 3 ): print i m = range ( 256 ) c . recvuntil ( 'ciphertext is ' ) ct = c . recvline () . strip () ct = ct . decode ( 'hex' ) assert len ( ct ) == 10 for i in range ( 10 ): a = ord ( ct [ i ]) b = ord ( pt [ i ]) #print m[a],b doswap ( m [ a ], b ) for j in range ( 256 ): if m [ j ] == b : m [ j ] = m [ a ] m [ a ] = b break c . sendline ( '-1' ) c . recvuntil ( 'Your flag here. \\n ' ) print c . recvline ()","title":"ARX"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#add-rotate-xor","text":"","title":"Add-Rotate-Xor"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#overview","text":"The ARX operation is a general term for the following three basic operations. - Add Modification on the finite field - Rotate circular shift - Xor XOR There are many common block cipher algorithms that use only these three basic operations in a round function. Typical examples are Salsa20, Speck, and so on. In addition, [IDEA] (./idea.md) also uses a similar basic operation to construct the encryption and decryption operation, but replaces the shift by multiplication.","title":"Overview"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#advantages","text":"Easy operation and fast operation Execution time is constant to avoid time-based channel attack The combined function is sufficiently expressive (see example below)","title":"Advantages"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#disadvantages","text":"Among the three basic operations, Rotate and Xor are completely linear operations for a single bit, which may cause some vulnerability (see [Rotational cryptanalysis] ( https://en.wikipedia.org/wiki/ Rotational_cryptanalysis))","title":"Disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#topic","text":"","title":"topic"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#2018-ctf-primitive","text":"","title":"2018 *ctf primitive"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#analysis","text":"This problem requires us to combine a certain number of Add-Rotate-Xor operations, so that the obtained encryption algorithm can encrypt the fixed plaintext into a specified random ciphertext, that is, construct an arbitrary permutation function through the basic operation. The flag is obtained after 3 successful builds.","title":"Analysis"},{"location":"crypto/ctf-wiki/blockcipher/arx-operations/#problem-solving","text":"For the operation under modulo 256, a typical ARX-based transposition operation can be expressed as the following combination RotateLeft_1(Add_255(RotateLeft_7(Add_2(x)))) The above function corresponds to a permutation operation that swaps 254 and 255 while keeping other numbers unchanged. Intuitively, since the carry occurs in the modulo plus 2 operation of the first step, only the input is 254, 255, the combined function can treat this situation differently. Using the above atomic operations, we can construct a permutation of any two numbers 'a, b`. Combined with the Xor operation, we can reduce the number of basic operations required to meet the limitations given by the title. One possible operational step is as follows: For a, b , make a 0 by modular operation Move to the right by making the lowest bit of b If b is not 1, perform the Xor 1, Add 255 operation, keeping a still 0 and decreasing the value of b Repeat operation 2-3 until b is 1 Perform Add 254 and transposition operations, exchanging a, b For all operations except transposition, add the corresponding inverse operation to ensure that the values other than a, b are unchanged. The complete solution script is as follows: from pwn import * import string from hashlib import sha256 #context.log_level='debug' def dopow (): chal = c . recvline () post = chal [ 12 : 28 ] tar = chal [ 33 : - 1 ] c . recvuntil ( ':' ) found = iters . bruteforce ( lambda x : sha256 ( x + post ) . hexdigest () == tar , string . ascii_letters + string . digits , 4 ) c . sendline ( found ) #c = remote('127.0.0.1',10001) c = remote ( '47.75.4.252' , 10001 ) doped () pt = 'GoodCipher' def doswap ( a , b ): if a == b : return if a > b : tmp = b b = a a = tmp years = [] ans . append (( 0.256 - a )) b -= a a = 0 while b != 1 : tmp = 0 lo = 1 while b & lo == 0 : what & lt ; & lt ; = 1 tmp += 1 if b == lo : ans . append (( 1 , 8 - tmp )) break if tmp != 0 : ans . append (( 1 , 8 - tmp )) b >>= tmp ans . append (( 2 , 1 )) b ^= 1 ans . append (( 0.255 )) b -= 1 ans . append (( 0.254 )) for a , b in ans : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in [( 0 , 2 ),( 1 , 7 ),( 0 , 255 ),( 1 , 1 )]: c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for a , b in ans [:: - 1 ]: if a == 0 : c . sendline ( ' %d %d ' % ( a , 256 - b )) elif a == 1 : c . sendline ( ' %d %d ' % ( a , 8 - b )) elif a == 2 : c . sendline ( ' %d %d ' % ( a , b )) c . recvline () for i in range ( 3 ): print i m = range ( 256 ) c . recvuntil ( 'ciphertext is ' ) ct = c . recvline () . strip () ct = ct . decode ( 'hex' ) assert len ( ct ) == 10 for i in range ( 10 ): a = ord ( ct [ i ]) b = ord ( pt [ i ]) #print m[a],b doswap ( m [ a ], b ) for j in range ( 256 ): if m [ j ] == b : m [ j ] = m [ a ] m [ a ] = b break c . sendline ( '-1' ) c . recvuntil ( 'Your flag here. \\n ' ) print c . recvline ()","title":"Problem Solving"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/","text":"EN | ZH DES \u00b6 \u57fa\u672c\u4ecb\u7ecd \u00b6 Data Encryption Standard(DES)\uff0c\u6570\u636e\u52a0\u5bc6\u6807\u51c6\uff0c\u662f\u5178\u578b\u7684\u5757\u52a0\u5bc6\uff0c\u5176\u57fa\u672c\u4fe1\u606f\u5982\u4e0b \u8f93\u5165 64 \u4f4d\u3002 \u8f93\u51fa 64 \u4f4d\u3002 \u5bc6\u94a5 64 \u4f4d\uff0c\u4f7f\u7528 64 \u4f4d\u5bc6\u94a5\u4e2d\u7684 56 \u4f4d\uff0c\u5269\u4f59\u7684 8 \u4f4d\u8981\u4e48\u4e22\u5f03\uff0c\u8981\u4e48\u4f5c\u4e3a\u5947\u5076\u6821\u9a8c\u4f4d\u3002 Feistel \u8fed\u4ee3\u7ed3\u6784 \u660e\u6587\u7ecf\u8fc7 16 \u8f6e\u8fed\u4ee3\u5f97\u5230\u5bc6\u6587\u3002 \u5bc6\u6587\u7ecf\u8fc7\u7c7b\u4f3c\u7684 16 \u8f6e\u8fed\u4ee3\u5f97\u5230\u660e\u6587\u3002 \u57fa\u672c\u6d41\u7a0b \u00b6 \u7ed9\u51fa\u4e00\u5f20\u7b80\u5355\u7684 DES \u6d41\u7a0b\u56fe \u3002 \u52a0\u5bc6 \u00b6 \u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4e00\u4e0b\u6bcf\u4e00\u8f6e\u7684\u52a0\u5bc6\u8fc7\u7a0b L_{i+1}=R_i L_{i+1}=R_i R_{i+1}=L_i\\oplus F(R_i,K_i) R_{i+1}=L_i\\oplus F(R_i,K_i) \u90a3\u4e48\u5728\u6700\u540e\u7684 Permutation \u4e4b\u524d\uff0c\u5bf9\u5e94\u7684\u5bc6\u6587\u4e3a (R_{n+1},L_{n+1}) (R_{n+1},L_{n+1}) \u3002 \u89e3\u5bc6 \u00b6 \u90a3\u4e48\u89e3\u5bc6\u5982\u4f55\u89e3\u5bc6\u5462\uff1f\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u628a\u5bc6\u6587\u5148\u8fdb\u884c\u9006\u7f6e\u6362\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u540e\u4e00\u8f6e\u7684\u8f93\u51fa\u3002\u6211\u4eec\u8fd9\u65f6\u8003\u8651\u6bcf\u4e00\u8f6e R_i=L_{i+1} R_i=L_{i+1} L_i=R_{i+1}\\oplus F(L_{i+1},K_i) L_i=R_{i+1}\\oplus F(L_{i+1},K_i) \u56e0\u6b64\uff0c (L_0,R_0) (L_0,R_0) \u5c31\u662f\u52a0\u5bc6\u65f6\u7b2c\u4e00\u6b21\u7f6e\u6362\u540e\u7684\u660e\u6587\u3002\u6211\u4eec\u53ea\u9700\u8981\u518d\u6267\u884c\u9006\u7f6e\u6362\u5c31\u53ef\u4ee5\u83b7\u5f97\u660e\u6587\u4e86\u3002 \u53ef\u4ee5\u770b\u51fa\uff0cDES \u52a0\u89e3\u5bc6\u4f7f\u7528\u540c\u4e00\u5957\u903b\u8f91\uff0c\u53ea\u662f\u5bc6\u94a5\u4f7f\u7528\u7684\u987a\u5e8f\u4e0d\u4e00\u81f4\u3002 \u6838\u5fc3\u90e8\u4ef6 \u00b6 DES \u4e2d\u7684\u6838\u5fc3\u90e8\u4ef6\u4e3b\u8981\u5305\u62ec\uff08\u8fd9\u91cc\u53ea\u7ed9\u51fa\u52a0\u5bc6\u8fc7\u7a0b\u7684\uff09 \u521d\u59cb\u7f6e\u6362 F \u51fd\u6570 E \u6269\u5c55\u51fd\u6570 S \u76d2\uff0c\u8bbe\u8ba1\u6807\u51c6\u672a\u7ed9\u51fa\u3002 P \u7f6e\u6362 \u6700\u540e\u7f6e\u6362 \u5176\u4e2d F \u51fd\u6570\u5982\u4e0b \u5982\u679c\u5bf9 DES \u66f4\u52a0\u611f\u5174\u8da3\uff0c\u53ef\u4ee5\u8fdb\u884c\u66f4\u52a0\u4ed4\u7ec6\u5730\u7814\u7a76\u3002\u6b22\u8fce\u63d0\u4f9b PR\u3002 \u884d\u751f \u00b6 \u5728 DES \u7684\u57fa\u7840\u4e0a\uff0c\u884d\u751f\u4e86\u4ee5\u4e0b\u4e24\u79cd\u52a0\u5bc6\u65b9\u5f0f \u53cc\u91cd DES \u4e09\u79cd DES \u53cc\u91cd DES \u00b6 \u53cc\u91cd DES \u4f7f\u7528\u4e24\u4e2a\u5bc6\u94a5\uff0c\u957f\u5ea6\u4e3a 112 \u6bd4\u7279\u3002\u52a0\u5bc6\u65b9\u5f0f\u5982\u4e0b C=E_{k2}(E_{k1}(P)) C=E_{k2}(E_{k1}(P)) \u4f46\u662f\u53cc\u91cd DES \u4e0d\u80fd\u62b5\u6297\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\uff0c\u6211\u4eec\u53ef\u4ee5\u6784\u9020\u5982\u4e0b\u4e24\u4e2a\u96c6\u5408 I={E_{k1}(P)} I={E_{k1}(P)} J=D_{k2}(C) J=D_{k2}(C) \u5373\u5206\u522b\u679a\u4e3e K1 \u548c K2 \u5206\u522b\u5bf9 P \u8fdb\u884c\u52a0\u5bc6\u548c\u5bf9 C \u8fdb\u884c\u89e3\u5bc6\u3002 \u5728\u6211\u4eec\u5bf9 P \u8fdb\u884c\u52a0\u5bc6\u5b8c\u6bd5\u540e\uff0c\u53ef\u4ee5\u5bf9\u52a0\u5bc6\u7ed3\u679c\u8fdb\u884c\u6392\u5e8f\uff0c\u8fd9\u6837\u7684\u590d\u6742\u5ea6\u4e3a 2^nlog(2^n)=O(n2^n) 2^nlog(2^n)=O(n2^n) \u5f53\u6211\u4eec\u5bf9 C \u8fdb\u884c\u89e3\u5bc6\u65f6\uff0c\u53ef\u4ee5\u6bcf\u89e3\u5bc6\u4e00\u4e2a\uff0c\u5c31\u53bb\u5bf9\u5e94\u7684\u8868\u4e2d\u67e5\u8be2\u3002 \u603b\u7684\u590d\u6742\u5ea6\u4e3a\u8fd8\u662f O(n2^n) O(n2^n) \u3002 \u4e09\u91cd DES \u00b6 \u4e09\u91cd DES \u7684\u52a0\u89e3\u5bc6\u65b9\u5f0f\u5982\u4e0b C=E_{k3}(D_{k2}(E_{k1}(P))) C=E_{k3}(D_{k2}(E_{k1}(P))) P=D_{k1}(E_{k2}(D_{k3}(C))) P=D_{k1}(E_{k2}(D_{k3}(C))) \u5728\u9009\u62e9\u5bc6\u94a5\u65f6\uff0c\u53ef\u4ee5\u6709\u4e24\u79cd\u65b9\u6cd5 3 \u4e2a\u4e0d\u540c\u7684\u5bc6\u94a5\uff0ck1\uff0ck2\uff0ck3 \u4e92\u76f8\u72ec\u7acb\uff0c\u4e00\u5171 168 \u6bd4\u7279\u3002 2 \u4e2a\u4e0d\u540c\u7684\u5bc6\u94a5\uff0ck1 \u4e0e k2 \u72ec\u7acb\uff0ck3=k1\uff0c112 \u6bd4\u7279\u3002 \u653b\u51fb\u65b9\u6cd5 \u00b6 \u5dee\u5206\u653b\u51fb \u7ebf\u6027\u653b\u51fb 2018 N1CTF N1ES \u00b6 \u57fa\u672c\u4ee3\u7801\u5982\u4e0b # -*- coding: utf-8 -*- def round_add ( a , b ): f = lambda x , y : x + y - 2 * ( x & y ) res = '' for i in range ( len ( a )): res += chr ( f ( ord ( a [ i ]), ord ( b [ i ]))) return res def permutate ( table , block ): return list ( map ( lambda x : block [ x ], table )) def string_to_bits ( data ): data = [ ord ( c ) for c in data ] l = len ( data ) * 8 result = [ 0 ] * l pos = 0 for ch in data : for i in range ( 0 , 8 ): result [( pos << 3 ) + i ] = ( ch >> i ) & 1 pos += 1 return result s_box = [ 54 , 132 , 138 , 83 , 16 , 73 , 187 , 84 , 146 , 30 , 95 , 21 , 148 , 63 , 65 , 189 , 188 , 151 , 72 , 161 , 116 , 63 , 161 , 91 , 37 , 24 , 126 , 107 , 87 , 30 , 117 , 185 , 98 , 90 , 0 , 42 , 140 , 70 , 86 , 0 , 42 , 150 , 54 , 22 , 144 , 153 , 36 , 90 , 149 , 54 , 156 , 8 , 59 , 40 , 110 , 56 , 1 , 84 , 103 , 22 , 65 , 17 , 190 , 41 , 99 , 151 , 119 , 124 , 68 , 17 , 166 , 125 , 95 , 65 , 105 , 133 , 49 , 19 , 138 , 29 , 110 , 7 , 81 , 134 , 70 , 87 , 180 , 78 , 175 , 108 , 26 , 121 , 74 , 29 , 68 , 162 , 142 , 177 , 143 , 86 , 129 , 101 , 117 , 41 , 57 , 34 , 177 , 103 , 61 , 135 , 191 , 74 , 69 , 147 , 90 , 49 , 135 , 124 , 106 , 19 , 8 9 , 38 , 21 , 41 , 17 , 155 , 83 , 38 , 159 , 179 , 19 , 157 , 68 , 105 , 151 , 166 , 171 , 122 , 179 , 114 , 52 , 183 , 89 , 107 , 113 , 65 , 161 , 141 , 18 , 121 , 95 , 4 , 95 , 101 , 81 , 156 , 17 , 190 , 38 , 84 , 9 , 171 , 180 , 59 , 45 , 15 , 34 , 89 , 75 , 164 , 190 , 140 , 6 , 41 , 188 , 77 , 165 , 105 , 5 , 107 , 31 , 183 , 107 , 141 , 66 , 63 , 10 , 9 , 125 , 50 , 2 , 153 , 156 , 162 , 186 , 76 , 158 , 153 , 117 , 9 , 77 , 156 , 11 , 145 , 12 , 169 , 52 , 57 , 161 , 7 , 158 , 110 , 191 , 43 , 82 , 186 , 49 , 102 , 166 , 31 , 41 , 5 , 189 , 27 ] def generate ( o ): k = permutate ( s_box , o ) b = [] for i in range ( 0 , len ( k ), 7 ): b . append ( k [ i : i + 7 ] + [ 1 ]) c = [] for i in range ( 32 ): pos = 0 x = 0 for j in b [ i ]: x += ( j << pos ) pos += 1 c . append (( 0x10001 ** x ) % ( 0x7f )) return c class N1ES : def __init__ ( self , key ): if ( len ( key ) != 24 or isinstance ( key , bytes ) == False ): raise Exception ( \"key must be 24 bytes long\" ) self . key = key self . gen_subkey () def gen_subkey ( self ): o = string_to_bits ( self . key ) k = [] for i in range ( 8 ): o = generate ( o ) k . extend ( o ) o = string_to_bits ([ chr ( c ) for c in o [ 0 : 24 ]]) self . Kn = [] for i in range ( 32 ): self . Kn . append ( map ( chr , k [ i * 8 : i * 8 + 8 ])) return def encrypt ( self , plaintext ): if ( len ( plaintext ) % 16 != 0 or isinstance ( plaintext , bytes ) == False ): raise Exception ( \"plaintext must be a multiple of 16 in length\" ) res = '' for i in range ( len ( plaintext ) / 16 ): block = plaintext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ round_cnt ])) L , R = R , L res += L + R return res \u663e\u7136\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u89c6\u4e3a\u4e00\u4e2a Feistel \u52a0\u5bc6\u7684\u65b9\u5f0f\uff0c\u89e3\u5bc6\u51fd\u6570\u5982\u4e0b def decrypt ( self , ciphertext ): res = '' for i in range ( len ( ciphertext ) / 16 ): block = ciphertext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ 31 - round_cnt ])) L , R = R , L res += L + R return res \u6700\u540e\u7ed3\u679c\u4e3a \u279c baby_N1ES cat challenge.py from N1ES import N1ES import base64 key = \"wxy191iss00000000000cute\" n1es = N1ES ( key ) flag = \"N1CTF{*****************************************}\" cipher = n1es.encrypt ( flag ) #print base64.b64encode(cipher) # HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx cipher = 'HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx' cipher = base64.b64decode ( cipher ) print n1es.decrypt ( cipher ) \u279c baby_N1ES python challenge.py N1CTF { F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d_/--/ } 2019 CISCN part_des \u00b6 \u9898\u76ee\u53ea\u7ed9\u4e86\u4e00\u4e2a\u6587\u4ef6\uff1a Round n part_encode-> 0x92d915250119e12b Key map -> 0xe0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84 \u8003\u8651\u5230\u9898\u76ee\u540d\u4ee5\u53ca\u6570\u636e\u7279\u5f81\uff0c Round n part_encode \u4e3a\u6267\u884cn\u8f6edes\u7684\u4e2d\u95f4\u7ed3\u679c\uff0c Key map \u5e94\u4e3ades\u7684\u5b50\u5bc6\u94a5\uff0c\u8981\u8fd8\u539f\u51fa\u660e\u6587\u53ea\u9700\u8fdb\u884cn\u8f6edes\u52a0\u5bc6\u7684\u9006\u8fc7\u7a0b\u5373\u53ef\uff0c\u89e3\u5bc6\u65f6\u6ce8\u610f\u4ee5\u4e0b\u4e09\u70b9\u3002 \u5b50\u5bc6\u94a5\u7684\u9009\u53d6\uff0c\u5bf9\u4e8e\u53ea\u8fdb\u884c\u4e86n\u8f6e\u7684\u52a0\u5bc6\u7ed3\u679c\uff0c\u89e3\u5bc6\u65f6\u5e94\u4f9d\u6b21\u4f7f\u7528\u5bc6\u94a5 n, n-1..., 1\u3002 des \u6700\u540e\u4e00\u8f6e\u540e\u7684\u64cd\u4f5c\uff0c\u672a\u5b8c\u6210\u7684 des \u6ca1\u6709\u4ea4\u6362\u5de6\u53f3\u4e24\u90e8\u5206\u548c\u9006\u521d\u59cb\u7f6e\u6362\uff0c\u56e0\u6b64\u89e3\u5bc6\u65f6\u6211\u4eec\u5e94\u5148\u5bf9\u5bc6\u6587\u8fdb\u884c\u8fd9\u4e24\u6b65\u64cd\u4f5c\u3002 n \u7684\u9009\u62e9\uff0c\u5728\u672c\u9898\u4e2d\uff0c\u6211\u4eec\u5e76\u4e0d\u77e5\u9053 n\uff0c\u4f46\u8fd9\u65e0\u5173\u7d27\u8981\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u6240\u6709\u53ef\u80fd\u7684\u53d6\u503c\uff080-15\uff09flag\u5e94\u4e3aascii\u5b57\u7b26\u4e32\u3002 \u89e3\u9898\u4ee3\u7801 kkk = 16 def bit_rot_left ( lst , pos ): return lst [ pos :] + lst [: pos ] class DES : IP = [ 58 , 50 , 42 , 34 , 26 , 18 , 10 , 2 , 60 , 52 , 44 , 36 , 28 , 20 , 12 , 4 , 62 , 54 , 46 , 38 , 30 , 22 , 14 , 6 , 64 , 56 , 48 , 40 , 32 , 24 , 16 , 8 , 57 , 49 , 41 , 33 , 25 , 17 , 9 , 1 , 59 , 51 , 43 , 35 , 27 , 19 , 11 , 3 , 61 , 53 , 45 , 37 , 29 , 21 , 13 , 5 , 63 , 55 , 47 , 39 , 31 , 23 , 15 , 7 ] IP_re = [ 40 , 8 , 48 , 16 , 56 , 24 , 64 , 32 , 39 , 7 , 47 , 15 , 55 , 23 , 63 , 31 , 38 , 6 , 46 , 14 , 54 , 22 , 62 , 30 , 37 , 5 , 45 , 13 , 53 , 21 , 61 , 29 , 36 , 4 , 44 , 12 , 52 , 20 , 60 , 28 , 35 , 3 , 43 , 11 , 51 , 19 , 59 , 27 , 34 , 2 , 42 , 10 , 50 , 18 , 58 , 26 , 33 , 1 , 41 , 9 , 49 , 17 , 57 , 25 ] Pbox = [ 16 , 7 , 20 , 21 , 29 , 12 , 28 , 17 , 1 , 15 , 23 , 26 , 5 , 18 , 31 , 10 , 2 , 8 , 24 , 14 , 32 , 27 , 3 , 9 , 19 , 13 , 30 , 6 , 22 , 11 , 4 , 25 ] E = [ 32 , 1 , 2 , 3 , 4 , 5 , 4 , 5 , 6 , 7 , 8 , 9 , 8 , 9 , 10 , 11 , 12 , 13 , 12 , 13 , 14 , 15 , 16 , 17 , 16 , 17 , 18 , 19 , 20 , 21 , 20 , 21 , 22 , 23 , 24 , 25 , 24 , 25 , 26 , 27 , 28 , 29 , 28 , 29 , 30 , 31 , 32 , 1 ] PC1 = [ 57 , 49 , 41 , 33 , 25 , 17 , 9 , 1 , 58 , 50 , 42 , 34 , 26 , 18 , 10 , 2 , 59 , 51 , 43 , 35 , 27 , 19 , 11 , 3 , 60 , 52 , 44 , 36 , 63 , 55 , 47 , 39 , 31 , 23 , 15 , 7 , 62 , 54 , 46 , 38 , 30 , 22 , 14 , 6 , 61 , 53 , 45 , 37 , 29 , 21 , 13 , 5 , 28 , 20 , 12 , 4 ] PC2 = [ 14 , 17 , 11 , 24 , 1 , 5 , 3 , 28 , 15 , 6 , 21 , 10 , 23 , 19 , 12 , 4 , 26 , 8 , 16 , 7 , 27 , 20 , 13 , 2 , 41 , 52 , 31 , 37 , 47 , 55 , 30 , 40 , 51 , 45 , 33 , 48 , 44 , 49 , 39 , 56 , 34 , 53 , 46 , 42 , 50 , 36 , 29 , 32 ] Sbox = [ [ [ 14 , 4 , 13 , 1 , 2 , 15 , 11 , 8 , 3 , 10 , 6 , 12 , 5 , 9 , 0 , 7 ], [ 0 , 15 , 7 , 4 , 14 , 2 , 13 , 1 , 10 , 6 , 12 , 11 , 9 , 5 , 3 , 8 ], [ 4 , 1 , 14 , 8 , 13 , 6 , 2 , 11 , 15 , 12 , 9 , 7 , 3 , 10 , 5 , 0 ], [ 15 , 12 , 8 , 2 , 4 , 9 , 1 , 7 , 5 , 11 , 3 , 14 , 10 , 0 , 6 , 13 ], ], [ [ 15 , 1 , 8 , 14 , 6 , 11 , 3 , 4 , 9 , 7 , 2 , 13 , 12 , 0 , 5 , 10 ], [ 3 , 13 , 4 , 7 , 15 , 2 , 8 , 14 , 12 , 0 , 1 , 10 , 6 , 9 , 11 , 5 ], [ 0 , 14 , 7 , 11 , 10 , 4 , 13 , 1 , 5 , 8 , 12 , 6 , 9 , 3 , 2 , 15 ], [ 13 , 8 , 10 , 1 , 3 , 15 , 4 , 2 , 11 , 6 , 7 , 12 , 0 , 5 , 14 , 9 ], ], [ [ 10 , 0 , 9 , 14 , 6 , 3 , 15 , 5 , 1 , 13 , 12 , 7 , 11 , 4 , 2 , 8 ], [ 13 , 7 , 0 , 9 , 3 , 4 , 6 , 10 , 2 , 8 , 5 , 14 , 12 , 11 , 15 , 1 ], [ 13 , 6 , 4 , 9 , 8 , 15 , 3 , 0 , 11 , 1 , 2 , 12 , 5 , 10 , 14 , 7 ], [ 1 , 10 , 13 , 0 , 6 , 9 , 8 , 7 , 4 , 15 , 14 , 3 , 11 , 5 , 2 , 12 ], ], [ [ 7 , 13 , 14 , 3 , 0 , 6 , 9 , 10 , 1 , 2 , 8 , 5 , 11 , 12 , 4 , 15 ], [ 13 , 8 , 11 , 5 , 6 , 15 , 0 , 3 , 4 , 7 , 2 , 12 , 1 , 10 , 14 , 9 ], [ 10 , 6 , 9 , 0 , 12 , 11 , 7 , 13 , 15 , 1 , 3 , 14 , 5 , 2 , 8 , 4 ], [ 3 , 15 , 0 , 6 , 10 , 1 , 13 , 8 , 9 , 4 , 5 , 11 , 12 , 7 , 2 , 14 ], ], [ [ 2 , 12 , 4 , 1 , 7 , 10 , 11 , 6 , 8 , 5 , 3 , 15 , 13 , 0 , 14 , 9 ], [ 14 , 11 , 2 , 12 , 4 , 7 , 13 , 1 , 5 , 0 , 15 , 10 , 3 , 9 , 8 , 6 ], [ 4 , 2 , 1 , 11 , 10 , 13 , 7 , 8 , 15 , 9 , 12 , 5 , 6 , 3 , 0 , 14 ], [ 11 , 8 , 12 , 7 , 1 , 14 , 2 , 13 , 6 , 15 , 0 , 9 , 10 , 4 , 5 , 3 ], ], [ [ 12 , 1 , 10 , 15 , 9 , 2 , 6 , 8 , 0 , 13 , 3 , 4 , 14 , 7 , 5 , 11 ], [ 10 , 15 , 4 , 2 , 7 , 12 , 9 , 5 , 6 , 1 , 13 , 14 , 0 , 11 , 3 , 8 ], [ 9 , 14 , 15 , 5 , 2 , 8 , 12 , 3 , 7 , 0 , 4 , 10 , 1 , 13 , 11 , 6 ], [ 4 , 3 , 2 , 12 , 9 , 5 , 15 , 10 , 11 , 14 , 1 , 7 , 6 , 0 , 8 , 13 ], ], [ [ 4 , 11 , 2 , 14 , 15 , 0 , 8 , 13 , 3 , 12 , 9 , 7 , 5 , 10 , 6 , 1 ], [ 13 , 0 , 11 , 7 , 4 , 9 , 1 , 10 , 14 , 3 , 5 , 12 , 2 , 15 , 8 , 6 ], [ 1 , 4 , 11 , 13 , 12 , 3 , 7 , 14 , 10 , 15 , 6 , 8 , 0 , 5 , 9 , 2 ], [ 6 , 11 , 13 , 8 , 1 , 4 , 10 , 7 , 9 , 5 , 0 , 15 , 14 , 2 , 3 , 12 ], ], [ [ 13 , 2 , 8 , 4 , 6 , 15 , 11 , 1 , 10 , 9 , 3 , 14 , 5 , 0 , 12 , 7 ], [ 1 , 15 , 13 , 8 , 10 , 3 , 7 , 4 , 12 , 5 , 6 , 11 , 0 , 14 , 9 , 2 ], [ 7 , 11 , 4 , 1 , 9 , 12 , 14 , 2 , 0 , 6 , 10 , 13 , 15 , 3 , 5 , 8 ], [ 2 , 1 , 14 , 7 , 4 , 10 , 8 , 13 , 15 , 12 , 9 , 0 , 3 , 5 , 6 , 11 ], ] ] rout = [ 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 1 ] def __init__ ( self ): self . subkey = [[[ 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ]], [[ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 ], [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ]]] def permute ( self , lst , tb ): return [ lst [ i - 1 ] for i in tb ] def f ( self , riti , subkeyi ): tmp = [ i ^ j for i , j in zip ( subkeyi , self . permute ( riti , DES . E ))] return self . permute ( sum ([[ int ( l ) for l in str ( bin ( DES . Sbox [ i ][ int ( str ( tmp [ 6 * i ]) + str ( tmp [ 6 * i + 5 ]), 2 )][ int ( \"\" . join ( str ( j ) for j in tmp [ 6 * i + 1 : 6 * i + 5 ]), 2 )])[ 2 :] . zfill ( 4 ))] for i in range ( 8 )],[]), DES . Pbox ) def des_main ( self , m , mark ): sbkey = self . subkey [ 0 ] #if mark == 'e' else self.subkey[1] # tmp = self.permute([int(i) for i in list((m).ljust(64,\"0\"))],self.IP) tmp = [ int ( i ) for i in list (( m ) . ljust ( 64 , \"0\" ))] global kkk print ( kkk ) for i in range ( kkk ): tmp = tmp [ 32 :] + [ j ^ k for j , k in zip ( tmp [: 32 ], self . f ( tmp [ 32 :], sbkey [ i if mark != 'd' else kkk - 1 - i ]))] return \"\" . join ([ str ( i ) for i in self . permute ( tmp [ 32 :] + tmp [: 32 ], self . IP_re )]) def des_encipher ( self , m ): m = \"\" . join ([ bin ( ord ( i ))[ 2 :] . zfill ( 8 ) for i in m ]) des_en = self . des_main ( m , 'e' ) return \"\" . join ([ chr ( int ( des_en [ i * 8 : i * 8 + 8 ], 2 )) for i in range ( 8 )]) def des_decipher ( self , c ): c = \"\" . join ([ bin ( ord ( i ))[ 2 :] . zfill ( 8 ) for i in c ]) des_de = self . des_main ( c , 'd' ) return \"\" . join ([ chr ( int ( des_de [ i * 8 : i * 8 + 8 ], 2 )) for i in range ( 8 )]) def test (): import base64 global kkk while kkk >= 0 : desobj = DES () # cipher = desobj.des_encipher(\"12345678\") cipher = ' \\x01\\x19\\xe1 + \\x92\\xd9\\x15 %' message1 = desobj . des_decipher ( cipher ) print ( message1 ) kkk -= 1 if __name__ == '__main__' : test () \u89e3\u5bc6\u7ed3\u679c\uff08\u90e8\u5206\uff09\uff1a 14 t-\u00cfE\u00cfx\u0090\u00a7 13 y0ur9Ood 12 \u00b5p^\u00db\u00e9=\u00b9\u0088 11 )\u00c1`r\u00fb\u00d5\u00fb\u009d \u53ef\u4ee5\u770b\u51fan\u4e3a13\uff0cflag\u4e3a flag{y0ur9Ood} \u53c2\u8003 \u00b6 \u6e05\u534e\u5927\u5b66\u7814\u7a76\u751f\u6570\u636e\u5b89\u5168\u8bfe\u7a0b\u8bfe\u4ef6 https://en.wikipedia.org/wiki/Data_Encryption_Standard","title":"Des zh"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#des","text":"","title":"DES"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#_1","text":"Data Encryption Standard(DES)\uff0c\u6570\u636e\u52a0\u5bc6\u6807\u51c6\uff0c\u662f\u5178\u578b\u7684\u5757\u52a0\u5bc6\uff0c\u5176\u57fa\u672c\u4fe1\u606f\u5982\u4e0b \u8f93\u5165 64 \u4f4d\u3002 \u8f93\u51fa 64 \u4f4d\u3002 \u5bc6\u94a5 64 \u4f4d\uff0c\u4f7f\u7528 64 \u4f4d\u5bc6\u94a5\u4e2d\u7684 56 \u4f4d\uff0c\u5269\u4f59\u7684 8 \u4f4d\u8981\u4e48\u4e22\u5f03\uff0c\u8981\u4e48\u4f5c\u4e3a\u5947\u5076\u6821\u9a8c\u4f4d\u3002 Feistel \u8fed\u4ee3\u7ed3\u6784 \u660e\u6587\u7ecf\u8fc7 16 \u8f6e\u8fed\u4ee3\u5f97\u5230\u5bc6\u6587\u3002 \u5bc6\u6587\u7ecf\u8fc7\u7c7b\u4f3c\u7684 16 \u8f6e\u8fed\u4ee3\u5f97\u5230\u660e\u6587\u3002","title":"\u57fa\u672c\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#_2","text":"\u7ed9\u51fa\u4e00\u5f20\u7b80\u5355\u7684 DES \u6d41\u7a0b\u56fe \u3002","title":"\u57fa\u672c\u6d41\u7a0b"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#_3","text":"\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4e00\u4e0b\u6bcf\u4e00\u8f6e\u7684\u52a0\u5bc6\u8fc7\u7a0b L_{i+1}=R_i L_{i+1}=R_i R_{i+1}=L_i\\oplus F(R_i,K_i) R_{i+1}=L_i\\oplus F(R_i,K_i) \u90a3\u4e48\u5728\u6700\u540e\u7684 Permutation \u4e4b\u524d\uff0c\u5bf9\u5e94\u7684\u5bc6\u6587\u4e3a (R_{n+1},L_{n+1}) (R_{n+1},L_{n+1}) \u3002","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#_4","text":"\u90a3\u4e48\u89e3\u5bc6\u5982\u4f55\u89e3\u5bc6\u5462\uff1f\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u628a\u5bc6\u6587\u5148\u8fdb\u884c\u9006\u7f6e\u6362\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u540e\u4e00\u8f6e\u7684\u8f93\u51fa\u3002\u6211\u4eec\u8fd9\u65f6\u8003\u8651\u6bcf\u4e00\u8f6e R_i=L_{i+1} R_i=L_{i+1} L_i=R_{i+1}\\oplus F(L_{i+1},K_i) L_i=R_{i+1}\\oplus F(L_{i+1},K_i) \u56e0\u6b64\uff0c (L_0,R_0) (L_0,R_0) \u5c31\u662f\u52a0\u5bc6\u65f6\u7b2c\u4e00\u6b21\u7f6e\u6362\u540e\u7684\u660e\u6587\u3002\u6211\u4eec\u53ea\u9700\u8981\u518d\u6267\u884c\u9006\u7f6e\u6362\u5c31\u53ef\u4ee5\u83b7\u5f97\u660e\u6587\u4e86\u3002 \u53ef\u4ee5\u770b\u51fa\uff0cDES \u52a0\u89e3\u5bc6\u4f7f\u7528\u540c\u4e00\u5957\u903b\u8f91\uff0c\u53ea\u662f\u5bc6\u94a5\u4f7f\u7528\u7684\u987a\u5e8f\u4e0d\u4e00\u81f4\u3002","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#_5","text":"DES \u4e2d\u7684\u6838\u5fc3\u90e8\u4ef6\u4e3b\u8981\u5305\u62ec\uff08\u8fd9\u91cc\u53ea\u7ed9\u51fa\u52a0\u5bc6\u8fc7\u7a0b\u7684\uff09 \u521d\u59cb\u7f6e\u6362 F \u51fd\u6570 E \u6269\u5c55\u51fd\u6570 S \u76d2\uff0c\u8bbe\u8ba1\u6807\u51c6\u672a\u7ed9\u51fa\u3002 P \u7f6e\u6362 \u6700\u540e\u7f6e\u6362 \u5176\u4e2d F \u51fd\u6570\u5982\u4e0b \u5982\u679c\u5bf9 DES \u66f4\u52a0\u611f\u5174\u8da3\uff0c\u53ef\u4ee5\u8fdb\u884c\u66f4\u52a0\u4ed4\u7ec6\u5730\u7814\u7a76\u3002\u6b22\u8fce\u63d0\u4f9b PR\u3002","title":"\u6838\u5fc3\u90e8\u4ef6"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#_6","text":"\u5728 DES \u7684\u57fa\u7840\u4e0a\uff0c\u884d\u751f\u4e86\u4ee5\u4e0b\u4e24\u79cd\u52a0\u5bc6\u65b9\u5f0f \u53cc\u91cd DES \u4e09\u79cd DES","title":"\u884d\u751f"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#des_1","text":"\u53cc\u91cd DES \u4f7f\u7528\u4e24\u4e2a\u5bc6\u94a5\uff0c\u957f\u5ea6\u4e3a 112 \u6bd4\u7279\u3002\u52a0\u5bc6\u65b9\u5f0f\u5982\u4e0b C=E_{k2}(E_{k1}(P)) C=E_{k2}(E_{k1}(P)) \u4f46\u662f\u53cc\u91cd DES \u4e0d\u80fd\u62b5\u6297\u4e2d\u95f4\u76f8\u9047\u653b\u51fb\uff0c\u6211\u4eec\u53ef\u4ee5\u6784\u9020\u5982\u4e0b\u4e24\u4e2a\u96c6\u5408 I={E_{k1}(P)} I={E_{k1}(P)} J=D_{k2}(C) J=D_{k2}(C) \u5373\u5206\u522b\u679a\u4e3e K1 \u548c K2 \u5206\u522b\u5bf9 P \u8fdb\u884c\u52a0\u5bc6\u548c\u5bf9 C \u8fdb\u884c\u89e3\u5bc6\u3002 \u5728\u6211\u4eec\u5bf9 P \u8fdb\u884c\u52a0\u5bc6\u5b8c\u6bd5\u540e\uff0c\u53ef\u4ee5\u5bf9\u52a0\u5bc6\u7ed3\u679c\u8fdb\u884c\u6392\u5e8f\uff0c\u8fd9\u6837\u7684\u590d\u6742\u5ea6\u4e3a 2^nlog(2^n)=O(n2^n) 2^nlog(2^n)=O(n2^n) \u5f53\u6211\u4eec\u5bf9 C \u8fdb\u884c\u89e3\u5bc6\u65f6\uff0c\u53ef\u4ee5\u6bcf\u89e3\u5bc6\u4e00\u4e2a\uff0c\u5c31\u53bb\u5bf9\u5e94\u7684\u8868\u4e2d\u67e5\u8be2\u3002 \u603b\u7684\u590d\u6742\u5ea6\u4e3a\u8fd8\u662f O(n2^n) O(n2^n) \u3002","title":"\u53cc\u91cd DES"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#des_2","text":"\u4e09\u91cd DES \u7684\u52a0\u89e3\u5bc6\u65b9\u5f0f\u5982\u4e0b C=E_{k3}(D_{k2}(E_{k1}(P))) C=E_{k3}(D_{k2}(E_{k1}(P))) P=D_{k1}(E_{k2}(D_{k3}(C))) P=D_{k1}(E_{k2}(D_{k3}(C))) \u5728\u9009\u62e9\u5bc6\u94a5\u65f6\uff0c\u53ef\u4ee5\u6709\u4e24\u79cd\u65b9\u6cd5 3 \u4e2a\u4e0d\u540c\u7684\u5bc6\u94a5\uff0ck1\uff0ck2\uff0ck3 \u4e92\u76f8\u72ec\u7acb\uff0c\u4e00\u5171 168 \u6bd4\u7279\u3002 2 \u4e2a\u4e0d\u540c\u7684\u5bc6\u94a5\uff0ck1 \u4e0e k2 \u72ec\u7acb\uff0ck3=k1\uff0c112 \u6bd4\u7279\u3002","title":"\u4e09\u91cd DES"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#_7","text":"\u5dee\u5206\u653b\u51fb \u7ebf\u6027\u653b\u51fb","title":"\u653b\u51fb\u65b9\u6cd5"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#2018-n1ctf-n1es","text":"\u57fa\u672c\u4ee3\u7801\u5982\u4e0b # -*- coding: utf-8 -*- def round_add ( a , b ): f = lambda x , y : x + y - 2 * ( x & y ) res = '' for i in range ( len ( a )): res += chr ( f ( ord ( a [ i ]), ord ( b [ i ]))) return res def permutate ( table , block ): return list ( map ( lambda x : block [ x ], table )) def string_to_bits ( data ): data = [ ord ( c ) for c in data ] l = len ( data ) * 8 result = [ 0 ] * l pos = 0 for ch in data : for i in range ( 0 , 8 ): result [( pos << 3 ) + i ] = ( ch >> i ) & 1 pos += 1 return result s_box = [ 54 , 132 , 138 , 83 , 16 , 73 , 187 , 84 , 146 , 30 , 95 , 21 , 148 , 63 , 65 , 189 , 188 , 151 , 72 , 161 , 116 , 63 , 161 , 91 , 37 , 24 , 126 , 107 , 87 , 30 , 117 , 185 , 98 , 90 , 0 , 42 , 140 , 70 , 86 , 0 , 42 , 150 , 54 , 22 , 144 , 153 , 36 , 90 , 149 , 54 , 156 , 8 , 59 , 40 , 110 , 56 , 1 , 84 , 103 , 22 , 65 , 17 , 190 , 41 , 99 , 151 , 119 , 124 , 68 , 17 , 166 , 125 , 95 , 65 , 105 , 133 , 49 , 19 , 138 , 29 , 110 , 7 , 81 , 134 , 70 , 87 , 180 , 78 , 175 , 108 , 26 , 121 , 74 , 29 , 68 , 162 , 142 , 177 , 143 , 86 , 129 , 101 , 117 , 41 , 57 , 34 , 177 , 103 , 61 , 135 , 191 , 74 , 69 , 147 , 90 , 49 , 135 , 124 , 106 , 19 , 8 9 , 38 , 21 , 41 , 17 , 155 , 83 , 38 , 159 , 179 , 19 , 157 , 68 , 105 , 151 , 166 , 171 , 122 , 179 , 114 , 52 , 183 , 89 , 107 , 113 , 65 , 161 , 141 , 18 , 121 , 95 , 4 , 95 , 101 , 81 , 156 , 17 , 190 , 38 , 84 , 9 , 171 , 180 , 59 , 45 , 15 , 34 , 89 , 75 , 164 , 190 , 140 , 6 , 41 , 188 , 77 , 165 , 105 , 5 , 107 , 31 , 183 , 107 , 141 , 66 , 63 , 10 , 9 , 125 , 50 , 2 , 153 , 156 , 162 , 186 , 76 , 158 , 153 , 117 , 9 , 77 , 156 , 11 , 145 , 12 , 169 , 52 , 57 , 161 , 7 , 158 , 110 , 191 , 43 , 82 , 186 , 49 , 102 , 166 , 31 , 41 , 5 , 189 , 27 ] def generate ( o ): k = permutate ( s_box , o ) b = [] for i in range ( 0 , len ( k ), 7 ): b . append ( k [ i : i + 7 ] + [ 1 ]) c = [] for i in range ( 32 ): pos = 0 x = 0 for j in b [ i ]: x += ( j << pos ) pos += 1 c . append (( 0x10001 ** x ) % ( 0x7f )) return c class N1ES : def __init__ ( self , key ): if ( len ( key ) != 24 or isinstance ( key , bytes ) == False ): raise Exception ( \"key must be 24 bytes long\" ) self . key = key self . gen_subkey () def gen_subkey ( self ): o = string_to_bits ( self . key ) k = [] for i in range ( 8 ): o = generate ( o ) k . extend ( o ) o = string_to_bits ([ chr ( c ) for c in o [ 0 : 24 ]]) self . Kn = [] for i in range ( 32 ): self . Kn . append ( map ( chr , k [ i * 8 : i * 8 + 8 ])) return def encrypt ( self , plaintext ): if ( len ( plaintext ) % 16 != 0 or isinstance ( plaintext , bytes ) == False ): raise Exception ( \"plaintext must be a multiple of 16 in length\" ) res = '' for i in range ( len ( plaintext ) / 16 ): block = plaintext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ round_cnt ])) L , R = R , L res += L + R return res \u663e\u7136\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u89c6\u4e3a\u4e00\u4e2a Feistel \u52a0\u5bc6\u7684\u65b9\u5f0f\uff0c\u89e3\u5bc6\u51fd\u6570\u5982\u4e0b def decrypt ( self , ciphertext ): res = '' for i in range ( len ( ciphertext ) / 16 ): block = ciphertext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ 31 - round_cnt ])) L , R = R , L res += L + R return res \u6700\u540e\u7ed3\u679c\u4e3a \u279c baby_N1ES cat challenge.py from N1ES import N1ES import base64 key = \"wxy191iss00000000000cute\" n1es = N1ES ( key ) flag = \"N1CTF{*****************************************}\" cipher = n1es.encrypt ( flag ) #print base64.b64encode(cipher) # HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx cipher = 'HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx' cipher = base64.b64decode ( cipher ) print n1es.decrypt ( cipher ) \u279c baby_N1ES python challenge.py N1CTF { F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d_/--/ }","title":"2018 N1CTF N1ES"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#2019-ciscn-part_des","text":"\u9898\u76ee\u53ea\u7ed9\u4e86\u4e00\u4e2a\u6587\u4ef6\uff1a Round n part_encode-> 0x92d915250119e12b Key map -> 0xe0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84 \u8003\u8651\u5230\u9898\u76ee\u540d\u4ee5\u53ca\u6570\u636e\u7279\u5f81\uff0c Round n part_encode \u4e3a\u6267\u884cn\u8f6edes\u7684\u4e2d\u95f4\u7ed3\u679c\uff0c Key map \u5e94\u4e3ades\u7684\u5b50\u5bc6\u94a5\uff0c\u8981\u8fd8\u539f\u51fa\u660e\u6587\u53ea\u9700\u8fdb\u884cn\u8f6edes\u52a0\u5bc6\u7684\u9006\u8fc7\u7a0b\u5373\u53ef\uff0c\u89e3\u5bc6\u65f6\u6ce8\u610f\u4ee5\u4e0b\u4e09\u70b9\u3002 \u5b50\u5bc6\u94a5\u7684\u9009\u53d6\uff0c\u5bf9\u4e8e\u53ea\u8fdb\u884c\u4e86n\u8f6e\u7684\u52a0\u5bc6\u7ed3\u679c\uff0c\u89e3\u5bc6\u65f6\u5e94\u4f9d\u6b21\u4f7f\u7528\u5bc6\u94a5 n, n-1..., 1\u3002 des \u6700\u540e\u4e00\u8f6e\u540e\u7684\u64cd\u4f5c\uff0c\u672a\u5b8c\u6210\u7684 des \u6ca1\u6709\u4ea4\u6362\u5de6\u53f3\u4e24\u90e8\u5206\u548c\u9006\u521d\u59cb\u7f6e\u6362\uff0c\u56e0\u6b64\u89e3\u5bc6\u65f6\u6211\u4eec\u5e94\u5148\u5bf9\u5bc6\u6587\u8fdb\u884c\u8fd9\u4e24\u6b65\u64cd\u4f5c\u3002 n \u7684\u9009\u62e9\uff0c\u5728\u672c\u9898\u4e2d\uff0c\u6211\u4eec\u5e76\u4e0d\u77e5\u9053 n\uff0c\u4f46\u8fd9\u65e0\u5173\u7d27\u8981\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u6240\u6709\u53ef\u80fd\u7684\u53d6\u503c\uff080-15\uff09flag\u5e94\u4e3aascii\u5b57\u7b26\u4e32\u3002 \u89e3\u9898\u4ee3\u7801 kkk = 16 def bit_rot_left ( lst , pos ): return lst [ pos :] + lst [: pos ] class DES : IP = [ 58 , 50 , 42 , 34 , 26 , 18 , 10 , 2 , 60 , 52 , 44 , 36 , 28 , 20 , 12 , 4 , 62 , 54 , 46 , 38 , 30 , 22 , 14 , 6 , 64 , 56 , 48 , 40 , 32 , 24 , 16 , 8 , 57 , 49 , 41 , 33 , 25 , 17 , 9 , 1 , 59 , 51 , 43 , 35 , 27 , 19 , 11 , 3 , 61 , 53 , 45 , 37 , 29 , 21 , 13 , 5 , 63 , 55 , 47 , 39 , 31 , 23 , 15 , 7 ] IP_re = [ 40 , 8 , 48 , 16 , 56 , 24 , 64 , 32 , 39 , 7 , 47 , 15 , 55 , 23 , 63 , 31 , 38 , 6 , 46 , 14 , 54 , 22 , 62 , 30 , 37 , 5 , 45 , 13 , 53 , 21 , 61 , 29 , 36 , 4 , 44 , 12 , 52 , 20 , 60 , 28 , 35 , 3 , 43 , 11 , 51 , 19 , 59 , 27 , 34 , 2 , 42 , 10 , 50 , 18 , 58 , 26 , 33 , 1 , 41 , 9 , 49 , 17 , 57 , 25 ] Pbox = [ 16 , 7 , 20 , 21 , 29 , 12 , 28 , 17 , 1 , 15 , 23 , 26 , 5 , 18 , 31 , 10 , 2 , 8 , 24 , 14 , 32 , 27 , 3 , 9 , 19 , 13 , 30 , 6 , 22 , 11 , 4 , 25 ] E = [ 32 , 1 , 2 , 3 , 4 , 5 , 4 , 5 , 6 , 7 , 8 , 9 , 8 , 9 , 10 , 11 , 12 , 13 , 12 , 13 , 14 , 15 , 16 , 17 , 16 , 17 , 18 , 19 , 20 , 21 , 20 , 21 , 22 , 23 , 24 , 25 , 24 , 25 , 26 , 27 , 28 , 29 , 28 , 29 , 30 , 31 , 32 , 1 ] PC1 = [ 57 , 49 , 41 , 33 , 25 , 17 , 9 , 1 , 58 , 50 , 42 , 34 , 26 , 18 , 10 , 2 , 59 , 51 , 43 , 35 , 27 , 19 , 11 , 3 , 60 , 52 , 44 , 36 , 63 , 55 , 47 , 39 , 31 , 23 , 15 , 7 , 62 , 54 , 46 , 38 , 30 , 22 , 14 , 6 , 61 , 53 , 45 , 37 , 29 , 21 , 13 , 5 , 28 , 20 , 12 , 4 ] PC2 = [ 14 , 17 , 11 , 24 , 1 , 5 , 3 , 28 , 15 , 6 , 21 , 10 , 23 , 19 , 12 , 4 , 26 , 8 , 16 , 7 , 27 , 20 , 13 , 2 , 41 , 52 , 31 , 37 , 47 , 55 , 30 , 40 , 51 , 45 , 33 , 48 , 44 , 49 , 39 , 56 , 34 , 53 , 46 , 42 , 50 , 36 , 29 , 32 ] Sbox = [ [ [ 14 , 4 , 13 , 1 , 2 , 15 , 11 , 8 , 3 , 10 , 6 , 12 , 5 , 9 , 0 , 7 ], [ 0 , 15 , 7 , 4 , 14 , 2 , 13 , 1 , 10 , 6 , 12 , 11 , 9 , 5 , 3 , 8 ], [ 4 , 1 , 14 , 8 , 13 , 6 , 2 , 11 , 15 , 12 , 9 , 7 , 3 , 10 , 5 , 0 ], [ 15 , 12 , 8 , 2 , 4 , 9 , 1 , 7 , 5 , 11 , 3 , 14 , 10 , 0 , 6 , 13 ], ], [ [ 15 , 1 , 8 , 14 , 6 , 11 , 3 , 4 , 9 , 7 , 2 , 13 , 12 , 0 , 5 , 10 ], [ 3 , 13 , 4 , 7 , 15 , 2 , 8 , 14 , 12 , 0 , 1 , 10 , 6 , 9 , 11 , 5 ], [ 0 , 14 , 7 , 11 , 10 , 4 , 13 , 1 , 5 , 8 , 12 , 6 , 9 , 3 , 2 , 15 ], [ 13 , 8 , 10 , 1 , 3 , 15 , 4 , 2 , 11 , 6 , 7 , 12 , 0 , 5 , 14 , 9 ], ], [ [ 10 , 0 , 9 , 14 , 6 , 3 , 15 , 5 , 1 , 13 , 12 , 7 , 11 , 4 , 2 , 8 ], [ 13 , 7 , 0 , 9 , 3 , 4 , 6 , 10 , 2 , 8 , 5 , 14 , 12 , 11 , 15 , 1 ], [ 13 , 6 , 4 , 9 , 8 , 15 , 3 , 0 , 11 , 1 , 2 , 12 , 5 , 10 , 14 , 7 ], [ 1 , 10 , 13 , 0 , 6 , 9 , 8 , 7 , 4 , 15 , 14 , 3 , 11 , 5 , 2 , 12 ], ], [ [ 7 , 13 , 14 , 3 , 0 , 6 , 9 , 10 , 1 , 2 , 8 , 5 , 11 , 12 , 4 , 15 ], [ 13 , 8 , 11 , 5 , 6 , 15 , 0 , 3 , 4 , 7 , 2 , 12 , 1 , 10 , 14 , 9 ], [ 10 , 6 , 9 , 0 , 12 , 11 , 7 , 13 , 15 , 1 , 3 , 14 , 5 , 2 , 8 , 4 ], [ 3 , 15 , 0 , 6 , 10 , 1 , 13 , 8 , 9 , 4 , 5 , 11 , 12 , 7 , 2 , 14 ], ], [ [ 2 , 12 , 4 , 1 , 7 , 10 , 11 , 6 , 8 , 5 , 3 , 15 , 13 , 0 , 14 , 9 ], [ 14 , 11 , 2 , 12 , 4 , 7 , 13 , 1 , 5 , 0 , 15 , 10 , 3 , 9 , 8 , 6 ], [ 4 , 2 , 1 , 11 , 10 , 13 , 7 , 8 , 15 , 9 , 12 , 5 , 6 , 3 , 0 , 14 ], [ 11 , 8 , 12 , 7 , 1 , 14 , 2 , 13 , 6 , 15 , 0 , 9 , 10 , 4 , 5 , 3 ], ], [ [ 12 , 1 , 10 , 15 , 9 , 2 , 6 , 8 , 0 , 13 , 3 , 4 , 14 , 7 , 5 , 11 ], [ 10 , 15 , 4 , 2 , 7 , 12 , 9 , 5 , 6 , 1 , 13 , 14 , 0 , 11 , 3 , 8 ], [ 9 , 14 , 15 , 5 , 2 , 8 , 12 , 3 , 7 , 0 , 4 , 10 , 1 , 13 , 11 , 6 ], [ 4 , 3 , 2 , 12 , 9 , 5 , 15 , 10 , 11 , 14 , 1 , 7 , 6 , 0 , 8 , 13 ], ], [ [ 4 , 11 , 2 , 14 , 15 , 0 , 8 , 13 , 3 , 12 , 9 , 7 , 5 , 10 , 6 , 1 ], [ 13 , 0 , 11 , 7 , 4 , 9 , 1 , 10 , 14 , 3 , 5 , 12 , 2 , 15 , 8 , 6 ], [ 1 , 4 , 11 , 13 , 12 , 3 , 7 , 14 , 10 , 15 , 6 , 8 , 0 , 5 , 9 , 2 ], [ 6 , 11 , 13 , 8 , 1 , 4 , 10 , 7 , 9 , 5 , 0 , 15 , 14 , 2 , 3 , 12 ], ], [ [ 13 , 2 , 8 , 4 , 6 , 15 , 11 , 1 , 10 , 9 , 3 , 14 , 5 , 0 , 12 , 7 ], [ 1 , 15 , 13 , 8 , 10 , 3 , 7 , 4 , 12 , 5 , 6 , 11 , 0 , 14 , 9 , 2 ], [ 7 , 11 , 4 , 1 , 9 , 12 , 14 , 2 , 0 , 6 , 10 , 13 , 15 , 3 , 5 , 8 ], [ 2 , 1 , 14 , 7 , 4 , 10 , 8 , 13 , 15 , 12 , 9 , 0 , 3 , 5 , 6 , 11 ], ] ] rout = [ 1 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 2 , 2 , 2 , 1 ] def __init__ ( self ): self . subkey = [[[ 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ]], [[ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 ], [ 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 ], [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 ], [ 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ], [ 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 ], [ 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 ], [ 1 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 1 ]]] def permute ( self , lst , tb ): return [ lst [ i - 1 ] for i in tb ] def f ( self , riti , subkeyi ): tmp = [ i ^ j for i , j in zip ( subkeyi , self . permute ( riti , DES . E ))] return self . permute ( sum ([[ int ( l ) for l in str ( bin ( DES . Sbox [ i ][ int ( str ( tmp [ 6 * i ]) + str ( tmp [ 6 * i + 5 ]), 2 )][ int ( \"\" . join ( str ( j ) for j in tmp [ 6 * i + 1 : 6 * i + 5 ]), 2 )])[ 2 :] . zfill ( 4 ))] for i in range ( 8 )],[]), DES . Pbox ) def des_main ( self , m , mark ): sbkey = self . subkey [ 0 ] #if mark == 'e' else self.subkey[1] # tmp = self.permute([int(i) for i in list((m).ljust(64,\"0\"))],self.IP) tmp = [ int ( i ) for i in list (( m ) . ljust ( 64 , \"0\" ))] global kkk print ( kkk ) for i in range ( kkk ): tmp = tmp [ 32 :] + [ j ^ k for j , k in zip ( tmp [: 32 ], self . f ( tmp [ 32 :], sbkey [ i if mark != 'd' else kkk - 1 - i ]))] return \"\" . join ([ str ( i ) for i in self . permute ( tmp [ 32 :] + tmp [: 32 ], self . IP_re )]) def des_encipher ( self , m ): m = \"\" . join ([ bin ( ord ( i ))[ 2 :] . zfill ( 8 ) for i in m ]) des_en = self . des_main ( m , 'e' ) return \"\" . join ([ chr ( int ( des_en [ i * 8 : i * 8 + 8 ], 2 )) for i in range ( 8 )]) def des_decipher ( self , c ): c = \"\" . join ([ bin ( ord ( i ))[ 2 :] . zfill ( 8 ) for i in c ]) des_de = self . des_main ( c , 'd' ) return \"\" . join ([ chr ( int ( des_de [ i * 8 : i * 8 + 8 ], 2 )) for i in range ( 8 )]) def test (): import base64 global kkk while kkk >= 0 : desobj = DES () # cipher = desobj.des_encipher(\"12345678\") cipher = ' \\x01\\x19\\xe1 + \\x92\\xd9\\x15 %' message1 = desobj . des_decipher ( cipher ) print ( message1 ) kkk -= 1 if __name__ == '__main__' : test () \u89e3\u5bc6\u7ed3\u679c\uff08\u90e8\u5206\uff09\uff1a 14 t-\u00cfE\u00cfx\u0090\u00a7 13 y0ur9Ood 12 \u00b5p^\u00db\u00e9=\u00b9\u0088 11 )\u00c1`r\u00fb\u00d5\u00fb\u009d \u53ef\u4ee5\u770b\u51fan\u4e3a13\uff0cflag\u4e3a flag{y0ur9Ood}","title":"2019 CISCN  part_des"},{"location":"crypto/ctf-wiki/blockcipher/des-zh/#_8","text":"\u6e05\u534e\u5927\u5b66\u7814\u7a76\u751f\u6570\u636e\u5b89\u5168\u8bfe\u7a0b\u8bfe\u4ef6 https://en.wikipedia.org/wiki/Data_Encryption_Standard","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/blockcipher/des/","text":"EN | ZH DES \u00b6 basic introduction \u00b6 Data Encryption Standard (DES), a data encryption standard, is a typical block encryption. The basic information is as follows: Enter 64 bits. Output 64 bits. The key is 64 bits, using 56 bits of the 64-bit key, and the remaining 8 bits are either discarded or used as parity bits. Feistel iterative structure The plaintext is ciphered after 16 iterations. The ciphertext is plaintext after a similar 16 iterations. Basic Process \u00b6 Give a simple [DES Flowchart] ( http://homepage.usask.ca/~dtr467/400/ ). Encryption \u00b6 We can consider each round of encryption process L_{i+1}=R_i L_{i+1}=R_i R_{i+1}=L_i\\oplus F(R_i,K_i) R_{i+1}=L_i\\oplus F(R_i,K_i) Then before the last Permutation, the corresponding ciphertext is (R_{n+1}, L_{n+1}) (R_{n+1}, L_{n+1}) . Decryption \u00b6 So how does decryption decrypt it? First, we can reverse the ciphertext first, then we can get the final round of output. We will consider each round at this time. R_i=L_{i+1} R_i=L_{i+1} L_i=R_{i+1}\\oplus F(L_{i+1},K_i) L_i=R_{i+1}\\oplus F(L_{i+1},K_i) Therefore, (L_0,R_0) (L_0,R_0) is the plaintext after the first replacement when encrypting. We only need to perform the inverse permutation to get the plaintext. It can be seen that DES encryption and decryption uses the same set of logic, except that the order in which the keys are used is inconsistent. Core components \u00b6 The core components in DES mainly include (only the encryption process is given here) initial replacement F function E extension function S box, design criteria not given. P replacement Last replacement Where the F function is as follows If you are more interested in DES, you can study it more closely. Welcome to PR. derivative \u00b6 Based on DES, the following two encryption methods are derived. Double DES Three DES Dual DES \u00b6 Dual DES uses two keys and is 112 bits long. Encryption method is as follows $ C = E_ {k2} (E_ {k1} (P)) $ But dual DES can't resist the middle encounter attack, we can construct the following two sets $ I = {E_ {k1} (P)} $ J=D_{k2}(C) J=D_{k2}(C) That is, respectively enumerate K1 and K2 to encrypt P and decrypt C respectively. After we encrypt P, we can sort the encryption results. The complexity is 2^nlog(2^n)=O(n2^n) 2^nlog(2^n)=O(n2^n) When we decrypt C, we can go to the corresponding table for each decryption. The total complexity is still O(n2^n) O(n2^n) . Triple DES \u00b6 Triple DES encryption and decryption methods are as follows C=E_{k3}(D_{k2}(E_{k1}(P))) C=E_{k3}(D_{k2}(E_{k1}(P))) P=D_{k1}(E_{k2}(D_{k3}(C))) P=D_{k1}(E_{k2}(D_{k3}(C))) There are two ways to choose a key. 3 different keys, k1, k2, k3 are independent of each other, a total of 168 bits. 2 different keys, k1 and k2 are independent, k3 = k1, 112 bits. Attack method \u00b6 Differential attack Linear attack 2018 N1CTF N1ES \u00b6 The basic code is as follows # -*- coding: utf-8 -*- def round_add ( a , b ): f = lambda x , y : x + y - 2 * ( x & y ) true = & #39;&#39; for i in range ( len ( a )): res + = chr ( f ( words ( a [ i ]), words ( b [ i ]))) return res def permutate ( table , block ): return list ( map ( lambda x : block [ x ], table )) def string_to_bits ( data ): data = [ ord ( c ) for c in data ] l = len ( data ) * 8 result = [ 0 ] * l post = 0 for ch in data : for i in range ( 0 , 8 ): result [( pos << 3 ) + i ] = ( ch >> i ) & 1 post + = 1 return result s_box = [ 54 , 132 , 138 , 83 , 16 , 73 , 187 , 84 , 146 , 30 , 95 , 21 , 148 , 63 , 65 , 189 , 188 , 151 , 72 , 161 , 116 , 63 , 161 , 91 , 37 , 24 , 126 , 107 , 87 , 30 , 117 , 185 , 98 , 90 , 0 , 42 , 140 , 70 , 86 , 0 , 42 , 150 , 54 , 22 , 144 , 153 , 36 , 90 , 149 , 54 , 156 , 8 , 59 , 40 , 110 , 56 , 1 , 84 , 103 , 22 , 65 , 17 , 190 , 41 , 99 , 151 , 119 , 124 , 68 , 17 , 166 , 125 , 95 , 65 , 105 , 133 , 49 , 19 , 138 , 29 , 110 , 7 , 81 , 134 , 70 , 87 , 180 , 78 , 175 , 108 , 26 , 121 , 74 , 29 , 68 , 162 , 142 , 177 , 143 , 86 , 129 , 101 , 117 , 41 , 57 , 34 , 177 , 103 , 61 , 135 , 191 , 74 , 69 , 147 , 90 , 49 , 135 , 124 , 106 , 19 , 8 9 , 38 , 21 , 41 , 17 , 155 , 83 , 38 , 159 , 179 , 19 , 157 , 68 , 105 , 151 , 166 , 171 , 122 , 179 , 114 , 52 , 183 , 89 , 107 , 113 , 65 , 161 , 141 , 18 , 121 , 95 , 4 , 95 , 101 , 81 , 156 , 17 , 190 , 38 , 84 , 9 , 171 , 180 , 59 , 45 , 15 , 34 , 89 , 75 , 164 , 190 , 140 , 6 , 41 , 188 , 77 , 165 , 105 , 5 , 107 , 31 , 183 , 107 , 141 , 66 , 63 , 10 , 9 , 125 , 50 , 2 , 153 , 156 , 162 , 186 , 76 , 158 , 153 , 117 , 9 , 77 , 156 , 11 , 145 , 12 , 169 , 52 , 57 , 161 , 7 , 158 , 110 , 191 , 43 , 82 , 186 , 49 , 102 , 166 , 31 , 41 , 5 , 189 , 27 ] def generate ( o ): k = permutate ( s_box , o ) b = [] for i in range ( 0 , len ( k ), 7 ): b . append ( k [ i : i + 7 ] + [ 1 ]) c = [] for i in range ( 32 ): post = 0 x = 0 for j in b [ i ]: x += ( j << pos ) post + = 1 c . append (( 0x10001 ** x ) % ( 0x7f )) return c class N1ES : def __init__ ( self , key ): if ( len ( key ) != 24 or isinstance ( key , bytes ) == False ): raise Exception ( \"key must be 24 bytes long\" ) self . key = key self . gen_subkey () def gen_subkey ( self ): o = string_to_bits ( self . key ) k = [] for i in range ( 8 ): o = generate ( o ) k . extend ( o ) o = string_to_bits ([ chr ( c ) for c in o [ 0 : 24 ]]) self . Kn = [] for i in range ( 32 ): self . Kn . append ( map ( chr , k [ i * 8 : i * 8 + 8 ])) return def encrypt ( self , plaintext ): if ( len ( plaintext ) % 16 != 0 or isinstance ( plaintext , bytes ) == False ): raise Exception ( \"plaintext must be a multiple of 16 in length\" ) true = & #39;&#39; for i in range ( len ( plaintext ) / 16 ): block = plaintext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ round_cnt ])) L , R = R , L res += L + R return res Obviously, we can think of it as a way of Feistel encryption, the decryption function is as follows def decrypt ( self , ciphertext ): true = & #39;&#39; for i in range ( len ( ciphertext ) / 16 ): block = ciphertext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ 31 - round_cnt ])) L , R = R , L res += L + R return res The final result is \u279c baby_N1ES cat challenge.py from N1ES import N1ES import base64 key = \"wxy191iss00000000000cute\" n1es = N1ES ( key ) flag = \"N1CTF{*****************************************}\" cipher = n1es.encrypt ( flag ) #print base64.b64encode(cipher) # HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx cipher = 'HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx' cipher = base64.b64decode ( cipher ) print n1es.decrypt ( cipher ) \u279c baby_N1ES python challenge.py N1CTF { F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d _ / - / } 2019 CISCN part_des \u00b6 The title only gave one file: Round n part_encode-> 0x92d915250119e12b Key map -> 0xe0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84 Considering the title name and data characteristics, Round n part_encode is the intermediate result of executing n rounds of des, and Key map should be the subkey of des. To restore the plaintext, only the reverse process of n rounds of des encryption can be performed. Pay attention to the following three points when decrypting. Subkey selection, for only n rounds of encryption results, the decryption should use the keys n, n-1..., 1 in sequence. des After the last round of operations, the unfinished des does not exchange the left and right parts and the inverse initial permutation, so we should perform these two steps on the ciphertext first. n choice, in this question, we don't know n, but it doesn't matter, we can try all possible values (0-15) flag should be ascii string. ??? note \"Solution code\" ``` python kkk = 16 def bit_rot_left(lst, pos): return lst[pos:] + lst[:pos] class DES: IP = [ 58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7 ] IP_re = [ 40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25 ] Pbox = [ 16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25 ] E = [ 32,1,2,3,4,5,4,5,6,7,8,9, 8,9,10,11,12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21,22,23,24,25, 24,25,26,27,28,29,28,29,30,31,32,1 ] PC1 = [ 57,49,41,33,25,17,9,1,58,50,42,34,26,18, 10,2,59,51,43,35,27,19,11,3,60,52,44,36, 63,55,47,39,31,23,15,7,62,54,46,38,30,22, 14,6,61,53,45,37,29,21,13,5,28,20,12,4 ] PC2 = [ 14,17,11,24,1,5,3,28,15,6,21,10, 23,19,12,4,26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40,51,45,33,48, 44,49,39,56,34,53,46,42,50,36,29,32 ] Sbox = [ [ [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7], [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8], [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0], [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], ], [ [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10], [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5], [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15], [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], ], [ [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8], [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1], [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7], [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], ], [ [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15], [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9], [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4], [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], ], [ [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9], [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6], [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14], [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], ], [ [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11], [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8], [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6], [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], ], [ [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1], [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6], [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2], [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], ], [ [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7], [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2], [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8], [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11], ] ] rout = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1] def __init__(self): self.subkey = [[[1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]] def permute(self, lst, tb): return [lst[i-1] for i in tb] def f(self,riti,subkeyi): tmp = [i^j for i,j in zip(subkeyi,self.permute(riti,DES.E))] return self.permute(sum([[int(l) for l in str(bin(DES.Sbox[i][int(str(tmp[6*i])+str(tmp[6*i+5]),2)][int(\"\".join(str(j) for j in tmp[6*i+1:6*i+5]),2)])[2:].zfill(4))] for i in range(8)],[]),DES.Pbox) def des_main(self,m,mark): sbkey = self.subkey[0] #if mark == 'e' else self.subkey[1] # tmp = self.permute([int(i) for i in list((m).ljust(64,\"0\"))],self.IP) tmp = [int(i) for i in list((m).ljust(64,\"0\"))] global kkk print (kkk) for i in range(kkk): tmp = tmp[32:] + [j^k for j,k in zip(tmp[:32],self.f(tmp[32:],sbkey[i if mark != 'd' else kkk-1-i]))] return \"\".join([str(i) for i in self.permute(tmp[32:]+tmp[:32],self.IP_re)]) def des_encipher(self,m): m = \"\".join([bin(ord(i))[2:].zfill(8) for i in m]) des_en = self.des_main (m, 'e') return \"\".join([chr(int(des_en[i 8:i 8+8],2)) for i in range(8)]) def des_decipher(self,c): c = \"\".join([bin(ord(i))[2:].zfill(8) for i in c]) des_de = self.des_main (c, 'd') return \"\".join([chr(int(des_de[i 8:i 8+8],2)) for i in range(8)]) def test(): import base64 global kkk while kkk >=0: desobj = DES () # cipher = desobj.des_encipher(\"12345678\") cipher = '\\x01\\x19\\xe1+\\x92\\xd9\\x15%' message1 = desobj.des_decipher(cipher) print(message1) kkk = 1 if name ==' main ': test() ``` Decryption result (partial): 14 t-\u00cfE\u00cfx\u0090\u00a7 13 y0ur9Ood 12 \u03bcp ^ \u00db\u00e9 = \u00b9 11 ) \u00c1`r\u00fb\u00d5\u00fb It can be seen that n is 13, and flag is flag{y0ur9Ood} Reference \u00b6 Tsinghua University graduate data security courseware - https://en.wikipedia.org/wiki/Data_Encryption_Standard","title":"DES"},{"location":"crypto/ctf-wiki/blockcipher/des/#des","text":"","title":"DES"},{"location":"crypto/ctf-wiki/blockcipher/des/#basic-introduction","text":"Data Encryption Standard (DES), a data encryption standard, is a typical block encryption. The basic information is as follows: Enter 64 bits. Output 64 bits. The key is 64 bits, using 56 bits of the 64-bit key, and the remaining 8 bits are either discarded or used as parity bits. Feistel iterative structure The plaintext is ciphered after 16 iterations. The ciphertext is plaintext after a similar 16 iterations.","title":"basic introduction"},{"location":"crypto/ctf-wiki/blockcipher/des/#basic-process","text":"Give a simple [DES Flowchart] ( http://homepage.usask.ca/~dtr467/400/ ).","title":"Basic Process"},{"location":"crypto/ctf-wiki/blockcipher/des/#encryption","text":"We can consider each round of encryption process L_{i+1}=R_i L_{i+1}=R_i R_{i+1}=L_i\\oplus F(R_i,K_i) R_{i+1}=L_i\\oplus F(R_i,K_i) Then before the last Permutation, the corresponding ciphertext is (R_{n+1}, L_{n+1}) (R_{n+1}, L_{n+1}) .","title":"Encryption"},{"location":"crypto/ctf-wiki/blockcipher/des/#decryption","text":"So how does decryption decrypt it? First, we can reverse the ciphertext first, then we can get the final round of output. We will consider each round at this time. R_i=L_{i+1} R_i=L_{i+1} L_i=R_{i+1}\\oplus F(L_{i+1},K_i) L_i=R_{i+1}\\oplus F(L_{i+1},K_i) Therefore, (L_0,R_0) (L_0,R_0) is the plaintext after the first replacement when encrypting. We only need to perform the inverse permutation to get the plaintext. It can be seen that DES encryption and decryption uses the same set of logic, except that the order in which the keys are used is inconsistent.","title":"Decryption"},{"location":"crypto/ctf-wiki/blockcipher/des/#core-components","text":"The core components in DES mainly include (only the encryption process is given here) initial replacement F function E extension function S box, design criteria not given. P replacement Last replacement Where the F function is as follows If you are more interested in DES, you can study it more closely. Welcome to PR.","title":"Core components"},{"location":"crypto/ctf-wiki/blockcipher/des/#derivative","text":"Based on DES, the following two encryption methods are derived. Double DES Three DES","title":"derivative"},{"location":"crypto/ctf-wiki/blockcipher/des/#dual-des","text":"Dual DES uses two keys and is 112 bits long. Encryption method is as follows $ C = E_ {k2} (E_ {k1} (P)) $ But dual DES can't resist the middle encounter attack, we can construct the following two sets $ I = {E_ {k1} (P)} $ J=D_{k2}(C) J=D_{k2}(C) That is, respectively enumerate K1 and K2 to encrypt P and decrypt C respectively. After we encrypt P, we can sort the encryption results. The complexity is 2^nlog(2^n)=O(n2^n) 2^nlog(2^n)=O(n2^n) When we decrypt C, we can go to the corresponding table for each decryption. The total complexity is still O(n2^n) O(n2^n) .","title":"Dual DES"},{"location":"crypto/ctf-wiki/blockcipher/des/#triple-des","text":"Triple DES encryption and decryption methods are as follows C=E_{k3}(D_{k2}(E_{k1}(P))) C=E_{k3}(D_{k2}(E_{k1}(P))) P=D_{k1}(E_{k2}(D_{k3}(C))) P=D_{k1}(E_{k2}(D_{k3}(C))) There are two ways to choose a key. 3 different keys, k1, k2, k3 are independent of each other, a total of 168 bits. 2 different keys, k1 and k2 are independent, k3 = k1, 112 bits.","title":"Triple DES"},{"location":"crypto/ctf-wiki/blockcipher/des/#attack-method","text":"Differential attack Linear attack","title":"Attack method"},{"location":"crypto/ctf-wiki/blockcipher/des/#2018-n1ctf-n1es","text":"The basic code is as follows # -*- coding: utf-8 -*- def round_add ( a , b ): f = lambda x , y : x + y - 2 * ( x & y ) true = & #39;&#39; for i in range ( len ( a )): res + = chr ( f ( words ( a [ i ]), words ( b [ i ]))) return res def permutate ( table , block ): return list ( map ( lambda x : block [ x ], table )) def string_to_bits ( data ): data = [ ord ( c ) for c in data ] l = len ( data ) * 8 result = [ 0 ] * l post = 0 for ch in data : for i in range ( 0 , 8 ): result [( pos << 3 ) + i ] = ( ch >> i ) & 1 post + = 1 return result s_box = [ 54 , 132 , 138 , 83 , 16 , 73 , 187 , 84 , 146 , 30 , 95 , 21 , 148 , 63 , 65 , 189 , 188 , 151 , 72 , 161 , 116 , 63 , 161 , 91 , 37 , 24 , 126 , 107 , 87 , 30 , 117 , 185 , 98 , 90 , 0 , 42 , 140 , 70 , 86 , 0 , 42 , 150 , 54 , 22 , 144 , 153 , 36 , 90 , 149 , 54 , 156 , 8 , 59 , 40 , 110 , 56 , 1 , 84 , 103 , 22 , 65 , 17 , 190 , 41 , 99 , 151 , 119 , 124 , 68 , 17 , 166 , 125 , 95 , 65 , 105 , 133 , 49 , 19 , 138 , 29 , 110 , 7 , 81 , 134 , 70 , 87 , 180 , 78 , 175 , 108 , 26 , 121 , 74 , 29 , 68 , 162 , 142 , 177 , 143 , 86 , 129 , 101 , 117 , 41 , 57 , 34 , 177 , 103 , 61 , 135 , 191 , 74 , 69 , 147 , 90 , 49 , 135 , 124 , 106 , 19 , 8 9 , 38 , 21 , 41 , 17 , 155 , 83 , 38 , 159 , 179 , 19 , 157 , 68 , 105 , 151 , 166 , 171 , 122 , 179 , 114 , 52 , 183 , 89 , 107 , 113 , 65 , 161 , 141 , 18 , 121 , 95 , 4 , 95 , 101 , 81 , 156 , 17 , 190 , 38 , 84 , 9 , 171 , 180 , 59 , 45 , 15 , 34 , 89 , 75 , 164 , 190 , 140 , 6 , 41 , 188 , 77 , 165 , 105 , 5 , 107 , 31 , 183 , 107 , 141 , 66 , 63 , 10 , 9 , 125 , 50 , 2 , 153 , 156 , 162 , 186 , 76 , 158 , 153 , 117 , 9 , 77 , 156 , 11 , 145 , 12 , 169 , 52 , 57 , 161 , 7 , 158 , 110 , 191 , 43 , 82 , 186 , 49 , 102 , 166 , 31 , 41 , 5 , 189 , 27 ] def generate ( o ): k = permutate ( s_box , o ) b = [] for i in range ( 0 , len ( k ), 7 ): b . append ( k [ i : i + 7 ] + [ 1 ]) c = [] for i in range ( 32 ): post = 0 x = 0 for j in b [ i ]: x += ( j << pos ) post + = 1 c . append (( 0x10001 ** x ) % ( 0x7f )) return c class N1ES : def __init__ ( self , key ): if ( len ( key ) != 24 or isinstance ( key , bytes ) == False ): raise Exception ( \"key must be 24 bytes long\" ) self . key = key self . gen_subkey () def gen_subkey ( self ): o = string_to_bits ( self . key ) k = [] for i in range ( 8 ): o = generate ( o ) k . extend ( o ) o = string_to_bits ([ chr ( c ) for c in o [ 0 : 24 ]]) self . Kn = [] for i in range ( 32 ): self . Kn . append ( map ( chr , k [ i * 8 : i * 8 + 8 ])) return def encrypt ( self , plaintext ): if ( len ( plaintext ) % 16 != 0 or isinstance ( plaintext , bytes ) == False ): raise Exception ( \"plaintext must be a multiple of 16 in length\" ) true = & #39;&#39; for i in range ( len ( plaintext ) / 16 ): block = plaintext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ round_cnt ])) L , R = R , L res += L + R return res Obviously, we can think of it as a way of Feistel encryption, the decryption function is as follows def decrypt ( self , ciphertext ): true = & #39;&#39; for i in range ( len ( ciphertext ) / 16 ): block = ciphertext [ i * 16 :( i + 1 ) * 16 ] L = block [: 8 ] R = block [ 8 :] for round_cnt in range ( 32 ): L , R = R , ( round_add ( L , self . Kn [ 31 - round_cnt ])) L , R = R , L res += L + R return res The final result is \u279c baby_N1ES cat challenge.py from N1ES import N1ES import base64 key = \"wxy191iss00000000000cute\" n1es = N1ES ( key ) flag = \"N1CTF{*****************************************}\" cipher = n1es.encrypt ( flag ) #print base64.b64encode(cipher) # HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx cipher = 'HRlgC2ReHW1/WRk2DikfNBo1dl1XZBJrRR9qECMNOjNHDktBJSxcI1hZIz07YjVx' cipher = base64.b64decode ( cipher ) print n1es.decrypt ( cipher ) \u279c baby_N1ES python challenge.py N1CTF { F3istel_n3tw0rk_c4n_b3_ea5i1y_s0lv3d _ / - / }","title":"2018 N1CTF N1ES"},{"location":"crypto/ctf-wiki/blockcipher/des/#2019-ciscn-part_des","text":"The title only gave one file: Round n part_encode-> 0x92d915250119e12b Key map -> 0xe0be661032d5f0b676f82095e4d67623628fe6d376363183aed373a60167af537b46abc2af53d97485591f5bd94b944a3f49d94897ea1f699d1cdc291f2d9d4a5c705f2cad89e938dbacaca15e10d8aeaed90236f0be2e954a8cf0bea6112e84 Considering the title name and data characteristics, Round n part_encode is the intermediate result of executing n rounds of des, and Key map should be the subkey of des. To restore the plaintext, only the reverse process of n rounds of des encryption can be performed. Pay attention to the following three points when decrypting. Subkey selection, for only n rounds of encryption results, the decryption should use the keys n, n-1..., 1 in sequence. des After the last round of operations, the unfinished des does not exchange the left and right parts and the inverse initial permutation, so we should perform these two steps on the ciphertext first. n choice, in this question, we don't know n, but it doesn't matter, we can try all possible values (0-15) flag should be ascii string. ??? note \"Solution code\" ``` python kkk = 16 def bit_rot_left(lst, pos): return lst[pos:] + lst[:pos] class DES: IP = [ 58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4, 62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8, 57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3, 61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7 ] IP_re = [ 40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31, 38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29, 36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27, 34,2,42,10,50,18,58,26,33,1,41,9,49,17,57,25 ] Pbox = [ 16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10, 2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25 ] E = [ 32,1,2,3,4,5,4,5,6,7,8,9, 8,9,10,11,12,13,12,13,14,15,16,17, 16,17,18,19,20,21,20,21,22,23,24,25, 24,25,26,27,28,29,28,29,30,31,32,1 ] PC1 = [ 57,49,41,33,25,17,9,1,58,50,42,34,26,18, 10,2,59,51,43,35,27,19,11,3,60,52,44,36, 63,55,47,39,31,23,15,7,62,54,46,38,30,22, 14,6,61,53,45,37,29,21,13,5,28,20,12,4 ] PC2 = [ 14,17,11,24,1,5,3,28,15,6,21,10, 23,19,12,4,26,8,16,7,27,20,13,2, 41,52,31,37,47,55,30,40,51,45,33,48, 44,49,39,56,34,53,46,42,50,36,29,32 ] Sbox = [ [ [14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7], [0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8], [4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0], [15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13], ], [ [15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10], [3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5], [0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15], [13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9], ], [ [10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8], [13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1], [13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7], [1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12], ], [ [7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15], [13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9], [10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4], [3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14], ], [ [2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9], [14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6], [4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14], [11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3], ], [ [12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11], [10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8], [9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6], [4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13], ], [ [4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1], [13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6], [1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2], [6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12], ], [ [13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7], [1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2], [7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8], [2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11], ] ] rout = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1] def __init__(self): self.subkey = [[[1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1]]] def permute(self, lst, tb): return [lst[i-1] for i in tb] def f(self,riti,subkeyi): tmp = [i^j for i,j in zip(subkeyi,self.permute(riti,DES.E))] return self.permute(sum([[int(l) for l in str(bin(DES.Sbox[i][int(str(tmp[6*i])+str(tmp[6*i+5]),2)][int(\"\".join(str(j) for j in tmp[6*i+1:6*i+5]),2)])[2:].zfill(4))] for i in range(8)],[]),DES.Pbox) def des_main(self,m,mark): sbkey = self.subkey[0] #if mark == 'e' else self.subkey[1] # tmp = self.permute([int(i) for i in list((m).ljust(64,\"0\"))],self.IP) tmp = [int(i) for i in list((m).ljust(64,\"0\"))] global kkk print (kkk) for i in range(kkk): tmp = tmp[32:] + [j^k for j,k in zip(tmp[:32],self.f(tmp[32:],sbkey[i if mark != 'd' else kkk-1-i]))] return \"\".join([str(i) for i in self.permute(tmp[32:]+tmp[:32],self.IP_re)]) def des_encipher(self,m): m = \"\".join([bin(ord(i))[2:].zfill(8) for i in m]) des_en = self.des_main (m, 'e') return \"\".join([chr(int(des_en[i 8:i 8+8],2)) for i in range(8)]) def des_decipher(self,c): c = \"\".join([bin(ord(i))[2:].zfill(8) for i in c]) des_de = self.des_main (c, 'd') return \"\".join([chr(int(des_de[i 8:i 8+8],2)) for i in range(8)]) def test(): import base64 global kkk while kkk >=0: desobj = DES () # cipher = desobj.des_encipher(\"12345678\") cipher = '\\x01\\x19\\xe1+\\x92\\xd9\\x15%' message1 = desobj.des_decipher(cipher) print(message1) kkk = 1 if name ==' main ': test() ``` Decryption result (partial): 14 t-\u00cfE\u00cfx\u0090\u00a7 13 y0ur9Ood 12 \u03bcp ^ \u00db\u00e9 = \u00b9 11 ) \u00c1`r\u00fb\u00d5\u00fb It can be seen that n is 13, and flag is flag{y0ur9Ood}","title":"2019 CISCN part_des"},{"location":"crypto/ctf-wiki/blockcipher/des/#reference","text":"Tsinghua University graduate data security courseware - https://en.wikipedia.org/wiki/Data_Encryption_Standard","title":"Reference"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/","text":"EN | ZH IDEA \u00b6 \u6982\u8ff0 \u00b6 \u56fd\u9645\u6570\u636e\u52a0\u5bc6\u7b97\u6cd5 \uff08International Data Encryption Algorithm\uff0cIDEA\uff09\uff0c\u6700\u65e9\u79f0\u4e3a \u6539\u826f\u5efa\u8bae\u52a0\u5bc6\u6807\u51c6 \uff08Improved Proposed Encryption Standard\uff0cIPES\uff09\uff0c\u662f\u5bc6\u7801\u5b66\u4e0a\u4e00\u79cd\u5bf9\u79f0\u5bc6\u94a5\u5206\u7ec4\u5bc6\u7801\uff0c\u7531 James Massey \u4e0e\u6765\u5b66\u5609\u8bbe\u8ba1\uff0c\u57281991\u5e74\u9996\u6b21\u63d0\u51fa\u3002\u8fd9\u4e2a\u7b97\u6cd5\u7684\u63d0\u51fa\uff0c\u662f\u4e3a\u4e86\u53d6\u4ee3\u65e7\u6709\u7684\u6570\u636e\u52a0\u5bc6\u6807\u51c6 DES\u3002\uff08\u6765\u81ea\u7ef4\u57fa\u767e\u79d1\uff09 \u57fa\u672c\u6d41\u7a0b \u00b6 \u5bc6\u94a5\u751f\u6210 \u00b6 IDEA \u5728\u52a0\u5bc6\u7684\u6bcf\u8f6e\u4e2d\u4f7f\u7528 6\u4e2a\u5bc6\u94a5\uff0c\u7136\u540e\u6700\u540e\u8f93\u51fa\u8f6e\u4f7f\u75284\u4e2a\u5bc6\u94a5\u3002\u6240\u4ee5\u4e00\u5171\u670952\u4e2a\u3002 \u524d8\u4e2a\u5bc6\u94a5\u6765\u81ea\u4e0e\u8be5\u7b97\u6cd5\u6700\u521d\u7684\u5bc6\u94a5\uff0cK1 \u53d6\u81ea\u5bc6\u94a5\u7684\u9ad816\u6bd4\u7279\uff0cK8 \u53d6\u81ea\u5bc6\u94a5\u7684\u4f4e16\u6bd4\u7279\u3002 \u5c06\u5bc6\u94a5\u5faa\u73af\u5de6\u79fb 25 \u4f4d\u83b7\u53d6\u4e0b\u4e00\u8f6e\u5bc6\u94a5\uff0c\u7136\u540e\u518d\u6b21\u5206\u4e3a8\u7ec4\u3002 \u52a0\u5bc6\u6d41\u7a0b \u00b6 IDEA \u52a0\u5bc6\u7684\u6570\u636e\u5757\u7684\u5927\u5c0f\u4e3a 64 \u6bd4\u7279\uff0c\u5176\u4f7f\u7528\u7684\u5bc6\u94a5\u957f\u5ea6\u4e3a128 \u6bd4\u7279\u3002\u8be5\u7b97\u6cd5\u4f1a\u5bf9\u8f93\u5165\u7684\u6570\u636e\u5757\u8fdb\u884c8\u6b21\u76f8\u540c\u7684\u53d8\u6362\uff0c\u53ea\u662f\u6bcf\u6b21\u4f7f\u7528\u7684\u5bc6\u94a5\u4e0d\u540c\uff0c\u6700\u540e\u4f1a\u8fdb\u884c\u4e00\u6b21\u8f93\u51fa\u53d8\u6362\u3002\u6bcf\u4e00\u8f6e\u7684\u64cd\u4f5c \u53ef\u4ee5\u8f93\u5165\u548c\u8f93\u51fa\u90fd\u662f 16 \u6bd4\u7279\u4f4d\u4e00\u7ec4\u3002\u6bcf\u4e00\u8f6e\u7684\u4e3b\u8981\u6267\u884c\u7684\u8fd0\u7b97\u6709 \u6309\u4f4d\u5f02\u6216\uff0c\u2295 \u6a21\u52a0\uff0c\u6a21\u6570\u4e3a 2^{16} 2^{16} \uff0c\u229e \u6a21\u4e58\uff0c\u6a21\u6570\u4e3a 2^{16}+1 2^{16}+1 \uff0c\u2299\u3002\u4f46\u662f\u9700\u8981\u6ce8\u610f\u7684\u662f 0x0000 \u7684\u8f93\u5165\u4f1a\u88ab\u4fee\u6539\u4e3a 2^{16} 2^{16} \uff0c 2^{16} 2^{16} \u7684\u8f93\u51fa\u7ed3\u679c\u4f1a\u88ab\u4fee\u6539\u4e3a0x0000\u3002 \u8fd9\u91cc\u6211\u4eec\u79f0\u7531 K5\uff0cK6 \u6784\u6210\u7684\u4e2d\u95f4\u90a3\u4e2a\u65b9\u683c\u7684\u52a0\u5bc6\u65b9\u5f0f\u4e3aMA\u3002\u8fd9\u4e5f\u662f IDEA \u7b97\u6cd5\u4e2d\u91cd\u8981\u7684\u4e00\u90e8\u5206\uff0c\u6b64\u5916\uff0c\u6211\u4eec\u79f0 MA_L \u4e3a\u8be5\u90e8\u5206\u52a0\u5bc6\u540e\u7684\u5de6\u4fa7\u7ed3\u679c\uff0c\u5176\u6700\u540e\u4f1a\u548c\u6700\u5de6\u8fb9\u7684 16 \u6bd4\u7279\u64cd\u4f5c\uff1bMA_R \u4e3a\u8be5\u90e8\u5206\u52a0\u5bc6\u540e\u7684\u53f3\u534a\u90e8\u5206\u7684\u7ed3\u679c\uff0c\u5176\u6700\u540e\u4f1a\u548c\u7b2c\u4e09\u4e2a 16 \u6bd4\u7279\u64cd\u4f5c\u3002 \u5728\u6700\u540e\u8f93\u51fa\u8f6e\u7684\u64cd\u4f5c\u5982\u4e0b \u89e3\u5bc6\u6d41\u7a0b \u00b6 \u89e3\u5bc6\u6d41\u7a0b\u4e0e\u52a0\u5bc6\u6d41\u7a0b\u76f8\u4f3c\uff0c\u4e3b\u8981\u5728\u4e8e\u5176\u5bc6\u94a5\u7684\u9009\u53d6 \u7b2c i(1-9) \u8f6e\u7684\u89e3\u5bc6\u7684\u5bc6\u94a5\u7684\u524d 4 \u4e2a\u5b50\u5bc6\u94a5\u7531\u52a0\u5bc6\u8fc7\u7a0b\u4e2d\u7b2c10-i \u8f6e\u7684\u524d 4 \u4e2a\u5b50\u5bc6\u94a5\u5f97\u51fa \u5176\u4e2d\u7b2c 1 \u4e2a\u548c\u7b2c 4 \u4e2a\u89e3\u5bc6\u5b50\u5bc6\u94a5\u4e3a\u76f8\u5e94\u7684\u5b50\u5bc6\u94a5\u5173\u4e8e 2^{16}+1 2^{16}+1 \u7684\u4e58\u6cd5\u9006\u5143\u3002 \u7b2c 2 \u4e2a\u548c\u7b2c 3 \u4e2a\u5b50\u5bc6\u94a5\u7684\u53d6\u6cd5\u4e3a \u5f53\u8f6e\u6570\u4e3a2\uff0c...\uff0c8\u65f6\uff0c\u53d6\u76f8\u5e94\u7684\u7b2c3\u4e2a\u548c\u7b2c2\u4e2a\u7684\u5b50\u5bc6\u94a5\u7684 2^{16} 2^{16} \u7684\u52a0\u5bc6\u9006\u5143\u3002 \u5f53\u8f6e\u6570\u4e3a 1 \u6216 9 \u65f6\uff0c\u53d6\u76f8\u5e94\u7684\u7b2c 2 \u4e2a\u548c\u7b2c 3 \u4e2a\u5b50\u5bc6\u94a5\u5bf9\u5e94\u7684 2^{16} 2^{16} \u7684\u52a0\u5bc6\u9006\u5143\u3002 \u7b2c 5 \u548c\u7b2c 6 \u4e2a\u5bc6\u94a5\u4e0d\u53d8\u3002 \u603b\u4f53\u6d41\u7a0b \u00b6 \u6211\u4eec\u6765\u8bc1\u660e\u4e00\u4e0b\u7b97\u6cd5\u7684\u6b63\u786e\u6027\uff0c\u8fd9\u91cc\u6211\u4eec\u5173\u6ce8\u4e8e\u89e3\u5bc6\u7b97\u6cd5\u7684\u7b2c\u4e00\u8f6e\uff0c\u9996\u5148\u6211\u4eec\u5148\u770b\u4e00\u4e0b Y_i Y_i \u662f\u5982\u4f55\u5f97\u5230\u7684 Y_1 = W_{81} \\odot Z_{49} Y_1 = W_{81} \\odot Z_{49} Y_2=W_{83}\\boxplus Z_{50} Y_2=W_{83}\\boxplus Z_{50} Y_3=W_{82}\\boxplus Z_{51} Y_3=W_{82}\\boxplus Z_{51} Y_4=W_{83}\\odot Z_{52} Y_4=W_{83}\\odot Z_{52} \u89e3\u5bc6\u65f6\uff0c\u7b2c\u4e00\u8f6e\u76f4\u63a5\u8fdb\u884c\u7684\u53d8\u6362\u4e3a J_{11}=Y_1 \\odot U_1=Y_1 \\odot Z_{49}^{-1}=W_{81} J_{11}=Y_1 \\odot U_1=Y_1 \\odot Z_{49}^{-1}=W_{81} J_{12}=Y_2 \\boxplus U2=Y_2\\boxplus Z_{50}^{-1}=W_{83} J_{12}=Y_2 \\boxplus U2=Y_2\\boxplus Z_{50}^{-1}=W_{83} J_{13}=Y_3 \\boxplus U3=Y_3\\boxplus Z_{51}^{-1}=W_{82} J_{13}=Y_3 \\boxplus U3=Y_3\\boxplus Z_{51}^{-1}=W_{82} J_{14}=Y_4 \\odot U_4=Y_4 \\odot Z_{52}^{-1}=W_{84} J_{14}=Y_4 \\odot U_4=Y_4 \\odot Z_{52}^{-1}=W_{84} \u53ef\u4ee5\u770b\u51fa\u5f97\u5230\u7684\u7ed3\u679c\u53ea\u6709\u4e2d\u95f4\u7684\u4e24\u4e2a16\u4f4d\u52a0\u5bc6\u7ed3\u679c\u6070\u597d\u76f8\u53cd\u3002\u6211\u4eec\u8fdb\u4e00\u6b65\u770b\u4e00\u4e0b W_{8i} W_{8i} \u662f\u5982\u4f55\u5f97\u5230\u7684\u3002 W_{81}=I_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{81}=I_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{82}=I_{83} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{82}=I_{83} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{83}=I_{82} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{83}=I_{82} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{84}=I_{84} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{84}=I_{84} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) \u90a3\u4e48\u5bf9\u4e8eV11\u6765\u8bf4 V_{11}=J_{11} \\oplus MA_R(J_{11}\\oplus J_{13},J_{12}\\oplus J_{14}) V_{11}=J_{11} \\oplus MA_R(J_{11}\\oplus J_{13},J_{12}\\oplus J_{14}) \u901a\u8fc7\u7b80\u5355\u5e26\u5165\u5df2\u6709\u7684\u503c\uff0c\u663e\u7136 V_{11}=W_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82} \\oplus I_{84})=I_{81} V_{11}=W_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82} \\oplus I_{84})=I_{81} \u5bf9\u4e8e\u5176\u4ed6\u7684\u5143\u7d20\u4e5f\u7c7b\u4f3c\uff0c\u90a3\u4e48\u5176\u5b9e\u6211\u4eec\u4f1a\u53d1\u73b0\u7b2c\u4e00\u8f6e\u89e3\u5bc6\u540e\u7684\u7ed3\u679c\u6070\u597d\u662f I_{81},I_{83},I_{82},I_{84} I_{81},I_{83},I_{82},I_{84} \u3002 \u7c7b\u4f3c\u5730\uff0c\u8fd9\u4e2a\u5173\u7cfb\u53ef\u4ee5\u4e00\u76f4\u6ee1\u8db3\u76f4\u5230 V_{81}=I_{11},V_{82}=I_{13},V_{83}=I_{12},V_{84}=I_{14} V_{81}=I_{11},V_{82}=I_{13},V_{83}=I_{12},V_{84}=I_{14} \u90a3\u4e48\u6700\u540e\u518d\u7ecf\u8fc7\u4e00\u6b21\u7b80\u5355\u7684\u8f93\u51fa\u53d8\u6362\uff0c\u6070\u597d\u5f97\u5230\u6700\u521d\u52a0\u5bc6\u7684\u6570\u503c\u3002 \u9898\u76ee \u00b6 2017 HITCON seccomp","title":"Idea zh"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/#idea","text":"","title":"IDEA"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/#_1","text":"\u56fd\u9645\u6570\u636e\u52a0\u5bc6\u7b97\u6cd5 \uff08International Data Encryption Algorithm\uff0cIDEA\uff09\uff0c\u6700\u65e9\u79f0\u4e3a \u6539\u826f\u5efa\u8bae\u52a0\u5bc6\u6807\u51c6 \uff08Improved Proposed Encryption Standard\uff0cIPES\uff09\uff0c\u662f\u5bc6\u7801\u5b66\u4e0a\u4e00\u79cd\u5bf9\u79f0\u5bc6\u94a5\u5206\u7ec4\u5bc6\u7801\uff0c\u7531 James Massey \u4e0e\u6765\u5b66\u5609\u8bbe\u8ba1\uff0c\u57281991\u5e74\u9996\u6b21\u63d0\u51fa\u3002\u8fd9\u4e2a\u7b97\u6cd5\u7684\u63d0\u51fa\uff0c\u662f\u4e3a\u4e86\u53d6\u4ee3\u65e7\u6709\u7684\u6570\u636e\u52a0\u5bc6\u6807\u51c6 DES\u3002\uff08\u6765\u81ea\u7ef4\u57fa\u767e\u79d1\uff09","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/#_2","text":"","title":"\u57fa\u672c\u6d41\u7a0b"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/#_3","text":"IDEA \u5728\u52a0\u5bc6\u7684\u6bcf\u8f6e\u4e2d\u4f7f\u7528 6\u4e2a\u5bc6\u94a5\uff0c\u7136\u540e\u6700\u540e\u8f93\u51fa\u8f6e\u4f7f\u75284\u4e2a\u5bc6\u94a5\u3002\u6240\u4ee5\u4e00\u5171\u670952\u4e2a\u3002 \u524d8\u4e2a\u5bc6\u94a5\u6765\u81ea\u4e0e\u8be5\u7b97\u6cd5\u6700\u521d\u7684\u5bc6\u94a5\uff0cK1 \u53d6\u81ea\u5bc6\u94a5\u7684\u9ad816\u6bd4\u7279\uff0cK8 \u53d6\u81ea\u5bc6\u94a5\u7684\u4f4e16\u6bd4\u7279\u3002 \u5c06\u5bc6\u94a5\u5faa\u73af\u5de6\u79fb 25 \u4f4d\u83b7\u53d6\u4e0b\u4e00\u8f6e\u5bc6\u94a5\uff0c\u7136\u540e\u518d\u6b21\u5206\u4e3a8\u7ec4\u3002","title":"\u5bc6\u94a5\u751f\u6210"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/#_4","text":"IDEA \u52a0\u5bc6\u7684\u6570\u636e\u5757\u7684\u5927\u5c0f\u4e3a 64 \u6bd4\u7279\uff0c\u5176\u4f7f\u7528\u7684\u5bc6\u94a5\u957f\u5ea6\u4e3a128 \u6bd4\u7279\u3002\u8be5\u7b97\u6cd5\u4f1a\u5bf9\u8f93\u5165\u7684\u6570\u636e\u5757\u8fdb\u884c8\u6b21\u76f8\u540c\u7684\u53d8\u6362\uff0c\u53ea\u662f\u6bcf\u6b21\u4f7f\u7528\u7684\u5bc6\u94a5\u4e0d\u540c\uff0c\u6700\u540e\u4f1a\u8fdb\u884c\u4e00\u6b21\u8f93\u51fa\u53d8\u6362\u3002\u6bcf\u4e00\u8f6e\u7684\u64cd\u4f5c \u53ef\u4ee5\u8f93\u5165\u548c\u8f93\u51fa\u90fd\u662f 16 \u6bd4\u7279\u4f4d\u4e00\u7ec4\u3002\u6bcf\u4e00\u8f6e\u7684\u4e3b\u8981\u6267\u884c\u7684\u8fd0\u7b97\u6709 \u6309\u4f4d\u5f02\u6216\uff0c\u2295 \u6a21\u52a0\uff0c\u6a21\u6570\u4e3a 2^{16} 2^{16} \uff0c\u229e \u6a21\u4e58\uff0c\u6a21\u6570\u4e3a 2^{16}+1 2^{16}+1 \uff0c\u2299\u3002\u4f46\u662f\u9700\u8981\u6ce8\u610f\u7684\u662f 0x0000 \u7684\u8f93\u5165\u4f1a\u88ab\u4fee\u6539\u4e3a 2^{16} 2^{16} \uff0c 2^{16} 2^{16} \u7684\u8f93\u51fa\u7ed3\u679c\u4f1a\u88ab\u4fee\u6539\u4e3a0x0000\u3002 \u8fd9\u91cc\u6211\u4eec\u79f0\u7531 K5\uff0cK6 \u6784\u6210\u7684\u4e2d\u95f4\u90a3\u4e2a\u65b9\u683c\u7684\u52a0\u5bc6\u65b9\u5f0f\u4e3aMA\u3002\u8fd9\u4e5f\u662f IDEA \u7b97\u6cd5\u4e2d\u91cd\u8981\u7684\u4e00\u90e8\u5206\uff0c\u6b64\u5916\uff0c\u6211\u4eec\u79f0 MA_L \u4e3a\u8be5\u90e8\u5206\u52a0\u5bc6\u540e\u7684\u5de6\u4fa7\u7ed3\u679c\uff0c\u5176\u6700\u540e\u4f1a\u548c\u6700\u5de6\u8fb9\u7684 16 \u6bd4\u7279\u64cd\u4f5c\uff1bMA_R \u4e3a\u8be5\u90e8\u5206\u52a0\u5bc6\u540e\u7684\u53f3\u534a\u90e8\u5206\u7684\u7ed3\u679c\uff0c\u5176\u6700\u540e\u4f1a\u548c\u7b2c\u4e09\u4e2a 16 \u6bd4\u7279\u64cd\u4f5c\u3002 \u5728\u6700\u540e\u8f93\u51fa\u8f6e\u7684\u64cd\u4f5c\u5982\u4e0b","title":"\u52a0\u5bc6\u6d41\u7a0b"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/#_5","text":"\u89e3\u5bc6\u6d41\u7a0b\u4e0e\u52a0\u5bc6\u6d41\u7a0b\u76f8\u4f3c\uff0c\u4e3b\u8981\u5728\u4e8e\u5176\u5bc6\u94a5\u7684\u9009\u53d6 \u7b2c i(1-9) \u8f6e\u7684\u89e3\u5bc6\u7684\u5bc6\u94a5\u7684\u524d 4 \u4e2a\u5b50\u5bc6\u94a5\u7531\u52a0\u5bc6\u8fc7\u7a0b\u4e2d\u7b2c10-i \u8f6e\u7684\u524d 4 \u4e2a\u5b50\u5bc6\u94a5\u5f97\u51fa \u5176\u4e2d\u7b2c 1 \u4e2a\u548c\u7b2c 4 \u4e2a\u89e3\u5bc6\u5b50\u5bc6\u94a5\u4e3a\u76f8\u5e94\u7684\u5b50\u5bc6\u94a5\u5173\u4e8e 2^{16}+1 2^{16}+1 \u7684\u4e58\u6cd5\u9006\u5143\u3002 \u7b2c 2 \u4e2a\u548c\u7b2c 3 \u4e2a\u5b50\u5bc6\u94a5\u7684\u53d6\u6cd5\u4e3a \u5f53\u8f6e\u6570\u4e3a2\uff0c...\uff0c8\u65f6\uff0c\u53d6\u76f8\u5e94\u7684\u7b2c3\u4e2a\u548c\u7b2c2\u4e2a\u7684\u5b50\u5bc6\u94a5\u7684 2^{16} 2^{16} \u7684\u52a0\u5bc6\u9006\u5143\u3002 \u5f53\u8f6e\u6570\u4e3a 1 \u6216 9 \u65f6\uff0c\u53d6\u76f8\u5e94\u7684\u7b2c 2 \u4e2a\u548c\u7b2c 3 \u4e2a\u5b50\u5bc6\u94a5\u5bf9\u5e94\u7684 2^{16} 2^{16} \u7684\u52a0\u5bc6\u9006\u5143\u3002 \u7b2c 5 \u548c\u7b2c 6 \u4e2a\u5bc6\u94a5\u4e0d\u53d8\u3002","title":"\u89e3\u5bc6\u6d41\u7a0b"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/#_6","text":"\u6211\u4eec\u6765\u8bc1\u660e\u4e00\u4e0b\u7b97\u6cd5\u7684\u6b63\u786e\u6027\uff0c\u8fd9\u91cc\u6211\u4eec\u5173\u6ce8\u4e8e\u89e3\u5bc6\u7b97\u6cd5\u7684\u7b2c\u4e00\u8f6e\uff0c\u9996\u5148\u6211\u4eec\u5148\u770b\u4e00\u4e0b Y_i Y_i \u662f\u5982\u4f55\u5f97\u5230\u7684 Y_1 = W_{81} \\odot Z_{49} Y_1 = W_{81} \\odot Z_{49} Y_2=W_{83}\\boxplus Z_{50} Y_2=W_{83}\\boxplus Z_{50} Y_3=W_{82}\\boxplus Z_{51} Y_3=W_{82}\\boxplus Z_{51} Y_4=W_{83}\\odot Z_{52} Y_4=W_{83}\\odot Z_{52} \u89e3\u5bc6\u65f6\uff0c\u7b2c\u4e00\u8f6e\u76f4\u63a5\u8fdb\u884c\u7684\u53d8\u6362\u4e3a J_{11}=Y_1 \\odot U_1=Y_1 \\odot Z_{49}^{-1}=W_{81} J_{11}=Y_1 \\odot U_1=Y_1 \\odot Z_{49}^{-1}=W_{81} J_{12}=Y_2 \\boxplus U2=Y_2\\boxplus Z_{50}^{-1}=W_{83} J_{12}=Y_2 \\boxplus U2=Y_2\\boxplus Z_{50}^{-1}=W_{83} J_{13}=Y_3 \\boxplus U3=Y_3\\boxplus Z_{51}^{-1}=W_{82} J_{13}=Y_3 \\boxplus U3=Y_3\\boxplus Z_{51}^{-1}=W_{82} J_{14}=Y_4 \\odot U_4=Y_4 \\odot Z_{52}^{-1}=W_{84} J_{14}=Y_4 \\odot U_4=Y_4 \\odot Z_{52}^{-1}=W_{84} \u53ef\u4ee5\u770b\u51fa\u5f97\u5230\u7684\u7ed3\u679c\u53ea\u6709\u4e2d\u95f4\u7684\u4e24\u4e2a16\u4f4d\u52a0\u5bc6\u7ed3\u679c\u6070\u597d\u76f8\u53cd\u3002\u6211\u4eec\u8fdb\u4e00\u6b65\u770b\u4e00\u4e0b W_{8i} W_{8i} \u662f\u5982\u4f55\u5f97\u5230\u7684\u3002 W_{81}=I_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{81}=I_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{82}=I_{83} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{82}=I_{83} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{83}=I_{82} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{83}=I_{82} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{84}=I_{84} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) W_{84}=I_{84} \\oplus MA_L(I_{81}\\oplus I_{83},I_{82}\\oplus I_{84}) \u90a3\u4e48\u5bf9\u4e8eV11\u6765\u8bf4 V_{11}=J_{11} \\oplus MA_R(J_{11}\\oplus J_{13},J_{12}\\oplus J_{14}) V_{11}=J_{11} \\oplus MA_R(J_{11}\\oplus J_{13},J_{12}\\oplus J_{14}) \u901a\u8fc7\u7b80\u5355\u5e26\u5165\u5df2\u6709\u7684\u503c\uff0c\u663e\u7136 V_{11}=W_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82} \\oplus I_{84})=I_{81} V_{11}=W_{81} \\oplus MA_R(I_{81}\\oplus I_{83},I_{82} \\oplus I_{84})=I_{81} \u5bf9\u4e8e\u5176\u4ed6\u7684\u5143\u7d20\u4e5f\u7c7b\u4f3c\uff0c\u90a3\u4e48\u5176\u5b9e\u6211\u4eec\u4f1a\u53d1\u73b0\u7b2c\u4e00\u8f6e\u89e3\u5bc6\u540e\u7684\u7ed3\u679c\u6070\u597d\u662f I_{81},I_{83},I_{82},I_{84} I_{81},I_{83},I_{82},I_{84} \u3002 \u7c7b\u4f3c\u5730\uff0c\u8fd9\u4e2a\u5173\u7cfb\u53ef\u4ee5\u4e00\u76f4\u6ee1\u8db3\u76f4\u5230 V_{81}=I_{11},V_{82}=I_{13},V_{83}=I_{12},V_{84}=I_{14} V_{81}=I_{11},V_{82}=I_{13},V_{83}=I_{12},V_{84}=I_{14} \u90a3\u4e48\u6700\u540e\u518d\u7ecf\u8fc7\u4e00\u6b21\u7b80\u5355\u7684\u8f93\u51fa\u53d8\u6362\uff0c\u6070\u597d\u5f97\u5230\u6700\u521d\u52a0\u5bc6\u7684\u6570\u503c\u3002","title":"\u603b\u4f53\u6d41\u7a0b"},{"location":"crypto/ctf-wiki/blockcipher/idea-zh/#_7","text":"2017 HITCON seccomp","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/blockcipher/idea/","text":"EN | ZH IDEA \u00b6 Overview \u00b6 **International Data Encryption Algorithm (IDEA), first known as the Improved Proposed Encryption Standard (IPES), is a symmetric key block cipher in cryptography. James Massey and Lai Xuejia Design, first introduced in 1991. This algorithm was proposed to replace the old data encryption standard DES. (from Wikipedia) Basic Process \u00b6 Key Generation \u00b6 IDEA uses 6 keys in each round of encryption and then 4 keys in the final output round. So there are a total of 52. The first 8 keys are from the original key of the algorithm, K1 is taken from the upper 16 bits of the key, and K8 is taken from the lower 16 bits of the key. Move the key loop left by 25 bits to get the next round key, and then divide it into 8 groups again. Encryption process \u00b6 The IDEA encrypted block is 64 bits in size and uses a key length of 128 bits. The algorithm performs the same transformation 8 times on the input data block, except that the key used each time is different, and finally an output transformation is performed. Each round of operation Both input and output can be a group of 16 bits. The main execution of each round has Bitwise XOR, \u2295 Modular plus, the modulus is 2^{16} 2^{16} , \u229e Modular multiplication, the modulus is 2^{16}+1 2^{16}+1 , \u2299. However, it should be noted that the input of 0x0000 will be modified to 2^{16} 2^{16} , and the output of 2^{16} 2^{16} will be modified to 0x0000. Here we call the encryption method of the middle square consisting of K5 and K6 as MA. This is also an important part of the IDEA algorithm. In addition, we call MA_L the left side result of this part of the encryption, which will end up with the leftmost 16 bits; MA_R is the result of the encrypted right part of the part, and finally Will work with the third 16 bits. The operation of the last output wheel is as follows Decryption process \u00b6 The decryption process is similar to the encryption process, mainly in the selection of its key. The first 4 subkeys of the decrypted key of the i(1-9)th round are derived from the first 4 subkeys of the 10 th -ith round of the encryption process where the 1 st and 4 th decryption subkeys are the multiplicative inverses of the corresponding subkeys for 2^{16}+1 2^{16}+1 . The second and third subkeys are taken as When the number of rounds is 2, ..., 8, the encrypted inverse of 2^{16} 2^{16} of the corresponding 3 rd and 2 nd subkeys is taken. When the number of rounds is 1 or 9, the encrypted inverse of 2^{16} 2^{16} corresponding to the corresponding 2 nd and 3 rd subkeys is taken. The 5 th and 6 th keys are unchanged. Overall process \u00b6 Let's prove the correctness of the algorithm. Here we focus on the first round of the decryption algorithm. First, let's first look at how Y_i Y_i is obtained. $ Y_1 = W_ {81} odot Z_ {49} $ $ Y_2 = W_ {83} boxplus Z_ {50} $ $ Y_3 = W_ {82} boxplus Z_ {51} $ $ Y_4 = W_ {83} odot Z_ {52} $ When decrypting, the first round of direct conversion is $ J_ {11} = Y_1 odot U_1 = Y_1 odot Z_ {49} ^ {- 1} = W_ {81} $ $ J_ {12} = Y_2 boxplus U2 = Y_2 boxplus Z_ {50} ^ {- 1} = W_ {83} $ $ J_ {13} = Y_3 boxplus U3 = Y_3 boxplus Z_ {51} ^ {- 1} = W_ {82} $ $ J_ {14} = Y_4 odot U_4 = Y_4 odot Z_ {52} ^ {- 1} = W_ {84} $ It can be seen that the result is only the opposite of the two 16-bit encryption results in the middle. Let's take a closer look at how W_{8i} W_{8i} was obtained. $ W_ {81} = I_ {81} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {82} = I_ {83} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {83} = I_ {82} oplus MA_L (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {84} = I_ {84} oplus MA_L (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ So for V11 $ V_ {11} = J_ {11} oplus MA_R (J_ {11} oplus J_ {13}, J_ {12} oplus J_ {14}) $ By simply bringing in the existing values, obviously $ V_ {11} = W_ {81} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) = I_ {81} $ For other elements, it is similar, then we will find that the first round of decryption results are exactly I_{81}, I_{83}, I_{82}, I_{84} I_{81}, I_{83}, I_{82}, I_{84} . Similarly, this relationship can be satisfied until $ V_ {81} = I_ {11}, V_ {82} = I_ {13}, V_ {83} = I_ {12}, V_ {84} = I_ {14} $ Then finally a simple output transformation happens to get the value that was originally encrypted. topic \u00b6 2017 HITCON seccomp","title":"IDEA"},{"location":"crypto/ctf-wiki/blockcipher/idea/#idea","text":"","title":"IDEA"},{"location":"crypto/ctf-wiki/blockcipher/idea/#overview","text":"**International Data Encryption Algorithm (IDEA), first known as the Improved Proposed Encryption Standard (IPES), is a symmetric key block cipher in cryptography. James Massey and Lai Xuejia Design, first introduced in 1991. This algorithm was proposed to replace the old data encryption standard DES. (from Wikipedia)","title":"Overview"},{"location":"crypto/ctf-wiki/blockcipher/idea/#basic-process","text":"","title":"Basic Process"},{"location":"crypto/ctf-wiki/blockcipher/idea/#key-generation","text":"IDEA uses 6 keys in each round of encryption and then 4 keys in the final output round. So there are a total of 52. The first 8 keys are from the original key of the algorithm, K1 is taken from the upper 16 bits of the key, and K8 is taken from the lower 16 bits of the key. Move the key loop left by 25 bits to get the next round key, and then divide it into 8 groups again.","title":"Key Generation"},{"location":"crypto/ctf-wiki/blockcipher/idea/#encryption-process","text":"The IDEA encrypted block is 64 bits in size and uses a key length of 128 bits. The algorithm performs the same transformation 8 times on the input data block, except that the key used each time is different, and finally an output transformation is performed. Each round of operation Both input and output can be a group of 16 bits. The main execution of each round has Bitwise XOR, \u2295 Modular plus, the modulus is 2^{16} 2^{16} , \u229e Modular multiplication, the modulus is 2^{16}+1 2^{16}+1 , \u2299. However, it should be noted that the input of 0x0000 will be modified to 2^{16} 2^{16} , and the output of 2^{16} 2^{16} will be modified to 0x0000. Here we call the encryption method of the middle square consisting of K5 and K6 as MA. This is also an important part of the IDEA algorithm. In addition, we call MA_L the left side result of this part of the encryption, which will end up with the leftmost 16 bits; MA_R is the result of the encrypted right part of the part, and finally Will work with the third 16 bits. The operation of the last output wheel is as follows","title":"Encryption process"},{"location":"crypto/ctf-wiki/blockcipher/idea/#decryption-process","text":"The decryption process is similar to the encryption process, mainly in the selection of its key. The first 4 subkeys of the decrypted key of the i(1-9)th round are derived from the first 4 subkeys of the 10 th -ith round of the encryption process where the 1 st and 4 th decryption subkeys are the multiplicative inverses of the corresponding subkeys for 2^{16}+1 2^{16}+1 . The second and third subkeys are taken as When the number of rounds is 2, ..., 8, the encrypted inverse of 2^{16} 2^{16} of the corresponding 3 rd and 2 nd subkeys is taken. When the number of rounds is 1 or 9, the encrypted inverse of 2^{16} 2^{16} corresponding to the corresponding 2 nd and 3 rd subkeys is taken. The 5 th and 6 th keys are unchanged.","title":"Decryption process"},{"location":"crypto/ctf-wiki/blockcipher/idea/#overall-process","text":"Let's prove the correctness of the algorithm. Here we focus on the first round of the decryption algorithm. First, let's first look at how Y_i Y_i is obtained. $ Y_1 = W_ {81} odot Z_ {49} $ $ Y_2 = W_ {83} boxplus Z_ {50} $ $ Y_3 = W_ {82} boxplus Z_ {51} $ $ Y_4 = W_ {83} odot Z_ {52} $ When decrypting, the first round of direct conversion is $ J_ {11} = Y_1 odot U_1 = Y_1 odot Z_ {49} ^ {- 1} = W_ {81} $ $ J_ {12} = Y_2 boxplus U2 = Y_2 boxplus Z_ {50} ^ {- 1} = W_ {83} $ $ J_ {13} = Y_3 boxplus U3 = Y_3 boxplus Z_ {51} ^ {- 1} = W_ {82} $ $ J_ {14} = Y_4 odot U_4 = Y_4 odot Z_ {52} ^ {- 1} = W_ {84} $ It can be seen that the result is only the opposite of the two 16-bit encryption results in the middle. Let's take a closer look at how W_{8i} W_{8i} was obtained. $ W_ {81} = I_ {81} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {82} = I_ {83} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {83} = I_ {82} oplus MA_L (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ $ W_ {84} = I_ {84} oplus MA_L (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) $ So for V11 $ V_ {11} = J_ {11} oplus MA_R (J_ {11} oplus J_ {13}, J_ {12} oplus J_ {14}) $ By simply bringing in the existing values, obviously $ V_ {11} = W_ {81} oplus MA_R (I_ {81} oplus I_ {83}, I_ {82} oplus I_ {84}) = I_ {81} $ For other elements, it is similar, then we will find that the first round of decryption results are exactly I_{81}, I_{83}, I_{82}, I_{84} I_{81}, I_{83}, I_{82}, I_{84} . Similarly, this relationship can be satisfied until $ V_ {81} = I_ {11}, V_ {82} = I_ {13}, V_ {83} = I_ {12}, V_ {84} = I_ {14} $ Then finally a simple output transformation happens to get the value that was originally encrypted.","title":"Overall process"},{"location":"crypto/ctf-wiki/blockcipher/idea/#topic","text":"2017 HITCON seccomp","title":"topic"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/","text":"EN | ZH \u5757\u52a0\u5bc6 \u00b6 \u6982\u8ff0 \u00b6 \u6240\u8c13\u5757\u52a0\u5bc6\u5c31\u662f\u6bcf\u6b21\u52a0\u5bc6\u4e00\u5757\u660e\u6587\uff0c\u5e38\u89c1\u7684\u52a0\u5bc6\u7b97\u6cd5\u6709 IDEA \u52a0\u5bc6 DES \u52a0\u5bc6 AES \u52a0\u5bc6 \u5757\u52a0\u5bc6\u4e5f\u662f\u5bf9\u79f0\u52a0\u5bc6\u3002 \u5176\u5b9e\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u628a\u5757\u52a0\u5bc6\u7406\u89e3\u4e00\u79cd\u7279\u6b8a\u7684\u66ff\u4ee3\u5bc6\u7801\uff0c\u4f46\u662f\u5176\u6bcf\u6b21\u66ff\u4ee3\u7684\u662f\u4e00\u5927\u5757\u3002\u800c\u6b63\u662f\u7531\u4e8e\u4e00\u5927\u5757\uff0c\u660e\u6587\u7a7a\u95f4\u5de8\u5927\uff0c\u800c\u4e14\u5bf9\u4e8e\u4e0d\u540c\u7684\u5bc6\u94a5\uff0c\u6211\u4eec\u65e0\u6cd5\u505a\u4e00\u4e2a\u8868\u8fdb\u884c\u5bf9\u5e94\u76f8\u5e94\u7684\u5bc6\u6587\uff0c\u56e0\u6b64\u5fc5\u987b\u5f97\u6709 \u590d\u6742 \u7684\u52a0\u89e3\u5bc6\u7b97\u6cd5\u6765\u52a0\u89e3\u5bc6\u660e\u5bc6\u6587\u3002 \u800c\u4e0e\u6b64\u540c\u65f6\uff0c\u660e\u6587\u5f80\u5f80\u53ef\u80fd\u5f88\u957f\u4e5f\u53ef\u80fd\u5f88\u77ed\uff0c\u56e0\u6b64\u5728\u5757\u52a0\u5bc6\u65f6\u5f80\u5f80\u9700\u8981\u4e24\u4e2a\u8f85\u52a9 padding\uff0c\u5373 padding \u5230\u6307\u5b9a\u5206\u7ec4\u957f\u5ea6 \u5206\u7ec4\u52a0\u5bc6\u6a21\u5f0f\uff0c\u5373\u660e\u6587\u5206\u7ec4\u52a0\u5bc6\u7684\u65b9\u5f0f\u3002 \u57fa\u672c\u7b56\u7565 \u00b6 \u5728\u5206\u7ec4\u5bc6\u7801\u8bbe\u8ba1\u65f6\uff0c\u5145\u5206\u4f7f\u7528\u4e86 Shannon \u63d0\u51fa\u7684\u4e24\u5927\u7b56\u7565\uff1a\u6df7\u6dc6\u4e0e\u6269\u6563\u4e24\u5927\u7b56\u7565\u3002 \u6df7\u6dc6 \u00b6 \u6df7\u6dc6\uff0cConfusion\uff0c\u5c06\u5bc6\u6587\u4e0e\u5bc6\u94a5\u4e4b\u95f4\u7684\u7edf\u8ba1\u5173\u7cfb\u53d8\u5f97\u5c3d\u53ef\u80fd\u590d\u6742\uff0c\u4f7f\u5f97\u653b\u51fb\u8005\u5373\u4f7f\u83b7\u53d6\u4e86\u5bc6\u6587\u7684\u4e00\u4e9b\u7edf\u8ba1\u7279\u6027\uff0c\u4e5f\u65e0\u6cd5\u63a8\u6d4b\u5bc6\u94a5\u3002\u4e00\u822c\u4f7f\u7528\u590d\u6742\u7684\u975e\u7ebf\u6027\u53d8\u6362\u53ef\u4ee5\u5f97\u5230\u5f88\u597d\u7684\u6df7\u6dc6\u6548\u679c\uff0c\u5e38\u89c1\u7684\u65b9\u6cd5\u5982\u4e0b S \u76d2 \u4e58\u6cd5 \u6269\u6563 \u00b6 \u6269\u6563\uff0cDiffusion\uff0c\u4f7f\u5f97\u660e\u6587\u4e2d\u7684\u6bcf\u4e00\u4f4d\u5f71\u54cd\u5bc6\u6587\u4e2d\u7684\u8bb8\u591a\u4f4d\u3002\u5e38\u89c1\u7684\u65b9\u6cd5\u6709 \u7ebf\u6027\u53d8\u6362 \u7f6e\u6362 \u79fb\u4f4d\uff0c\u5faa\u73af\u79fb\u4f4d \u5e38\u89c1\u52a0\u89e3\u5bc6\u7ed3\u6784 \u00b6 \u76ee\u524d\u5757\u52a0\u5bc6\u4e2d\u4e3b\u8981\u4f7f\u7528\u7684\u662f\u7ed3\u6784\u662f \u8fed\u4ee3\u7ed3\u6784\uff0c\u8fd9\u662f\u56e0\u4e3a\u8fed\u4ee3\u7ed3\u6784\u4fbf\u4e8e\u8bbe\u8ba1\u4e0e\u5b9e\u73b0\uff0c\u540c\u65f6\u65b9\u4fbf\u5b89\u5168\u6027\u8bc4\u4f30\u3002 \u8fed\u4ee3\u7ed3\u6784 \u00b6 \u6982\u8ff0 \u00b6 \u8fed\u4ee3\u7ed3\u6784\u57fa\u672c\u5982\u4e0b\uff0c\u4e00\u822c\u5305\u62ec\u4e09\u4e2a\u90e8\u5206 \u5bc6\u94a5\u7f6e\u6362 \u8f6e\u52a0\u5bc6\u51fd\u6570 \u8f6e\u89e3\u5bc6\u51fd\u6570 \u8f6e\u51fd\u6570 \u00b6 \u76ee\u524d\u6765\u8bf4\uff0c\u8f6e\u51fd\u6570\u4e3b\u8981\u6709\u4e3b\u8981\u6709\u4ee5\u4e0b\u8bbe\u8ba1\u65b9\u6cd5 Feistel Network\uff0c\u7531 Horst Feistel \u53d1\u660e\uff0cDES \u8bbe\u8ba1\u8005\u4e4b\u4e00\u3002 DES Substitution-Permutation Network(SPN) AES \u5176\u4ed6\u65b9\u6848 \u5bc6\u94a5\u6269\u5c55 \u00b6 \u76ee\u524d\uff0c\u5bc6\u94a5\u6269\u5c55\u7684\u65b9\u6cd5\u6709\u5f88\u591a\uff0c\u6ca1\u6709\u89c1\u5230\u4ec0\u4e48\u5b8c\u7f8e\u7684\u5bc6\u94a5\u6269\u5c55\u65b9\u6cd5\uff0c\u57fa\u672c\u539f\u5219\u662f\u4f7f\u5f97\u5bc6\u94a5\u7684\u6bcf\u4e00\u4e2a\u6bd4\u7279\u5c3d\u53ef\u80fd\u5f71\u54cd\u591a\u8f6e\u7684\u8f6e\u5bc6\u94a5\u3002","title":"Introduction zh"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_1","text":"","title":"\u5757\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_2","text":"\u6240\u8c13\u5757\u52a0\u5bc6\u5c31\u662f\u6bcf\u6b21\u52a0\u5bc6\u4e00\u5757\u660e\u6587\uff0c\u5e38\u89c1\u7684\u52a0\u5bc6\u7b97\u6cd5\u6709 IDEA \u52a0\u5bc6 DES \u52a0\u5bc6 AES \u52a0\u5bc6 \u5757\u52a0\u5bc6\u4e5f\u662f\u5bf9\u79f0\u52a0\u5bc6\u3002 \u5176\u5b9e\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u628a\u5757\u52a0\u5bc6\u7406\u89e3\u4e00\u79cd\u7279\u6b8a\u7684\u66ff\u4ee3\u5bc6\u7801\uff0c\u4f46\u662f\u5176\u6bcf\u6b21\u66ff\u4ee3\u7684\u662f\u4e00\u5927\u5757\u3002\u800c\u6b63\u662f\u7531\u4e8e\u4e00\u5927\u5757\uff0c\u660e\u6587\u7a7a\u95f4\u5de8\u5927\uff0c\u800c\u4e14\u5bf9\u4e8e\u4e0d\u540c\u7684\u5bc6\u94a5\uff0c\u6211\u4eec\u65e0\u6cd5\u505a\u4e00\u4e2a\u8868\u8fdb\u884c\u5bf9\u5e94\u76f8\u5e94\u7684\u5bc6\u6587\uff0c\u56e0\u6b64\u5fc5\u987b\u5f97\u6709 \u590d\u6742 \u7684\u52a0\u89e3\u5bc6\u7b97\u6cd5\u6765\u52a0\u89e3\u5bc6\u660e\u5bc6\u6587\u3002 \u800c\u4e0e\u6b64\u540c\u65f6\uff0c\u660e\u6587\u5f80\u5f80\u53ef\u80fd\u5f88\u957f\u4e5f\u53ef\u80fd\u5f88\u77ed\uff0c\u56e0\u6b64\u5728\u5757\u52a0\u5bc6\u65f6\u5f80\u5f80\u9700\u8981\u4e24\u4e2a\u8f85\u52a9 padding\uff0c\u5373 padding \u5230\u6307\u5b9a\u5206\u7ec4\u957f\u5ea6 \u5206\u7ec4\u52a0\u5bc6\u6a21\u5f0f\uff0c\u5373\u660e\u6587\u5206\u7ec4\u52a0\u5bc6\u7684\u65b9\u5f0f\u3002","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_3","text":"\u5728\u5206\u7ec4\u5bc6\u7801\u8bbe\u8ba1\u65f6\uff0c\u5145\u5206\u4f7f\u7528\u4e86 Shannon \u63d0\u51fa\u7684\u4e24\u5927\u7b56\u7565\uff1a\u6df7\u6dc6\u4e0e\u6269\u6563\u4e24\u5927\u7b56\u7565\u3002","title":"\u57fa\u672c\u7b56\u7565"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_4","text":"\u6df7\u6dc6\uff0cConfusion\uff0c\u5c06\u5bc6\u6587\u4e0e\u5bc6\u94a5\u4e4b\u95f4\u7684\u7edf\u8ba1\u5173\u7cfb\u53d8\u5f97\u5c3d\u53ef\u80fd\u590d\u6742\uff0c\u4f7f\u5f97\u653b\u51fb\u8005\u5373\u4f7f\u83b7\u53d6\u4e86\u5bc6\u6587\u7684\u4e00\u4e9b\u7edf\u8ba1\u7279\u6027\uff0c\u4e5f\u65e0\u6cd5\u63a8\u6d4b\u5bc6\u94a5\u3002\u4e00\u822c\u4f7f\u7528\u590d\u6742\u7684\u975e\u7ebf\u6027\u53d8\u6362\u53ef\u4ee5\u5f97\u5230\u5f88\u597d\u7684\u6df7\u6dc6\u6548\u679c\uff0c\u5e38\u89c1\u7684\u65b9\u6cd5\u5982\u4e0b S \u76d2 \u4e58\u6cd5","title":"\u6df7\u6dc6"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_5","text":"\u6269\u6563\uff0cDiffusion\uff0c\u4f7f\u5f97\u660e\u6587\u4e2d\u7684\u6bcf\u4e00\u4f4d\u5f71\u54cd\u5bc6\u6587\u4e2d\u7684\u8bb8\u591a\u4f4d\u3002\u5e38\u89c1\u7684\u65b9\u6cd5\u6709 \u7ebf\u6027\u53d8\u6362 \u7f6e\u6362 \u79fb\u4f4d\uff0c\u5faa\u73af\u79fb\u4f4d","title":"\u6269\u6563"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_6","text":"\u76ee\u524d\u5757\u52a0\u5bc6\u4e2d\u4e3b\u8981\u4f7f\u7528\u7684\u662f\u7ed3\u6784\u662f \u8fed\u4ee3\u7ed3\u6784\uff0c\u8fd9\u662f\u56e0\u4e3a\u8fed\u4ee3\u7ed3\u6784\u4fbf\u4e8e\u8bbe\u8ba1\u4e0e\u5b9e\u73b0\uff0c\u540c\u65f6\u65b9\u4fbf\u5b89\u5168\u6027\u8bc4\u4f30\u3002","title":"\u5e38\u89c1\u52a0\u89e3\u5bc6\u7ed3\u6784"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_7","text":"","title":"\u8fed\u4ee3\u7ed3\u6784"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_8","text":"\u8fed\u4ee3\u7ed3\u6784\u57fa\u672c\u5982\u4e0b\uff0c\u4e00\u822c\u5305\u62ec\u4e09\u4e2a\u90e8\u5206 \u5bc6\u94a5\u7f6e\u6362 \u8f6e\u52a0\u5bc6\u51fd\u6570 \u8f6e\u89e3\u5bc6\u51fd\u6570","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_9","text":"\u76ee\u524d\u6765\u8bf4\uff0c\u8f6e\u51fd\u6570\u4e3b\u8981\u6709\u4e3b\u8981\u6709\u4ee5\u4e0b\u8bbe\u8ba1\u65b9\u6cd5 Feistel Network\uff0c\u7531 Horst Feistel \u53d1\u660e\uff0cDES \u8bbe\u8ba1\u8005\u4e4b\u4e00\u3002 DES Substitution-Permutation Network(SPN) AES \u5176\u4ed6\u65b9\u6848","title":"\u8f6e\u51fd\u6570"},{"location":"crypto/ctf-wiki/blockcipher/introduction-zh/#_10","text":"\u76ee\u524d\uff0c\u5bc6\u94a5\u6269\u5c55\u7684\u65b9\u6cd5\u6709\u5f88\u591a\uff0c\u6ca1\u6709\u89c1\u5230\u4ec0\u4e48\u5b8c\u7f8e\u7684\u5bc6\u94a5\u6269\u5c55\u65b9\u6cd5\uff0c\u57fa\u672c\u539f\u5219\u662f\u4f7f\u5f97\u5bc6\u94a5\u7684\u6bcf\u4e00\u4e2a\u6bd4\u7279\u5c3d\u53ef\u80fd\u5f71\u54cd\u591a\u8f6e\u7684\u8f6e\u5bc6\u94a5\u3002","title":"\u5bc6\u94a5\u6269\u5c55"},{"location":"crypto/ctf-wiki/blockcipher/introduction/","text":"EN | ZH \u5757\u52a0\u5bc6 \u00b6 Overview \u00b6 The so-called block encryption is to encrypt a piece of plaintext each time. Common encryption algorithms are available. IDEA encryption DES encryption AES encryption Block encryption is also symmetric encryption. In fact, we can also understand block encryption as a special alternative password, but each time it is replaced by a large block. It is precisely because of a large block, the plaintext space is huge, and for different keys, we can't make a table to correspond to the corresponding ciphertext, so we must have complex encryption and decryption algorithm to encrypt and decrypt the ciphertext . At the same time, plain text can often be very long or short, so two blocks are often needed for block encryption. padding, ie padding to the specified packet length Packet encryption mode, which is the way in which plaintext packets are encrypted. Basic strategy \u00b6 In the design of block ciphers, Shannon proposed two strategies: confusion and diffusion. Confusion \u00b6 Confusion, Confusion, makes the statistical relationship between the ciphertext and the key as complex as possible, so that the attacker can not guess the key even if it acquires some statistical characteristics of the ciphertext. Generally, complex nonlinear transformations can be used to get a good confusion. The common methods are as follows: S box Multiplication Diffusion \u00b6 Diffusion, Diffusion, makes every bit in the plaintext affect many bits in the ciphertext. Common methods are Linear transformation replacement shift, rotate Common encryption and decryption structure \u00b6 The main block block encryption currently used is the structure. Iterative structure, because the iterative structure is easy to design and implement, while facilitating security assessment. Iterative structure \u00b6 Overview \u00b6 The iterative structure is basically as follows, generally consisting of three parts Key replacement Round encryption function Round decryption function Round Function \u00b6 At present, the main functions of the round function are mainly the following design methods. Feistel Network, invented by Horst Feistel, one of the DES designers. DES Substitution-Permutation Network(SPN) AES Other programs Key Expansion \u00b6 At present, there are many methods for key expansion. There is no perfect key expansion method. The basic principle is that each bit of the key affects multiple rounds of round keys as much as possible.","title":"\u5757\u52a0\u5bc6\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#_1","text":"","title":"\u5757\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#overview","text":"The so-called block encryption is to encrypt a piece of plaintext each time. Common encryption algorithms are available. IDEA encryption DES encryption AES encryption Block encryption is also symmetric encryption. In fact, we can also understand block encryption as a special alternative password, but each time it is replaced by a large block. It is precisely because of a large block, the plaintext space is huge, and for different keys, we can't make a table to correspond to the corresponding ciphertext, so we must have complex encryption and decryption algorithm to encrypt and decrypt the ciphertext . At the same time, plain text can often be very long or short, so two blocks are often needed for block encryption. padding, ie padding to the specified packet length Packet encryption mode, which is the way in which plaintext packets are encrypted.","title":"Overview"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#basic-strategy","text":"In the design of block ciphers, Shannon proposed two strategies: confusion and diffusion.","title":"Basic strategy"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#confusion","text":"Confusion, Confusion, makes the statistical relationship between the ciphertext and the key as complex as possible, so that the attacker can not guess the key even if it acquires some statistical characteristics of the ciphertext. Generally, complex nonlinear transformations can be used to get a good confusion. The common methods are as follows: S box Multiplication","title":"Confusion"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#diffusion","text":"Diffusion, Diffusion, makes every bit in the plaintext affect many bits in the ciphertext. Common methods are Linear transformation replacement shift, rotate","title":"Diffusion"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#common-encryption-and-decryption-structure","text":"The main block block encryption currently used is the structure. Iterative structure, because the iterative structure is easy to design and implement, while facilitating security assessment.","title":"Common encryption and decryption structure"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#iterative-structure","text":"","title":"Iterative structure"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#overview_1","text":"The iterative structure is basically as follows, generally consisting of three parts Key replacement Round encryption function Round decryption function","title":"Overview"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#round-function","text":"At present, the main functions of the round function are mainly the following design methods. Feistel Network, invented by Horst Feistel, one of the DES designers. DES Substitution-Permutation Network(SPN) AES Other programs","title":"Round Function"},{"location":"crypto/ctf-wiki/blockcipher/introduction/#key-expansion","text":"At present, there are many methods for key expansion. There is no perfect key expansion method. The basic principle is that each bit of the key affects multiple rounds of round keys as much as possible.","title":"Key Expansion"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck-zh/","text":"EN | ZH Simon and Speck Block Ciphers \u00b6 \u8fd9\u662f\u4e00\u7ec4\u59d0\u59b9\u8f7b\u91cf\u7ea7\u52a0\u5bc6\u3002 Simon Block Cipher \u00b6 \u57fa\u672c\u4ecb\u7ecd \u00b6 Simon \u5757\u52a0\u5bc6\u7b97\u6cd5\u7531 NSA 2013 \u5e74 6 \u6708\u516c\u5e03\uff0c\u4e3b\u8981\u5728 \u786c\u4ef6\u5b9e\u73b0 \u4e0a\u8fdb\u884c\u4e86\u4f18\u5316\u3002 Simon Block Cipher \u662f\u5e73\u8861\u7684 Feistel cipher \u52a0\u5bc6\uff0c\u4e00\u5171\u6709\u4e24\u5757\uff0c\u82e5\u6bcf\u5757\u52a0\u5bc6\u7684\u5927\u5c0f\u4e3a n bits\uff0c\u90a3\u4e48\u660e\u6587\u7684\u5927\u5c0f\u5c31\u662f 2n bits\u3002\u6b64\u5916\uff0c\u4e00\u822c\u6765\u8bf4\uff0c\u8be5\u52a0\u5bc6\u4e2d\u6240\u4f7f\u7528\u7684\u5bc6\u94a5\u957f\u5ea6\u662f\u5757\u957f\u5ea6\u7684\u6574\u6570\u500d\uff0c\u6bd4\u5982 2n\uff0c4n\u7b49\u3002\u5e38\u89c1\u7684 Simon \u52a0\u5bc6\u7b97\u6cd5\u6709 \u4e00\u822c\u6765\u8bf4\uff0cSimon \u7b97\u6cd5\u79f0\u4e4b\u4e3a Simon 2 n /nm\uff0cn \u4e3a\u5757\u5927\u5c0f\uff0cm \u662f\u5757\u5927\u5c0f\u4e0e\u5bc6\u94a5\u4e4b\u95f4\u7684\u500d\u6570\u3002\u6bd4\u5982\u8bf4 Simon 48/96 \u5c31\u662f\u6307\u660e\u6587\u662f 48 \u6bd4\u7279\uff0c\u5bc6\u94a5\u662f 96 \u6bd4\u7279\u7684\u52a0\u5bc6\u7b97\u6cd5\u3002 \u6b64\u5916\uff0c\u5bf9\u4e8e Simon \u5757\u52a0\u5bc6\u7b97\u6cd5\u6765\u8bf4\uff0c\u6bcf\u8f6e\u7684\u52a0\u5bc6\u8fc7\u7a0b\u4e00\u6837\uff0c\u5982\u4e0b \u5f53\u7136\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u8f6e\u4ee5\u53ca\u4e0d\u540c\u7684 m \u6765\u8bf4\uff0c\u5bc6\u94a5\u4e5f\u4f1a\u6709\u6240\u4e0d\u540c \u5176\u4e2d\uff0c z_j z_j \u662f\u7531 Linear Feedback Shift Register (LFSR) \u751f\u6210\u7684\uff0c\u867d\u7136\u5bf9\u4e8e\u4e0d\u540c\u7684 z_j z_j \u7684\u903b\u8f91\u4e0d\u540c\uff0c\u4f46\u662f\u521d\u59cb\u5411\u91cf\u662f\u56fa\u5b9a\u7684\u3002 Constant z_{0} z_{0} =11111010001001010110000111001101111101000100101011000011100110 z_{1} z_{1} =10001110111110010011000010110101000111011111001001100001011010 z_{2} z_{2} =10101111011100000011010010011000101000010001111110010110110011 z_{3} z_{3} =11011011101011000110010111100000010010001010011100110100001111 z_{4} z_{4} =11010001111001101011011000100000010111000011001010010011101111 2017 SECCON Simon and Speck Block Ciphers \u00b6 \u9898\u76ee\u63cf\u8ff0\u5982\u4e0b Simon and Speck Block Ciphers https://eprint.iacr.org/2013/404.pdf Simon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5 \u4ece\u540d\u5b57\u4e2d\u53ef\u4ee5\u770b\u51fa\u5bc6\u94a5\u662f 96 \u6bd4\u7279\uff0812 byte\uff09\uff0c\u660e\u6587\u662f 64 \u6bd4\u7279\uff088\u5b57\u8282\uff09\uff0c\u800c\u5bc6\u94a5\u5df2\u7ecf\u7ed9\u51fa\u4e86 8 \u4e2a\u5b57\u8282\uff0c\u53ea\u5269\u4e0b\u56db\u4e2a\u5b57\u8282\u672a\u77e5\u3002\u90a3\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u66b4\u529b\u7834\u89e3\u7684\u65b9\u6cd5\u3002\u8fd9\u91cc\u4ece https://github.com/bozhu/NSA-ciphers/blob/master/simon.py \u83b7\u53d6\u4e86\u4e00\u4efd simon \u52a0\u5bc6\u7b97\u6cd5\u3002 \u5177\u4f53\u5982\u4e0b from pwn import * from simon import SIMON plain = 0x6d564d37426e6e71 cipher = 0xbb5d12ba422834b5 def compare ( key ): key = \"SECCON{\" + key + \"}\" key = key . encode ( 'hex' ) key = int ( key , 16 ) my_simon = SIMON ( 64 , 96 , key ) test = my_simon . encrypt ( plain ) if test == cipher : return True else : return False def solve (): visible = string . uppercase + string . lowercase + string . digits + string . punctuation + \" \" key = pwnlib . util . iters . mbruteforce ( compare , visible , 4 , method = \"fixed\" ) print key if __name__ == \"__main__\" : solve () \u7ed3\u679c\u5982\u4e0b \u279c 2017_seccon_simon_and_speck_block_ciphers git: ( master ) python exp.py [ + ] MBruteforcing: Found key: \"6Pz0\" \u53c2\u8003\u6587\u732e \u00b6 https://en.wikipedia.org/wiki/Simon_(cipher )","title":"Simon speck zh"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck-zh/#simon-and-speck-block-ciphers","text":"\u8fd9\u662f\u4e00\u7ec4\u59d0\u59b9\u8f7b\u91cf\u7ea7\u52a0\u5bc6\u3002","title":"Simon and Speck Block Ciphers"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck-zh/#simon-block-cipher","text":"","title":"Simon Block Cipher"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck-zh/#_1","text":"Simon \u5757\u52a0\u5bc6\u7b97\u6cd5\u7531 NSA 2013 \u5e74 6 \u6708\u516c\u5e03\uff0c\u4e3b\u8981\u5728 \u786c\u4ef6\u5b9e\u73b0 \u4e0a\u8fdb\u884c\u4e86\u4f18\u5316\u3002 Simon Block Cipher \u662f\u5e73\u8861\u7684 Feistel cipher \u52a0\u5bc6\uff0c\u4e00\u5171\u6709\u4e24\u5757\uff0c\u82e5\u6bcf\u5757\u52a0\u5bc6\u7684\u5927\u5c0f\u4e3a n bits\uff0c\u90a3\u4e48\u660e\u6587\u7684\u5927\u5c0f\u5c31\u662f 2n bits\u3002\u6b64\u5916\uff0c\u4e00\u822c\u6765\u8bf4\uff0c\u8be5\u52a0\u5bc6\u4e2d\u6240\u4f7f\u7528\u7684\u5bc6\u94a5\u957f\u5ea6\u662f\u5757\u957f\u5ea6\u7684\u6574\u6570\u500d\uff0c\u6bd4\u5982 2n\uff0c4n\u7b49\u3002\u5e38\u89c1\u7684 Simon \u52a0\u5bc6\u7b97\u6cd5\u6709 \u4e00\u822c\u6765\u8bf4\uff0cSimon \u7b97\u6cd5\u79f0\u4e4b\u4e3a Simon 2 n /nm\uff0cn \u4e3a\u5757\u5927\u5c0f\uff0cm \u662f\u5757\u5927\u5c0f\u4e0e\u5bc6\u94a5\u4e4b\u95f4\u7684\u500d\u6570\u3002\u6bd4\u5982\u8bf4 Simon 48/96 \u5c31\u662f\u6307\u660e\u6587\u662f 48 \u6bd4\u7279\uff0c\u5bc6\u94a5\u662f 96 \u6bd4\u7279\u7684\u52a0\u5bc6\u7b97\u6cd5\u3002 \u6b64\u5916\uff0c\u5bf9\u4e8e Simon \u5757\u52a0\u5bc6\u7b97\u6cd5\u6765\u8bf4\uff0c\u6bcf\u8f6e\u7684\u52a0\u5bc6\u8fc7\u7a0b\u4e00\u6837\uff0c\u5982\u4e0b \u5f53\u7136\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u8f6e\u4ee5\u53ca\u4e0d\u540c\u7684 m \u6765\u8bf4\uff0c\u5bc6\u94a5\u4e5f\u4f1a\u6709\u6240\u4e0d\u540c \u5176\u4e2d\uff0c z_j z_j \u662f\u7531 Linear Feedback Shift Register (LFSR) \u751f\u6210\u7684\uff0c\u867d\u7136\u5bf9\u4e8e\u4e0d\u540c\u7684 z_j z_j \u7684\u903b\u8f91\u4e0d\u540c\uff0c\u4f46\u662f\u521d\u59cb\u5411\u91cf\u662f\u56fa\u5b9a\u7684\u3002 Constant z_{0} z_{0} =11111010001001010110000111001101111101000100101011000011100110 z_{1} z_{1} =10001110111110010011000010110101000111011111001001100001011010 z_{2} z_{2} =10101111011100000011010010011000101000010001111110010110110011 z_{3} z_{3} =11011011101011000110010111100000010010001010011100110100001111 z_{4} z_{4} =11010001111001101011011000100000010111000011001010010011101111","title":"\u57fa\u672c\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck-zh/#2017-seccon-simon-and-speck-block-ciphers","text":"\u9898\u76ee\u63cf\u8ff0\u5982\u4e0b Simon and Speck Block Ciphers https://eprint.iacr.org/2013/404.pdf Simon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5 \u4ece\u540d\u5b57\u4e2d\u53ef\u4ee5\u770b\u51fa\u5bc6\u94a5\u662f 96 \u6bd4\u7279\uff0812 byte\uff09\uff0c\u660e\u6587\u662f 64 \u6bd4\u7279\uff088\u5b57\u8282\uff09\uff0c\u800c\u5bc6\u94a5\u5df2\u7ecf\u7ed9\u51fa\u4e86 8 \u4e2a\u5b57\u8282\uff0c\u53ea\u5269\u4e0b\u56db\u4e2a\u5b57\u8282\u672a\u77e5\u3002\u90a3\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u66b4\u529b\u7834\u89e3\u7684\u65b9\u6cd5\u3002\u8fd9\u91cc\u4ece https://github.com/bozhu/NSA-ciphers/blob/master/simon.py \u83b7\u53d6\u4e86\u4e00\u4efd simon \u52a0\u5bc6\u7b97\u6cd5\u3002 \u5177\u4f53\u5982\u4e0b from pwn import * from simon import SIMON plain = 0x6d564d37426e6e71 cipher = 0xbb5d12ba422834b5 def compare ( key ): key = \"SECCON{\" + key + \"}\" key = key . encode ( 'hex' ) key = int ( key , 16 ) my_simon = SIMON ( 64 , 96 , key ) test = my_simon . encrypt ( plain ) if test == cipher : return True else : return False def solve (): visible = string . uppercase + string . lowercase + string . digits + string . punctuation + \" \" key = pwnlib . util . iters . mbruteforce ( compare , visible , 4 , method = \"fixed\" ) print key if __name__ == \"__main__\" : solve () \u7ed3\u679c\u5982\u4e0b \u279c 2017_seccon_simon_and_speck_block_ciphers git: ( master ) python exp.py [ + ] MBruteforcing: Found key: \"6Pz0\"","title":"2017 SECCON Simon and Speck Block Ciphers"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck-zh/#_2","text":"https://en.wikipedia.org/wiki/Simon_(cipher )","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck/","text":"EN | ZH Simon and Speck Block Ciphers \u00b6 This is a set of sister lightweight encryption. Simon Block Cipher \u00b6 basic introduction \u00b6 The Simon block encryption algorithm was released by the NSA in June 2013 and was optimized primarily on the Hardware Implementation . Simon Block Cipher is a balanced [Feistel cipher] ( https://en.wikipedia.org/wiki/Feistel_cipher ) encryption. There are two blocks. If the size of each block is n bits, the size of the plaintext is 2n bits. Further, in general, the key length used in the encryption is an integer multiple of the block length, such as 2n, 4n, and the like. Common Simon encryption algorithms are available In general, the Simon algorithm is called Simon 2 n /nm, where n is the block size and m is the multiple between the block size and the key. For example, Simon 48/96 means that the text is 48 bits and the key is a 96-bit encryption algorithm. In addition, for the Simon block encryption algorithm, the encryption process is the same for each round, as follows Of course, the keys will be different for each round and for different m. Where z_j z_j is generated by the Linear Feedback Shift Register (LFSR), although the logic for the different z_j z_j is different, the initial vector is fixed. | Constant | | :--------------------------------------: | | $ z_ {0} $ = 11111010001001010110000111001101111101000100101011000011100110 | | $ z_ {1} $ = 10001110111110010011000010110101000111011111001001100001011010 | | $ z_ {2} $ = 10101111011100000011010010011000101000010001111110010110110011 | | $ z_ {3} $ = 11011011101011000110010111100000010010001010011100110100001111 | | $ z_ {4} $ = 11010001111001101011011000100000010111000011001010010011101111 | 2017 SECCON Simon and Speck Block Ciphers \u00b6 The title is described below Simon and Speck Block Ciphers https://eprint.iacr.org/2013/404.pdf Simon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5 It can be seen from the name that the key is 96 bits (12 bytes), the plaintext is 64 bits (8 bytes), and the key has been given 8 bytes, leaving only four bytes unknown. Then we can use the method of brute force. Here is a simon encryption algorithm from https://github.com/bozhu/NSA-ciphers/blob/master/simon.py . details as follows from pwn import * from simon import SIMON plain = 0x6d564d37426e6e71 cipher = 0xbb5d12ba422834b5 def compare ( key ): key = \"SECCON{\" + key + \"}\" key = key . encode ( 'hex' ) key = int ( key , 16 ) my_simon = SIMON ( 64 , 96 , key ) test = my_simon . encrypt ( plain ) if test == cipher : return True else : return False def solve (): visible = string . uppercase + string . lowercase + string . digits + string . punctuation + \" \" key = pwnlib . util . iters . mbruteforce ( compare , visible , 4 , method = & quot ; fixed & quot ;) print key if __name__ == \"__main__\" : solve () Results are as follows \u279c 2017_seccon_simon_and_speck_block_ciphers git: ( master ) python exp.py [ + ] MBruteforcing: Found key: \"6Pz0\" references \u00b6 https://en.wikipedia.org/wiki/Simon_(cipher )","title":"Simon and Speck"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck/#simon-and-speck-block-ciphers","text":"This is a set of sister lightweight encryption.","title":"Simon and Speck Block Ciphers"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck/#simon-block-cipher","text":"","title":"Simon Block Cipher"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck/#basic-introduction","text":"The Simon block encryption algorithm was released by the NSA in June 2013 and was optimized primarily on the Hardware Implementation . Simon Block Cipher is a balanced [Feistel cipher] ( https://en.wikipedia.org/wiki/Feistel_cipher ) encryption. There are two blocks. If the size of each block is n bits, the size of the plaintext is 2n bits. Further, in general, the key length used in the encryption is an integer multiple of the block length, such as 2n, 4n, and the like. Common Simon encryption algorithms are available In general, the Simon algorithm is called Simon 2 n /nm, where n is the block size and m is the multiple between the block size and the key. For example, Simon 48/96 means that the text is 48 bits and the key is a 96-bit encryption algorithm. In addition, for the Simon block encryption algorithm, the encryption process is the same for each round, as follows Of course, the keys will be different for each round and for different m. Where z_j z_j is generated by the Linear Feedback Shift Register (LFSR), although the logic for the different z_j z_j is different, the initial vector is fixed. | Constant | | :--------------------------------------: | | $ z_ {0} $ = 11111010001001010110000111001101111101000100101011000011100110 | | $ z_ {1} $ = 10001110111110010011000010110101000111011111001001100001011010 | | $ z_ {2} $ = 10101111011100000011010010011000101000010001111110010110110011 | | $ z_ {3} $ = 11011011101011000110010111100000010010001010011100110100001111 | | $ z_ {4} $ = 11010001111001101011011000100000010111000011001010010011101111 |","title":"basic introduction"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck/#2017-seccon-simon-and-speck-block-ciphers","text":"The title is described below Simon and Speck Block Ciphers https://eprint.iacr.org/2013/404.pdf Simon_96_64, ECB, key=\"SECCON{xxxx}\", plain=0x6d564d37426e6e71, cipher=0xbb5d12ba422834b5 It can be seen from the name that the key is 96 bits (12 bytes), the plaintext is 64 bits (8 bytes), and the key has been given 8 bytes, leaving only four bytes unknown. Then we can use the method of brute force. Here is a simon encryption algorithm from https://github.com/bozhu/NSA-ciphers/blob/master/simon.py . details as follows from pwn import * from simon import SIMON plain = 0x6d564d37426e6e71 cipher = 0xbb5d12ba422834b5 def compare ( key ): key = \"SECCON{\" + key + \"}\" key = key . encode ( 'hex' ) key = int ( key , 16 ) my_simon = SIMON ( 64 , 96 , key ) test = my_simon . encrypt ( plain ) if test == cipher : return True else : return False def solve (): visible = string . uppercase + string . lowercase + string . digits + string . punctuation + \" \" key = pwnlib . util . iters . mbruteforce ( compare , visible , 4 , method = & quot ; fixed & quot ;) print key if __name__ == \"__main__\" : solve () Results are as follows \u279c 2017_seccon_simon_and_speck_block_ciphers git: ( master ) python exp.py [ + ] MBruteforcing: Found key: \"6Pz0\"","title":"2017 SECCON Simon and Speck Block Ciphers"},{"location":"crypto/ctf-wiki/blockcipher/simon-speck/#references","text":"https://en.wikipedia.org/wiki/Simon_(cipher )","title":"references"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/","text":"EN | ZH CBC \u00b6 CBC\u5168\u79f0\u4e3a\u5bc6\u7801\u5206\u7ec4\u94fe\u63a5\uff08Cipher-block chaining\uff09 \u6a21\u5f0f\uff0c\u8fd9\u91cc IV \u4e0d\u8981\u6c42\u4fdd\u5bc6 IV \u5fc5\u987b\u662f\u4e0d\u53ef\u9884\u6d4b\u7684\uff0c\u800c\u4e14\u8981\u4fdd\u8bc1\u5b8c\u6574\u6027\u3002 \u52a0\u5bc6 \u00b6 \u89e3\u5bc6 \u00b6 \u4f18\u7f3a\u70b9 \u00b6 \u4f18\u70b9 \u00b6 \u5bc6\u6587\u5757\u4e0d\u4ec5\u548c\u5f53\u524d\u5bc6\u6587\u5757\u76f8\u5173\uff0c\u800c\u4e14\u548c\u524d\u4e00\u4e2a\u5bc6\u6587\u5757\u6216 IV \u76f8\u5173\uff0c\u9690\u85cf\u4e86\u660e\u6587\u7684\u7edf\u8ba1\u7279\u6027\u3002 \u5177\u6709\u6709\u9650\u7684\u4e24\u6b65\u9519\u8bef\u4f20\u64ad\u7279\u6027\uff0c\u5373\u5bc6\u6587\u5757\u4e2d\u7684\u4e00\u4f4d\u53d8\u5316\u53ea\u4f1a\u5f71\u54cd\u5f53\u524d\u5bc6\u6587\u5757\u548c\u4e0b\u4e00\u5bc6\u6587\u5757\u3002 \u5177\u6709\u81ea\u540c\u6b65\u7279\u6027\uff0c\u5373\u7b2c k \u5757\u8d77\u5bc6\u6587\u6b63\u786e\uff0c\u5219\u7b2c k+1 \u5757\u5c31\u80fd\u6b63\u5e38\u89e3\u5bc6\u3002 \u7f3a\u70b9 \u00b6 \u52a0\u5bc6\u4e0d\u80fd\u5e76\u884c\uff0c\u89e3\u5bc6\u53ef\u4ee5\u5e76\u884c\u3002 \u5e94\u7528 \u00b6 CBC \u5e94\u7528\u5341\u5206\u5e7f\u6cdb \u5e38\u89c1\u7684\u6570\u636e\u52a0\u5bc6\u548c TLS \u52a0\u5bc6\u3002 \u5b8c\u6574\u6027\u8ba4\u8bc1\u548c\u8eab\u4efd\u8ba4\u8bc1\u3002 \u653b\u51fb \u00b6 \u5b57\u8282\u53cd\u8f6c\u653b\u51fb \u00b6 \u539f\u7406 \u00b6 \u5b57\u8282\u53cd\u8f6c\u7684\u539f\u7406\u5341\u5206\u7b80\u5355\uff0c\u6211\u4eec\u89c2\u5bdf \u89e3\u5bc6\u8fc7\u7a0b \u53ef\u4ee5\u53d1\u73b0\u5982\u4e0b\u7279\u6027: IV \u5411\u91cf\u5f71\u54cd\u7b2c\u4e00\u4e2a\u660e\u6587\u5206\u7ec4 \u7b2c n \u4e2a\u5bc6\u6587\u5206\u7ec4\u53ef\u4ee5\u5f71\u54cd\u7b2c n + 1 \u4e2a\u660e\u6587\u5206\u7ec4 \u5047\u8bbe\u7b2c n n \u4e2a\u5bc6\u6587\u5206\u7ec4\u4e3a C_n C_n \uff0c\u89e3\u5bc6\u540e\u7684\u7b2c n n \u4e2a\u660e\u6587\u5206\u7ec4\u4e3a\u4e3a P_n P_n \u3002 \u7136\u540e P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) \u3002 \u5176\u4e2d f f \u51fd\u6570\u4e3a\u56fe\u4e2d\u7684 \\text{Block Cipher Decryption} \\text{Block Cipher Decryption} \u3002 \u5bf9\u4e8e\u67d0\u4e2a\u4fe1\u606f\u5df2\u77e5\u7684\u539f\u6587\u548c\u5bc6\u6587\uff0c\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u7b2c n n \u4e2a\u5bc6\u6587\u5757 C_n C_n \u4e3a C_n~\\text{xor}~P_{n+1}~\\text{xor}~A C_n~\\text{xor}~P_{n+1}~\\text{xor}~A \u3002\u7136\u540e\u518d\u5bf9\u8fd9\u6761\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u90a3\u4e48\u89e3\u5bc6\u540e\u7684\u7b2c n n \u4e2a\u660e\u6587\u5feb\u5c06\u4f1a\u53d8\u6210 A A \u3002 \u4f8b\u9898 \u00b6 from flag import FLAG from Crypto.Cipher import AES from Crypto import Random import base64 BLOCK_SIZE = 16 IV = Random . new () . read ( BLOCK_SIZE ) passphrase = Random . new () . read ( BLOCK_SIZE ) pad = lambda s : s + ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) * chr ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) unpad = lambda s : s [: - ord ( s [ len ( s ) - 1 :])] prefix = \"flag=\" + FLAG + \"&userdata=\" suffix = \"&user=guest\" def menu (): print \"1. encrypt\" print \"2. decrypt\" return raw_input ( \"> \" ) def encrypt (): data = raw_input ( \"your data: \" ) plain = prefix + data + suffix aes = AES . new ( passphrase , AES . MODE_CBC , IV ) print base64 . b64encode ( aes . encrypt ( pad ( plain ))) def decrypt (): data = raw_input ( \"input data: \" ) aes = AES . new ( passphrase , AES . MODE_CBC , IV ) plain = unpad ( aes . decrypt ( base64 . b64decode ( data ))) print 'DEBUG ====> ' + plain if plain [ - 5 :] == \"admin\" : print plain else : print \"you are not admin\" def main (): for _ in range ( 10 ): cmd = menu () if cmd == \"1\" : encrypt () elif cmd == \"2\" : decrypt () else : exit () if __name__ == \"__main__\" : main () \u53ef\u89c1\u9898\u76ee\u5e0c\u671b\u6211\u4eec\u63d0\u4f9b\u4e00\u4e2a\u52a0\u5bc6\u7684\u5b57\u7b26\u4e32\uff0c\u5982\u679c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u89e3\u5bc6\u540e\u6700\u540e\u7684\u5185\u5bb9\u4e3aadmin\u3002\u7a0b\u5e8f\u5c06\u4f1a\u8f93\u51fa\u660e\u6587\u3002\u6240\u4ee5\u9898\u76ee\u6d41\u7a0b\u4e3a\u5148\u968f\u4fbf\u63d0\u4f9b\u4e00\u4e2a\u660e\u6587\uff0c\u7136\u540e\u5c06\u5bc6\u6587\u8fdb\u884c\u4fee\u6539\uff0c\u4f7f\u5f97\u89e3\u5bc6\u540e\u7684\u5b57\u7b26\u4e32\u6700\u540e\u7684\u5185\u5bb9\u4e3aadmin,\u6211\u4eec\u53ef\u4ee5\u679a\u4e3eflag\u7684\u957f\u5ea6\u6765\u786e\u5b9a\u6211\u4eec\u9700\u8981\u5728\u4ec0\u4e48\u4f4d\u7f6e\u8fdb\u884c\u4fee\u6539\u3002 \u4ee5\u4e0b\u662fexp.py from pwn import * import base64 pad = 16 data = 'a' * pad for x in range ( 10 , 100 ): r = remote ( 'xxx.xxx.xxx.xxx' , 10004 ) #r = process('./chall.sh') r . sendlineafter ( '> ' , '1' ) r . sendlineafter ( 'your data: ' , data ) cipher = list ( base64 . b64decode ( r . recv ())) #print 'cipher ===>', ''.join(cipher) BLOCK_SIZE = 16 prefix = \"flag=\" + 'a' * x + \"&userdata=\" suffix = \"&user=guest\" plain = prefix + data + suffix idx = ( 22 + x + pad ) % BLOCK_SIZE + (( 22 + x + pad ) / BLOCK_SIZE - 1 ) * BLOCK_SIZE cipher [ idx + 0 ] = chr ( ord ( cipher [ idx + 0 ]) ^ ord ( 'g' ) ^ ord ( 'a' )) cipher [ idx + 1 ] = chr ( ord ( cipher [ idx + 1 ]) ^ ord ( 'u' ) ^ ord ( 'd' )) cipher [ idx + 2 ] = chr ( ord ( cipher [ idx + 2 ]) ^ ord ( 'e' ) ^ ord ( 'm' )) cipher [ idx + 3 ] = chr ( ord ( cipher [ idx + 3 ]) ^ ord ( 's' ) ^ ord ( 'i' )) cipher [ idx + 4 ] = chr ( ord ( cipher [ idx + 4 ]) ^ ord ( 't' ) ^ ord ( 'n' )) r . sendlineafter ( '> ' , '2' ) r . sendlineafter ( 'input data: ' , base64 . b64encode ( '' . join ( cipher ))) msg = r . recvline () if 'you are not admin' not in msg : print msg break r . close () Padding Oracle Attack \u00b6 \u5177\u4f53\u53c2\u89c1\u4e0b\u9762\u7684\u4ecb\u7ecd\u3002","title":"Cbc zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#cbc","text":"CBC\u5168\u79f0\u4e3a\u5bc6\u7801\u5206\u7ec4\u94fe\u63a5\uff08Cipher-block chaining\uff09 \u6a21\u5f0f\uff0c\u8fd9\u91cc IV \u4e0d\u8981\u6c42\u4fdd\u5bc6 IV \u5fc5\u987b\u662f\u4e0d\u53ef\u9884\u6d4b\u7684\uff0c\u800c\u4e14\u8981\u4fdd\u8bc1\u5b8c\u6574\u6027\u3002","title":"CBC"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_1","text":"","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_2","text":"","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_3","text":"","title":"\u4f18\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_4","text":"\u5bc6\u6587\u5757\u4e0d\u4ec5\u548c\u5f53\u524d\u5bc6\u6587\u5757\u76f8\u5173\uff0c\u800c\u4e14\u548c\u524d\u4e00\u4e2a\u5bc6\u6587\u5757\u6216 IV \u76f8\u5173\uff0c\u9690\u85cf\u4e86\u660e\u6587\u7684\u7edf\u8ba1\u7279\u6027\u3002 \u5177\u6709\u6709\u9650\u7684\u4e24\u6b65\u9519\u8bef\u4f20\u64ad\u7279\u6027\uff0c\u5373\u5bc6\u6587\u5757\u4e2d\u7684\u4e00\u4f4d\u53d8\u5316\u53ea\u4f1a\u5f71\u54cd\u5f53\u524d\u5bc6\u6587\u5757\u548c\u4e0b\u4e00\u5bc6\u6587\u5757\u3002 \u5177\u6709\u81ea\u540c\u6b65\u7279\u6027\uff0c\u5373\u7b2c k \u5757\u8d77\u5bc6\u6587\u6b63\u786e\uff0c\u5219\u7b2c k+1 \u5757\u5c31\u80fd\u6b63\u5e38\u89e3\u5bc6\u3002","title":"\u4f18\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_5","text":"\u52a0\u5bc6\u4e0d\u80fd\u5e76\u884c\uff0c\u89e3\u5bc6\u53ef\u4ee5\u5e76\u884c\u3002","title":"\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_6","text":"CBC \u5e94\u7528\u5341\u5206\u5e7f\u6cdb \u5e38\u89c1\u7684\u6570\u636e\u52a0\u5bc6\u548c TLS \u52a0\u5bc6\u3002 \u5b8c\u6574\u6027\u8ba4\u8bc1\u548c\u8eab\u4efd\u8ba4\u8bc1\u3002","title":"\u5e94\u7528"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_7","text":"","title":"\u653b\u51fb"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_8","text":"","title":"\u5b57\u8282\u53cd\u8f6c\u653b\u51fb"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_9","text":"\u5b57\u8282\u53cd\u8f6c\u7684\u539f\u7406\u5341\u5206\u7b80\u5355\uff0c\u6211\u4eec\u89c2\u5bdf \u89e3\u5bc6\u8fc7\u7a0b \u53ef\u4ee5\u53d1\u73b0\u5982\u4e0b\u7279\u6027: IV \u5411\u91cf\u5f71\u54cd\u7b2c\u4e00\u4e2a\u660e\u6587\u5206\u7ec4 \u7b2c n \u4e2a\u5bc6\u6587\u5206\u7ec4\u53ef\u4ee5\u5f71\u54cd\u7b2c n + 1 \u4e2a\u660e\u6587\u5206\u7ec4 \u5047\u8bbe\u7b2c n n \u4e2a\u5bc6\u6587\u5206\u7ec4\u4e3a C_n C_n \uff0c\u89e3\u5bc6\u540e\u7684\u7b2c n n \u4e2a\u660e\u6587\u5206\u7ec4\u4e3a\u4e3a P_n P_n \u3002 \u7136\u540e P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) \u3002 \u5176\u4e2d f f \u51fd\u6570\u4e3a\u56fe\u4e2d\u7684 \\text{Block Cipher Decryption} \\text{Block Cipher Decryption} \u3002 \u5bf9\u4e8e\u67d0\u4e2a\u4fe1\u606f\u5df2\u77e5\u7684\u539f\u6587\u548c\u5bc6\u6587\uff0c\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u7b2c n n \u4e2a\u5bc6\u6587\u5757 C_n C_n \u4e3a C_n~\\text{xor}~P_{n+1}~\\text{xor}~A C_n~\\text{xor}~P_{n+1}~\\text{xor}~A \u3002\u7136\u540e\u518d\u5bf9\u8fd9\u6761\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u90a3\u4e48\u89e3\u5bc6\u540e\u7684\u7b2c n n \u4e2a\u660e\u6587\u5feb\u5c06\u4f1a\u53d8\u6210 A A \u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#_10","text":"from flag import FLAG from Crypto.Cipher import AES from Crypto import Random import base64 BLOCK_SIZE = 16 IV = Random . new () . read ( BLOCK_SIZE ) passphrase = Random . new () . read ( BLOCK_SIZE ) pad = lambda s : s + ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) * chr ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) unpad = lambda s : s [: - ord ( s [ len ( s ) - 1 :])] prefix = \"flag=\" + FLAG + \"&userdata=\" suffix = \"&user=guest\" def menu (): print \"1. encrypt\" print \"2. decrypt\" return raw_input ( \"> \" ) def encrypt (): data = raw_input ( \"your data: \" ) plain = prefix + data + suffix aes = AES . new ( passphrase , AES . MODE_CBC , IV ) print base64 . b64encode ( aes . encrypt ( pad ( plain ))) def decrypt (): data = raw_input ( \"input data: \" ) aes = AES . new ( passphrase , AES . MODE_CBC , IV ) plain = unpad ( aes . decrypt ( base64 . b64decode ( data ))) print 'DEBUG ====> ' + plain if plain [ - 5 :] == \"admin\" : print plain else : print \"you are not admin\" def main (): for _ in range ( 10 ): cmd = menu () if cmd == \"1\" : encrypt () elif cmd == \"2\" : decrypt () else : exit () if __name__ == \"__main__\" : main () \u53ef\u89c1\u9898\u76ee\u5e0c\u671b\u6211\u4eec\u63d0\u4f9b\u4e00\u4e2a\u52a0\u5bc6\u7684\u5b57\u7b26\u4e32\uff0c\u5982\u679c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u89e3\u5bc6\u540e\u6700\u540e\u7684\u5185\u5bb9\u4e3aadmin\u3002\u7a0b\u5e8f\u5c06\u4f1a\u8f93\u51fa\u660e\u6587\u3002\u6240\u4ee5\u9898\u76ee\u6d41\u7a0b\u4e3a\u5148\u968f\u4fbf\u63d0\u4f9b\u4e00\u4e2a\u660e\u6587\uff0c\u7136\u540e\u5c06\u5bc6\u6587\u8fdb\u884c\u4fee\u6539\uff0c\u4f7f\u5f97\u89e3\u5bc6\u540e\u7684\u5b57\u7b26\u4e32\u6700\u540e\u7684\u5185\u5bb9\u4e3aadmin,\u6211\u4eec\u53ef\u4ee5\u679a\u4e3eflag\u7684\u957f\u5ea6\u6765\u786e\u5b9a\u6211\u4eec\u9700\u8981\u5728\u4ec0\u4e48\u4f4d\u7f6e\u8fdb\u884c\u4fee\u6539\u3002 \u4ee5\u4e0b\u662fexp.py from pwn import * import base64 pad = 16 data = 'a' * pad for x in range ( 10 , 100 ): r = remote ( 'xxx.xxx.xxx.xxx' , 10004 ) #r = process('./chall.sh') r . sendlineafter ( '> ' , '1' ) r . sendlineafter ( 'your data: ' , data ) cipher = list ( base64 . b64decode ( r . recv ())) #print 'cipher ===>', ''.join(cipher) BLOCK_SIZE = 16 prefix = \"flag=\" + 'a' * x + \"&userdata=\" suffix = \"&user=guest\" plain = prefix + data + suffix idx = ( 22 + x + pad ) % BLOCK_SIZE + (( 22 + x + pad ) / BLOCK_SIZE - 1 ) * BLOCK_SIZE cipher [ idx + 0 ] = chr ( ord ( cipher [ idx + 0 ]) ^ ord ( 'g' ) ^ ord ( 'a' )) cipher [ idx + 1 ] = chr ( ord ( cipher [ idx + 1 ]) ^ ord ( 'u' ) ^ ord ( 'd' )) cipher [ idx + 2 ] = chr ( ord ( cipher [ idx + 2 ]) ^ ord ( 'e' ) ^ ord ( 'm' )) cipher [ idx + 3 ] = chr ( ord ( cipher [ idx + 3 ]) ^ ord ( 's' ) ^ ord ( 'i' )) cipher [ idx + 4 ] = chr ( ord ( cipher [ idx + 4 ]) ^ ord ( 't' ) ^ ord ( 'n' )) r . sendlineafter ( '> ' , '2' ) r . sendlineafter ( 'input data: ' , base64 . b64encode ( '' . join ( cipher ))) msg = r . recvline () if 'you are not admin' not in msg : print msg break r . close ()","title":"\u4f8b\u9898"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc-zh/#padding-oracle-attack","text":"\u5177\u4f53\u53c2\u89c1\u4e0b\u9762\u7684\u4ecb\u7ecd\u3002","title":"Padding Oracle Attack"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/","text":"EN | ZH CBC \u00b6 CBC is called the Cipher-block chaining mode, here IV does not require confidentiality IV must be unpredictable and must be complete. Encryption \u00b6 decryption \u00b6 Advantages and disadvantages \u00b6 Advantages \u00b6 The ciphertext block is not only related to the current ciphertext block, but also related to the previous ciphertext block or IV, hiding the statistical properties of the plaintext. Has a limited two-step error propagation feature, that is, a one-bit change in the ciphertext block only affects the current ciphertext block and the next ciphertext block. With self-synchronization feature, that is, the k-th block is correct, the k+1th block can be decrypted normally. Disadvantages \u00b6 Encryption cannot be parallel, decryption can be parallel. Application \u00b6 CBC is widely used Common data encryption and TLS encryption. Integrity and identity authentication. Attack \u00b6 Byte reversal attack \u00b6 Principle \u00b6 The principle of byte inversion is very simple, we observe the decryption process can find the following characteristics: IV vector affects the first plaintext grouping The nth ciphertext packet can affect the n + 1 plaintext packet Assuming that the n n ciphertext is grouped as C_n C_n , the decrypted n n plaintext is grouped as P_n P_n . Then P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) . The f f function is \\text{Block Cipher Decryption} \\text{Block Cipher Decryption} in the figure. For the original text and ciphertext of a certain information, then we can modify the n n ciphertext block C_n C_n to C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A . Then decrypt the ciphertext, then the decrypted n n plaintext will soon become A A . Example \u00b6 from flag import FLAG from Crypto.Cipher import AES from Crypto import Random import base64 BLOCK_SIZE = 16 IV = Random . new () . read ( BLOCK_SIZE ) passphrase = Random . new () . read ( BLOCK_SIZE ) pad = lambda s : s + ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) * chr ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) unpad = lambda s : s [: - ord ( s [ len ( s ) - 1 :])] prefix = \"flag=\" + FLAG + \"&userdata=\" suffix = \"&user=guest\" def menu (): print \"1. encrypt\" print \"2. decrypt\" return raw_input ( \"> \" ) def encrypt (): data = raw_input ( \"your data: \" ) plain = prefix + data + suffix aes = AES . new ( passphrase , AES . MODE_CBC , IV ) print base64 . b64encode ( aes . encrypt ( pad ( plain ))) def decrypt (): data = raw_input ( \"input data: \" ) aes = AES . new ( passphrase , AES . MODE_CBC , IV ) plain = unpad ( aes . decrypt ( base64 . b64decode ( data ))) print 'DEBUG ====> ' + plain if plain [ - 5 :] == \"admin\" : print plain else : print \"you are not admin\" def main (): for _ in range ( 10 ): cmd = menu () if cmd == \"1\" : encrypt () elif cmd == & quot ; 2 & quot ;: decrypt () else : exit () if __name__ == \"__main__\" : main () Visible topic I hope we provide an encrypted string, if the final content of this string is admin. The program will output clear text. Therefore, the problem flow is to provide a plain text first, and then modify the ciphertext so that the final content of the decrypted string is admin. We can enumerate the length of the flag to determine where we need to modify it. The following is exp.py from pwn import * import base64 pad = 16 data = 'a' * pad for x in range ( 10 , 100 ): r = remote ( 'xxx.xxx.xxx.xxx' , 10004 ) #r = process('./chall.sh') r . sendlineafter ( '> ' , '1' ) r . sendlineafter ( 'your data: ' , data ) cipher = list ( base64 . b64decode ( r . recv ())) #print 'cipher ===>', ''.join(cipher) BLOCK_SIZE = 16 prefix = \"flag=\" + 'a' * x + \"&userdata=\" suffix = \"&user=guest\" plain = prefix + data + suffix idx = ( 22 + x + pad ) % BLOCK_SIZE + (( 22 + x + pad ) / BLOCK_SIZE - 1 ) * BLOCK_SIZE cipher [ idx + 0 ] = chr ( ord ( cipher [ idx + 0 ]) ^ ord ( 'g' ) ^ ord ( 'a' )) cipher [ idx + 1 ] = chr ( ord ( cipher [ idx + 1 ]) ^ ord ( 'u' ) ^ ord ( 'd' )) cipher [ idx + 2 ] = chr ( ord ( cipher [ idx + 2 ]) ^ ord ( 'e' ) ^ ord ( 'm' )) cipher [ idx + 3 ] = chr ( ord ( cipher [ idx + 3 ]) ^ ord ( 's' ) ^ ord ( 'i' )) cipher [ idx + 4 ] = chr ( ord ( cipher [ idx + 4 ]) ^ ord ( 't' ) ^ ord ( 'n' )) r . sendlineafter ( '> ' , '2' ) r . sendlineafter ( 'input data: ' , base64 . b64encode ( '' . join ( cipher ))) msg = r . recvline () if 'you are not admin' not in msg : print msg break r . close () Padding Oracle Attack \u00b6 See the introduction below for details.","title":"CBC"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#cbc","text":"CBC is called the Cipher-block chaining mode, here IV does not require confidentiality IV must be unpredictable and must be complete.","title":"CBC"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#encryption","text":"","title":"Encryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#decryption","text":"","title":"decryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#advantages","text":"The ciphertext block is not only related to the current ciphertext block, but also related to the previous ciphertext block or IV, hiding the statistical properties of the plaintext. Has a limited two-step error propagation feature, that is, a one-bit change in the ciphertext block only affects the current ciphertext block and the next ciphertext block. With self-synchronization feature, that is, the k-th block is correct, the k+1th block can be decrypted normally.","title":"Advantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#disadvantages","text":"Encryption cannot be parallel, decryption can be parallel.","title":"Disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#application","text":"CBC is widely used Common data encryption and TLS encryption. Integrity and identity authentication.","title":"Application"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#attack","text":"","title":"Attack"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#byte-reversal-attack","text":"","title":"Byte reversal attack"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#principle","text":"The principle of byte inversion is very simple, we observe the decryption process can find the following characteristics: IV vector affects the first plaintext grouping The nth ciphertext packet can affect the n + 1 plaintext packet Assuming that the n n ciphertext is grouped as C_n C_n , the decrypted n n plaintext is grouped as P_n P_n . Then P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) P_{n+1}=C_n~\\text{xor}~f(C_{n+1}) . The f f function is \\text{Block Cipher Decryption} \\text{Block Cipher Decryption} in the figure. For the original text and ciphertext of a certain information, then we can modify the n n ciphertext block C_n C_n to C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A C_n~\\text{xor}~P_{n+1}~\\text{xor}~ A . Then decrypt the ciphertext, then the decrypted n n plaintext will soon become A A .","title":"Principle"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#example","text":"from flag import FLAG from Crypto.Cipher import AES from Crypto import Random import base64 BLOCK_SIZE = 16 IV = Random . new () . read ( BLOCK_SIZE ) passphrase = Random . new () . read ( BLOCK_SIZE ) pad = lambda s : s + ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) * chr ( BLOCK_SIZE - len ( s ) % BLOCK_SIZE ) unpad = lambda s : s [: - ord ( s [ len ( s ) - 1 :])] prefix = \"flag=\" + FLAG + \"&userdata=\" suffix = \"&user=guest\" def menu (): print \"1. encrypt\" print \"2. decrypt\" return raw_input ( \"> \" ) def encrypt (): data = raw_input ( \"your data: \" ) plain = prefix + data + suffix aes = AES . new ( passphrase , AES . MODE_CBC , IV ) print base64 . b64encode ( aes . encrypt ( pad ( plain ))) def decrypt (): data = raw_input ( \"input data: \" ) aes = AES . new ( passphrase , AES . MODE_CBC , IV ) plain = unpad ( aes . decrypt ( base64 . b64decode ( data ))) print 'DEBUG ====> ' + plain if plain [ - 5 :] == \"admin\" : print plain else : print \"you are not admin\" def main (): for _ in range ( 10 ): cmd = menu () if cmd == \"1\" : encrypt () elif cmd == & quot ; 2 & quot ;: decrypt () else : exit () if __name__ == \"__main__\" : main () Visible topic I hope we provide an encrypted string, if the final content of this string is admin. The program will output clear text. Therefore, the problem flow is to provide a plain text first, and then modify the ciphertext so that the final content of the decrypted string is admin. We can enumerate the length of the flag to determine where we need to modify it. The following is exp.py from pwn import * import base64 pad = 16 data = 'a' * pad for x in range ( 10 , 100 ): r = remote ( 'xxx.xxx.xxx.xxx' , 10004 ) #r = process('./chall.sh') r . sendlineafter ( '> ' , '1' ) r . sendlineafter ( 'your data: ' , data ) cipher = list ( base64 . b64decode ( r . recv ())) #print 'cipher ===>', ''.join(cipher) BLOCK_SIZE = 16 prefix = \"flag=\" + 'a' * x + \"&userdata=\" suffix = \"&user=guest\" plain = prefix + data + suffix idx = ( 22 + x + pad ) % BLOCK_SIZE + (( 22 + x + pad ) / BLOCK_SIZE - 1 ) * BLOCK_SIZE cipher [ idx + 0 ] = chr ( ord ( cipher [ idx + 0 ]) ^ ord ( 'g' ) ^ ord ( 'a' )) cipher [ idx + 1 ] = chr ( ord ( cipher [ idx + 1 ]) ^ ord ( 'u' ) ^ ord ( 'd' )) cipher [ idx + 2 ] = chr ( ord ( cipher [ idx + 2 ]) ^ ord ( 'e' ) ^ ord ( 'm' )) cipher [ idx + 3 ] = chr ( ord ( cipher [ idx + 3 ]) ^ ord ( 's' ) ^ ord ( 'i' )) cipher [ idx + 4 ] = chr ( ord ( cipher [ idx + 4 ]) ^ ord ( 't' ) ^ ord ( 'n' )) r . sendlineafter ( '> ' , '2' ) r . sendlineafter ( 'input data: ' , base64 . b64encode ( '' . join ( cipher ))) msg = r . recvline () if 'you are not admin' not in msg : print msg break r . close ()","title":"Example"},{"location":"crypto/ctf-wiki/blockcipher/mode/cbc/#padding-oracle-attack","text":"See the introduction below for details.","title":"Padding Oracle Attack"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/","text":"EN | ZH CFB \u00b6 CFB \u5168\u79f0\u4e3a\u5bc6\u6587\u53cd\u9988\u6a21\u5f0f\uff08Cipher feedback\uff09\u3002 \u52a0\u5bc6 \u00b6 \u89e3\u5bc6 \u00b6 \u4f18\u7f3a\u70b9 \u00b6 \u4f18\u70b9 \u00b6 \u9002\u5e94\u4e8e\u4e0d\u540c\u6570\u636e\u683c\u5f0f\u7684\u8981\u6c42 \u6709\u9650\u9519\u8bef\u4f20\u64ad \u81ea\u540c\u6b65 \u7f3a\u70b9 \u00b6 \u52a0\u5bc6\u4e0d\u80fd\u5e76\u884c\u5316\uff0c\u89e3\u5bc6\u4e0d\u80fd\u5e76\u884c \u5e94\u7528\u573a\u666f \u00b6 \u8be5\u6a21\u5f0f\u9002\u5e94\u4e8e\u6570\u636e\u5e93\u52a0\u5bc6\uff0c\u65e0\u7ebf\u901a\u4fe1\u52a0\u5bc6\u7b49\u5bf9\u6570\u636e\u683c\u5f0f\u6709\u7279\u6b8a\u8981\u6c42\u7684\u52a0\u5bc6\u73af\u5883\u3002 \u9898\u76ee \u00b6 HITCONCTF-Quals-2015-Simple-(Crypto-100)","title":"Cfb zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/#cfb","text":"CFB \u5168\u79f0\u4e3a\u5bc6\u6587\u53cd\u9988\u6a21\u5f0f\uff08Cipher feedback\uff09\u3002","title":"CFB"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/#_1","text":"","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/#_2","text":"","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/#_3","text":"","title":"\u4f18\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/#_4","text":"\u9002\u5e94\u4e8e\u4e0d\u540c\u6570\u636e\u683c\u5f0f\u7684\u8981\u6c42 \u6709\u9650\u9519\u8bef\u4f20\u64ad \u81ea\u540c\u6b65","title":"\u4f18\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/#_5","text":"\u52a0\u5bc6\u4e0d\u80fd\u5e76\u884c\u5316\uff0c\u89e3\u5bc6\u4e0d\u80fd\u5e76\u884c","title":"\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/#_6","text":"\u8be5\u6a21\u5f0f\u9002\u5e94\u4e8e\u6570\u636e\u5e93\u52a0\u5bc6\uff0c\u65e0\u7ebf\u901a\u4fe1\u52a0\u5bc6\u7b49\u5bf9\u6570\u636e\u683c\u5f0f\u6709\u7279\u6b8a\u8981\u6c42\u7684\u52a0\u5bc6\u73af\u5883\u3002","title":"\u5e94\u7528\u573a\u666f"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb-zh/#_7","text":"HITCONCTF-Quals-2015-Simple-(Crypto-100)","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/","text":"EN | ZH CFB \u00b6 The CFB is called the Cipher feedback. Encryption \u00b6 decryption \u00b6 Advantages and disadvantages \u00b6 Advantages \u00b6 Adapt to different data format requirements Limited error propagation Self synchronization Disadvantages \u00b6 Encryption cannot be parallelized, decryption cannot be parallel Application Scenario \u00b6 This mode is suitable for database encryption, wireless communication encryption and other encryption environments that have special requirements on data formats. topic \u00b6 HITCONCTF-Quals-2015-Simple- (Crypto-100)","title":"CFB"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/#cfb","text":"The CFB is called the Cipher feedback.","title":"CFB"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/#encryption","text":"","title":"Encryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/#decryption","text":"","title":"decryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/#advantages","text":"Adapt to different data format requirements Limited error propagation Self synchronization","title":"Advantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/#disadvantages","text":"Encryption cannot be parallelized, decryption cannot be parallel","title":"Disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/#application-scenario","text":"This mode is suitable for database encryption, wireless communication encryption and other encryption environments that have special requirements on data formats.","title":"Application Scenario"},{"location":"crypto/ctf-wiki/blockcipher/mode/cfb/#topic","text":"HITCONCTF-Quals-2015-Simple- (Crypto-100)","title":"topic"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr-zh/","text":"EN | ZH CTR \u00b6 CTR\u5168\u79f0\u4e3a\u8ba1\u6570\u5668\u6a21\u5f0f\uff08Counter mode\uff09\uff0c\u8be5\u6a21\u5f0f\u7531 Diffe \u548c Hellman \u8bbe\u8ba1\u3002 \u52a0\u5bc6 \u00b6 \u89e3\u5bc6 \u00b6 \u9898\u76ee \u00b6 2017 star ctf ssss 2017 star ctf ssss2","title":"Ctr zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr-zh/#ctr","text":"CTR\u5168\u79f0\u4e3a\u8ba1\u6570\u5668\u6a21\u5f0f\uff08Counter mode\uff09\uff0c\u8be5\u6a21\u5f0f\u7531 Diffe \u548c Hellman \u8bbe\u8ba1\u3002","title":"CTR"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr-zh/#_1","text":"","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr-zh/#_2","text":"","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr-zh/#_3","text":"2017 star ctf ssss 2017 star ctf ssss2","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr/","text":"EN | ZH CTR \u00b6 The CTR is called the Counter mode, which is designed by Diffe and Hellman. Encryption \u00b6 decryption \u00b6 topic \u00b6 2017 star ctf ssss 2017 star ctf ssss2","title":"CTR"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr/#ctr","text":"The CTR is called the Counter mode, which is designed by Diffe and Hellman.","title":"CTR"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr/#encryption","text":"","title":"Encryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr/#decryption","text":"","title":"decryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/ctr/#topic","text":"2017 star ctf ssss 2017 star ctf ssss2","title":"topic"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/","text":"EN | ZH ECB \u00b6 ECB\u6a21\u5f0f\u5168\u79f0\u4e3a\u7535\u5b50\u5bc6\u7801\u672c\u6a21\u5f0f\uff08Electronic codebook\uff09\u3002 \u52a0\u5bc6 \u00b6 \u89e3\u5bc6 \u00b6 \u4f18\u7f3a\u70b9 \u00b6 \u4f18\u70b9 \u00b6 \u5b9e\u73b0\u7b80\u5355\u3002 \u4e0d\u540c\u660e\u6587\u5206\u7ec4\u7684\u52a0\u5bc6\u53ef\u4ee5\u5e76\u884c\u8ba1\u7b97\uff0c\u901f\u5ea6\u5f88\u5feb\u3002 \u7f3a\u70b9 \u00b6 \u540c\u6837\u7684\u660e\u6587\u5757\u4f1a\u88ab\u52a0\u5bc6\u6210\u76f8\u540c\u7684\u5bc6\u6587\u5757\uff0c\u4e0d\u4f1a\u9690\u85cf\u660e\u6587\u5206\u7ec4\u7684\u7edf\u8ba1\u89c4\u5f8b\u3002\u6b63\u5982\u4e0b\u56fe\u6240\u793a \u4e3a\u4e86\u89e3\u51b3\u7edf\u4e00\u660e\u6587\u4ea7\u751f\u76f8\u540c\u5bc6\u6587\u7684\u95ee\u9898\uff0c\u63d0\u51fa\u4e86\u5176\u5b83\u7684\u52a0\u5bc6\u6a21\u5f0f\u3002 \u5178\u578b\u5e94\u7528 \u00b6 \u7528\u4e8e\u968f\u673a\u6570\u7684\u52a0\u5bc6\u4fdd\u62a4\u3002 \u7528\u4e8e\u5355\u5206\u7ec4\u660e\u6587\u7684\u52a0\u5bc6\u3002 2016 ABCTF aes-mess-75 \u00b6 \u9898\u76ee\u63cf\u8ff0\u5982\u4e0b We encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75 However, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(. Luckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this? [HINT] There has to be some way to work backwards, right? \u53ef\u4ee5\u770b\u51fa\uff0c\u8fd9\u4e2a\u52a0\u5bc6\u662f\u4e00\u4e2a ECB \u52a0\u5bc6\uff0c\u7136\u540e AES \u662f 16 \u4e2a\u5b57\u8282\u4e00\u7ec4\uff0c\u6bcf\u4e2a\u5b57\u8282\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a 16 \u8fdb\u5236\u5b57\u7b26\u8868\u793a\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u6bcf 32 \u4e2a\u5b57\u7b26\u4e00\u7ec4\u8fdb\u884c\u5206\u7ec4\uff0c\u7136\u540e\u53bb\u5bf9\u5e94\u7684 txt \u6587\u4ef6\u4e2d\u641c\u7d22\u5373\u53ef\u3002 \u5bf9\u5e94 flag e220eb994c8fc16388dbd60a969d4953 abctf{looks_like f042fc0bce25dbef573cf522636a1ba3 _you_can_break_a fafa1a7c21ff824a5824c5dc4a376e75 es} \u6700\u540e\u4e00\u4e2a\u663e\u7136\u5728\u52a0\u5bc6\u65f6\u8fdb\u884c\u4e86 padding\u3002 \u9898\u76ee \u00b6 2018 PlaidCTF macsh","title":"Ecb zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#ecb","text":"ECB\u6a21\u5f0f\u5168\u79f0\u4e3a\u7535\u5b50\u5bc6\u7801\u672c\u6a21\u5f0f\uff08Electronic codebook\uff09\u3002","title":"ECB"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#_1","text":"","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#_2","text":"","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#_3","text":"","title":"\u4f18\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#_4","text":"\u5b9e\u73b0\u7b80\u5355\u3002 \u4e0d\u540c\u660e\u6587\u5206\u7ec4\u7684\u52a0\u5bc6\u53ef\u4ee5\u5e76\u884c\u8ba1\u7b97\uff0c\u901f\u5ea6\u5f88\u5feb\u3002","title":"\u4f18\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#_5","text":"\u540c\u6837\u7684\u660e\u6587\u5757\u4f1a\u88ab\u52a0\u5bc6\u6210\u76f8\u540c\u7684\u5bc6\u6587\u5757\uff0c\u4e0d\u4f1a\u9690\u85cf\u660e\u6587\u5206\u7ec4\u7684\u7edf\u8ba1\u89c4\u5f8b\u3002\u6b63\u5982\u4e0b\u56fe\u6240\u793a \u4e3a\u4e86\u89e3\u51b3\u7edf\u4e00\u660e\u6587\u4ea7\u751f\u76f8\u540c\u5bc6\u6587\u7684\u95ee\u9898\uff0c\u63d0\u51fa\u4e86\u5176\u5b83\u7684\u52a0\u5bc6\u6a21\u5f0f\u3002","title":"\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#_6","text":"\u7528\u4e8e\u968f\u673a\u6570\u7684\u52a0\u5bc6\u4fdd\u62a4\u3002 \u7528\u4e8e\u5355\u5206\u7ec4\u660e\u6587\u7684\u52a0\u5bc6\u3002","title":"\u5178\u578b\u5e94\u7528"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#2016-abctf-aes-mess-75","text":"\u9898\u76ee\u63cf\u8ff0\u5982\u4e0b We encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75 However, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(. Luckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this? [HINT] There has to be some way to work backwards, right? \u53ef\u4ee5\u770b\u51fa\uff0c\u8fd9\u4e2a\u52a0\u5bc6\u662f\u4e00\u4e2a ECB \u52a0\u5bc6\uff0c\u7136\u540e AES \u662f 16 \u4e2a\u5b57\u8282\u4e00\u7ec4\uff0c\u6bcf\u4e2a\u5b57\u8282\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a 16 \u8fdb\u5236\u5b57\u7b26\u8868\u793a\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u6bcf 32 \u4e2a\u5b57\u7b26\u4e00\u7ec4\u8fdb\u884c\u5206\u7ec4\uff0c\u7136\u540e\u53bb\u5bf9\u5e94\u7684 txt \u6587\u4ef6\u4e2d\u641c\u7d22\u5373\u53ef\u3002 \u5bf9\u5e94 flag e220eb994c8fc16388dbd60a969d4953 abctf{looks_like f042fc0bce25dbef573cf522636a1ba3 _you_can_break_a fafa1a7c21ff824a5824c5dc4a376e75 es} \u6700\u540e\u4e00\u4e2a\u663e\u7136\u5728\u52a0\u5bc6\u65f6\u8fdb\u884c\u4e86 padding\u3002","title":"2016 ABCTF aes-mess-75"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb-zh/#_7","text":"2018 PlaidCTF macsh","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/","text":"EN | ZH ECB \u00b6 The ECB mode is called the electronic codebook mode. Encryption \u00b6 decryption \u00b6 Advantages and disadvantages \u00b6 Advantages \u00b6 Simple to implement. Encryption of different plaintext packets can be calculated in parallel, which is fast. Disadvantages \u00b6 The same plaintext block will be encrypted into the same ciphertext block, and the statistical rules of the plaintext grouping will not be hidden. As shown below In order to solve the problem that the unified plaintext generates the same ciphertext, other encryption modes are proposed. typical application \u00b6 Encryption protection for random numbers. Encryption for single-packet plaintext. 2016 ABCTF aes-mess-75 \u00b6 The title is described below We encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75 However, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(. Luckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this? [HINT] There has to be some way to work backwards, right? It can be seen that this encryption is an ECB encryption, then AES is a group of 16 bytes, each byte can be represented by two hexadecimal characters, so we group each 32 characters and then correspond Search in the txt file. Corresponding flag e220eb994c8fc16388dbd60a969d4953 abctf{looks_like f042fc0bce25dbef573cf522636a1ba3 _you_can_break_a fafa1a7c21ff824a5824c5dc4a376e75 is} The last one is obviously padding when it is encrypted. topic \u00b6 2018 PlaidCTF macsh","title":"ECB"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#ecb","text":"The ECB mode is called the electronic codebook mode.","title":"ECB"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#encryption","text":"","title":"Encryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#decryption","text":"","title":"decryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#advantages","text":"Simple to implement. Encryption of different plaintext packets can be calculated in parallel, which is fast.","title":"Advantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#disadvantages","text":"The same plaintext block will be encrypted into the same ciphertext block, and the statistical rules of the plaintext grouping will not be hidden. As shown below In order to solve the problem that the unified plaintext generates the same ciphertext, other encryption modes are proposed.","title":"Disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#typical-application","text":"Encryption protection for random numbers. Encryption for single-packet plaintext.","title":"typical application"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#2016-abctf-aes-mess-75","text":"The title is described below We encrypted a flag with AES-ECB encryption using a secret key, and got the hash: e220eb994c8fc16388dbd60a969d4953f042fc0bce25dbef573cf522636a1ba3fafa1a7c21ff824a5824c5dc4a376e75 However, we lost our plaintext flag and also lost our key and we can't seem to decrypt the hash back :(. Luckily we encrypted a bunch of other flags with the same key. Can you recover the lost flag using this? [HINT] There has to be some way to work backwards, right? It can be seen that this encryption is an ECB encryption, then AES is a group of 16 bytes, each byte can be represented by two hexadecimal characters, so we group each 32 characters and then correspond Search in the txt file. Corresponding flag e220eb994c8fc16388dbd60a969d4953 abctf{looks_like f042fc0bce25dbef573cf522636a1ba3 _you_can_break_a fafa1a7c21ff824a5824c5dc4a376e75 is} The last one is obviously padding when it is encrypted.","title":"2016 ABCTF aes-mess-75"},{"location":"crypto/ctf-wiki/blockcipher/mode/ecb/#topic","text":"2018 PlaidCTF macsh","title":"topic"},{"location":"crypto/ctf-wiki/blockcipher/mode/introduction-zh/","text":"EN | ZH \u5206\u7ec4\u6a21\u5f0f \u00b6 \u5206\u7ec4\u52a0\u5bc6\u4f1a\u5c06\u660e\u6587\u6d88\u606f\u5212\u5206\u4e3a\u56fa\u5b9a\u5927\u5c0f\u7684\u5757\uff0c\u6bcf\u5757\u660e\u6587\u5206\u522b\u5728\u5bc6\u94a5\u63a7\u5236\u4e0b\u52a0\u5bc6\u4e3a\u5bc6\u6587\u3002\u5f53\u7136\u5e76\u4e0d\u662f\u6bcf\u4e2a\u6d88\u606f\u90fd\u662f\u76f8\u5e94\u5757\u5927\u5c0f\u7684\u6574\u6570\u500d\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u80fd\u9700\u8981\u8fdb\u884c\u586b\u5145\u3002","title":"Introduction zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/introduction-zh/#_1","text":"\u5206\u7ec4\u52a0\u5bc6\u4f1a\u5c06\u660e\u6587\u6d88\u606f\u5212\u5206\u4e3a\u56fa\u5b9a\u5927\u5c0f\u7684\u5757\uff0c\u6bcf\u5757\u660e\u6587\u5206\u522b\u5728\u5bc6\u94a5\u63a7\u5236\u4e0b\u52a0\u5bc6\u4e3a\u5bc6\u6587\u3002\u5f53\u7136\u5e76\u4e0d\u662f\u6bcf\u4e2a\u6d88\u606f\u90fd\u662f\u76f8\u5e94\u5757\u5927\u5c0f\u7684\u6574\u6570\u500d\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u80fd\u9700\u8981\u8fdb\u884c\u586b\u5145\u3002","title":"\u5206\u7ec4\u6a21\u5f0f"},{"location":"crypto/ctf-wiki/blockcipher/mode/introduction/","text":"EN | ZH \u7ec4\u6a21\u5f0f \u00b6 Packet encryption divides the plaintext message into fixed-size blocks, and each block of plaintext is encrypted into ciphertext under key control. Of course not every message is an integer multiple of the corresponding block size, so we may need to do the padding.","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/blockcipher/mode/introduction/#_1","text":"Packet encryption divides the plaintext message into fixed-size blocks, and each block of plaintext is encrypted into ciphertext under key control. Of course not every message is an integer multiple of the corresponding block size, so we may need to do the padding.","title":"\u7ec4\u6a21\u5f0f"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb-zh/","text":"EN | ZH OFB \u00b6 OFB\u5168\u79f0\u4e3a\u8f93\u51fa\u53cd\u9988\u6a21\u5f0f\uff08Output feedback\uff09\uff0c\u5176\u53cd\u9988\u5185\u5bb9\u662f\u5206\u7ec4\u52a0\u5bc6\u540e\u7684\u5185\u5bb9\u800c\u4e0d\u662f\u5bc6\u6587\u3002 \u52a0\u5bc6 \u00b6 \u89e3\u5bc6 \u00b6 \u4f18\u7f3a\u70b9 \u00b6 \u4f18\u70b9 \u00b6 \u4e0d\u5177\u6709\u9519\u8bef\u4f20\u64ad\u7279\u6027\u3002 \u7f3a\u70b9 \u00b6 IV \u65e0\u9700\u4fdd\u5bc6\uff0c\u4f46\u662f\u5bf9\u6bcf\u4e2a\u6d88\u606f\u5fc5\u987b\u9009\u62e9\u4e0d\u540c\u7684 IV\u3002 \u4e0d\u5177\u6709\u81ea\u540c\u6b65\u80fd\u529b\u3002 \u9002\u7528\u573a\u666f \u00b6 \u9002\u7528\u4e8e\u4e00\u4e9b\u660e\u6587\u5197\u4f59\u5ea6\u6bd4\u8f83\u5927\u7684\u573a\u666f\uff0c\u5982\u56fe\u50cf\u52a0\u5bc6\u548c\u8bed\u97f3\u52a0\u5bc6\u3002","title":"Ofb zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb-zh/#ofb","text":"OFB\u5168\u79f0\u4e3a\u8f93\u51fa\u53cd\u9988\u6a21\u5f0f\uff08Output feedback\uff09\uff0c\u5176\u53cd\u9988\u5185\u5bb9\u662f\u5206\u7ec4\u52a0\u5bc6\u540e\u7684\u5185\u5bb9\u800c\u4e0d\u662f\u5bc6\u6587\u3002","title":"OFB"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb-zh/#_1","text":"","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb-zh/#_2","text":"","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb-zh/#_3","text":"","title":"\u4f18\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb-zh/#_4","text":"\u4e0d\u5177\u6709\u9519\u8bef\u4f20\u64ad\u7279\u6027\u3002","title":"\u4f18\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb-zh/#_5","text":"IV \u65e0\u9700\u4fdd\u5bc6\uff0c\u4f46\u662f\u5bf9\u6bcf\u4e2a\u6d88\u606f\u5fc5\u987b\u9009\u62e9\u4e0d\u540c\u7684 IV\u3002 \u4e0d\u5177\u6709\u81ea\u540c\u6b65\u80fd\u529b\u3002","title":"\u7f3a\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb-zh/#_6","text":"\u9002\u7528\u4e8e\u4e00\u4e9b\u660e\u6587\u5197\u4f59\u5ea6\u6bd4\u8f83\u5927\u7684\u573a\u666f\uff0c\u5982\u56fe\u50cf\u52a0\u5bc6\u548c\u8bed\u97f3\u52a0\u5bc6\u3002","title":"\u9002\u7528\u573a\u666f"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb/","text":"EN | ZH OFB \u00b6 OFB is called output feedback mode, and its feedback content is packet-encrypted content instead of ciphertext. Encryption \u00b6 decryption \u00b6 Advantages and disadvantages \u00b6 Advantages \u00b6 Does not have error propagation characteristics. Disadvantages \u00b6 IV does not require confidentiality, but a different IV must be chosen for each message. Does not have self-synchronization capability. Applicable scene \u00b6 Applicable to some scenarios where the plaintext redundancy is relatively large, such as image encryption and voice encryption.","title":"OFB"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb/#ofb","text":"OFB is called output feedback mode, and its feedback content is packet-encrypted content instead of ciphertext.","title":"OFB"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb/#encryption","text":"","title":"Encryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb/#decryption","text":"","title":"decryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb/#advantages-and-disadvantages","text":"","title":"Advantages and disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb/#advantages","text":"Does not have error propagation characteristics.","title":"Advantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb/#disadvantages","text":"IV does not require confidentiality, but a different IV must be chosen for each message. Does not have self-synchronization capability.","title":"Disadvantages"},{"location":"crypto/ctf-wiki/blockcipher/mode/ofb/#applicable-scene","text":"Applicable to some scenarios where the plaintext redundancy is relatively large, such as image encryption and voice encryption.","title":"Applicable scene"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/","text":"EN | ZH Padding Oracle Attack \u00b6 \u4ecb\u7ecd \u00b6 Padding Oracle Attack \u653b\u51fb\u4e00\u822c\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u51e0\u4e2a\u6761\u4ef6 \u52a0\u5bc6\u7b97\u6cd5 \u91c7\u7528 PKCS5 Padding \u7684\u52a0\u5bc6\u7b97\u6cd5\u3002 \u5f53\u7136\uff0c\u975e\u5bf9\u79f0\u52a0\u5bc6\u4e2d OAEP \u7684\u586b\u5145\u65b9\u5f0f\u4e5f\u6709\u53ef\u80fd\u4f1a\u53d7\u5230\u5f71\u54cd\u3002 \u5206\u7ec4\u6a21\u5f0f\u4e3a CBC \u6a21\u5f0f\u3002 \u653b\u51fb\u8005\u80fd\u529b \u653b\u51fb\u8005\u53ef\u4ee5\u62e6\u622a\u4e0a\u8ff0\u52a0\u5bc6\u7b97\u6cd5\u52a0\u5bc6\u7684\u6d88\u606f\u3002 \u653b\u51fb\u8005\u53ef\u4ee5\u548c padding oracle\uff08\u5373\u670d\u52a1\u5668\uff09 \u8fdb\u884c\u4ea4\u4e92\uff1a\u5ba2\u6237\u7aef\u5411\u670d\u52a1\u5668\u7aef\u53d1\u9001\u5bc6\u6587\uff0c\u670d\u52a1\u5668\u7aef\u4f1a\u4ee5\u67d0\u79cd\u8fd4\u56de\u4fe1\u606f\u544a\u77e5\u5ba2\u6237\u7aef padding \u662f\u5426\u6b63\u5e38\u3002 Padding Oracle Attack \u653b\u51fb\u53ef\u4ee5\u8fbe\u5230\u7684\u6548\u679c\u5982\u4e0b \u5728\u4e0d\u6e05\u695a key \u548c IV \u7684\u524d\u63d0\u4e0b\u89e3\u5bc6\u4efb\u610f\u7ed9\u5b9a\u7684\u5bc6\u6587\u3002 \u539f\u7406 \u00b6 Padding Oracle Attack \u653b\u51fb\u7684\u57fa\u672c\u539f\u7406\u5982\u4e0b \u5bf9\u4e8e\u5f88\u957f\u7684\u6d88\u606f\u4e00\u5757\u4e00\u5757\u89e3\u5bc6\u3002 \u5bf9\u4e8e\u6bcf\u4e00\u5757\u6d88\u606f\uff0c\u5148\u89e3\u5bc6\u6d88\u606f\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u7136\u540e\u89e3\u5bc6\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b57\u8282\uff0c\u4f9d\u6b21\u7c7b\u63a8\u3002 \u8fd9\u91cc\u6211\u4eec\u56de\u987e\u4e00\u4e0b CBC \u7684 \u52a0\u5bc6 C_i=E_K(P_i \\oplus C_{i-1})\\\\ C_0=IV C_i=E_K(P_i \\oplus C_{i-1})\\\\ C_0=IV \u89e3\u5bc6 P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\\\ C_{0}=IV P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\\\ C_{0}=IV \u6211\u4eec\u4e3b\u8981\u5173\u6ce8\u4e8e\u89e3\u5bc6\uff0c\u8fd9\u91cc\u6211\u4eec\u5e76\u4e0d\u77e5\u9053 IV \u548c key\u3002\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u5bc6\u6587\u5757\u7684\u957f\u5ea6\u4e3a n \u4e2a\u5b57\u8282\u3002 \u5047\u8bbe\u6211\u4eec\u622a\u83b7\u4e86\u5bc6\u6587 Y\uff0c\u4ee5\u83b7\u53d6\u5bc6\u6587 Y \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u4e3a\u4f8b\u5b50\u8fdb\u884c\u5206\u6790\u3002\u4e3a\u4e86\u83b7\u53d6 Y \u7684\u5185\u5bb9\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u4f2a\u9020\u4e00\u5757\u5bc6\u6587 F \u4ee5\u4fbf\u4e8e\u53ef\u4ee5\u4fee\u6539 Y \u5bf9\u5e94\u660e\u6587\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002\u8fd9\u662f\u56e0\u4e3a\u82e5\u6211\u4eec\u6784\u9020\u5bc6\u6587 F|Y \uff0c\u90a3\u4e48\u89e3\u5bc6 Y \u65f6\u5177\u4f53\u4e3a $$ P=D_K(Y)\\oplus F $$ \u6240\u4ee5\u4fee\u6539\u5bc6\u6587 F \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282 F_{n} F_{n} \u53ef\u4ee5\u4fee\u6539 Y \u5bf9\u5e94\u7684\u660e\u6587\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002\u4e0b\u9762\u7ed9\u51fa\u83b7\u53d6 P \u6700\u540e\u4e00\u4e2a\u5b57\u8282\u7684\u8fc7\u7a0b i=0\uff0c\u8bbe\u7f6e F \u7684\u6bcf\u4e2a\u5b57\u8282\u4e3a \u968f\u673a\u5b57\u8282 \u3002 \u8bbe\u7f6e F_n=i \\oplus 0x01 F_n=i \\oplus 0x01 \u5c06 F|Y \u53d1\u9001\u7ed9\u670d\u52a1\u5668\uff0c\u5982\u679c P \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u662f i \u7684\u8bdd\uff0c\u90a3\u4e48\u6700\u540e\u7684 padding \u5c31\u662f 0x01\uff0c\u4e0d\u4f1a\u51fa\u73b0\u9519\u8bef\u3002\u5426\u5219\uff0c\u53ea\u6709 P \u7684\u6700\u540e P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 \u5b57\u8282\u90fd\u662f P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 \u624d\u4e0d\u4f1a\u62a5\u9519\u3002 \u800c\u4e14\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f padding \u7684\u5b57\u8282\u53ea\u80fd\u662f 0 \u5230 n\u3002 \u56e0\u6b64\uff0c\u82e5\u60f3\u8981\u4f7f\u5f97\u5728 F \u968f\u673a\u5730\u60c5\u51b5\u4e0b\uff0c\u5e76\u4e14\u6ee1\u8db3padding \u5b57\u8282\u5927\u5c0f\u7684\u7ea6\u675f\u60c5\u51b5\u4e0b\u8fd8\u4e0d\u62a5\u9519 \u6982\u7387\u5f88\u5c0f \u3002\u6240\u4ee5\u5728\u670d\u52a1\u5668\u7aef\u4e0d\u62a5\u9519\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u6211\u4eec\u786e\u5b9e\u83b7\u53d6\u4e86\u6b63\u786e\u7684\u5b57\u8282\u3002 \u5728\u51fa\u73b0\u9519\u8bef\u7684\u60c5\u51b5\u4e0b\uff0ci=i+1\uff0c\u8df3\u8f6c\u52302\u3002 \u5f53\u83b7\u53d6\u4e86 P \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u83b7\u53d6 P \u7684\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b57\u8282\uff0c\u6b64\u65f6\u9700\u8981\u8bbe\u7f6e F_n=P_n\\oplus 0x02 F_n=P_n\\oplus 0x02 \uff0c\u540c\u65f6\u8bbe\u7f6e F_{n-1}=i \\oplus 0x02 F_{n-1}=i \\oplus 0x02 \u53bb\u679a\u4e3e i\u3002 \u6240\u4ee5\uff0c\u7efc\u4e0a\u6240\u793a\uff0cPadding Oracle Attack \u5176\u5b9e\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u662f\u4e00\u79cd\u5177\u6709\u5f88\u5927\u6982\u7387\u6210\u529f\u7684\u653b\u51fb\u65b9\u6cd5\u3002 \u7136\u800c\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5f80\u5f80\u9047\u5230\u7684\u4e00\u4e9b\u73b0\u5b9e\u95ee\u9898\u5e76\u4e0d\u662f\u6807\u51c6\u7684 Padding Oracle Attack \u6a21\u5f0f\uff0c\u6211\u4eec\u5f80\u5f80\u9700\u8981\u8fdb\u884c\u4e00\u4e9b\u53d8\u5f62\u3002 2017 HITCON Secret Server \u00b6 \u5206\u6790 \u00b6 \u7a0b\u5e8f\u4e2d\u91c7\u7528\u7684\u52a0\u5bc6\u662f AES CBC\uff0c\u5176\u4e2d\u91c7\u7528\u7684 padding \u4e0e PKCS5 \u7c7b\u4f3c def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] \u4f46\u662f\uff0c\u5728\u6bcf\u6b21 unpad \u65f6\u5e76\u6ca1\u6709\u8fdb\u884c\u68c0\u6d4b\uff0c\u800c\u662f\u76f4\u63a5\u8fdb\u884c unpad\u3002 \u5176\u4e2d\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6bcf\u6b21\u548c\u7528\u6237\u4ea4\u4e92\u7684\u51fd\u6570\u662f send_msg \uff0c\u63a5\u53d7\u7528\u6237\u7684\u660e\u6587\uff0c\u4f7f\u7528\u56fa\u5b9a\u7684 2jpmLoSsOlQrqyqE \u4f5c\u4e3a IV\uff0c\u8fdb\u884c\u52a0\u5bc6\uff0c\u5e76\u5c06\u52a0\u5bc6\u7ed3\u679c\u8f93\u51fa\u3002 recv_msg \uff0c\u63a5\u53d7\u7528\u6237\u7684 IV \u548c\u5bc6\u6587\uff0c\u5bf9\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u5e76\u8fd4\u56de\u3002\u6839\u636e\u8fd4\u56de\u7684\u7ed3\u679c\u4f1a\u6709\u4e0d\u540c\u7684\u64cd\u4f5c msg = recv_msg () . strip () if msg . startswith ( 'exit-here' ): exit ( 0 ) elif msg . startswith ( 'get-flag' ): send_msg ( flag ) elif msg . startswith ( 'get-md5' ): send_msg ( MD5 . new ( msg [ 7 :]) . digest ()) elif msg . startswith ( 'get-time' ): send_msg ( str ( time . time ())) elif msg . startswith ( 'get-sha1' ): send_msg ( SHA . new ( msg [ 8 :]) . digest ()) elif msg . startswith ( 'get-sha256' ): send_msg ( SHA256 . new ( msg [ 10 :]) . digest ()) elif msg . startswith ( 'get-hmac' ): send_msg ( HMAC . new ( msg [ 8 :]) . digest ()) else : send_msg ( 'command not found' ) \u4e3b\u8981\u6f0f\u6d1e \u00b6 \u8fd9\u91cc\u6211\u4eec\u518d\u7b80\u5355\u603b\u7ed3\u4e00\u4e0b\u6211\u4eec\u5df2\u6709\u7684\u90e8\u5206 \u52a0\u5bc6 \u52a0\u5bc6\u65f6\u7684 IV \u662f\u56fa\u5b9a\u7684\u800c\u4e14\u5df2\u77e5\u3002 'Welcome!!' \u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u3002 \u89e3\u5bc6 \u6211\u4eec\u53ef\u4ee5\u63a7\u5236 IV\u3002 \u9996\u5148\uff0c\u65e2\u7136\u6211\u4eec\u77e5\u9053 Welcome!! \u52a0\u5bc6\u540e\u7684\u7ed3\u679c\uff0c\u8fd8\u53ef\u4ee5\u63a7\u5236 recv_msg \u4e2d\u7684 IV\uff0c\u90a3\u4e48\u6839\u636e\u89e3\u5bc6\u8fc7\u7a0b $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ \u5982\u679c\u6211\u4eec\u5c06 Welcome!! \u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u8f93\u5165\u7ed9 recv_msg\uff0c\u90a3\u4e48\u76f4\u63a5\u89e3\u5bc6\u540e\u7684\u7ed3\u679c\u4fbf\u662f \uff08Welcome!!+'\\x07'*7) xor iv \uff0c\u5982\u679c\u6211\u4eec \u6070\u5f53\u7684\u63a7\u5236\u89e3\u5bc6\u8fc7\u7a0b\u4e2d\u4f20\u9012\u7684 iv \uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u7ed3\u679c\u3002\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u53ef\u4ee5\u6267\u884c \u4e0a\u8ff0\u6240\u8bf4\u7684\u4efb\u610f\u547d\u4ee4 \u3002\u4ece\u800c\uff0c\u6211\u4eec\u4e5f\u5c31\u53ef\u4ee5\u77e5\u9053 flag \u89e3\u5bc6\u540e\u7684\u7ed3\u679c\u3002 \u5176\u6b21\uff0c\u5728\u4e0a\u9762\u7684\u57fa\u7840\u4e4b\u4e0a\uff0c\u5982\u679c\u6211\u4eec\u5728\u4efb\u4f55\u5bc6\u6587 C \u540e\u9762\u6dfb\u52a0\u81ea\u5b9a\u4e49\u7684 IV \u548c Welcome \u52a0\u5bc6\u540e\u7684\u7ed3\u679c\uff0c\u4f5c\u4e3a\u8f93\u5165\u4f20\u9012\u7ed9 recv_msg\uff0c\u90a3\u4e48\u6211\u4eec\u4fbf\u53ef\u4ee5\u63a7\u5236\u89e3\u5bc6\u4e4b\u540e\u7684\u6d88\u606f\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c \u90a3\u4e48\u7531\u4e8e unpad \u64cd\u4f5c\uff0c\u6211\u4eec\u4fbf\u53ef\u4ee5\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u7684\u957f\u5ea6\u51cf\u5c0f 0 \u5230 255 \u3002 \u5229\u7528\u601d\u8def \u00b6 \u57fa\u672c\u5229\u7528\u601d\u8def\u5982\u4e0b \u7ed5\u8fc7 proof of work \u6839\u636e\u6267\u884c\u4efb\u610f\u547d\u4ee4\u7684\u65b9\u5f0f\u83b7\u53d6\u52a0\u5bc6\u540e\u7684 flag\u3002 \u7531\u4e8e flag \u7684\u5f00\u5934\u662f hitcon{ \uff0c\u4e00\u5171\u67097\u4e2a\u5b57\u8282\uff0c\u6240\u4ee5\u6211\u4eec\u4efb\u7136\u53ef\u4ee5\u901a\u8fc7\u63a7\u5236 iv \u6765\u4f7f\u5f97\u89e3\u5bc6\u540e\u7684\u524d 7 \u4e2a\u5b57\u8282\u4e3a\u6307\u5b9a\u5b57\u8282\u3002\u8fd9\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u6267\u884c get-md5 \u547d\u4ee4\u3002\u800c\u6839\u636e unpad \u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u6070\u597d\u5728\u6d88\u606f\u7684\u7b2c\u51e0\u4e2a\u5b57\u8282\u5904\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u65f6\u5c06\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u4e3a hitcon{x \uff0c\u5373\u53ea\u4fdd\u7559 hitcon{ \u540e\u7684\u4e00\u4e2a\u5b57\u8282\u3002\u8fd9\u6837\u4fbf\u53ef\u4ee5\u83b7\u5f97\u5e26\u4e00\u4e2a\u5b57\u8282\u54c8\u5e0c\u540e\u7684\u52a0\u5bc6\u7ed3\u679c\u3002\u7c7b\u4f3c\u5730\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u83b7\u5f97\u5e26\u5236\u5b9a\u4e2a\u5b57\u8282\u54c8\u5e0c\u540e\u7684\u52a0\u5bc6\u7ed3\u679c\u3002 \u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u672c\u5730\u9010\u5b57\u8282\u7206\u7834\uff0c\u8ba1\u7b97\u5bf9\u5e94 md5 \uff0c\u7136\u540e\u518d\u6b21\u5229\u7528\u4efb\u610f\u547d\u4ee4\u6267\u884c\u7684\u65b9\u5f0f\uff0c\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u660e\u6587\u4e3a\u4efb\u610f\u6307\u5b9a\u547d\u4ee4\uff0c\u5982\u679c\u63a7\u5236\u4e0d\u6210\u529f\uff0c\u90a3\u8bf4\u660e\u8be5\u5b57\u8282\u4e0d\u5bf9\uff0c\u9700\u8981\u518d\u6b21\u7206\u7834\uff1b\u5982\u679c\u6b63\u786e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u76f4\u63a5\u6267\u884c\u5bf9\u5e94\u7684\u547d\u4ee4\u3002 \u5177\u4f53\u4ee3\u7801\u5982\u4e0b #coding=utf-8 from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' if args [ 'REMOTE' ]: p = remote ( '52.193.157.19' , 9999 ) else : p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] # \u53bb\u6389pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) p . recvuntil ( 'Done! \\n ' ) iv_encrypt = '2jpmLoSsOlQrqyqE' def getmd5enc ( i , cipher_flag , cipher_welcome ): \"\"\"return encrypt( md5( flag[7:7+i] ) )\"\"\" ## keep iv[7:] do not change, so decrypt won't change new_iv = flipplain ( \"hitcon{\" . ljust ( 16 , ' \\x00 ' ), \"get-md5\" . ljust ( 16 , ' \\x00 ' ), iv_encrypt ) payload = new_iv + cipher_flag ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_flag ) + 16 + 16 - ( 7 + i + 1 )), iv_encrypt ) payload += last_byte_iv + cipher_welcome p . sendline ( base64 . b64encode ( payload )) return p . recvuntil ( \" \\n \" , drop = True ) def main (): bypassproof () # result of encrypted Welcome!! cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_welcome = base64 . b64decode ( cipher )[ 16 :] log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-flag get_flag_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-flag\" ), iv_encrypt ) payload = base64 . b64encode ( get_flag_iv + cipher_welcome ) p . sendline ( payload ) cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_flag = base64 . b64decode ( cipher )[ 16 :] flaglen = len ( cipher_flag ) log . info ( \"cipher flag is : \" + cipher_flag ) # get command not found cipher p . sendline ( base64 . b64encode ( iv_encrypt + cipher_welcome )) cipher_notfound = p . recvuntil ( ' \\n ' , drop = True ) flag = \"\" # brute force for every byte of flag for i in range ( flaglen - 7 ): md5_indexi = getmd5enc ( i , cipher_flag , cipher_welcome ) md5_indexi = base64 . b64decode ( md5_indexi )[ 16 :] log . info ( \"get encrypt(md5(flag[7:7+i])): \" + md5_indexi ) for guess in range ( 256 ): # locally compute md5 hash guess_md5 = MD5 . new ( flag + chr ( guess )) . digest () # try to null out the md5 plaintext and execute a command payload = flipplain ( guess_md5 , 'get-time' . ljust ( 16 , ' \\x01 ' ), iv_encrypt ) payload += md5_indexi p . sendline ( base64 . b64encode ( payload )) res = p . recvuntil ( \" \\n \" , drop = True ) # if we receive the block for 'command not found', the hash was wrong if res == cipher_notfound : print 'Guess {} is wrong.' . format ( guess ) # otherwise we correctly guessed the hash and the command was executed else : print 'Found!' flag += chr ( guess ) print 'Flag so far:' , flag break if __name__ == \"__main__\" : main () \u6700\u540e\u7ed3\u679c\u5982\u4e0b Flag so far: Paddin9_15_ve3y_h4rd__!! } \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 2017 HITCON Secret Server Revenge \u00b6 \u63cf\u8ff0 \u00b6 The password of zip is the flag of \"Secret Server\" \u5206\u6790 \u00b6 \u8fd9\u4e2a\u7a0b\u5e8f\u65f6\u63a5\u7740\u4e0a\u9762\u7684\u7a0b\u5e8f\u7ee7\u7eed\u641e\u7684\uff0c\u4e0d\u8fc7\u8fd9\u6b21\u8fdb\u884c\u7684\u7b80\u5355\u7684\u4fee\u6539 \u52a0\u5bc6\u7b97\u6cd5\u7684 iv \u672a\u77e5\uff0c\u4e0d\u8fc7\u53ef\u4ee5\u6839\u636e Welcome \u52a0\u5bc6\u540e\u7684\u6d88\u606f\u63a8\u7b97\u51fa\u6765\u3002 \u7a0b\u5e8f\u591a\u4e86\u4e00\u4e2a 56 \u5b57\u8282\u7684 token\u3002 \u7a0b\u5e8f\u6700\u591a\u80fd\u8fdb\u884c 340 \u64cd\u4f5c\uff0c\u56e0\u6b64\u4e0a\u8ff0\u7684\u7206\u7834\u81ea\u7136\u4e0d\u53ef\u884c \u7a0b\u5e8f\u7684\u5927\u6982\u6d41\u7a0b\u5982\u4e0b \u7ecf\u8fc7 proof of work \u53d1\u9001 \u201cWelcome!!\u201d \u52a0\u5bc6\u540e\u7684\u6d88\u606f \u5728 340 \u6b21\u64cd\u4f5c\u4e2d\uff0c\u9700\u8981\u731c\u4e2d token \u7684\u503c\uff0c\u7136\u540e\u4f1a\u81ea\u52a8\u5c06 flag \u8f93\u51fa\u3002 \u6f0f\u6d1e \u00b6 \u5f53\u7136\uff0c\u5728\u4e0a\u4e2a\u9898\u76ee\u4e2d\u5b58\u5728\u7684\u6f0f\u6d1e\uff0c\u5728\u8fd9\u4e2a\u9898\u76ee\u4e2d\u4ecd\u7136\u5b58\u5728\uff0c\u5373 \u4efb\u610f\u6267\u884c\u7ed9\u5b9a\u547d\u4ee4 \u957f\u5ea6\u622a\u65ad \u5229\u7528\u601d\u8def \u00b6 \u7531\u4e8e 340 \u7684\u6b21\u6570\u9650\u5236\uff0c\u867d\u7136\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5\u83b7\u5f97 md5(token[:i]) \u52a0\u5bc6\u540e\u7684\u503c\uff08 \u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u662f\u8fd9\u90e8\u5206\u52a0\u5bc6\u540e\u6070\u597d\u662f 32 \u4e2a\u5b57\u8282\uff0c\u524d 16 \u4e2a\u5b57\u8282\u662f md5 \u540e\u52a0\u5bc6\u7684\u503c\uff0c\u540e\u9762\u7684 16 \u4e2a\u5b57\u8282\u5b8c\u5168\u662f\u586b\u5145\u7684\u52a0\u5bc6\u540e\u7684\u5b57\u8282\u3002 \u8fd9\u91cc md5(token[:i]) \u7279\u6307\u524d16\u4e2a\u5b57\u8282\u3002\uff09\u3002\u4f46\u662f\uff0c\u6211\u4eec\u4e0d\u80fd\u518d\u6b21\u4e3a\u4e86\u83b7\u5f97\u4e00\u4e2a\u5b57\u7b26\u53bb\u7206\u7834 256 \u6b21\u4e86\u3002 \u65e2\u7136\u4e0d\u80fd\u591f\u7206\u7834\uff0c\u90a3\u4e48\u6211\u4eec\u6709\u6ca1\u6709\u53ef\u80fd\u4e00\u6b21\u83b7\u53d6\u4e00\u4e2a\u5b57\u8282\u7684\u5927\u5c0f\u5462\uff1f\u8fd9\u91cc\uff0c\u6211\u4eec\u518d\u6765\u68b3\u7406\u4e00\u4e0b\u8be5\u7a0b\u5e8f\u53ef\u80fd\u53ef\u4ee5\u6cc4\u6f0f\u7684\u4fe1\u606f \u67d0\u4e9b\u6d88\u606f\u7684 md5 \u503c\u52a0\u5bc6\u540e\u7684\u503c\uff0c\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6 md5(token[:i]) \u52a0\u5bc6\u540e\u7684\u503c\u3002 unpad \u6bcf\u6b21\u4f1a\u5bf9\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u8fdb\u884c unpad\uff0c\u8fd9\u4e2a\u5b57\u8282\u662f\u6839\u636e\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u6765\u51b3\u5b9a\u7684\u3002\u5982\u679c\u6211\u4eec\u53ef\u4ee5\u8ba1\u7b97\u51fa\u8fd9\u4e2a\u5b57\u8282\u7684\u5927\u5c0f\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u80fd\u53ef\u4ee5\u77e5\u9053\u4e00\u4e2a\u5b57\u8282\u7684\u503c\u3002 \u8fd9\u91cc\u6211\u4eec\u6df1\u5165\u5206\u6790\u4e00\u4e0b unpad \u7684\u4fe1\u606f\u6cc4\u6f0f\u3002\u5982\u679c\u6211\u4eec\u5c06\u52a0\u5bc6 IV \u548c encrypt(md5(token[:i])) \u653e\u5728\u67d0\u4e2a\u5bc6\u6587 C \u7684\u540e\u9762\uff0c\u6784\u6210 C|IV|encrypt(md5(token[:i])) \uff0c\u90a3\u4e48\u89e3\u5bc6\u51fa\u6765\u7684\u6d88\u606f\u7684\u6700\u540e\u4e00\u4e2a\u660e\u6587\u5757\u5c31\u662f md5(token[:i]) \u3002\u8fdb\u800c\uff0c\u5728 unpad \u7684\u65f6\u5019\u5c31\u662f\u5229\u7528 md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff08 0-255\uff09\u8fdb\u884c unpad\uff0c\u4e4b\u540e\u5bf9 unpad \u540e\u7684\u5b57\u7b26\u4e32\u6267\u884c\u6307\u5b9a\u7684\u547d\u4ee4\uff08\u6bd4\u5982md5\uff09\u3002\u90a3\u4e48\uff0c\u5982\u679c\u6211\u4eec \u4e8b\u5148\u6784\u9020\u4e00\u4e9b\u6d88\u606f\u54c8\u5e0c\u540e\u52a0\u5bc6\u7684\u6837\u672c \uff0c\u7136\u540e\u5c06\u4e0a\u8ff0\u6267\u884c\u540e\u7684\u7ed3\u679c\u4e0e\u6837\u672c\u6bd4\u8f83\uff0c\u5982\u679c\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u57fa\u672c\u53ef\u4ee5\u786e\u5b9a md5(token[:i]) \u7684 \u6700\u540e\u4e00\u4e2a\u5b57\u8282 \u3002\u7136\u800c\uff0c\u5982\u679c md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u5c0f\u4e8e16\uff0c\u90a3\u4e48\u5728 unpad \u65f6\u5c31\u4f1a\u5229\u7528\u4e00\u4e9b md5 \u4e2d\u7684\u503c\uff0c\u800c\u8fd9\u90e8\u5206\u503c\uff0c\u7531\u4e8e\u5bf9\u4e8e\u4e0d\u540c\u957f\u5ea6\u7684 token[:i] \u51e0\u4e4e\u90fd\u4e0d\u4f1a\u76f8\u540c\u3002\u6240\u4ee5\u53ef\u80fd\u9700\u8981\u7279\u6b8a\u5904\u7406\u3002 \u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u8fd9\u4e2a\u95ee\u9898\u7684\u5173\u952e\uff0c\u5373\u751f\u6210\u4e0e unpad \u5b57\u8282\u5927\u5c0f\u5bf9\u5e94\u7684\u52a0\u5bc6\u7ed3\u679c\u6837\u672c\uff0c\u4ee5\u4fbf\u4e8e\u67e5\u8868\u3002 \u5177\u4f53\u5229\u7528\u601d\u8def\u5982\u4e0b \u7ed5\u8fc7 proof of work\u3002 \u83b7\u53d6 token \u52a0\u5bc6\u540e\u7684\u7ed3\u679c token_enc \uff0c\u8fd9\u91cc\u4f1a\u5728 token \u524d\u9762\u6dfb\u52a0 7 \u4e2a\u5b57\u8282 \"token: \" \u3002 \u56e0\u6b64\u52a0\u5bc6\u540e\u7684\u957f\u5ea6\u4e3a 64\u3002 \u4f9d\u6b21\u83b7\u53d6 encrypt(md5(token[:i])) \u7684\u7ed3\u679c\uff0c\u4e00\u5171\u662f 57 \u4e2a\uff0c\u5305\u62ec\u6700\u540e\u4e00\u4e2a token \u7684 padding\u3002 \u6784\u9020\u4e0e unpad \u5927\u5c0f\u5bf9\u5e94\u7684\u6837\u672c\u3002\u8fd9\u91cc\u6211\u4eec\u6784\u9020\u5bc6\u6587 token_enc|padding|IV_indexi|welcome_enc \u3002\u7531\u4e8e IV_indexi \u662f\u4e3a\u4e86\u4fee\u6539\u6700\u540e\u4e00\u4e2a\u660e\u6587\u5757\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u6240\u4ee5\u8be5\u5b57\u8282\u5904\u4e8e\u53d8\u5316\u4e4b\u4e2d\u3002\u6211\u4eec\u82e5\u60f3\u83b7\u53d6\u4e00\u4e9b\u56fa\u5b9a\u5b57\u8282\u7684\u54c8\u5e0c\u503c\uff0c\u8fd9\u90e8\u5206\u81ea\u7136\u4e0d\u80fd\u6dfb\u52a0\u3002\u56e0\u6b64\u8fd9\u91cc\u4ea7\u751f\u6837\u672c\u65f6 unpad \u7684\u5927\u5c0f\u8303\u56f4\u4e3a 17 ~ 255\u3002\u5982\u679c\u6700\u540e\u6d4b\u8bd5\u65f6 md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u5c0f\u4e8e17\u7684\u8bdd\uff0c\u57fa\u672c\u5c31\u4f1a\u51fa\u73b0\u4e00\u4e9b\u672a\u77e5\u7684\u6837\u672c\u3002\u5f88\u81ea\u7136\u7684\u4e00\u4e2a\u60f3\u6cd5\u662f\u6211\u4eec\u76f4\u63a5\u83b7\u53d6 255-17+1\u4e2a\u8fd9\u4e48\u591a\u4e2a\u6837\u672c\uff0c\u7136\u800c\uff0c\u5982\u679c\u8fd9\u6837\u505a\u7684\u8bdd\uff0c\u6839\u636e\u4e0a\u9762 340 \u7684\u6b21\u6570\uff08255-17+1+57+56>340\uff09\u9650\u5236\uff0c\u6211\u4eec\u663e\u7136\u4e0d\u80fd\u83b7\u53d6\u5230 token \u7684\u6240\u6709\u5b57\u8282\u3002\u6240\u4ee5\u8fd9\u91cc\u6211\u4eec\u9700\u8981\u60f3\u529e\u6cd5\u590d\u7528\u4e00\u4e9b\u5185\u5bb9\uff0c\u8fd9\u91cc\u6211\u4eec\u9009\u62e9\u590d\u7528 encrypt(md5(token[:i])) \u7684\u7ed3\u679c\u3002\u90a3\u4e48\u6211\u4eec\u5728\u8865\u5145 padding \u65f6\u9700\u8981\u786e\u4fdd\u4e00\u65b9\u9762\u6b21\u6570\u591f\u7528\uff0c\u53e6\u4e00\u65b9\u9762\u53ef\u4ee5\u590d\u7528\u4e4b\u524d\u7684\u7ed3\u679c\u3002\u8fd9\u91cc\u6211\u4eec\u8bbe\u7f6e unpad \u7684\u5faa\u73af\u4e3a 17 \u5230 208\uff0c\u5e76\u4f7f\u5f97 unpad \u5927\u4e8e 208 \u65f6\u6070\u597d unpad \u5230\u6211\u4eec\u53ef\u4ee5\u590d\u7528\u7684\u5730\u65b9\u3002\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5f53 md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u4e3a 0 \u65f6\uff0c\u4f1a\u5c06\u6240\u6709\u89e3\u5bc6\u540e\u7684\u660e\u6587 unpad \u6389\uff0c\u56e0\u6b64\u4f1a\u51fa\u73b0 command not found \u7684\u5bc6\u6587\u3002 \u518d\u6b21\u6784\u9020\u5bc6\u6587 token_enc|padding|IV|encrypt(md5(token[:i])) \uff0c\u90a3\u4e48\uff0c\u89e3\u5bc6\u65f6\u5373\u4f7f\u7528 md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u8fdb\u884c unpad\u3002\u5982\u679c\u8fd9\u4e2a\u5b57\u8282\u4e0d\u5c0f\u4e8e17\u6216\u8005\u4e3a0\uff0c\u5219\u53ef\u4ee5\u5904\u7406\u3002\u5982\u679c\u8fd9\u4e2a\u5b57\u8282\u5c0f\u4e8e17\uff0c\u90a3\u4e48\u663e\u7136\uff0c\u6700\u540e\u8fd4\u56de\u7ed9\u7528\u6237\u7684 md5 \u7684\u7ed3\u679c\u5e76\u4e0d\u5728\u6837\u672c\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6211\u4eec\u4fee\u6539\u5176\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u7684\u6700\u9ad8\u6bd4\u7279\u4f4d\uff0c\u4f7f\u5176 unpad \u540e\u53ef\u4ee5\u843d\u5728\u6837\u672c\u8303\u56f4\u5185\u3002\u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u731c\u51fa md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002 \u5728\u731c\u51fa md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u672c\u5730\u66b4\u529b\u7834\u89e3 256 \u6b21\uff0c\u627e\u51fa\u6240\u6709\u54c8\u5e0c\u503c\u672b\u5c3e\u4e3a md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u7684\u5b57\u7b26\u3002 \u4f46\u662f\uff0c\u5728\u7b2c\u516d\u6b65\u4e2d\uff0c\u5bf9\u4e8e\u4e00\u4e2a md5(token[:i]) \u53ef\u80fd\u4f1a\u627e\u51fa\u591a\u4e2a\u5907\u9009\u5b57\u7b26\uff0c\u56e0\u4e3a\u6211\u4eec\u53ea\u9700\u8981\u4f7f\u5f97\u5176\u672b\u5c3e\u5b57\u8282\u662f\u7ed9\u5b9a\u5b57\u8282\u5373\u53ef\u3002 \u90a3\u4e48\uff0c\u95ee\u9898\u6765\u4e86\uff0c\u5982\u4f55\u5220\u9664\u4e00\u4e9b\u591a\u4f59\u7684\u5907\u9009\u5b57\u7b26\u4e32\u5462\uff1f\u8fd9\u91cc\u6211\u5c31\u9009\u62e9\u4e86\u4e00\u4e2a\u5c0f trick\uff0c\u5373\u5728\u9010\u5b57\u8282\u679a\u4e3e\u65f6\uff0c\u540c\u65f6\u679a\u4e3e\u51fa token \u7684 padding\u3002\u7531\u4e8e padding \u662f 0x01 \u662f\u56fa\u5b9a\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u8fc7\u6ee4\u51fa\u6240\u6709\u7ed3\u5c3e\u4e0d\u662f 0x01 \u7684token \u5373\u53ef\u3002 \u8fd9\u91cc\uff0c\u5728\u6d4b\u8bd5\u65f6\uff0c\u5c06\u4ee3\u7801\u4e2d sleep \u6ce8\u91ca\u6389\u4e86\u3002\u4ee5\u4fbf\u4e8e\u52a0\u5feb\u4ea4\u4e92\u901f\u5ea6\u3002\u5229\u7528\u4ee3\u7801\u5982\u4e0b from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] # remove pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) def sendmsg ( iv , cipher ): payload = iv + cipher payload = base64 . b64encode ( payload ) p . sendline ( payload ) def recvmsg (): data = p . recvuntil ( \" \\n \" , drop = True ) data = base64 . b64decode ( data ) return data [: 16 ], data [ 16 :] def getmd5enc ( i , cipher_token , cipher_welcome , iv ): \"\"\"return encrypt( md5( token[:i+1] ) )\"\"\" ## keep iv[7:] do not change, so decrypt msg[7:] won't change get_md5_iv = flipplain ( \"token: \" . ljust ( 16 , ' \\x00 ' ), \"get-md5\" . ljust ( 16 , ' \\x00 ' ), iv ) payload = cipher_token ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_token ) + 16 + 16 - ( 7 + i + 1 )), iv ) payload += last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , payload ) return recvmsg () def get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ): md5_token_idxi = [] for i in range ( len ( cipher_token ) - 7 ): log . info ( \"idx i: {} \" . format ( i )) _ , md5_indexi = getmd5enc ( i , cipher_token , cipher_welcome , iv_encrypt ) assert ( len ( md5_indexi ) == 32 ) # remove the last 16 byte for padding md5_token_idxi . append ( md5_indexi [: 16 ]) return md5_token_idxi def doin ( unpadcipher , md5map , candidates , flag ): if unpadcipher in md5map : lastbyte = md5map [ unpadcipher ] else : lastbyte = 0 if flag == 0 : lastbyte ^= 0x80 newcandidates = [] for x in candidates : for c in range ( 256 ): if MD5 . new ( x + chr ( c )) . digest ()[ - 1 ] == chr ( lastbyte ): newcandidates . append ( x + chr ( c )) candidates = newcandidates print candidates return candidates def main (): bypassproof () # result of encrypted Welcome!! iv_encrypt , cipher_welcome = recvmsg () log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-token get_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-token\" ), iv_encrypt ) sendmsg ( get_token_iv , cipher_welcome ) _ , cipher_token = recvmsg () token_len = len ( cipher_token ) log . info ( \"cipher token is : \" + cipher_token ) # get command not found cipher sendmsg ( iv_encrypt , cipher_welcome ) _ , cipher_notfound = recvmsg () # get encrypted(token[:i+1]),57 times md5_token_idx_list = get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ) # get md5map for each unpadsize, 209-17 times # when upadsize>208, it will unpad ciphertoken # then we can reuse md5map = dict () for unpadsize in range ( 17 , 209 ): log . info ( \"get unpad size {} cipher\" . format ( unpadsize )) get_md5_iv = flipplain ( \"token: \" . ljust ( 16 , ' \\x00 ' ), \"get-md5\" . ljust ( 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" ## calculate the proper last byte number, only change the last byte ## set last_byte_iv = iv_encrypted[:15] | proper byte last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"Welcome!!\" )[: 15 ] + chr ( unpadsize ), iv_encrypt ) cipher = cipher_token + padding + last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () md5map [ unpadcipher ] = unpadsize # reuse encrypted(token[:i+1]) for i in range ( 209 , 256 ): target = md5_token_idx_list [ 56 - ( i - 209 )] md5map [ target ] = i candidates = [ \"\" ] # get the byte token[i], only 56 byte for i in range ( token_len - 7 ): log . info ( \"get token[ {} ]\" . format ( i )) get_md5_iv = flipplain ( \"token: \" . ljust ( 16 , ' \\x00 ' ), \"get-md5\" . ljust ( 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list [ i ] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () # already in or md5[token[:i]][-1]='\\x00' if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 1 ) else : log . info ( \"unpad size 1-16\" ) # flip most significant bit of last byte to move it in a good range cipher = cipher [: - 17 ] + strxor ( cipher [ - 17 ], ' \\x80 ' ) + cipher [ - 16 :] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 0 ) else : log . info ( 'oh my god,,,, it must be in...' ) exit () print len ( candidates ) # padding 0x01 candidates = filter ( lambda x : x [ - 1 ] == chr ( 0x01 ), candidates ) # only 56 bytes candidates = [ x [: - 1 ] for x in candidates ] print len ( candidates ) assert ( len ( candidates [ 0 ]) == 56 ) # check-token check_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"check-token\" ), iv_encrypt ) sendmsg ( check_token_iv , cipher_welcome ) p . recvuntil ( \"Give me the token! \\n \" ) p . sendline ( base64 . b64encode ( candidates [ 0 ])) print p . recv () p . interactive () if __name__ == \"__main__\" : main () \u6548\u679c\u5982\u4e0b ... 79 1 hitcon { uNp@d_M3th0D_i5_am4Z1n9! } Teaser Dragon CTF 2018 AES-128-TSB \u00b6 \u8fd9\u4e2a\u9898\u76ee\u8fd8\u662f\u86ee\u6709\u610f\u601d\u7684\uff0c\u9898\u76ee\u63cf\u8ff0\u5982\u4e0b Haven't you ever thought that GCM mode is overcomplicated and there must be a simpler way to achieve Authenticated Encryption? Here it is! Server: aes-128-tsb.hackable.software 1337 server.py \u9644\u4ef6\u4ee5\u53ca\u6700\u540e\u7684 exp \u81ea\u884c\u5230 ctf-challenge \u4ed3\u5e93\u4e0b\u5bfb\u627e\u3002 \u9898\u76ee\u7684\u57fa\u672c\u6d41\u7a0b\u4e3a \u4e0d\u65ad\u63a5\u6536 a \u548c b \u4e24\u4e2a\u5b57\u7b26\u4e32\uff0c\u5176\u4e2d a \u4e3a\u660e\u6587\uff0cb \u4e3a\u5bc6\u6587\uff0c\u6ce8\u610f b \u5728\u89e3\u5bc6\u540e\u9700\u8981\u6ee1\u8db3\u5c3e\u90e8\u6070\u597d\u7b49\u4e8e iv\u3002 \u5982\u679c a \u548c b \u76f8\u7b49\uff0c\u90a3\u4e48\u6839\u636e a \u4e3a gimme_flag \uff0c\u8f93\u51fa\u52a0\u5bc6\u540e\u7684 flag\u3002 \u5426\u5219\uff0c\u8f93\u51fa\u4e00\u4e32\u968f\u673a\u52a0\u5bc6\u7684\u5b57\u7b26\u4e32\u3002 \u5426\u5219\u8f93\u51fa\u4e00\u4e32\u660e\u6587\u7684\u5b57\u7b26\u4e32\u3002 \u6b64\u5916\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u53d1\u73b0\u9898\u76ee\u4e2d\u7684 unpad \u5b58\u5728\u95ee\u9898\uff0c\u53ef\u4ee5\u622a\u65ad\u6307\u5b9a\u957f\u5ea6\u3002 def unpad ( msg ): if not msg : return '' return msg [: - ord ( msg [ - 1 ])] \u4e00\u5f00\u59cb\uff0c\u5f88\u76f4\u63a5\u7684\u601d\u8def\u662f a \u548c b \u7684\u957f\u5ea6\u90fd\u8f93\u5165 0 \uff0c\u90a3\u4e48\u53ef\u4ee5\u76f4\u63a5\u7ed5\u8fc7 a==b \u68c0\u67e5\uff0c\u83b7\u53d6\u4e00\u4e32\u968f\u673a\u5bc6\u6587\u52a0\u5bc6\u7684\u5b57\u7b26\u4e32\u3002\u7136\u800c\u4f3c\u4e4e\u5e76\u6ca1\u6709\u4ec0\u4e48\u4f5c\u7528\uff0c\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u52a0\u5bc6\u7684\u6d41\u7a0b def tsb_encrypt ( aes , msg ): msg = pad ( msg ) iv = get_random_bytes ( 16 ) prev_pt = iv prev_ct = iv ct = '' for block in split_by ( msg , 16 ) + [ iv ]: ct_block = xor ( block , prev_pt ) ct_block = aes . encrypt ( ct_block ) ct_block = xor ( ct_block , prev_ct ) ct += ct_block prev_pt = block prev_ct = ct_block return iv + ct \u4e0d\u59a8\u5047\u8bbe P_0=iv,C_0=iv P_0=iv,C_0=iv \uff0c\u5219 C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) \u90a3\u4e48\uff0c\u5047\u8bbe\u6d88\u606f\u957f\u5ea6\u4e3a 16\uff0c\u4e0e\u6211\u4eec\u60f3\u8981\u5f97\u5230\u7684 gimme_flag padding \u540e\u957f\u5ea6\u7c7b\u4f3c\uff0c\u5219 C_1=IV\\oplus E( IV \\oplus P_1) C_1=IV\\oplus E( IV \\oplus P_1) C_2=C_1 \\oplus E(P_1 \\oplus IV) C_2=C_1 \\oplus E(P_1 \\oplus IV) \u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u53d1\u73b0 C_2=IV C_2=IV \u3002 \uff08 \u76d7\u56fe \uff0c\u4e0b\u9762\u7684\u56fe\u7247\u66f4\u52a0\u6e05\u6670 \u53cd\u8fc7\u6765\u60f3\uff0c\u5982\u679c\u6211\u4eec\u5411\u670d\u52a1\u5668\u53d1\u9001 iv+c+iv \uff0c\u90a3\u4e48\u603b\u80fd\u7ed5\u8fc7 tsb_decrypt \u7684 mac \u68c0\u67e5 def tsb_decrypt ( aes , msg ): iv , msg = msg [: 16 ], msg [ 16 :] prev_pt = iv prev_ct = iv pt = '' for block in split_by ( msg , 16 ): pt_block = xor ( block , prev_ct ) pt_block = aes . decrypt ( pt_block ) pt_block = xor ( pt_block , prev_pt ) pt += pt_block prev_pt = pt_block prev_ct = block pt , mac = pt [: - 16 ], pt [ - 16 :] if mac != iv : raise CryptoError () return unpad ( pt ) \u90a3\u4e48\u6b64\u65f6\uff0c\u670d\u52a1\u5668\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u5219\u662f unpad(IV \\oplus D(C_1 \\oplus IV)) unpad(IV \\oplus D(C_1 \\oplus IV)) \u83b7\u53d6\u660e\u6587\u6700\u540e\u4e00\u4e2a\u5b57\u8282 \u00b6 \u6211\u4eec\u53ef\u4ee5\u8003\u8651\u63a7\u5236 D \u89e3\u5bc6\u7684\u6d88\u606f\u4e3a\u5e38\u6570\u503c\uff0c\u6bd4\u5982\u5168\u96f6\uff0c\u5373 C1=IV \uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u4ece 0 \u5230 255 \u679a\u4e3e IV \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u5f97\u5230 IV \\oplus D(C_1 \\oplus IV) IV \\oplus D(C_1 \\oplus IV) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u4e5f\u662f 0~255\u3002\u800c\u53ea\u6709\u662f 1~15 \u7684\u65f6\u5019\uff0c unpad \u64cd\u4f5c\u8fc7\u540e\uff0c\u6d88\u606f\u957f\u5ea6\u4e0d\u4e3a 0\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u679a\u4e3e\u65f6\u7edf\u8ba1\u7a76\u7adf\u54ea\u4e9b\u6570\u5b57\u5bfc\u81f4\u4e86\u957f\u5ea6\u4e0d\u4e3a\u96f6\uff0c\u5e76\u6807\u8bb0\u4e3a 1\uff0c\u5176\u4f59\u6807\u8bb0\u4e3a 0\u3002 def getlast_byte ( iv , block ): iv_pre = iv [: 15 ] iv_last = ord ( iv [ - 1 ]) tmp = [] print ( 'get last byte' ) for i in range ( 256 ): send_data ( '' ) iv = iv_pre + chr ( i ) tmpblock = block [: 15 ] + chr ( i ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' in data : tmp . append ( 1 ) else : tmp . append ( 0 ) last_bytes = [] for i in range ( 256 ): if tmp == xor_byte_map [ i ][ 0 ]: last_bytes . append ( xor_byte_map [ i ][ 1 ]) print ( 'possible last byte is ' + str ( last_bytes )) return last_bytes \u6b64\u5916\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u6700\u521d\u7684\u65f6\u5019\u6253\u8868\u83b7\u53d6\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u6240\u6709\u7684\u53ef\u80fd\u60c5\u51b5\uff0c\u8bb0\u5f55\u5728 xor_byte_map \u4e2d\u3002 \"\"\" every item is a pair [a,b] a is the xor list b is the idx which is zero when xored \"\"\" xor_byte_map = [] for i in range ( 256 ): a = [] b = 0 for j in range ( 256 ): tmp = i ^ j if tmp > 0 and tmp <= 15 : a . append ( 1 ) else : a . append ( 0 ) if tmp == 0 : b = j xor_byte_map . append ([ a , b ]) \u901a\u8fc7\u4e0e\u8fd9\u4e2a\u8868\u8fdb\u884c\u5bf9\u6bd4\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u77e5\u9053\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u53ef\u80fd\u7684\u60c5\u51b5\u3002 \u89e3\u5bc6\u4efb\u610f\u52a0\u5bc6\u5757 \u00b6 \u5728\u83b7\u53d6\u4e86\u660e\u6587\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u540e\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5229\u7528 unpad \u7684\u6f0f\u6d1e\uff0c\u4ece\u957f\u5ea6 1 \u679a\u4e3e\u5230\u957f\u5ea6 15 \u6765\u83b7\u5f97\u5bf9\u5e94\u7684\u660e\u6587\u5185\u5bb9\u3002 def dec_block ( iv , block ): last_bytes = getlast_byte ( iv , block ) iv_pre = iv [: 15 ] iv_last = ord ( iv [ - 1 ]) print ( 'try to get plain' ) plain0 = '' for last_byte in last_bytes : plain0 = '' for i in range ( 15 ): print 'idx:' , i tag = False for j in range ( 256 ): send_data ( plain0 + chr ( j )) pad_size = 15 - i iv = iv_pre + chr ( pad_size ^ last_byte ) tmpblock = block [: 15 ] + chr ( pad_size ^ last_byte ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' not in data : # success plain0 += chr ( j ) tag = True break if not tag : break # means the last byte is ok if plain0 != '' : break plain0 += chr ( iv_last ^ last_byte ) return plain0 \u89e3\u5bc6\u51fa\u6307\u5b9a\u660e\u6587 \u00b6 \u8fd9\u4e00\u70b9\u6bd4\u8f83\u7b80\u5355\uff0c\u6211\u4eec\u5e0c\u671b\u5229\u7528\u8fd9\u4e00\u70b9\u6765\u83b7\u53d6 gimme_flag \u7684\u5bc6\u6587 print ( 'get the cipher of flag' ) gemmi_iv1 = xor ( pad ( 'gimme_flag' ), plain0 ) gemmi_c1 = xor ( gemmi_iv1 , cipher0 ) payload = gemmi_iv1 + gemmi_c1 + gemmi_iv1 send_data ( 'gimme_flag' ) send_data ( payload ) flag_len , flag_cipher = recv_data () \u5176\u4e2d plain0 \u548c cipher0 \u662f\u6211\u4eec\u83b7\u53d6\u7684 AES \u52a0\u5bc6\u7684\u660e\u5bc6\u6587\u5bf9\uff0c\u4e0d\u5305\u62ec\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u4e24\u4e2a\u5f02\u6216\u3002 \u89e3\u5bc6 flag \u00b6 \u8fd9\u4e00\u70b9\uff0c\u5176\u5b9e\u5c31\u662f\u5229\u7528\u89e3\u5bc6\u4efb\u610f\u52a0\u5bc6\u5757\u7684\u529f\u80fd\u5b9e\u73b0\u7684\uff0c\u5982\u4e0b print ( 'the flag cipher is ' + flag_cipher . encode ( 'hex' )) flag_cipher = split_by ( flag_cipher , 16 ) print ( 'decrypt the blocks one by one' ) plain = '' for i in range ( len ( flag_cipher ) - 1 ): print ( 'block: ' + str ( i )) if i == 0 : plain += dec_block ( flag_cipher [ i ], flag_cipher [ i + 1 ]) else : iv = plain [ - 16 :] cipher = xor ( xor ( iv , flag_cipher [ i + 1 ]), flag_cipher [ i ]) plain += dec_block ( iv , cipher ) pass print ( 'now plain: ' + plain ) print plain \u53ef\u4ee5\u601d\u8003\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u7b2c\u4e8c\u5757\u4e4b\u540e\u7684\u5bc6\u6587\u64cd\u4f5c\u4f1a\u6709\u6240\u4e0d\u540c\u3002 \u5b8c\u6574\u7684\u4ee3\u7801\u53c2\u8003 ctf-challenge \u4ed3\u5e93\u3002 \u53c2\u8003\u8d44\u6599 \u00b6 \u5206\u7ec4\u52a0\u5bc6\u6a21\u5f0f https://en.wikipedia.org/wiki/Padding_oracle_attack http://netifera.com/research/poet/PaddingOraclesEverywhereEkoparty2010.pdf https://ctftime.org/writeup/7975 https://ctftime.org/writeup/7974","title":"Padding oracle attack zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#padding-oracle-attack","text":"","title":"Padding Oracle Attack"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_1","text":"Padding Oracle Attack \u653b\u51fb\u4e00\u822c\u9700\u8981\u6ee1\u8db3\u4ee5\u4e0b\u51e0\u4e2a\u6761\u4ef6 \u52a0\u5bc6\u7b97\u6cd5 \u91c7\u7528 PKCS5 Padding \u7684\u52a0\u5bc6\u7b97\u6cd5\u3002 \u5f53\u7136\uff0c\u975e\u5bf9\u79f0\u52a0\u5bc6\u4e2d OAEP \u7684\u586b\u5145\u65b9\u5f0f\u4e5f\u6709\u53ef\u80fd\u4f1a\u53d7\u5230\u5f71\u54cd\u3002 \u5206\u7ec4\u6a21\u5f0f\u4e3a CBC \u6a21\u5f0f\u3002 \u653b\u51fb\u8005\u80fd\u529b \u653b\u51fb\u8005\u53ef\u4ee5\u62e6\u622a\u4e0a\u8ff0\u52a0\u5bc6\u7b97\u6cd5\u52a0\u5bc6\u7684\u6d88\u606f\u3002 \u653b\u51fb\u8005\u53ef\u4ee5\u548c padding oracle\uff08\u5373\u670d\u52a1\u5668\uff09 \u8fdb\u884c\u4ea4\u4e92\uff1a\u5ba2\u6237\u7aef\u5411\u670d\u52a1\u5668\u7aef\u53d1\u9001\u5bc6\u6587\uff0c\u670d\u52a1\u5668\u7aef\u4f1a\u4ee5\u67d0\u79cd\u8fd4\u56de\u4fe1\u606f\u544a\u77e5\u5ba2\u6237\u7aef padding \u662f\u5426\u6b63\u5e38\u3002 Padding Oracle Attack \u653b\u51fb\u53ef\u4ee5\u8fbe\u5230\u7684\u6548\u679c\u5982\u4e0b \u5728\u4e0d\u6e05\u695a key \u548c IV \u7684\u524d\u63d0\u4e0b\u89e3\u5bc6\u4efb\u610f\u7ed9\u5b9a\u7684\u5bc6\u6587\u3002","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_2","text":"Padding Oracle Attack \u653b\u51fb\u7684\u57fa\u672c\u539f\u7406\u5982\u4e0b \u5bf9\u4e8e\u5f88\u957f\u7684\u6d88\u606f\u4e00\u5757\u4e00\u5757\u89e3\u5bc6\u3002 \u5bf9\u4e8e\u6bcf\u4e00\u5757\u6d88\u606f\uff0c\u5148\u89e3\u5bc6\u6d88\u606f\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u7136\u540e\u89e3\u5bc6\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b57\u8282\uff0c\u4f9d\u6b21\u7c7b\u63a8\u3002 \u8fd9\u91cc\u6211\u4eec\u56de\u987e\u4e00\u4e0b CBC \u7684 \u52a0\u5bc6 C_i=E_K(P_i \\oplus C_{i-1})\\\\ C_0=IV C_i=E_K(P_i \\oplus C_{i-1})\\\\ C_0=IV \u89e3\u5bc6 P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\\\ C_{0}=IV P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\\\ C_{0}=IV \u6211\u4eec\u4e3b\u8981\u5173\u6ce8\u4e8e\u89e3\u5bc6\uff0c\u8fd9\u91cc\u6211\u4eec\u5e76\u4e0d\u77e5\u9053 IV \u548c key\u3002\u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\u5bc6\u6587\u5757\u7684\u957f\u5ea6\u4e3a n \u4e2a\u5b57\u8282\u3002 \u5047\u8bbe\u6211\u4eec\u622a\u83b7\u4e86\u5bc6\u6587 Y\uff0c\u4ee5\u83b7\u53d6\u5bc6\u6587 Y \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u4e3a\u4f8b\u5b50\u8fdb\u884c\u5206\u6790\u3002\u4e3a\u4e86\u83b7\u53d6 Y \u7684\u5185\u5bb9\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u4f2a\u9020\u4e00\u5757\u5bc6\u6587 F \u4ee5\u4fbf\u4e8e\u53ef\u4ee5\u4fee\u6539 Y \u5bf9\u5e94\u660e\u6587\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002\u8fd9\u662f\u56e0\u4e3a\u82e5\u6211\u4eec\u6784\u9020\u5bc6\u6587 F|Y \uff0c\u90a3\u4e48\u89e3\u5bc6 Y \u65f6\u5177\u4f53\u4e3a $$ P=D_K(Y)\\oplus F $$ \u6240\u4ee5\u4fee\u6539\u5bc6\u6587 F \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282 F_{n} F_{n} \u53ef\u4ee5\u4fee\u6539 Y \u5bf9\u5e94\u7684\u660e\u6587\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002\u4e0b\u9762\u7ed9\u51fa\u83b7\u53d6 P \u6700\u540e\u4e00\u4e2a\u5b57\u8282\u7684\u8fc7\u7a0b i=0\uff0c\u8bbe\u7f6e F \u7684\u6bcf\u4e2a\u5b57\u8282\u4e3a \u968f\u673a\u5b57\u8282 \u3002 \u8bbe\u7f6e F_n=i \\oplus 0x01 F_n=i \\oplus 0x01 \u5c06 F|Y \u53d1\u9001\u7ed9\u670d\u52a1\u5668\uff0c\u5982\u679c P \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u662f i \u7684\u8bdd\uff0c\u90a3\u4e48\u6700\u540e\u7684 padding \u5c31\u662f 0x01\uff0c\u4e0d\u4f1a\u51fa\u73b0\u9519\u8bef\u3002\u5426\u5219\uff0c\u53ea\u6709 P \u7684\u6700\u540e P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 \u5b57\u8282\u90fd\u662f P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 \u624d\u4e0d\u4f1a\u62a5\u9519\u3002 \u800c\u4e14\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f padding \u7684\u5b57\u8282\u53ea\u80fd\u662f 0 \u5230 n\u3002 \u56e0\u6b64\uff0c\u82e5\u60f3\u8981\u4f7f\u5f97\u5728 F \u968f\u673a\u5730\u60c5\u51b5\u4e0b\uff0c\u5e76\u4e14\u6ee1\u8db3padding \u5b57\u8282\u5927\u5c0f\u7684\u7ea6\u675f\u60c5\u51b5\u4e0b\u8fd8\u4e0d\u62a5\u9519 \u6982\u7387\u5f88\u5c0f \u3002\u6240\u4ee5\u5728\u670d\u52a1\u5668\u7aef\u4e0d\u62a5\u9519\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u6211\u4eec\u786e\u5b9e\u83b7\u53d6\u4e86\u6b63\u786e\u7684\u5b57\u8282\u3002 \u5728\u51fa\u73b0\u9519\u8bef\u7684\u60c5\u51b5\u4e0b\uff0ci=i+1\uff0c\u8df3\u8f6c\u52302\u3002 \u5f53\u83b7\u53d6\u4e86 P \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u7ee7\u7eed\u83b7\u53d6 P \u7684\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b57\u8282\uff0c\u6b64\u65f6\u9700\u8981\u8bbe\u7f6e F_n=P_n\\oplus 0x02 F_n=P_n\\oplus 0x02 \uff0c\u540c\u65f6\u8bbe\u7f6e F_{n-1}=i \\oplus 0x02 F_{n-1}=i \\oplus 0x02 \u53bb\u679a\u4e3e i\u3002 \u6240\u4ee5\uff0c\u7efc\u4e0a\u6240\u793a\uff0cPadding Oracle Attack \u5176\u5b9e\u5728\u4e00\u5b9a\u7a0b\u5ea6\u4e0a\u662f\u4e00\u79cd\u5177\u6709\u5f88\u5927\u6982\u7387\u6210\u529f\u7684\u653b\u51fb\u65b9\u6cd5\u3002 \u7136\u800c\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5f80\u5f80\u9047\u5230\u7684\u4e00\u4e9b\u73b0\u5b9e\u95ee\u9898\u5e76\u4e0d\u662f\u6807\u51c6\u7684 Padding Oracle Attack \u6a21\u5f0f\uff0c\u6211\u4eec\u5f80\u5f80\u9700\u8981\u8fdb\u884c\u4e00\u4e9b\u53d8\u5f62\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#2017-hitcon-secret-server","text":"","title":"2017 HITCON Secret Server"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_3","text":"\u7a0b\u5e8f\u4e2d\u91c7\u7528\u7684\u52a0\u5bc6\u662f AES CBC\uff0c\u5176\u4e2d\u91c7\u7528\u7684 padding \u4e0e PKCS5 \u7c7b\u4f3c def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] \u4f46\u662f\uff0c\u5728\u6bcf\u6b21 unpad \u65f6\u5e76\u6ca1\u6709\u8fdb\u884c\u68c0\u6d4b\uff0c\u800c\u662f\u76f4\u63a5\u8fdb\u884c unpad\u3002 \u5176\u4e2d\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6bcf\u6b21\u548c\u7528\u6237\u4ea4\u4e92\u7684\u51fd\u6570\u662f send_msg \uff0c\u63a5\u53d7\u7528\u6237\u7684\u660e\u6587\uff0c\u4f7f\u7528\u56fa\u5b9a\u7684 2jpmLoSsOlQrqyqE \u4f5c\u4e3a IV\uff0c\u8fdb\u884c\u52a0\u5bc6\uff0c\u5e76\u5c06\u52a0\u5bc6\u7ed3\u679c\u8f93\u51fa\u3002 recv_msg \uff0c\u63a5\u53d7\u7528\u6237\u7684 IV \u548c\u5bc6\u6587\uff0c\u5bf9\u5bc6\u6587\u8fdb\u884c\u89e3\u5bc6\uff0c\u5e76\u8fd4\u56de\u3002\u6839\u636e\u8fd4\u56de\u7684\u7ed3\u679c\u4f1a\u6709\u4e0d\u540c\u7684\u64cd\u4f5c msg = recv_msg () . strip () if msg . startswith ( 'exit-here' ): exit ( 0 ) elif msg . startswith ( 'get-flag' ): send_msg ( flag ) elif msg . startswith ( 'get-md5' ): send_msg ( MD5 . new ( msg [ 7 :]) . digest ()) elif msg . startswith ( 'get-time' ): send_msg ( str ( time . time ())) elif msg . startswith ( 'get-sha1' ): send_msg ( SHA . new ( msg [ 8 :]) . digest ()) elif msg . startswith ( 'get-sha256' ): send_msg ( SHA256 . new ( msg [ 10 :]) . digest ()) elif msg . startswith ( 'get-hmac' ): send_msg ( HMAC . new ( msg [ 8 :]) . digest ()) else : send_msg ( 'command not found' )","title":"\u5206\u6790"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_4","text":"\u8fd9\u91cc\u6211\u4eec\u518d\u7b80\u5355\u603b\u7ed3\u4e00\u4e0b\u6211\u4eec\u5df2\u6709\u7684\u90e8\u5206 \u52a0\u5bc6 \u52a0\u5bc6\u65f6\u7684 IV \u662f\u56fa\u5b9a\u7684\u800c\u4e14\u5df2\u77e5\u3002 'Welcome!!' \u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u3002 \u89e3\u5bc6 \u6211\u4eec\u53ef\u4ee5\u63a7\u5236 IV\u3002 \u9996\u5148\uff0c\u65e2\u7136\u6211\u4eec\u77e5\u9053 Welcome!! \u52a0\u5bc6\u540e\u7684\u7ed3\u679c\uff0c\u8fd8\u53ef\u4ee5\u63a7\u5236 recv_msg \u4e2d\u7684 IV\uff0c\u90a3\u4e48\u6839\u636e\u89e3\u5bc6\u8fc7\u7a0b $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ \u5982\u679c\u6211\u4eec\u5c06 Welcome!! \u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u8f93\u5165\u7ed9 recv_msg\uff0c\u90a3\u4e48\u76f4\u63a5\u89e3\u5bc6\u540e\u7684\u7ed3\u679c\u4fbf\u662f \uff08Welcome!!+'\\x07'*7) xor iv \uff0c\u5982\u679c\u6211\u4eec \u6070\u5f53\u7684\u63a7\u5236\u89e3\u5bc6\u8fc7\u7a0b\u4e2d\u4f20\u9012\u7684 iv \uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u7ed3\u679c\u3002\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u53ef\u4ee5\u6267\u884c \u4e0a\u8ff0\u6240\u8bf4\u7684\u4efb\u610f\u547d\u4ee4 \u3002\u4ece\u800c\uff0c\u6211\u4eec\u4e5f\u5c31\u53ef\u4ee5\u77e5\u9053 flag \u89e3\u5bc6\u540e\u7684\u7ed3\u679c\u3002 \u5176\u6b21\uff0c\u5728\u4e0a\u9762\u7684\u57fa\u7840\u4e4b\u4e0a\uff0c\u5982\u679c\u6211\u4eec\u5728\u4efb\u4f55\u5bc6\u6587 C \u540e\u9762\u6dfb\u52a0\u81ea\u5b9a\u4e49\u7684 IV \u548c Welcome \u52a0\u5bc6\u540e\u7684\u7ed3\u679c\uff0c\u4f5c\u4e3a\u8f93\u5165\u4f20\u9012\u7ed9 recv_msg\uff0c\u90a3\u4e48\u6211\u4eec\u4fbf\u53ef\u4ee5\u63a7\u5236\u89e3\u5bc6\u4e4b\u540e\u7684\u6d88\u606f\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c \u90a3\u4e48\u7531\u4e8e unpad \u64cd\u4f5c\uff0c\u6211\u4eec\u4fbf\u53ef\u4ee5\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u7684\u957f\u5ea6\u51cf\u5c0f 0 \u5230 255 \u3002","title":"\u4e3b\u8981\u6f0f\u6d1e"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_5","text":"\u57fa\u672c\u5229\u7528\u601d\u8def\u5982\u4e0b \u7ed5\u8fc7 proof of work \u6839\u636e\u6267\u884c\u4efb\u610f\u547d\u4ee4\u7684\u65b9\u5f0f\u83b7\u53d6\u52a0\u5bc6\u540e\u7684 flag\u3002 \u7531\u4e8e flag \u7684\u5f00\u5934\u662f hitcon{ \uff0c\u4e00\u5171\u67097\u4e2a\u5b57\u8282\uff0c\u6240\u4ee5\u6211\u4eec\u4efb\u7136\u53ef\u4ee5\u901a\u8fc7\u63a7\u5236 iv \u6765\u4f7f\u5f97\u89e3\u5bc6\u540e\u7684\u524d 7 \u4e2a\u5b57\u8282\u4e3a\u6307\u5b9a\u5b57\u8282\u3002\u8fd9\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u6267\u884c get-md5 \u547d\u4ee4\u3002\u800c\u6839\u636e unpad \u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u6070\u597d\u5728\u6d88\u606f\u7684\u7b2c\u51e0\u4e2a\u5b57\u8282\u5904\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u65f6\u5c06\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u4e3a hitcon{x \uff0c\u5373\u53ea\u4fdd\u7559 hitcon{ \u540e\u7684\u4e00\u4e2a\u5b57\u8282\u3002\u8fd9\u6837\u4fbf\u53ef\u4ee5\u83b7\u5f97\u5e26\u4e00\u4e2a\u5b57\u8282\u54c8\u5e0c\u540e\u7684\u52a0\u5bc6\u7ed3\u679c\u3002\u7c7b\u4f3c\u5730\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u83b7\u5f97\u5e26\u5236\u5b9a\u4e2a\u5b57\u8282\u54c8\u5e0c\u540e\u7684\u52a0\u5bc6\u7ed3\u679c\u3002 \u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u672c\u5730\u9010\u5b57\u8282\u7206\u7834\uff0c\u8ba1\u7b97\u5bf9\u5e94 md5 \uff0c\u7136\u540e\u518d\u6b21\u5229\u7528\u4efb\u610f\u547d\u4ee4\u6267\u884c\u7684\u65b9\u5f0f\uff0c\u63a7\u5236\u89e3\u5bc6\u540e\u7684\u660e\u6587\u4e3a\u4efb\u610f\u6307\u5b9a\u547d\u4ee4\uff0c\u5982\u679c\u63a7\u5236\u4e0d\u6210\u529f\uff0c\u90a3\u8bf4\u660e\u8be5\u5b57\u8282\u4e0d\u5bf9\uff0c\u9700\u8981\u518d\u6b21\u7206\u7834\uff1b\u5982\u679c\u6b63\u786e\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u76f4\u63a5\u6267\u884c\u5bf9\u5e94\u7684\u547d\u4ee4\u3002 \u5177\u4f53\u4ee3\u7801\u5982\u4e0b #coding=utf-8 from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' if args [ 'REMOTE' ]: p = remote ( '52.193.157.19' , 9999 ) else : p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] # \u53bb\u6389pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) p . recvuntil ( 'Done! \\n ' ) iv_encrypt = '2jpmLoSsOlQrqyqE' def getmd5enc ( i , cipher_flag , cipher_welcome ): \"\"\"return encrypt( md5( flag[7:7+i] ) )\"\"\" ## keep iv[7:] do not change, so decrypt won't change new_iv = flipplain ( \"hitcon{\" . ljust ( 16 , ' \\x00 ' ), \"get-md5\" . ljust ( 16 , ' \\x00 ' ), iv_encrypt ) payload = new_iv + cipher_flag ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_flag ) + 16 + 16 - ( 7 + i + 1 )), iv_encrypt ) payload += last_byte_iv + cipher_welcome p . sendline ( base64 . b64encode ( payload )) return p . recvuntil ( \" \\n \" , drop = True ) def main (): bypassproof () # result of encrypted Welcome!! cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_welcome = base64 . b64decode ( cipher )[ 16 :] log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-flag get_flag_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-flag\" ), iv_encrypt ) payload = base64 . b64encode ( get_flag_iv + cipher_welcome ) p . sendline ( payload ) cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_flag = base64 . b64decode ( cipher )[ 16 :] flaglen = len ( cipher_flag ) log . info ( \"cipher flag is : \" + cipher_flag ) # get command not found cipher p . sendline ( base64 . b64encode ( iv_encrypt + cipher_welcome )) cipher_notfound = p . recvuntil ( ' \\n ' , drop = True ) flag = \"\" # brute force for every byte of flag for i in range ( flaglen - 7 ): md5_indexi = getmd5enc ( i , cipher_flag , cipher_welcome ) md5_indexi = base64 . b64decode ( md5_indexi )[ 16 :] log . info ( \"get encrypt(md5(flag[7:7+i])): \" + md5_indexi ) for guess in range ( 256 ): # locally compute md5 hash guess_md5 = MD5 . new ( flag + chr ( guess )) . digest () # try to null out the md5 plaintext and execute a command payload = flipplain ( guess_md5 , 'get-time' . ljust ( 16 , ' \\x01 ' ), iv_encrypt ) payload += md5_indexi p . sendline ( base64 . b64encode ( payload )) res = p . recvuntil ( \" \\n \" , drop = True ) # if we receive the block for 'command not found', the hash was wrong if res == cipher_notfound : print 'Guess {} is wrong.' . format ( guess ) # otherwise we correctly guessed the hash and the command was executed else : print 'Found!' flag += chr ( guess ) print 'Flag so far:' , flag break if __name__ == \"__main__\" : main () \u6700\u540e\u7ed3\u679c\u5982\u4e0b Flag so far: Paddin9_15_ve3y_h4rd__!! } \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10","title":"\u5229\u7528\u601d\u8def"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#2017-hitcon-secret-server-revenge","text":"","title":"2017 HITCON Secret Server Revenge"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_6","text":"The password of zip is the flag of \"Secret Server\"","title":"\u63cf\u8ff0"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_7","text":"\u8fd9\u4e2a\u7a0b\u5e8f\u65f6\u63a5\u7740\u4e0a\u9762\u7684\u7a0b\u5e8f\u7ee7\u7eed\u641e\u7684\uff0c\u4e0d\u8fc7\u8fd9\u6b21\u8fdb\u884c\u7684\u7b80\u5355\u7684\u4fee\u6539 \u52a0\u5bc6\u7b97\u6cd5\u7684 iv \u672a\u77e5\uff0c\u4e0d\u8fc7\u53ef\u4ee5\u6839\u636e Welcome \u52a0\u5bc6\u540e\u7684\u6d88\u606f\u63a8\u7b97\u51fa\u6765\u3002 \u7a0b\u5e8f\u591a\u4e86\u4e00\u4e2a 56 \u5b57\u8282\u7684 token\u3002 \u7a0b\u5e8f\u6700\u591a\u80fd\u8fdb\u884c 340 \u64cd\u4f5c\uff0c\u56e0\u6b64\u4e0a\u8ff0\u7684\u7206\u7834\u81ea\u7136\u4e0d\u53ef\u884c \u7a0b\u5e8f\u7684\u5927\u6982\u6d41\u7a0b\u5982\u4e0b \u7ecf\u8fc7 proof of work \u53d1\u9001 \u201cWelcome!!\u201d \u52a0\u5bc6\u540e\u7684\u6d88\u606f \u5728 340 \u6b21\u64cd\u4f5c\u4e2d\uff0c\u9700\u8981\u731c\u4e2d token \u7684\u503c\uff0c\u7136\u540e\u4f1a\u81ea\u52a8\u5c06 flag \u8f93\u51fa\u3002","title":"\u5206\u6790"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_8","text":"\u5f53\u7136\uff0c\u5728\u4e0a\u4e2a\u9898\u76ee\u4e2d\u5b58\u5728\u7684\u6f0f\u6d1e\uff0c\u5728\u8fd9\u4e2a\u9898\u76ee\u4e2d\u4ecd\u7136\u5b58\u5728\uff0c\u5373 \u4efb\u610f\u6267\u884c\u7ed9\u5b9a\u547d\u4ee4 \u957f\u5ea6\u622a\u65ad","title":"\u6f0f\u6d1e"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_9","text":"\u7531\u4e8e 340 \u7684\u6b21\u6570\u9650\u5236\uff0c\u867d\u7136\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5\u83b7\u5f97 md5(token[:i]) \u52a0\u5bc6\u540e\u7684\u503c\uff08 \u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u662f\u8fd9\u90e8\u5206\u52a0\u5bc6\u540e\u6070\u597d\u662f 32 \u4e2a\u5b57\u8282\uff0c\u524d 16 \u4e2a\u5b57\u8282\u662f md5 \u540e\u52a0\u5bc6\u7684\u503c\uff0c\u540e\u9762\u7684 16 \u4e2a\u5b57\u8282\u5b8c\u5168\u662f\u586b\u5145\u7684\u52a0\u5bc6\u540e\u7684\u5b57\u8282\u3002 \u8fd9\u91cc md5(token[:i]) \u7279\u6307\u524d16\u4e2a\u5b57\u8282\u3002\uff09\u3002\u4f46\u662f\uff0c\u6211\u4eec\u4e0d\u80fd\u518d\u6b21\u4e3a\u4e86\u83b7\u5f97\u4e00\u4e2a\u5b57\u7b26\u53bb\u7206\u7834 256 \u6b21\u4e86\u3002 \u65e2\u7136\u4e0d\u80fd\u591f\u7206\u7834\uff0c\u90a3\u4e48\u6211\u4eec\u6709\u6ca1\u6709\u53ef\u80fd\u4e00\u6b21\u83b7\u53d6\u4e00\u4e2a\u5b57\u8282\u7684\u5927\u5c0f\u5462\uff1f\u8fd9\u91cc\uff0c\u6211\u4eec\u518d\u6765\u68b3\u7406\u4e00\u4e0b\u8be5\u7a0b\u5e8f\u53ef\u80fd\u53ef\u4ee5\u6cc4\u6f0f\u7684\u4fe1\u606f \u67d0\u4e9b\u6d88\u606f\u7684 md5 \u503c\u52a0\u5bc6\u540e\u7684\u503c\uff0c\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u83b7\u53d6 md5(token[:i]) \u52a0\u5bc6\u540e\u7684\u503c\u3002 unpad \u6bcf\u6b21\u4f1a\u5bf9\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u8fdb\u884c unpad\uff0c\u8fd9\u4e2a\u5b57\u8282\u662f\u6839\u636e\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u6765\u51b3\u5b9a\u7684\u3002\u5982\u679c\u6211\u4eec\u53ef\u4ee5\u8ba1\u7b97\u51fa\u8fd9\u4e2a\u5b57\u8282\u7684\u5927\u5c0f\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u80fd\u53ef\u4ee5\u77e5\u9053\u4e00\u4e2a\u5b57\u8282\u7684\u503c\u3002 \u8fd9\u91cc\u6211\u4eec\u6df1\u5165\u5206\u6790\u4e00\u4e0b unpad \u7684\u4fe1\u606f\u6cc4\u6f0f\u3002\u5982\u679c\u6211\u4eec\u5c06\u52a0\u5bc6 IV \u548c encrypt(md5(token[:i])) \u653e\u5728\u67d0\u4e2a\u5bc6\u6587 C \u7684\u540e\u9762\uff0c\u6784\u6210 C|IV|encrypt(md5(token[:i])) \uff0c\u90a3\u4e48\u89e3\u5bc6\u51fa\u6765\u7684\u6d88\u606f\u7684\u6700\u540e\u4e00\u4e2a\u660e\u6587\u5757\u5c31\u662f md5(token[:i]) \u3002\u8fdb\u800c\uff0c\u5728 unpad \u7684\u65f6\u5019\u5c31\u662f\u5229\u7528 md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff08 0-255\uff09\u8fdb\u884c unpad\uff0c\u4e4b\u540e\u5bf9 unpad \u540e\u7684\u5b57\u7b26\u4e32\u6267\u884c\u6307\u5b9a\u7684\u547d\u4ee4\uff08\u6bd4\u5982md5\uff09\u3002\u90a3\u4e48\uff0c\u5982\u679c\u6211\u4eec \u4e8b\u5148\u6784\u9020\u4e00\u4e9b\u6d88\u606f\u54c8\u5e0c\u540e\u52a0\u5bc6\u7684\u6837\u672c \uff0c\u7136\u540e\u5c06\u4e0a\u8ff0\u6267\u884c\u540e\u7684\u7ed3\u679c\u4e0e\u6837\u672c\u6bd4\u8f83\uff0c\u5982\u679c\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u57fa\u672c\u53ef\u4ee5\u786e\u5b9a md5(token[:i]) \u7684 \u6700\u540e\u4e00\u4e2a\u5b57\u8282 \u3002\u7136\u800c\uff0c\u5982\u679c md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u5c0f\u4e8e16\uff0c\u90a3\u4e48\u5728 unpad \u65f6\u5c31\u4f1a\u5229\u7528\u4e00\u4e9b md5 \u4e2d\u7684\u503c\uff0c\u800c\u8fd9\u90e8\u5206\u503c\uff0c\u7531\u4e8e\u5bf9\u4e8e\u4e0d\u540c\u957f\u5ea6\u7684 token[:i] \u51e0\u4e4e\u90fd\u4e0d\u4f1a\u76f8\u540c\u3002\u6240\u4ee5\u53ef\u80fd\u9700\u8981\u7279\u6b8a\u5904\u7406\u3002 \u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u8fd9\u4e2a\u95ee\u9898\u7684\u5173\u952e\uff0c\u5373\u751f\u6210\u4e0e unpad \u5b57\u8282\u5927\u5c0f\u5bf9\u5e94\u7684\u52a0\u5bc6\u7ed3\u679c\u6837\u672c\uff0c\u4ee5\u4fbf\u4e8e\u67e5\u8868\u3002 \u5177\u4f53\u5229\u7528\u601d\u8def\u5982\u4e0b \u7ed5\u8fc7 proof of work\u3002 \u83b7\u53d6 token \u52a0\u5bc6\u540e\u7684\u7ed3\u679c token_enc \uff0c\u8fd9\u91cc\u4f1a\u5728 token \u524d\u9762\u6dfb\u52a0 7 \u4e2a\u5b57\u8282 \"token: \" \u3002 \u56e0\u6b64\u52a0\u5bc6\u540e\u7684\u957f\u5ea6\u4e3a 64\u3002 \u4f9d\u6b21\u83b7\u53d6 encrypt(md5(token[:i])) \u7684\u7ed3\u679c\uff0c\u4e00\u5171\u662f 57 \u4e2a\uff0c\u5305\u62ec\u6700\u540e\u4e00\u4e2a token \u7684 padding\u3002 \u6784\u9020\u4e0e unpad \u5927\u5c0f\u5bf9\u5e94\u7684\u6837\u672c\u3002\u8fd9\u91cc\u6211\u4eec\u6784\u9020\u5bc6\u6587 token_enc|padding|IV_indexi|welcome_enc \u3002\u7531\u4e8e IV_indexi \u662f\u4e3a\u4e86\u4fee\u6539\u6700\u540e\u4e00\u4e2a\u660e\u6587\u5757\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u6240\u4ee5\u8be5\u5b57\u8282\u5904\u4e8e\u53d8\u5316\u4e4b\u4e2d\u3002\u6211\u4eec\u82e5\u60f3\u83b7\u53d6\u4e00\u4e9b\u56fa\u5b9a\u5b57\u8282\u7684\u54c8\u5e0c\u503c\uff0c\u8fd9\u90e8\u5206\u81ea\u7136\u4e0d\u80fd\u6dfb\u52a0\u3002\u56e0\u6b64\u8fd9\u91cc\u4ea7\u751f\u6837\u672c\u65f6 unpad \u7684\u5927\u5c0f\u8303\u56f4\u4e3a 17 ~ 255\u3002\u5982\u679c\u6700\u540e\u6d4b\u8bd5\u65f6 md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u5c0f\u4e8e17\u7684\u8bdd\uff0c\u57fa\u672c\u5c31\u4f1a\u51fa\u73b0\u4e00\u4e9b\u672a\u77e5\u7684\u6837\u672c\u3002\u5f88\u81ea\u7136\u7684\u4e00\u4e2a\u60f3\u6cd5\u662f\u6211\u4eec\u76f4\u63a5\u83b7\u53d6 255-17+1\u4e2a\u8fd9\u4e48\u591a\u4e2a\u6837\u672c\uff0c\u7136\u800c\uff0c\u5982\u679c\u8fd9\u6837\u505a\u7684\u8bdd\uff0c\u6839\u636e\u4e0a\u9762 340 \u7684\u6b21\u6570\uff08255-17+1+57+56>340\uff09\u9650\u5236\uff0c\u6211\u4eec\u663e\u7136\u4e0d\u80fd\u83b7\u53d6\u5230 token \u7684\u6240\u6709\u5b57\u8282\u3002\u6240\u4ee5\u8fd9\u91cc\u6211\u4eec\u9700\u8981\u60f3\u529e\u6cd5\u590d\u7528\u4e00\u4e9b\u5185\u5bb9\uff0c\u8fd9\u91cc\u6211\u4eec\u9009\u62e9\u590d\u7528 encrypt(md5(token[:i])) \u7684\u7ed3\u679c\u3002\u90a3\u4e48\u6211\u4eec\u5728\u8865\u5145 padding \u65f6\u9700\u8981\u786e\u4fdd\u4e00\u65b9\u9762\u6b21\u6570\u591f\u7528\uff0c\u53e6\u4e00\u65b9\u9762\u53ef\u4ee5\u590d\u7528\u4e4b\u524d\u7684\u7ed3\u679c\u3002\u8fd9\u91cc\u6211\u4eec\u8bbe\u7f6e unpad \u7684\u5faa\u73af\u4e3a 17 \u5230 208\uff0c\u5e76\u4f7f\u5f97 unpad \u5927\u4e8e 208 \u65f6\u6070\u597d unpad \u5230\u6211\u4eec\u53ef\u4ee5\u590d\u7528\u7684\u5730\u65b9\u3002\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5f53 md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u4e3a 0 \u65f6\uff0c\u4f1a\u5c06\u6240\u6709\u89e3\u5bc6\u540e\u7684\u660e\u6587 unpad \u6389\uff0c\u56e0\u6b64\u4f1a\u51fa\u73b0 command not found \u7684\u5bc6\u6587\u3002 \u518d\u6b21\u6784\u9020\u5bc6\u6587 token_enc|padding|IV|encrypt(md5(token[:i])) \uff0c\u90a3\u4e48\uff0c\u89e3\u5bc6\u65f6\u5373\u4f7f\u7528 md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u8fdb\u884c unpad\u3002\u5982\u679c\u8fd9\u4e2a\u5b57\u8282\u4e0d\u5c0f\u4e8e17\u6216\u8005\u4e3a0\uff0c\u5219\u53ef\u4ee5\u5904\u7406\u3002\u5982\u679c\u8fd9\u4e2a\u5b57\u8282\u5c0f\u4e8e17\uff0c\u90a3\u4e48\u663e\u7136\uff0c\u6700\u540e\u8fd4\u56de\u7ed9\u7528\u6237\u7684 md5 \u7684\u7ed3\u679c\u5e76\u4e0d\u5728\u6837\u672c\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u6211\u4eec\u4fee\u6539\u5176\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u7684\u6700\u9ad8\u6bd4\u7279\u4f4d\uff0c\u4f7f\u5176 unpad \u540e\u53ef\u4ee5\u843d\u5728\u6837\u672c\u8303\u56f4\u5185\u3002\u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u731c\u51fa md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002 \u5728\u731c\u51fa md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u672c\u5730\u66b4\u529b\u7834\u89e3 256 \u6b21\uff0c\u627e\u51fa\u6240\u6709\u54c8\u5e0c\u503c\u672b\u5c3e\u4e3a md5(token[:i]) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u7684\u5b57\u7b26\u3002 \u4f46\u662f\uff0c\u5728\u7b2c\u516d\u6b65\u4e2d\uff0c\u5bf9\u4e8e\u4e00\u4e2a md5(token[:i]) \u53ef\u80fd\u4f1a\u627e\u51fa\u591a\u4e2a\u5907\u9009\u5b57\u7b26\uff0c\u56e0\u4e3a\u6211\u4eec\u53ea\u9700\u8981\u4f7f\u5f97\u5176\u672b\u5c3e\u5b57\u8282\u662f\u7ed9\u5b9a\u5b57\u8282\u5373\u53ef\u3002 \u90a3\u4e48\uff0c\u95ee\u9898\u6765\u4e86\uff0c\u5982\u4f55\u5220\u9664\u4e00\u4e9b\u591a\u4f59\u7684\u5907\u9009\u5b57\u7b26\u4e32\u5462\uff1f\u8fd9\u91cc\u6211\u5c31\u9009\u62e9\u4e86\u4e00\u4e2a\u5c0f trick\uff0c\u5373\u5728\u9010\u5b57\u8282\u679a\u4e3e\u65f6\uff0c\u540c\u65f6\u679a\u4e3e\u51fa token \u7684 padding\u3002\u7531\u4e8e padding \u662f 0x01 \u662f\u56fa\u5b9a\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u8fc7\u6ee4\u51fa\u6240\u6709\u7ed3\u5c3e\u4e0d\u662f 0x01 \u7684token \u5373\u53ef\u3002 \u8fd9\u91cc\uff0c\u5728\u6d4b\u8bd5\u65f6\uff0c\u5c06\u4ee3\u7801\u4e2d sleep \u6ce8\u91ca\u6389\u4e86\u3002\u4ee5\u4fbf\u4e8e\u52a0\u5feb\u4ea4\u4e92\u901f\u5ea6\u3002\u5229\u7528\u4ee3\u7801\u5982\u4e0b from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] # remove pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) def sendmsg ( iv , cipher ): payload = iv + cipher payload = base64 . b64encode ( payload ) p . sendline ( payload ) def recvmsg (): data = p . recvuntil ( \" \\n \" , drop = True ) data = base64 . b64decode ( data ) return data [: 16 ], data [ 16 :] def getmd5enc ( i , cipher_token , cipher_welcome , iv ): \"\"\"return encrypt( md5( token[:i+1] ) )\"\"\" ## keep iv[7:] do not change, so decrypt msg[7:] won't change get_md5_iv = flipplain ( \"token: \" . ljust ( 16 , ' \\x00 ' ), \"get-md5\" . ljust ( 16 , ' \\x00 ' ), iv ) payload = cipher_token ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_token ) + 16 + 16 - ( 7 + i + 1 )), iv ) payload += last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , payload ) return recvmsg () def get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ): md5_token_idxi = [] for i in range ( len ( cipher_token ) - 7 ): log . info ( \"idx i: {} \" . format ( i )) _ , md5_indexi = getmd5enc ( i , cipher_token , cipher_welcome , iv_encrypt ) assert ( len ( md5_indexi ) == 32 ) # remove the last 16 byte for padding md5_token_idxi . append ( md5_indexi [: 16 ]) return md5_token_idxi def doin ( unpadcipher , md5map , candidates , flag ): if unpadcipher in md5map : lastbyte = md5map [ unpadcipher ] else : lastbyte = 0 if flag == 0 : lastbyte ^= 0x80 newcandidates = [] for x in candidates : for c in range ( 256 ): if MD5 . new ( x + chr ( c )) . digest ()[ - 1 ] == chr ( lastbyte ): newcandidates . append ( x + chr ( c )) candidates = newcandidates print candidates return candidates def main (): bypassproof () # result of encrypted Welcome!! iv_encrypt , cipher_welcome = recvmsg () log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-token get_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-token\" ), iv_encrypt ) sendmsg ( get_token_iv , cipher_welcome ) _ , cipher_token = recvmsg () token_len = len ( cipher_token ) log . info ( \"cipher token is : \" + cipher_token ) # get command not found cipher sendmsg ( iv_encrypt , cipher_welcome ) _ , cipher_notfound = recvmsg () # get encrypted(token[:i+1]),57 times md5_token_idx_list = get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ) # get md5map for each unpadsize, 209-17 times # when upadsize>208, it will unpad ciphertoken # then we can reuse md5map = dict () for unpadsize in range ( 17 , 209 ): log . info ( \"get unpad size {} cipher\" . format ( unpadsize )) get_md5_iv = flipplain ( \"token: \" . ljust ( 16 , ' \\x00 ' ), \"get-md5\" . ljust ( 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" ## calculate the proper last byte number, only change the last byte ## set last_byte_iv = iv_encrypted[:15] | proper byte last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"Welcome!!\" )[: 15 ] + chr ( unpadsize ), iv_encrypt ) cipher = cipher_token + padding + last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () md5map [ unpadcipher ] = unpadsize # reuse encrypted(token[:i+1]) for i in range ( 209 , 256 ): target = md5_token_idx_list [ 56 - ( i - 209 )] md5map [ target ] = i candidates = [ \"\" ] # get the byte token[i], only 56 byte for i in range ( token_len - 7 ): log . info ( \"get token[ {} ]\" . format ( i )) get_md5_iv = flipplain ( \"token: \" . ljust ( 16 , ' \\x00 ' ), \"get-md5\" . ljust ( 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list [ i ] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () # already in or md5[token[:i]][-1]='\\x00' if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 1 ) else : log . info ( \"unpad size 1-16\" ) # flip most significant bit of last byte to move it in a good range cipher = cipher [: - 17 ] + strxor ( cipher [ - 17 ], ' \\x80 ' ) + cipher [ - 16 :] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 0 ) else : log . info ( 'oh my god,,,, it must be in...' ) exit () print len ( candidates ) # padding 0x01 candidates = filter ( lambda x : x [ - 1 ] == chr ( 0x01 ), candidates ) # only 56 bytes candidates = [ x [: - 1 ] for x in candidates ] print len ( candidates ) assert ( len ( candidates [ 0 ]) == 56 ) # check-token check_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"check-token\" ), iv_encrypt ) sendmsg ( check_token_iv , cipher_welcome ) p . recvuntil ( \"Give me the token! \\n \" ) p . sendline ( base64 . b64encode ( candidates [ 0 ])) print p . recv () p . interactive () if __name__ == \"__main__\" : main () \u6548\u679c\u5982\u4e0b ... 79 1 hitcon { uNp@d_M3th0D_i5_am4Z1n9! }","title":"\u5229\u7528\u601d\u8def"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#teaser-dragon-ctf-2018-aes-128-tsb","text":"\u8fd9\u4e2a\u9898\u76ee\u8fd8\u662f\u86ee\u6709\u610f\u601d\u7684\uff0c\u9898\u76ee\u63cf\u8ff0\u5982\u4e0b Haven't you ever thought that GCM mode is overcomplicated and there must be a simpler way to achieve Authenticated Encryption? Here it is! Server: aes-128-tsb.hackable.software 1337 server.py \u9644\u4ef6\u4ee5\u53ca\u6700\u540e\u7684 exp \u81ea\u884c\u5230 ctf-challenge \u4ed3\u5e93\u4e0b\u5bfb\u627e\u3002 \u9898\u76ee\u7684\u57fa\u672c\u6d41\u7a0b\u4e3a \u4e0d\u65ad\u63a5\u6536 a \u548c b \u4e24\u4e2a\u5b57\u7b26\u4e32\uff0c\u5176\u4e2d a \u4e3a\u660e\u6587\uff0cb \u4e3a\u5bc6\u6587\uff0c\u6ce8\u610f b \u5728\u89e3\u5bc6\u540e\u9700\u8981\u6ee1\u8db3\u5c3e\u90e8\u6070\u597d\u7b49\u4e8e iv\u3002 \u5982\u679c a \u548c b \u76f8\u7b49\uff0c\u90a3\u4e48\u6839\u636e a \u4e3a gimme_flag \uff0c\u8f93\u51fa\u52a0\u5bc6\u540e\u7684 flag\u3002 \u5426\u5219\uff0c\u8f93\u51fa\u4e00\u4e32\u968f\u673a\u52a0\u5bc6\u7684\u5b57\u7b26\u4e32\u3002 \u5426\u5219\u8f93\u51fa\u4e00\u4e32\u660e\u6587\u7684\u5b57\u7b26\u4e32\u3002 \u6b64\u5916\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u53d1\u73b0\u9898\u76ee\u4e2d\u7684 unpad \u5b58\u5728\u95ee\u9898\uff0c\u53ef\u4ee5\u622a\u65ad\u6307\u5b9a\u957f\u5ea6\u3002 def unpad ( msg ): if not msg : return '' return msg [: - ord ( msg [ - 1 ])] \u4e00\u5f00\u59cb\uff0c\u5f88\u76f4\u63a5\u7684\u601d\u8def\u662f a \u548c b \u7684\u957f\u5ea6\u90fd\u8f93\u5165 0 \uff0c\u90a3\u4e48\u53ef\u4ee5\u76f4\u63a5\u7ed5\u8fc7 a==b \u68c0\u67e5\uff0c\u83b7\u53d6\u4e00\u4e32\u968f\u673a\u5bc6\u6587\u52a0\u5bc6\u7684\u5b57\u7b26\u4e32\u3002\u7136\u800c\u4f3c\u4e4e\u5e76\u6ca1\u6709\u4ec0\u4e48\u4f5c\u7528\uff0c\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u52a0\u5bc6\u7684\u6d41\u7a0b def tsb_encrypt ( aes , msg ): msg = pad ( msg ) iv = get_random_bytes ( 16 ) prev_pt = iv prev_ct = iv ct = '' for block in split_by ( msg , 16 ) + [ iv ]: ct_block = xor ( block , prev_pt ) ct_block = aes . encrypt ( ct_block ) ct_block = xor ( ct_block , prev_ct ) ct += ct_block prev_pt = block prev_ct = ct_block return iv + ct \u4e0d\u59a8\u5047\u8bbe P_0=iv,C_0=iv P_0=iv,C_0=iv \uff0c\u5219 C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) \u90a3\u4e48\uff0c\u5047\u8bbe\u6d88\u606f\u957f\u5ea6\u4e3a 16\uff0c\u4e0e\u6211\u4eec\u60f3\u8981\u5f97\u5230\u7684 gimme_flag padding \u540e\u957f\u5ea6\u7c7b\u4f3c\uff0c\u5219 C_1=IV\\oplus E( IV \\oplus P_1) C_1=IV\\oplus E( IV \\oplus P_1) C_2=C_1 \\oplus E(P_1 \\oplus IV) C_2=C_1 \\oplus E(P_1 \\oplus IV) \u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u53d1\u73b0 C_2=IV C_2=IV \u3002 \uff08 \u76d7\u56fe \uff0c\u4e0b\u9762\u7684\u56fe\u7247\u66f4\u52a0\u6e05\u6670 \u53cd\u8fc7\u6765\u60f3\uff0c\u5982\u679c\u6211\u4eec\u5411\u670d\u52a1\u5668\u53d1\u9001 iv+c+iv \uff0c\u90a3\u4e48\u603b\u80fd\u7ed5\u8fc7 tsb_decrypt \u7684 mac \u68c0\u67e5 def tsb_decrypt ( aes , msg ): iv , msg = msg [: 16 ], msg [ 16 :] prev_pt = iv prev_ct = iv pt = '' for block in split_by ( msg , 16 ): pt_block = xor ( block , prev_ct ) pt_block = aes . decrypt ( pt_block ) pt_block = xor ( pt_block , prev_pt ) pt += pt_block prev_pt = pt_block prev_ct = block pt , mac = pt [: - 16 ], pt [ - 16 :] if mac != iv : raise CryptoError () return unpad ( pt ) \u90a3\u4e48\u6b64\u65f6\uff0c\u670d\u52a1\u5668\u89e3\u5bc6\u540e\u7684\u6d88\u606f\u5219\u662f unpad(IV \\oplus D(C_1 \\oplus IV)) unpad(IV \\oplus D(C_1 \\oplus IV))","title":"Teaser Dragon CTF 2018 AES-128-TSB"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_10","text":"\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u63a7\u5236 D \u89e3\u5bc6\u7684\u6d88\u606f\u4e3a\u5e38\u6570\u503c\uff0c\u6bd4\u5982\u5168\u96f6\uff0c\u5373 C1=IV \uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u4ece 0 \u5230 255 \u679a\u4e3e IV \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\uff0c\u5f97\u5230 IV \\oplus D(C_1 \\oplus IV) IV \\oplus D(C_1 \\oplus IV) \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u4e5f\u662f 0~255\u3002\u800c\u53ea\u6709\u662f 1~15 \u7684\u65f6\u5019\uff0c unpad \u64cd\u4f5c\u8fc7\u540e\uff0c\u6d88\u606f\u957f\u5ea6\u4e0d\u4e3a 0\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u679a\u4e3e\u65f6\u7edf\u8ba1\u7a76\u7adf\u54ea\u4e9b\u6570\u5b57\u5bfc\u81f4\u4e86\u957f\u5ea6\u4e0d\u4e3a\u96f6\uff0c\u5e76\u6807\u8bb0\u4e3a 1\uff0c\u5176\u4f59\u6807\u8bb0\u4e3a 0\u3002 def getlast_byte ( iv , block ): iv_pre = iv [: 15 ] iv_last = ord ( iv [ - 1 ]) tmp = [] print ( 'get last byte' ) for i in range ( 256 ): send_data ( '' ) iv = iv_pre + chr ( i ) tmpblock = block [: 15 ] + chr ( i ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' in data : tmp . append ( 1 ) else : tmp . append ( 0 ) last_bytes = [] for i in range ( 256 ): if tmp == xor_byte_map [ i ][ 0 ]: last_bytes . append ( xor_byte_map [ i ][ 1 ]) print ( 'possible last byte is ' + str ( last_bytes )) return last_bytes \u6b64\u5916\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u6700\u521d\u7684\u65f6\u5019\u6253\u8868\u83b7\u53d6\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u6240\u6709\u7684\u53ef\u80fd\u60c5\u51b5\uff0c\u8bb0\u5f55\u5728 xor_byte_map \u4e2d\u3002 \"\"\" every item is a pair [a,b] a is the xor list b is the idx which is zero when xored \"\"\" xor_byte_map = [] for i in range ( 256 ): a = [] b = 0 for j in range ( 256 ): tmp = i ^ j if tmp > 0 and tmp <= 15 : a . append ( 1 ) else : a . append ( 0 ) if tmp == 0 : b = j xor_byte_map . append ([ a , b ]) \u901a\u8fc7\u4e0e\u8fd9\u4e2a\u8868\u8fdb\u884c\u5bf9\u6bd4\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u77e5\u9053\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u53ef\u80fd\u7684\u60c5\u51b5\u3002","title":"\u83b7\u53d6\u660e\u6587\u6700\u540e\u4e00\u4e2a\u5b57\u8282"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_11","text":"\u5728\u83b7\u53d6\u4e86\u660e\u6587\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u540e\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5229\u7528 unpad \u7684\u6f0f\u6d1e\uff0c\u4ece\u957f\u5ea6 1 \u679a\u4e3e\u5230\u957f\u5ea6 15 \u6765\u83b7\u5f97\u5bf9\u5e94\u7684\u660e\u6587\u5185\u5bb9\u3002 def dec_block ( iv , block ): last_bytes = getlast_byte ( iv , block ) iv_pre = iv [: 15 ] iv_last = ord ( iv [ - 1 ]) print ( 'try to get plain' ) plain0 = '' for last_byte in last_bytes : plain0 = '' for i in range ( 15 ): print 'idx:' , i tag = False for j in range ( 256 ): send_data ( plain0 + chr ( j )) pad_size = 15 - i iv = iv_pre + chr ( pad_size ^ last_byte ) tmpblock = block [: 15 ] + chr ( pad_size ^ last_byte ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' not in data : # success plain0 += chr ( j ) tag = True break if not tag : break # means the last byte is ok if plain0 != '' : break plain0 += chr ( iv_last ^ last_byte ) return plain0","title":"\u89e3\u5bc6\u4efb\u610f\u52a0\u5bc6\u5757"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_12","text":"\u8fd9\u4e00\u70b9\u6bd4\u8f83\u7b80\u5355\uff0c\u6211\u4eec\u5e0c\u671b\u5229\u7528\u8fd9\u4e00\u70b9\u6765\u83b7\u53d6 gimme_flag \u7684\u5bc6\u6587 print ( 'get the cipher of flag' ) gemmi_iv1 = xor ( pad ( 'gimme_flag' ), plain0 ) gemmi_c1 = xor ( gemmi_iv1 , cipher0 ) payload = gemmi_iv1 + gemmi_c1 + gemmi_iv1 send_data ( 'gimme_flag' ) send_data ( payload ) flag_len , flag_cipher = recv_data () \u5176\u4e2d plain0 \u548c cipher0 \u662f\u6211\u4eec\u83b7\u53d6\u7684 AES \u52a0\u5bc6\u7684\u660e\u5bc6\u6587\u5bf9\uff0c\u4e0d\u5305\u62ec\u4e4b\u524d\u548c\u4e4b\u540e\u7684\u4e24\u4e2a\u5f02\u6216\u3002","title":"\u89e3\u5bc6\u51fa\u6307\u5b9a\u660e\u6587"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#flag","text":"\u8fd9\u4e00\u70b9\uff0c\u5176\u5b9e\u5c31\u662f\u5229\u7528\u89e3\u5bc6\u4efb\u610f\u52a0\u5bc6\u5757\u7684\u529f\u80fd\u5b9e\u73b0\u7684\uff0c\u5982\u4e0b print ( 'the flag cipher is ' + flag_cipher . encode ( 'hex' )) flag_cipher = split_by ( flag_cipher , 16 ) print ( 'decrypt the blocks one by one' ) plain = '' for i in range ( len ( flag_cipher ) - 1 ): print ( 'block: ' + str ( i )) if i == 0 : plain += dec_block ( flag_cipher [ i ], flag_cipher [ i + 1 ]) else : iv = plain [ - 16 :] cipher = xor ( xor ( iv , flag_cipher [ i + 1 ]), flag_cipher [ i ]) plain += dec_block ( iv , cipher ) pass print ( 'now plain: ' + plain ) print plain \u53ef\u4ee5\u601d\u8003\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u7b2c\u4e8c\u5757\u4e4b\u540e\u7684\u5bc6\u6587\u64cd\u4f5c\u4f1a\u6709\u6240\u4e0d\u540c\u3002 \u5b8c\u6574\u7684\u4ee3\u7801\u53c2\u8003 ctf-challenge \u4ed3\u5e93\u3002","title":"\u89e3\u5bc6 flag"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack-zh/#_13","text":"\u5206\u7ec4\u52a0\u5bc6\u6a21\u5f0f https://en.wikipedia.org/wiki/Padding_oracle_attack http://netifera.com/research/poet/PaddingOraclesEverywhereEkoparty2010.pdf https://ctftime.org/writeup/7975 https://ctftime.org/writeup/7974","title":"\u53c2\u8003\u8d44\u6599"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/","text":"EN | ZH Padding Oracle Attack \u00b6 Introduction \u00b6 Padding Oracle Attack attacks generally need to meet the following conditions Encryption Algorithm Encryption algorithm using PKCS5 Padding. Of course, the way OAEP is filled in asymmetric encryption may also be affected. The grouping mode is CBC mode. Attacker ability An attacker can intercept messages encrypted by the above encryption algorithm. The attacker can interact with the padding oracle (the server): the client sends the ciphertext to the server, and the server will use some kind of return information to inform the client whether the padding is normal. Padding Oracle Attack can achieve the following effects Decrypt any given ciphertext without knowing the key and IV. Principle \u00b6 The basic principles of the Padding Oracle Attack attack are as follows Decrypt a very long message piece by piece. For each message, first decrypt the last byte of the message, then decrypt the second to last byte, and so on. Here we review the CBC Encryption $$ C_i=E_K(P_i \\oplus C_{i-1})\\ IV = C_0 $$ Decryption $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ We mainly focus on decryption, we don't know IV and key here. Here we assume that the length of the ciphertext block is n bytes. Suppose we intercepted ciphertext Y to obtain the last byte of ciphertext Y as an example for analysis. In order to obtain the content of Y, we first need to forge a piece of ciphertext F so that the last byte of the plaintext corresponding to Y can be modified. This is because if we construct the ciphertext F|Y , then the decryption Y is specifically $$ P = D_K (Y) oplus F $$ So modify the last byte of ciphertext F, F_{n} F_{n} , to modify the last byte of the plaintext corresponding to Y. The process of getting the last byte of P is given below. i=0, set each byte of F to be random byte . Set F_n=i \\oplus 0x01 F_n=i \\oplus 0x01 Send F|Y to the server. If the last byte of P is i, then the last padding is 0x01 and no error will occur. Otherwise, only the last P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 bytes of P are P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 and no error will be reported. Also, note that the padding bytes can only be 0 to n. Therefore, if you want to make the error in the case of F randomly and satisfy the padding byte size, the probability is small**. So in the case of no error on the server side, we can think that we did get the correct bytes. In the event of an error, i=i+1, jump to 2. After getting the last byte of P, we can continue to get the second-to-last byte of P. In this case, we need to set F_n=P_n\\oplus 0x02 F_n=P_n\\oplus 0x02 and set F_{n-1}=i \\oplus 0x02 F_{n-1}=i \\oplus 0x02 to enumerate i. So, in summary, Padding Oracle Attack is actually a method of attack with a high probability of success. However, it's important to note that some of the real-world problems that are often encountered are not the standard Padding Oracle Attack mode, and we often need to make some changes. 2017 HITCON Secret Server \u00b6 Analysis \u00b6 The encryption used in the program is AES CBC, which uses padding similar to PKCS5. def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] However, in each unpad, no detection is performed, but the unpad is directly executed. Among them, it should be noted that the function that interacts with the user each time is send_msg , accepts the user's plaintext, encrypts it with a fixed 2jpmLoSsOlQrqyqE , and outputs the encrypted result. recv_msg , accepts the user's IV and ciphertext, decrypts the ciphertext, and returns. There will be different actions depending on the results returned. msg = recv_msg () . strip () if msg . startswith ( 'exit-here' ): exit ( 0 ) elif msg . startswith ( 'get-flag' ): send_msg ( flag ) elif msg . startswith ( 'get-md5' ): send_msg ( MD5 . new ( msg [ 7 :]) . digest ()) elif msg . startswith ( 'get-time' ): send_msg ( str ( time . time ())) elif msg . startswith ( 'get-sha1' ): send_msg ( SHA . new ( msg [ 8 :]) . digest ()) elif msg . startswith ( 'get-sha256' ): send_msg ( SHA256 . new ( msg [ 10 :]) . digest ()) elif msg . startswith ( 'get-hmac' ): send_msg ( HMAC . new ( msg [ 8 :]) . digest ()) else : send_msg ( 'command not found' ) Main Vulnerabilities \u00b6 Here we briefly summarize the parts we have. Encryption The IV when encrypting is fixed and known. 'Welcome!!' Encrypted result. Decryption We can control IV. First of all, since we know the result of the Welcome!! encryption, we can also control the IV in recv_msg, then according to the decryption process $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ If we enter the encrypted result of Welcome!! into recv_msg, the result of direct decryption is (Welcome!!+&#39;\\x07&#39;*7) xor iv , if we properly control the decryption process In the iv passed, then we can control the decrypted result. In other words, we can execute any of the commands described above**. Thus, we can also know the result of the flag decryption. Secondly, on the above basis, if we add the custom IV and Welcome encrypted result after any ciphertext C and pass it to recv_msg as input, then we can control the last byte of the message after decryption. So due to the unpad operation, we can control the length of the decrypted message to be reduced from 0 to 255 . Using ideas \u00b6 Basic use ideas are as follows Bypass proof of work 2. Obtain the encrypted flag according to the way you execute any command. 3. Since the beginning of the flag is hitcon{ , there are 7 bytes in total, so we can still control the iv to make the first 7 bytes after decryption the specified byte. This allows us to execute the get-md5 command on the decrypted message. According to the unpad operation, we can control the decrypted message exactly at the first few bytes of the message. So we can start controlling the decrypted message as hitcon{x , that is, only one byte after hitcon{ . This will result in an encrypted result with a one-byte hash. Similarly, we can also get the result of the encryption with a byte hash. 4. In this case, we can blast locally byte by byte, calculate the corresponding md5 , and then use the arbitrary command execution mode to control the decrypted plaintext to any specified command. If the control is unsuccessful, it means that the byte is incorrect. , need to blast again; if it is correct, then you can directly execute the corresponding command. The specific code is as follows #coding=utf-8 from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' if args [ 'REMOTE' ]: p = remote ( '52.193.157.19' , 9999 ) else : p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): Return msg [: - ord ( msg [ - 1 ])] # Remove the pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) p . recvuntil ( 'Done! \\n ' ) iv_encrypt = '2jpmLoSsOlQrqyqE' def getmd5enc ( i , cipher_flag , cipher_welcome ): \"\"\"return encrypt( md5( flag[7:7+i] ) )\"\"\" ## keep iv[7:] do not change, so decrypt won't change new_iv = flipplain ( & quot ; hitcon { & quot ; . bright ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . light ( 16 , ' \\x00 ' ), iv_encrypt ) payload = new_iv + cipher_flag ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_flag ) + 16 + 16 - ( 7 + i + 1 )), iv_encrypt ) payload += last_byte_iv + cipher_welcome p . sendline ( base64 . b64encode ( payload )) return p . recvuntil ( \" \\n \" , drop = True ) def main (): bypassproof () # result of encrypted Welcome!! cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_welcome = base64 . b64decode ( cipher )[ 16 :] log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-flag get_flag_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-flag\" ), iv_encrypt ) payload = base64 . b64encode ( get_flag_iv + cipher_welcome ) p . sendline ( payload ) cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_flag = base64 . b64decode ( cipher )[ 16 :] flaglen = len ( cipher_flag ) log . info ( \"cipher flag is : \" + cipher_flag ) # get command not found cipher p . sendline ( base64 . b64encode ( iv_encrypt + cipher_welcome )) cipher_notfound = p . recvuntil ( ' \\n ' , drop = True ) flag = \"\" # brute force for every byte of flag for i in range ( flaglen - 7 ): md5_indexi = getmd5enc ( i , cipher_flag , cipher_welcome ) md5_indexi = base64 . b64decode ( md5_indexi ) [ 16 :] log . info ( \"get encrypt(md5(flag[7:7+i])): \" + md5_indexi ) for guess in range ( 256 ): # locally compute md5 hash guess_md5 = MD5 . new ( flag + chr ( guess )) . digest () # try to null out the md5 plaintext and execute a command payload = flipplain ( guess_md5 , 'get-time' . ljust ( 16 , ' \\x01 ' ), iv_encrypt ) payload += md5_indexi p . sendline ( base64 . b64encode ( payload )) res = p . recvuntil ( \" \\n \" , drop = True ) # if we receive the block for 'command not found', the hash was wrong if res == cipher_notfound : print 'Guess {} is wrong.' . format ( guess ) # otherwise we correctly guessed the hash and the command was executed else : print 'Found!' flag += chr ( guess ) print 'Flag so far:' , flag break if __name__ == \"__main__\" : main () The final result is as follows Flag so far: Paddin9_15_ve3y_h4rd__!! } \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 2017 HITCON Secret Server Revenge \u00b6 Description \u00b6 The password of zip is the flag of \"Secret Server\" Analysis \u00b6 This program continues with the above program, but this time a simple modification The iv of the encryption algorithm is unknown, but can be derived from the message encrypted by Welcome. The program has a 56-byte token. The program can perform up to 340 operations, so the above blasting is naturally not feasible The general process of the program is as follows After proof of work 2. Send \"Welcome!!\" encrypted message 3. In 340 operations, you need to guess the value of the token and then automatically output the flag. Vulnerability \u00b6 Of course, the loopholes in the previous topic still exist in this topic, namely Execute the given command arbitrarily Length truncation Using ideas \u00b6 Due to the limitation of the number of 340, although we can still get the value of md5(token[:i]) encrypted ( here we need to pay attention to this part of the encryption is exactly 32 bytes, the first 16 bytes are The value after md5 is encrypted, the next 16 bytes are completely filled with encrypted bytes. Here md5(token[:i]) refers specifically to the first 16 bytes.). However, we can't blast 256 times again in order to get a character. Since it is not possible to blast, is it possible to get the size of one byte at a time? Here, let's take a look at the information that the program may leak. The encrypted value of the md5 value of some messages. Here we can get the encrypted value of md5(token[:i]) . Unpad will unmap the decrypted message each time. This byte is determined based on the last byte of the decrypted message. If we can calculate the size of this byte, then we may know the value of a byte. Here we delve into the information leak of unpad. If we put the encryption IV and encrypt(md5(token[:i])) after a ciphertext C to form C|IV|encrypt(md5(token[:i])) , then decrypt The last plaintext block of the outgoing message is md5(token[:i]) . Furthermore, in the unpad, the last byte (0-255) of md5(token[:i]) is used for unpad, and then the specified command (such as md5) is executed on the string after the unpad. Then, if we pre-configure some hashed samples after the message hash, and then compare the results of the above execution with the sample, if they are the same, then we can basically determine the md5(token[:i]) * * Last byte . However, if the last byte of md5(token[:i]) is less than 16, then some values in md5 will be used in unpad, and this part of the value, due to token[:i] for different lengths Almost all will not be the same. So special handling may be required. We already know the key to this problem, which is to generate a sample of the encrypted result corresponding to the size of the unpad byte, in order to facilitate the lookup table. The specific use ideas are as follows Bypass proof of work. Get the token encrypted result token_enc , which will add 7 bytes &quot;token: &quot; in front of the token. Therefore, the length after encryption is 64. Get the result of encrypt(md5(token[:i])) , which is a total of 57, including the padding of the last token. Construct a sample that corresponds to the size of the unpad. Here we construct the ciphertext token_enc|padding|IV_indexi|welcome_enc . Since IV_indexi is to modify the last byte of the last plaintext block, the byte is in the process of being changed. If we want to get some fixed byte hashes, this part can't be added naturally. Therefore, the size of the unpad ranges from 17 to 255 when the sample is generated here. If the last byte of md5(token[:i]) is less than 17 at the end of the test, there will be some unknown samples. A natural idea is that we directly get 255-17+1 such multiple samples, however, if we do this, according to the number of times above 340 (255-17+1+57+56>340), we obviously can't Get all the bytes to the token. So here we need to find ways to reuse some content, here we choose to reuse the result of encrypt(md5(token[:i])) . Then we need to ensure that the number of times is sufficient on the one hand, and on the other hand, the previous results can be reused. Here we set the unpad loop to 17 to 208, and make the unpad more than 208 when we just unpad to where we can reuse. It should be noted here that when the last byte of md5(token[:i]) is 0, all decrypted plaintext unpad will be dropped, so the ciphertext of command not found will appear. Construct the ciphertext token_enc|padding|IV|encrypt(md5(token[:i])) again, then use the last byte of md5(token[:i]) for unpad when decrypting. If this byte is not less than 17 or 0, it can be processed. If this byte is less than 17, then obviously, the result of the last md5 returned to the user is not within the sample range, then we modify the highest bit of its last byte so that it can fall within the sample range after the unpad. In this way, we can guess the last byte of md5(token[:i]) . After guessing the last byte of md5(token[:i]) , we can brute 256 times locally and find out that all hashes are at the end of md5(token[:i]) The last byte of the character. However, in the sixth step, for a md5(token[:i]) we may find multiple alternative characters because we only need to make the last byte of the given byte. So, the question is, how do you delete some extra candidate strings? Here I chose a small trick, which enumerates the padding of the token at the same time as the byte-by-byte enumeration. Since padding is fixed at 0x01, we only need to filter out all tokens that are not 0x01 at the end. Here, the sleep in the code is commented out during the test. In order to speed up the interaction. Use the code as follows from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] # remove pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) def sendmsg ( iv , cipher ): payload = iv + cipher payload = base64 . b64encode ( payload ) p . sendline ( payload ) def recvmsg (): data = p . recvuntil ( \" \\n \" , drop = True ) data = base64 . b64decode ( data ) return data [: 16 ], data [ 16 :] def getmd5enc ( i , cipher_token , cipher_welcome , iv ): \"\"\"return encrypt( md5( token[:i+1] ) )\"\"\" ## keep iv[7:] do not change, so decrypt msg[7:] won't change get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv ) payload = cipher_token ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_token ) + 16 + 16 - ( 7 + i + 1 )), iv ) payload += last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , payload ) return recvmsg () def get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ): md5_token_idxi = [] for i in range ( len ( cipher_token ) - 7 ): log . info ( \"idx i: {} \" . format ( i )) _ , md5_indexi = getmd5enc ( i , cipher_token , cipher_welcome , iv_encrypt ) assert ( only ( md5_indexi ) == 32 ) # remove the last 16 byte for padding md5_token_idxi . append ( md5_indexi [: 16 ]) return md5_token_idxi def doin ( unpadcipher , md5map , candidates , flag ): if unpadcipher in md5map : lastbyte = md5map [ unpadcipher ] else : lastbyte = 0 if flag == 0 : lastbyte ^= 0x80 newcandidates = [] for x in candidates : for c in range ( 256 ): if MD5 . new ( x + chr ( c )) . digest ()[ - 1 ] == chr ( lastbyte ): newcandidates . append ( x + chr ( c )) candidates = newcandidates print candidates return candidates def main (): bypassproof () # result of encrypted Welcome!! iv_encrypt , cipher_welcome = recvmsg () log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-token get_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-token\" ), iv_encrypt ) sendmsg ( get_token_iv , cipher_welcome ) _ , cipher_token = recvmsg () token_len = only ( cipher_token ) log . info ( \"cipher token is : \" + cipher_token ) # get command not found cipher sendmsg ( iv_encrypt , cipher_welcome ) _ , cipher_notfound = recvmsg () # get encrypted(token[:i+1]),57 times md5_token_idx_list = get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ) # get md5map for each unpadsize, 209-17 times # when upadsize>208, it will unpad ciphertoken # then we can reuse md5map = dict () for unpadsize in range ( 17 , 209 ): log . info ( \"get unpad size {} cipher\" . format ( unpadsize )) get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" ## calculate the proper last byte number, only change the last byte ## set last_byte_iv = iv_encrypted[:15] | proper byte last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"Welcome!!\" )[: 15 ] + chr ( unpadsize ), iv_encrypt ) cipher = cipher_token + padding + last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () md5map [ unpadcipher ] = unpadsize # reuse encrypted(token[:i+1]) for i in range ( 209 , 256 ): target = md5_token_idx_list [ 56 - ( i - 209 )] md5map [ target ] = i candidates = [ \"\" ] # get the byte token[i], only 56 byte for i in range ( token_len - 7 ): log . info ( \"get token[ {} ]\" . format ( i )) get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list [ i ] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () # already in or md5[token[:i]][-1]='\\x00' if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 1 ) else : log . info ( & quot ; unpad size 1 - 16 & quot ;) # flip most significant bit of last byte to move it in a good range cipher = cipher [: - 17 ] + strxor ( cipher [ - 17 ], ' \\x80 ' ) + cipher [ - 16 :] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 0 ) else : log . info ( 'oh my god,,,, it must be in...' ) exit () print len ( candidates ) # padding 0x01 candidates = filter ( lambda x : x [ - 1 ] == chr ( 0x01 ), candidates ) # only 56 bytes candidates = [ x [: - 1 ] for x in candidates ] print len ( candidates ) assert ( len ( candidates [ 0 ]) == 56 ) # check-token check_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"check-token\" ), iv_encrypt ) sendmsg ( check_token_iv , cipher_welcome ) p . recvuntil ( \"Give me the token! \\n \" ) p . sendline ( base64 . b64encode ( candidates [ 0 ])) print p . recv () p . interactive () if __name__ == \"__main__\" : main () The effect is as follows ... 79 1 hitcon { uNp @ d_M3th0D_i5_am4Z1n9! } Teaser Dragon CTF 2018 AES-128-TSB \u00b6 This topic is still very interesting, the title is described as follows Haven't you ever thought that GCM mode is overcomplicated and there must be a simpler way to achieve Authenticated Encryption? Here it is! Server: aes-128-tsb.hackable.software 1337 server.py The attachment and the final exp are found by the ctf-challenge repository. The basic process of the topic is Continuously receive two strings a and b, where a is plaintext and b is ciphertext, note b needs to satisfy the tail just equal to iv after decryption. if a and b are equal, then a is gimme_flag and the encrypted flag is output. Otherwise, output a string of randomly encrypted strings. Otherwise output a string of plain text. In addition, we can also find that there is a problem with the unpad in the title, and the specified length can be truncated. def unpad ( msg ): if not msg : return '' return msg [: - ord ( msg [ - 1 ])] In the beginning, the very straightforward idea is to enter 0 for the lengths of a and b, then you can bypass the a==b check to get a string of random ciphertext encrypted strings. However, it does not seem to have any effect, let's analyze the encryption process. def tsb_encrypt ( aes , msg ): msg = pad ( msg ) iv = get_random_bytes ( 16 ) prev_pt = iv prev_ct = iv ct = '' for block in split_by ( msg , 16 ) + [ iv ]: ct_block = xor ( block , prev_pt ) ct_block = aes . encrypt ( ct_block ) ct_block = xor ( ct_block , prev_ct ) ct += ct_block prev_pt = block prev_ct = ct_block return iv + ct Let's assume that P_0=iv, C_0=iv P_0=iv, C_0=iv , then C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) So, assuming the message length is 16, similar to the length of the gimme_flag padding we want to get, then $ C_1 = IV oplus E (IV oplus P_1) $ C_2=C_1 \\oplus E(P_1 \\oplus IV) C_2=C_1 \\oplus E(P_1 \\oplus IV) It is easy to find C_2=IV C_2=IV . ([Pirates] ( https://github.com/pberba/ctf-solutions/tree/master/20180929_teaser_dragon/aes_128_tsb ), the picture below is clearer Conversely, if we send iv+c+iv to the server, we can always bypass the tsb_decrypt mac check. def tsb_decrypt ( aes , msg ): iv , msg = msg [: 16 ], msg [ 16 :] prev_pt = iv prev_ct = iv pt = & #39;&#39; for block in split_by ( msg , 16 ): pt_block = xor ( block , prev_ct ) pt_block = aes . decrypt ( pt_block ) pt_block = xor ( pt_block , prev_pt ) pt += pt_block prev_pt = pt_block prev_ct = block pt , mac = pt [: - 16 ], pt [ - 16 :] if mac != iv : raise CryptoError () return unpad ( pt ) Then at this point, the message decrypted by the server is $ unpad (IV oplus D (C_1 oplus IV)) $ Get the last byte of the plaintext \u00b6 We can consider controlling the D decrypted message as a constant value, such as all zeros, ie C1=IV , then we can enumerate the last byte of the IV from 0 to 255, get $IV \\oplus D(C_1 \\oplus IV) The last byte of $ is also 0~255. Only when it is 1~15, after the unpad operation, the message length is not 0. Therefore, we can count which numbers cause the length to be non-zero and enumerate as 1 and the remaining flags to 0. def getlast_byte ( iv , block ): iv_pre = iv [: 15 ] iv_last = words ( iv [ - 1 ]) tmp = [] print ( 'get last byte' ) for i in range ( 256 ): send_data ( '' ) iv = iv_pre + chr ( i ) tmpblock = block [: 15 ] + chr ( i ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' in data : tmp . append ( 1 ) else : tmp . append ( 0 ) last_bytes = [] for i in range ( 256 ): if tmp == xor_byte_map [ i ][ 0 ]: last_bytes . append ( xor_byte_map [ i ][ 1 ]) print ( 'possible last byte is ' + str ( last_bytes )) return last_bytes In addition, we can get all the possible cases of the last byte at the beginning of the table, recorded in xor_byte_map. \"\"\" every item is a pair [a,b] a is the xor list b is the idx which is zero when xored \"\"\" xor_byte_map = [] for i in range ( 256 ): a = [] b = 0 for j in range ( 256 ): tmp = i ^ j if tmp > 0 and tmp <= 15 : a . append ( 1 ) else : a . append ( 0 ) if tmp == 0 : b = j xor_byte_map . append ([ a , b ]) By comparing this table, we can know what is possible with the last byte. Decrypt any encrypted block \u00b6 After obtaining the last byte of the plaintext, we can use the unpad vulnerability to get the corresponding plaintext content from length 1 to length 15. def dec_block ( iv , block ): last_bytes = getlast_byte ( iv , block ) iv_pre = iv [: 15 ] iv_last = words ( iv [ - 1 ]) print ( 'try to get plain' ) plain0 = & #39;&#39; for last_byte in last_bytes : plain0 = & #39;&#39; for i in range ( 15 ): print 'idx:' , i tag = false for j in range ( 256 ): send_data ( plain0 + chr ( j )) pad_size = 15 - i iv = iv_pre + chr ( pad_size ^ last_byte ) tmpblock = block [: 15 ] + chr ( pad_size ^ last_byte ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' not in data : # success plain0 + = chr ( j ) tag = True break if not tag : break # means the last byte is ok if plain0 != '' : break plain0 += chr ( iv_last ^ last_byte ) return plain0 Decrypt the specified plaintext \u00b6 This is relatively simple, we hope to use this to get the ciphertext of gimme_flag print ( 'get the cipher of flag' ) gemmi_iv1 = xor ( pad ( 'gimme_flag' ), plain0 ) gemmi_c1 = xor ( gemmi_iv1 , cipher0 ) payload = gemmi_iv1 + gemmi_c1 + gemmi_iv1 send_data ( 'gimme_flag' ) send_data ( payload ) flag_len , flag_cipher = recv_data () Where plain0 and cipher0 are the clear ciphertext pairs we obtained for AES encryption, excluding the two exclusive ORs before and after. Decrypt flag \u00b6 This point is actually achieved by the function of decrypting any encrypted block, as follows print ( 'the flag cipher is ' + flag_cipher . encode ( 'hex' )) flag_cipher = split_by ( flag_cipher , 16 ) print ( 'decrypt the blocks one by one' ) plain = '' for i in range ( len ( flag_cipher ) - 1 ): print ( 'block: ' + str ( i )) if i == 0 : plain += dec_block ( flag_cipher [ i ], flag_cipher [ i + 1 ]) else : iv = plain [ - 16 :] cipher = xor ( xor ( iv , flag_cipher [ i + 1 ]), flag_cipher [ i ]) plain += dec_block ( iv , cipher ) pass print ( 'now plain: ' + plain ) print plain Think about why the ciphertext operation after the second block will be different. The complete code references the ctf-challenge repository. References \u00b6 [Packet Encryption Mode] ( https://en.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5 % E4%BD%9C%E6%A8%A1%E5%BC%8F) https://en.wikipedia.org/wiki/Padding_oracle_attack http://netifera.com/research/poet/PaddingOraclesEverywhereEkoparty2010.pdf https://ctftime.org/writeup/7975 https://ctftime.org/writeup/7974","title":"Padding Oracle Attack"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#padding-oracle-attack","text":"","title":"Padding Oracle Attack"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#introduction","text":"Padding Oracle Attack attacks generally need to meet the following conditions Encryption Algorithm Encryption algorithm using PKCS5 Padding. Of course, the way OAEP is filled in asymmetric encryption may also be affected. The grouping mode is CBC mode. Attacker ability An attacker can intercept messages encrypted by the above encryption algorithm. The attacker can interact with the padding oracle (the server): the client sends the ciphertext to the server, and the server will use some kind of return information to inform the client whether the padding is normal. Padding Oracle Attack can achieve the following effects Decrypt any given ciphertext without knowing the key and IV.","title":"Introduction"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#principle","text":"The basic principles of the Padding Oracle Attack attack are as follows Decrypt a very long message piece by piece. For each message, first decrypt the last byte of the message, then decrypt the second to last byte, and so on. Here we review the CBC Encryption $$ C_i=E_K(P_i \\oplus C_{i-1})\\ IV = C_0 $$ Decryption $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ We mainly focus on decryption, we don't know IV and key here. Here we assume that the length of the ciphertext block is n bytes. Suppose we intercepted ciphertext Y to obtain the last byte of ciphertext Y as an example for analysis. In order to obtain the content of Y, we first need to forge a piece of ciphertext F so that the last byte of the plaintext corresponding to Y can be modified. This is because if we construct the ciphertext F|Y , then the decryption Y is specifically $$ P = D_K (Y) oplus F $$ So modify the last byte of ciphertext F, F_{n} F_{n} , to modify the last byte of the plaintext corresponding to Y. The process of getting the last byte of P is given below. i=0, set each byte of F to be random byte . Set F_n=i \\oplus 0x01 F_n=i \\oplus 0x01 Send F|Y to the server. If the last byte of P is i, then the last padding is 0x01 and no error will occur. Otherwise, only the last P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 bytes of P are P_n \\oplus i \\oplus 0x01 P_n \\oplus i \\oplus 0x01 and no error will be reported. Also, note that the padding bytes can only be 0 to n. Therefore, if you want to make the error in the case of F randomly and satisfy the padding byte size, the probability is small**. So in the case of no error on the server side, we can think that we did get the correct bytes. In the event of an error, i=i+1, jump to 2. After getting the last byte of P, we can continue to get the second-to-last byte of P. In this case, we need to set F_n=P_n\\oplus 0x02 F_n=P_n\\oplus 0x02 and set F_{n-1}=i \\oplus 0x02 F_{n-1}=i \\oplus 0x02 to enumerate i. So, in summary, Padding Oracle Attack is actually a method of attack with a high probability of success. However, it's important to note that some of the real-world problems that are often encountered are not the standard Padding Oracle Attack mode, and we often need to make some changes.","title":"Principle"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#2017-hitcon-secret-server","text":"","title":"2017 HITCON Secret Server"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#analysis","text":"The encryption used in the program is AES CBC, which uses padding similar to PKCS5. def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] However, in each unpad, no detection is performed, but the unpad is directly executed. Among them, it should be noted that the function that interacts with the user each time is send_msg , accepts the user's plaintext, encrypts it with a fixed 2jpmLoSsOlQrqyqE , and outputs the encrypted result. recv_msg , accepts the user's IV and ciphertext, decrypts the ciphertext, and returns. There will be different actions depending on the results returned. msg = recv_msg () . strip () if msg . startswith ( 'exit-here' ): exit ( 0 ) elif msg . startswith ( 'get-flag' ): send_msg ( flag ) elif msg . startswith ( 'get-md5' ): send_msg ( MD5 . new ( msg [ 7 :]) . digest ()) elif msg . startswith ( 'get-time' ): send_msg ( str ( time . time ())) elif msg . startswith ( 'get-sha1' ): send_msg ( SHA . new ( msg [ 8 :]) . digest ()) elif msg . startswith ( 'get-sha256' ): send_msg ( SHA256 . new ( msg [ 10 :]) . digest ()) elif msg . startswith ( 'get-hmac' ): send_msg ( HMAC . new ( msg [ 8 :]) . digest ()) else : send_msg ( 'command not found' )","title":"Analysis"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#main-vulnerabilities","text":"Here we briefly summarize the parts we have. Encryption The IV when encrypting is fixed and known. 'Welcome!!' Encrypted result. Decryption We can control IV. First of all, since we know the result of the Welcome!! encryption, we can also control the IV in recv_msg, then according to the decryption process $$ P_{i}=D_{K}(C_{i})\\oplus C_{i-1}\\ C_{0}=IV $$ If we enter the encrypted result of Welcome!! into recv_msg, the result of direct decryption is (Welcome!!+&#39;\\x07&#39;*7) xor iv , if we properly control the decryption process In the iv passed, then we can control the decrypted result. In other words, we can execute any of the commands described above**. Thus, we can also know the result of the flag decryption. Secondly, on the above basis, if we add the custom IV and Welcome encrypted result after any ciphertext C and pass it to recv_msg as input, then we can control the last byte of the message after decryption. So due to the unpad operation, we can control the length of the decrypted message to be reduced from 0 to 255 .","title":"Main Vulnerabilities"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#using-ideas","text":"Basic use ideas are as follows Bypass proof of work 2. Obtain the encrypted flag according to the way you execute any command. 3. Since the beginning of the flag is hitcon{ , there are 7 bytes in total, so we can still control the iv to make the first 7 bytes after decryption the specified byte. This allows us to execute the get-md5 command on the decrypted message. According to the unpad operation, we can control the decrypted message exactly at the first few bytes of the message. So we can start controlling the decrypted message as hitcon{x , that is, only one byte after hitcon{ . This will result in an encrypted result with a one-byte hash. Similarly, we can also get the result of the encryption with a byte hash. 4. In this case, we can blast locally byte by byte, calculate the corresponding md5 , and then use the arbitrary command execution mode to control the decrypted plaintext to any specified command. If the control is unsuccessful, it means that the byte is incorrect. , need to blast again; if it is correct, then you can directly execute the corresponding command. The specific code is as follows #coding=utf-8 from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' if args [ 'REMOTE' ]: p = remote ( '52.193.157.19' , 9999 ) else : p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): Return msg [: - ord ( msg [ - 1 ])] # Remove the pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) p . recvuntil ( 'Done! \\n ' ) iv_encrypt = '2jpmLoSsOlQrqyqE' def getmd5enc ( i , cipher_flag , cipher_welcome ): \"\"\"return encrypt( md5( flag[7:7+i] ) )\"\"\" ## keep iv[7:] do not change, so decrypt won't change new_iv = flipplain ( & quot ; hitcon { & quot ; . bright ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . light ( 16 , ' \\x00 ' ), iv_encrypt ) payload = new_iv + cipher_flag ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_flag ) + 16 + 16 - ( 7 + i + 1 )), iv_encrypt ) payload += last_byte_iv + cipher_welcome p . sendline ( base64 . b64encode ( payload )) return p . recvuntil ( \" \\n \" , drop = True ) def main (): bypassproof () # result of encrypted Welcome!! cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_welcome = base64 . b64decode ( cipher )[ 16 :] log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-flag get_flag_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-flag\" ), iv_encrypt ) payload = base64 . b64encode ( get_flag_iv + cipher_welcome ) p . sendline ( payload ) cipher = p . recvuntil ( ' \\n ' , drop = True ) cipher_flag = base64 . b64decode ( cipher )[ 16 :] flaglen = len ( cipher_flag ) log . info ( \"cipher flag is : \" + cipher_flag ) # get command not found cipher p . sendline ( base64 . b64encode ( iv_encrypt + cipher_welcome )) cipher_notfound = p . recvuntil ( ' \\n ' , drop = True ) flag = \"\" # brute force for every byte of flag for i in range ( flaglen - 7 ): md5_indexi = getmd5enc ( i , cipher_flag , cipher_welcome ) md5_indexi = base64 . b64decode ( md5_indexi ) [ 16 :] log . info ( \"get encrypt(md5(flag[7:7+i])): \" + md5_indexi ) for guess in range ( 256 ): # locally compute md5 hash guess_md5 = MD5 . new ( flag + chr ( guess )) . digest () # try to null out the md5 plaintext and execute a command payload = flipplain ( guess_md5 , 'get-time' . ljust ( 16 , ' \\x01 ' ), iv_encrypt ) payload += md5_indexi p . sendline ( base64 . b64encode ( payload )) res = p . recvuntil ( \" \\n \" , drop = True ) # if we receive the block for 'command not found', the hash was wrong if res == cipher_notfound : print 'Guess {} is wrong.' . format ( guess ) # otherwise we correctly guessed the hash and the command was executed else : print 'Found!' flag += chr ( guess ) print 'Flag so far:' , flag break if __name__ == \"__main__\" : main () The final result is as follows Flag so far: Paddin9_15_ve3y_h4rd__!! } \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10 \\x 10","title":"Using ideas"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#2017-hitcon-secret-server-revenge","text":"","title":"2017 HITCON Secret Server Revenge"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#description","text":"The password of zip is the flag of \"Secret Server\"","title":"Description"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#analysis_1","text":"This program continues with the above program, but this time a simple modification The iv of the encryption algorithm is unknown, but can be derived from the message encrypted by Welcome. The program has a 56-byte token. The program can perform up to 340 operations, so the above blasting is naturally not feasible The general process of the program is as follows After proof of work 2. Send \"Welcome!!\" encrypted message 3. In 340 operations, you need to guess the value of the token and then automatically output the flag.","title":"Analysis"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#vulnerability","text":"Of course, the loopholes in the previous topic still exist in this topic, namely Execute the given command arbitrarily Length truncation","title":"Vulnerability"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#using-ideas_1","text":"Due to the limitation of the number of 340, although we can still get the value of md5(token[:i]) encrypted ( here we need to pay attention to this part of the encryption is exactly 32 bytes, the first 16 bytes are The value after md5 is encrypted, the next 16 bytes are completely filled with encrypted bytes. Here md5(token[:i]) refers specifically to the first 16 bytes.). However, we can't blast 256 times again in order to get a character. Since it is not possible to blast, is it possible to get the size of one byte at a time? Here, let's take a look at the information that the program may leak. The encrypted value of the md5 value of some messages. Here we can get the encrypted value of md5(token[:i]) . Unpad will unmap the decrypted message each time. This byte is determined based on the last byte of the decrypted message. If we can calculate the size of this byte, then we may know the value of a byte. Here we delve into the information leak of unpad. If we put the encryption IV and encrypt(md5(token[:i])) after a ciphertext C to form C|IV|encrypt(md5(token[:i])) , then decrypt The last plaintext block of the outgoing message is md5(token[:i]) . Furthermore, in the unpad, the last byte (0-255) of md5(token[:i]) is used for unpad, and then the specified command (such as md5) is executed on the string after the unpad. Then, if we pre-configure some hashed samples after the message hash, and then compare the results of the above execution with the sample, if they are the same, then we can basically determine the md5(token[:i]) * * Last byte . However, if the last byte of md5(token[:i]) is less than 16, then some values in md5 will be used in unpad, and this part of the value, due to token[:i] for different lengths Almost all will not be the same. So special handling may be required. We already know the key to this problem, which is to generate a sample of the encrypted result corresponding to the size of the unpad byte, in order to facilitate the lookup table. The specific use ideas are as follows Bypass proof of work. Get the token encrypted result token_enc , which will add 7 bytes &quot;token: &quot; in front of the token. Therefore, the length after encryption is 64. Get the result of encrypt(md5(token[:i])) , which is a total of 57, including the padding of the last token. Construct a sample that corresponds to the size of the unpad. Here we construct the ciphertext token_enc|padding|IV_indexi|welcome_enc . Since IV_indexi is to modify the last byte of the last plaintext block, the byte is in the process of being changed. If we want to get some fixed byte hashes, this part can't be added naturally. Therefore, the size of the unpad ranges from 17 to 255 when the sample is generated here. If the last byte of md5(token[:i]) is less than 17 at the end of the test, there will be some unknown samples. A natural idea is that we directly get 255-17+1 such multiple samples, however, if we do this, according to the number of times above 340 (255-17+1+57+56>340), we obviously can't Get all the bytes to the token. So here we need to find ways to reuse some content, here we choose to reuse the result of encrypt(md5(token[:i])) . Then we need to ensure that the number of times is sufficient on the one hand, and on the other hand, the previous results can be reused. Here we set the unpad loop to 17 to 208, and make the unpad more than 208 when we just unpad to where we can reuse. It should be noted here that when the last byte of md5(token[:i]) is 0, all decrypted plaintext unpad will be dropped, so the ciphertext of command not found will appear. Construct the ciphertext token_enc|padding|IV|encrypt(md5(token[:i])) again, then use the last byte of md5(token[:i]) for unpad when decrypting. If this byte is not less than 17 or 0, it can be processed. If this byte is less than 17, then obviously, the result of the last md5 returned to the user is not within the sample range, then we modify the highest bit of its last byte so that it can fall within the sample range after the unpad. In this way, we can guess the last byte of md5(token[:i]) . After guessing the last byte of md5(token[:i]) , we can brute 256 times locally and find out that all hashes are at the end of md5(token[:i]) The last byte of the character. However, in the sixth step, for a md5(token[:i]) we may find multiple alternative characters because we only need to make the last byte of the given byte. So, the question is, how do you delete some extra candidate strings? Here I chose a small trick, which enumerates the padding of the token at the same time as the byte-by-byte enumeration. Since padding is fixed at 0x01, we only need to filter out all tokens that are not 0x01 at the end. Here, the sleep in the code is commented out during the test. In order to speed up the interaction. Use the code as follows from pwn import * import base64 , time , random , string from Crypto.Cipher import AES from Crypto.Hash import SHA256 , MD5 #context.log_level = 'debug' p = remote ( '127.0.0.1' , 7777 ) def strxor ( str1 , str2 ): return '' . join ([ chr ( ord ( c1 ) ^ ord ( c2 )) for c1 , c2 in zip ( str1 , str2 )]) def pad ( msg ): pad_length = 16 - len ( msg ) % 16 return msg + chr ( pad_length ) * pad_length def unpad ( msg ): return msg [: - ord ( msg [ - 1 ])] # remove pad def flipplain ( oldplain , newplain , iv ): \"\"\"flip oldplain to new plain, return proper iv\"\"\" return strxor ( strxor ( oldplain , newplain ), iv ) def bypassproof (): p . recvuntil ( 'SHA256(XXXX+' ) lastdata = p . recvuntil ( ')' , drop = True ) p . recvuntil ( ' == ' ) digest = p . recvuntil ( ' \\n Give me XXXX:' , drop = True ) def proof ( s ): return SHA256 . new ( s + lastdata ) . hexdigest () == digest data = pwnlib . util . iters . mbruteforce ( proof , string . ascii_letters + string . digits , 4 , method = 'fixed' ) p . sendline ( data ) def sendmsg ( iv , cipher ): payload = iv + cipher payload = base64 . b64encode ( payload ) p . sendline ( payload ) def recvmsg (): data = p . recvuntil ( \" \\n \" , drop = True ) data = base64 . b64decode ( data ) return data [: 16 ], data [ 16 :] def getmd5enc ( i , cipher_token , cipher_welcome , iv ): \"\"\"return encrypt( md5( token[:i+1] ) )\"\"\" ## keep iv[7:] do not change, so decrypt msg[7:] won't change get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv ) payload = cipher_token ## calculate the proper last byte number last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), \"a\" * 15 + chr ( len ( cipher_token ) + 16 + 16 - ( 7 + i + 1 )), iv ) payload += last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , payload ) return recvmsg () def get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ): md5_token_idxi = [] for i in range ( len ( cipher_token ) - 7 ): log . info ( \"idx i: {} \" . format ( i )) _ , md5_indexi = getmd5enc ( i , cipher_token , cipher_welcome , iv_encrypt ) assert ( only ( md5_indexi ) == 32 ) # remove the last 16 byte for padding md5_token_idxi . append ( md5_indexi [: 16 ]) return md5_token_idxi def doin ( unpadcipher , md5map , candidates , flag ): if unpadcipher in md5map : lastbyte = md5map [ unpadcipher ] else : lastbyte = 0 if flag == 0 : lastbyte ^= 0x80 newcandidates = [] for x in candidates : for c in range ( 256 ): if MD5 . new ( x + chr ( c )) . digest ()[ - 1 ] == chr ( lastbyte ): newcandidates . append ( x + chr ( c )) candidates = newcandidates print candidates return candidates def main (): bypassproof () # result of encrypted Welcome!! iv_encrypt , cipher_welcome = recvmsg () log . info ( \"cipher welcome is : \" + cipher_welcome ) # execute get-token get_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"get-token\" ), iv_encrypt ) sendmsg ( get_token_iv , cipher_welcome ) _ , cipher_token = recvmsg () token_len = only ( cipher_token ) log . info ( \"cipher token is : \" + cipher_token ) # get command not found cipher sendmsg ( iv_encrypt , cipher_welcome ) _ , cipher_notfound = recvmsg () # get encrypted(token[:i+1]),57 times md5_token_idx_list = get_md5_token_indexi ( iv_encrypt , cipher_welcome , cipher_token ) # get md5map for each unpadsize, 209-17 times # when upadsize>208, it will unpad ciphertoken # then we can reuse md5map = dict () for unpadsize in range ( 17 , 209 ): log . info ( \"get unpad size {} cipher\" . format ( unpadsize )) get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" ## calculate the proper last byte number, only change the last byte ## set last_byte_iv = iv_encrypted[:15] | proper byte last_byte_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"Welcome!!\" )[: 15 ] + chr ( unpadsize ), iv_encrypt ) cipher = cipher_token + padding + last_byte_iv + cipher_welcome sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () md5map [ unpadcipher ] = unpadsize # reuse encrypted(token[:i+1]) for i in range ( 209 , 256 ): target = md5_token_idx_list [ 56 - ( i - 209 )] md5map [ target ] = i candidates = [ \"\" ] # get the byte token[i], only 56 byte for i in range ( token_len - 7 ): log . info ( \"get token[ {} ]\" . format ( i )) get_md5_iv = flipplain ( & quot ; token : & quot ; . lit ( 16 , & quot ; x00 & quot ;), & quot ; get - md5 & quot ; . 16 , ' \\x00 ' ), iv_encrypt ) ## padding 16*11 bytes padding = 16 * 11 * \"a\" cipher = cipher_token + padding + iv_encrypt + md5_token_idx_list [ i ] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () # already in or md5[token[:i]][-1]='\\x00' if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 1 ) else : log . info ( & quot ; unpad size 1 - 16 & quot ;) # flip most significant bit of last byte to move it in a good range cipher = cipher [: - 17 ] + strxor ( cipher [ - 17 ], ' \\x80 ' ) + cipher [ - 16 :] sendmsg ( get_md5_iv , cipher ) _ , unpadcipher = recvmsg () if unpadcipher in md5map or unpadcipher == cipher_notfound : candidates = doin ( unpadcipher , md5map , candidates , 0 ) else : log . info ( 'oh my god,,,, it must be in...' ) exit () print len ( candidates ) # padding 0x01 candidates = filter ( lambda x : x [ - 1 ] == chr ( 0x01 ), candidates ) # only 56 bytes candidates = [ x [: - 1 ] for x in candidates ] print len ( candidates ) assert ( len ( candidates [ 0 ]) == 56 ) # check-token check_token_iv = flipplain ( pad ( \"Welcome!!\" ), pad ( \"check-token\" ), iv_encrypt ) sendmsg ( check_token_iv , cipher_welcome ) p . recvuntil ( \"Give me the token! \\n \" ) p . sendline ( base64 . b64encode ( candidates [ 0 ])) print p . recv () p . interactive () if __name__ == \"__main__\" : main () The effect is as follows ... 79 1 hitcon { uNp @ d_M3th0D_i5_am4Z1n9! }","title":"Using ideas"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#teaser-dragon-ctf-2018-aes-128-tsb","text":"This topic is still very interesting, the title is described as follows Haven't you ever thought that GCM mode is overcomplicated and there must be a simpler way to achieve Authenticated Encryption? Here it is! Server: aes-128-tsb.hackable.software 1337 server.py The attachment and the final exp are found by the ctf-challenge repository. The basic process of the topic is Continuously receive two strings a and b, where a is plaintext and b is ciphertext, note b needs to satisfy the tail just equal to iv after decryption. if a and b are equal, then a is gimme_flag and the encrypted flag is output. Otherwise, output a string of randomly encrypted strings. Otherwise output a string of plain text. In addition, we can also find that there is a problem with the unpad in the title, and the specified length can be truncated. def unpad ( msg ): if not msg : return '' return msg [: - ord ( msg [ - 1 ])] In the beginning, the very straightforward idea is to enter 0 for the lengths of a and b, then you can bypass the a==b check to get a string of random ciphertext encrypted strings. However, it does not seem to have any effect, let's analyze the encryption process. def tsb_encrypt ( aes , msg ): msg = pad ( msg ) iv = get_random_bytes ( 16 ) prev_pt = iv prev_ct = iv ct = '' for block in split_by ( msg , 16 ) + [ iv ]: ct_block = xor ( block , prev_pt ) ct_block = aes . encrypt ( ct_block ) ct_block = xor ( ct_block , prev_ct ) ct += ct_block prev_pt = block prev_ct = ct_block return iv + ct Let's assume that P_0=iv, C_0=iv P_0=iv, C_0=iv , then C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) C_i=C_{i-1}\\oplus E(P_{i-1} \\oplus P_i) So, assuming the message length is 16, similar to the length of the gimme_flag padding we want to get, then $ C_1 = IV oplus E (IV oplus P_1) $ C_2=C_1 \\oplus E(P_1 \\oplus IV) C_2=C_1 \\oplus E(P_1 \\oplus IV) It is easy to find C_2=IV C_2=IV . ([Pirates] ( https://github.com/pberba/ctf-solutions/tree/master/20180929_teaser_dragon/aes_128_tsb ), the picture below is clearer Conversely, if we send iv+c+iv to the server, we can always bypass the tsb_decrypt mac check. def tsb_decrypt ( aes , msg ): iv , msg = msg [: 16 ], msg [ 16 :] prev_pt = iv prev_ct = iv pt = & #39;&#39; for block in split_by ( msg , 16 ): pt_block = xor ( block , prev_ct ) pt_block = aes . decrypt ( pt_block ) pt_block = xor ( pt_block , prev_pt ) pt += pt_block prev_pt = pt_block prev_ct = block pt , mac = pt [: - 16 ], pt [ - 16 :] if mac != iv : raise CryptoError () return unpad ( pt ) Then at this point, the message decrypted by the server is $ unpad (IV oplus D (C_1 oplus IV)) $","title":"Teaser Dragon CTF 2018 AES-128-TSB"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#get-the-last-byte-of-the-plaintext","text":"We can consider controlling the D decrypted message as a constant value, such as all zeros, ie C1=IV , then we can enumerate the last byte of the IV from 0 to 255, get $IV \\oplus D(C_1 \\oplus IV) The last byte of $ is also 0~255. Only when it is 1~15, after the unpad operation, the message length is not 0. Therefore, we can count which numbers cause the length to be non-zero and enumerate as 1 and the remaining flags to 0. def getlast_byte ( iv , block ): iv_pre = iv [: 15 ] iv_last = words ( iv [ - 1 ]) tmp = [] print ( 'get last byte' ) for i in range ( 256 ): send_data ( '' ) iv = iv_pre + chr ( i ) tmpblock = block [: 15 ] + chr ( i ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' in data : tmp . append ( 1 ) else : tmp . append ( 0 ) last_bytes = [] for i in range ( 256 ): if tmp == xor_byte_map [ i ][ 0 ]: last_bytes . append ( xor_byte_map [ i ][ 1 ]) print ( 'possible last byte is ' + str ( last_bytes )) return last_bytes In addition, we can get all the possible cases of the last byte at the beginning of the table, recorded in xor_byte_map. \"\"\" every item is a pair [a,b] a is the xor list b is the idx which is zero when xored \"\"\" xor_byte_map = [] for i in range ( 256 ): a = [] b = 0 for j in range ( 256 ): tmp = i ^ j if tmp > 0 and tmp <= 15 : a . append ( 1 ) else : a . append ( 0 ) if tmp == 0 : b = j xor_byte_map . append ([ a , b ]) By comparing this table, we can know what is possible with the last byte.","title":"Get the last byte of the plaintext"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#decrypt-any-encrypted-block","text":"After obtaining the last byte of the plaintext, we can use the unpad vulnerability to get the corresponding plaintext content from length 1 to length 15. def dec_block ( iv , block ): last_bytes = getlast_byte ( iv , block ) iv_pre = iv [: 15 ] iv_last = words ( iv [ - 1 ]) print ( 'try to get plain' ) plain0 = & #39;&#39; for last_byte in last_bytes : plain0 = & #39;&#39; for i in range ( 15 ): print 'idx:' , i tag = false for j in range ( 256 ): send_data ( plain0 + chr ( j )) pad_size = 15 - i iv = iv_pre + chr ( pad_size ^ last_byte ) tmpblock = block [: 15 ] + chr ( pad_size ^ last_byte ^ ord ( block [ - 1 ]) ^ iv_last ) payload = iv + tmpblock + iv send_data ( payload ) length , data = recv_data () if 'Looks' not in data : # success plain0 + = chr ( j ) tag = True break if not tag : break # means the last byte is ok if plain0 != '' : break plain0 += chr ( iv_last ^ last_byte ) return plain0","title":"Decrypt any encrypted block"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#decrypt-the-specified-plaintext","text":"This is relatively simple, we hope to use this to get the ciphertext of gimme_flag print ( 'get the cipher of flag' ) gemmi_iv1 = xor ( pad ( 'gimme_flag' ), plain0 ) gemmi_c1 = xor ( gemmi_iv1 , cipher0 ) payload = gemmi_iv1 + gemmi_c1 + gemmi_iv1 send_data ( 'gimme_flag' ) send_data ( payload ) flag_len , flag_cipher = recv_data () Where plain0 and cipher0 are the clear ciphertext pairs we obtained for AES encryption, excluding the two exclusive ORs before and after.","title":"Decrypt the specified plaintext"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#decrypt-flag","text":"This point is actually achieved by the function of decrypting any encrypted block, as follows print ( 'the flag cipher is ' + flag_cipher . encode ( 'hex' )) flag_cipher = split_by ( flag_cipher , 16 ) print ( 'decrypt the blocks one by one' ) plain = '' for i in range ( len ( flag_cipher ) - 1 ): print ( 'block: ' + str ( i )) if i == 0 : plain += dec_block ( flag_cipher [ i ], flag_cipher [ i + 1 ]) else : iv = plain [ - 16 :] cipher = xor ( xor ( iv , flag_cipher [ i + 1 ]), flag_cipher [ i ]) plain += dec_block ( iv , cipher ) pass print ( 'now plain: ' + plain ) print plain Think about why the ciphertext operation after the second block will be different. The complete code references the ctf-challenge repository.","title":"Decrypt flag"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-oracle-attack/#references","text":"[Packet Encryption Mode] ( https://en.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5 % E4%BD%9C%E6%A8%A1%E5%BC%8F) https://en.wikipedia.org/wiki/Padding_oracle_attack http://netifera.com/research/poet/PaddingOraclesEverywhereEkoparty2010.pdf https://ctftime.org/writeup/7975 https://ctftime.org/writeup/7974","title":"References"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/","text":"EN | ZH \u586b\u5145\u89c4\u5219 \u00b6 \u6b63\u5982\u6211\u4eec\u4e4b\u524d\u6240\u8bf4\uff0c\u5728\u5206\u7ec4\u52a0\u5bc6\u4e2d\uff0c\u660e\u6587\u7684\u957f\u5ea6\u5f80\u5f80\u5e76\u4e0d\u6ee1\u8db3\u8981\u6c42\uff0c\u9700\u8981\u8fdb\u884c padding\uff0c\u800c\u5982\u4f55 padding \u76ee\u524d\u4e5f\u5df2\u7ecf\u6709\u4e86\u4e0d\u5c11\u7684\u89c4\u5b9a\u3002 \u5e38\u89c1\u7684 \u586b\u5145\u89c4\u5219 \u5982\u4e0b\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5373\u4f7f\u6d88\u606f\u7684\u957f\u5ea6\u662f\u5757\u5927\u5c0f\u7684\u6574\u6570\u500d\uff0c\u4ecd\u7136\u9700\u8981\u586b\u5145\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u5982\u679c\u5728\u89e3\u5bc6\u4e4b\u540e\u53d1\u73b0 Padding \u4e0d\u6b63\u786e\uff0c\u5219\u5f80\u5f80\u4f1a\u629b\u51fa\u5f02\u5e38\u3002\u6211\u4eec\u4e5f\u56e0\u6b64\u53ef\u4ee5\u77e5\u9053 Paddig \u662f\u5426\u6b63\u786e\u3002 Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding) \u00b6 \u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 05 05 05 05 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40 Pad with 0x80 followed by zero bytes (OneAndZeroes Padding) \u00b6 \u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 80 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40 \u8fd9\u91cc\u5176\u5b9e\u5c31\u662f\u548c md5 \u548c sha1 \u7684 padding \u5dee\u4e0d\u591a\u3002 Pad with zeroes except make the last byte equal to the number of padding bytes \u00b6 \u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8 Pad with zero (null) characters \u00b6 \u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75 Pad with spaces \u00b6 \u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 20 20 20 20 20 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25 2018 \u4e0a\u6d77\u5e02\u5927\u5b66\u751f\u7f51\u7edc\u5b89\u5168\u5927\u8d5b aessss \u00b6 \u6709\u65f6\u5019\u53ef\u4ee5\u9488\u5bf9\u4e00\u4e9b\u4f7f\u7528\u4e0d\u5f53\u7684 Padding \u8fdb\u884c\u653b\u51fb\u3002\u8fd9\u91cc\u4ee5 2018 \u4e0a\u6d77\u5e02\u5927\u5b66\u751f\u7f51\u7edc\u5b89\u5168\u5927\u8d5b\u7684\u4e00\u9053\u9898\u76ee\u4e3a\u4f8b\uff1a \u9898\u76ee\u811a\u672c\u5982\u4e0b\uff1a import random import sys import string from hashlib import sha256 import SocketServer from Crypto.Cipher import AES from secret import FLAG , IV , KEY class Task ( SocketServer . BaseRequestHandler ): def proof_of_work ( self ): proof = '' . join ( [ random . choice ( string . ascii_letters + string . digits ) for _ in xrange ( 20 )]) # print proof digest = sha256 ( proof ) . hexdigest () self . request . send ( \"sha256(XXXX+ %s ) == %s \\n \" % ( proof [ 4 :], digest )) self . request . send ( 'Give me XXXX:' ) x = self . request . recv ( 10 ) x = x . strip () if len ( x ) != 4 or sha256 ( x + proof [ 4 :]) . hexdigest () != digest : return False return True def pad ( self , s ): s += ( 256 - len ( s )) * chr ( 256 - len ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return '' . join ( ret [ 0 : - ord ( ret [ - 1 ])]) s_box = [ 0x63 , 0x7C , 0x77 , 0x7B , 0xF2 , 0x6B , 0x6F , 0xC5 , 0x30 , 0x01 , 0x67 , 0x2B , 0xFE , 0xD7 , 0xAB , 0x76 , 0xCA , 0x82 , 0xC9 , 0x7D , 0xFA , 0x59 , 0x47 , 0xF0 , 0xAD , 0xD4 , 0xA2 , 0xAF , 0x9C , 0xA4 , 0x72 , 0xC0 , 0xB7 , 0xFD , 0x93 , 0x26 , 0x36 , 0x3F , 0xF7 , 0xCC , 0x34 , 0xA5 , 0xE5 , 0xF1 , 0x71 , 0xD8 , 0x31 , 0x15 , 0x04 , 0xC7 , 0x23 , 0xC3 , 0x18 , 0x96 , 0x05 , 0x9A , 0x07 , 0x12 , 0x80 , 0xE2 , 0xEB , 0x27 , 0xB2 , 0x75 , 0x09 , 0x83 , 0x2C , 0x1A , 0x1B , 0x6E , 0x5A , 0xA0 , 0x52 , 0x3B , 0xD6 , 0xB3 , 0x29 , 0xE3 , 0x2F , 0x84 , 0x53 , 0xD1 , 0x00 , 0xED , 0x20 , 0xFC , 0xB1 , 0x5B , 0x6A , 0xCB , 0xBE , 0x39 , 0x4A , 0x4C , 0x58 , 0xCF , 0xD0 , 0xEF , 0xAA , 0xFB , 0x43 , 0x4D , 0x33 , 0x85 , 0x45 , 0xF9 , 0x02 , 0x7F , 0x50 , 0x3C , 0x9F , 0xA8 , 0x51 , 0xA3 , 0x40 , 0x8F , 0x92 , 0x9D , 0x38 , 0xF5 , 0xBC , 0xB6 , 0xDA , 0x21 , 0x10 , 0xFF , 0xF3 , 0xD2 , 0xCD , 0x0C , 0x13 , 0xEC , 0x5F , 0x97 , 0x44 , 0x17 , 0xC4 , 0xA7 , 0x7E , 0x3D , 0x64 , 0x5D , 0x19 , 0x73 , 0x60 , 0x81 , 0x4F , 0xDC , 0x22 , 0x2A , 0x90 , 0x88 , 0x46 , 0xEE , 0xB8 , 0x14 , 0xDE , 0x5E , 0x0B , 0xDB , 0xE0 , 0x32 , 0x3A , 0x0A , 0x49 , 0x06 , 0x24 , 0x5C , 0xC2 , 0xD3 , 0xAC , 0x62 , 0x91 , 0x95 , 0xE4 , 0x79 , 0xE7 , 0xC8 , 0x37 , 0x6D , 0x8D , 0xD5 , 0x4E , 0xA9 , 0x6C , 0x56 , 0xF4 , 0xEA , 0x65 , 0x7A , 0xAE , 0x08 , 0xBA , 0x78 , 0x25 , 0x2E , 0x1C , 0xA6 , 0xB4 , 0xC6 , 0xE8 , 0xDD , 0x74 , 0x1F , 0x4B , 0xBD , 0x8B , 0x8A , 0x70 , 0x3E , 0xB5 , 0x66 , 0x48 , 0x03 , 0xF6 , 0x0E , 0x61 , 0x35 , 0x57 , 0xB9 , 0x86 , 0xC1 , 0x1D , 0x9E , 0xE1 , 0xF8 , 0x98 , 0x11 , 0x69 , 0xD9 , 0x8E , 0x94 , 0x9B , 0x1E , 0x87 , 0xE9 , 0xCE , 0x55 , 0x28 , 0xDF , 0x8C , 0xA1 , 0x89 , 0x0D , 0xBF , 0xE6 , 0x42 , 0x68 , 0x41 , 0x99 , 0x2D , 0x0F , 0xB0 , 0x54 , 0xBB , 0x16 ] invs_box = [ 0x52 , 0x09 , 0x6A , 0xD5 , 0x30 , 0x36 , 0xA5 , 0x38 , 0xBF , 0x40 , 0xA3 , 0x9E , 0x81 , 0xF3 , 0xD7 , 0xFB , 0x7C , 0xE3 , 0x39 , 0x82 , 0x9B , 0x2F , 0xFF , 0x87 , 0x34 , 0x8E , 0x43 , 0x44 , 0xC4 , 0xDE , 0xE9 , 0xCB , 0x54 , 0x7B , 0x94 , 0x32 , 0xA6 , 0xC2 , 0x23 , 0x3D , 0xEE , 0x4C , 0x95 , 0x0B , 0x42 , 0xFA , 0xC3 , 0x4E , 0x08 , 0x2E , 0xA1 , 0x66 , 0x28 , 0xD9 , 0x24 , 0xB2 , 0x76 , 0x5B , 0xA2 , 0x49 , 0x6D , 0x8B , 0xD1 , 0x25 , 0x72 , 0xF8 , 0xF6 , 0x64 , 0x86 , 0x68 , 0x98 , 0x16 , 0xD4 , 0xA4 , 0x5C , 0xCC , 0x5D , 0x65 , 0xB6 , 0x92 , 0x6C , 0x70 , 0x48 , 0x50 , 0xFD , 0xED , 0xB9 , 0xDA , 0x5E , 0x15 , 0x46 , 0x57 , 0xA7 , 0x8D , 0x9D , 0x84 , 0x90 , 0xD8 , 0xAB , 0x00 , 0x8C , 0xBC , 0xD3 , 0x0A , 0xF7 , 0xE4 , 0x58 , 0x05 , 0xB8 , 0xB3 , 0x45 , 0x06 , 0xD0 , 0x2C , 0x1E , 0x8F , 0xCA , 0x3F , 0x0F , 0x02 , 0xC1 , 0xAF , 0xBD , 0x03 , 0x01 , 0x13 , 0x8A , 0x6B , 0x3A , 0x91 , 0x11 , 0x41 , 0x4F , 0x67 , 0xDC , 0xEA , 0x97 , 0xF2 , 0xCF , 0xCE , 0xF0 , 0xB4 , 0xE6 , 0x73 , 0x96 , 0xAC , 0x74 , 0x22 , 0xE7 , 0xAD , 0x35 , 0x85 , 0xE2 , 0xF9 , 0x37 , 0xE8 , 0x1C , 0x75 , 0xDF , 0x6E , 0x47 , 0xF1 , 0x1A , 0x71 , 0x1D , 0x29 , 0xC5 , 0x89 , 0x6F , 0xB7 , 0x62 , 0x0E , 0xAA , 0x18 , 0xBE , 0x1B , 0xFC , 0x56 , 0x3E , 0x4B , 0xC6 , 0xD2 , 0x79 , 0x20 , 0x9A , 0xDB , 0xC0 , 0xFE , 0x78 , 0xCD , 0x5A , 0xF4 , 0x1F , 0xDD , 0xA8 , 0x33 , 0x88 , 0x07 , 0xC7 , 0x31 , 0xB1 , 0x12 , 0x10 , 0x59 , 0x27 , 0x80 , 0xEC , 0x5F , 0x60 , 0x51 , 0x7F , 0xA9 , 0x19 , 0xB5 , 0x4A , 0x0D , 0x2D , 0xE5 , 0x7A , 0x9F , 0x93 , 0xC9 , 0x9C , 0xEF , 0xA0 , 0xE0 , 0x3B , 0x4D , 0xAE , 0x2A , 0xF5 , 0xB0 , 0xC8 , 0xEB , 0xBB , 0x3C , 0x83 , 0x53 , 0x99 , 0x61 , 0x17 , 0x2B , 0x04 , 0x7E , 0xBA , 0x77 , 0xD6 , 0x26 , 0xE1 , 0x69 , 0x14 , 0x63 , 0x55 , 0x21 , 0x0C , 0x7D ] def encrypt ( self , msg ): cipher = AES . new ( KEY , AES . MODE_CBC , IV ) return cipher . encrypt ( msg ) . encode ( 'hex' ) def handle ( self ): if not self . proof_of_work (): return self . request . settimeout ( 15 ) req = self . request flag_len = len ( FLAG ) assert ( flag_len == 33 ) self . flag = self . pad ( FLAG ) assert ( len ( self . flag ) == 256 ) while True : req . sendall ( 'Welcome to AES(WXH) encrypt system. \\n 1. get encrypted flag. \\n 2. pad flag. \\n 3.Do some encrypt. \\n Your choice:' ) cmd = req . recv ( 2 ) . strip () try : cmd = int ( cmd ) except ValueError : cmd = 0 if cmd == 1 : enc = self . encrypt ( self . flag ) req . sendall ( 'Here is the encrypted flag: 0x %s \\n ' % enc ) elif cmd == 2 : req . sendall ( 'Pad me something:' ) self . flag = self . unpad ( self . flag )[ : flag_len ] + req . recv ( 1024 ) . strip () assert ( len ( self . flag ) <= 256 ) self . flag = self . pad ( self . flag ) req . sendall ( 'Done. \\n ' ) elif cmd == 3 : req . sendall ( 'What do you want to encrypt:' ) msg = self . pad ( req . recv ( 1024 ) . strip ()) assert ( len ( msg ) <= 256 ) enc = self . encrypt ( msg ) req . sendall ( 'Here is the encrypted message: 0x %s \\n ' % enc ) else : req . sendall ( 'Do not lose heart\uff5e \uff01% Once WXH AK IOI 2019 can Solved! WXH is the first in the tianxia!' ) req . close () return class ThreadedServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ): pass if __name__ == \"__main__\" : HOST , PORT = '0.0.0.0' , 23333 print 'Run in port:23333' server = ThreadedServer (( HOST , PORT ), Task ) server . allow_reuse_address = True server . serve_forever () \u5206\u6790 \u00b6 \u8fd9\u4e2a\u9898\u76ee\u95ee\u9898\u51fa\u5728 padding \u7684\u65f6\u5019\uff0c\u7531\u4e8e\u4e0d\u8db3 256 \u4f4d\u8981\u8fdb\u884c padding\uff0cpadding \u7684\u5b57\u8282\u4e5f\u5c31\u662f\u7f3a\u7684\u5b57\u8282\u6570\uff0c\u4f46\u662f\u5982\u679c\u660e\u6587\u591f 256 \u5b57\u8282\uff0c\u90a3\u4e48\u6309\u7167\u4ee3\u7801\u903b\u8f91\u5c31\u4e0d\u8fdb\u884c padding\uff1a def pad ( self , s ): s += ( 256 - len ( s )) * chr ( 256 - len ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) \u6700\u5927\u7684\u95ee\u9898\u51fa\u5728 unpad \u4e0a\uff0cunpad \u6ca1\u6709\u8fdb\u884c\u68c0\u67e5\uff0c\u4ec5\u4ec5\u901a\u8fc7\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u6765\u5224\u65ad\u586b\u5145\u7684\u5b57\u8282\u6570\u3002 def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return '' . join ( ret [ 0 : - ord ( ret [ - 1 ])]) \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u7be1\u6539\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u6765\u63a7\u5236\u53bb\u6389\u7684 padding \u5b57\u8282\u6570\u3002 \u5229\u7528 \u00b6 \u9009\u62e9 choice2\uff0c\u8ffd\u52a0 256-33 =223 \u5b57\u8282\uff0c\u4f7f\u5f53\u524d flag \u4e0d\u9700\u8981\u586b\u5145\uff0c\u8ffd\u52a0\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u8bbe\u7f6e\u6210 chr(256-32) \u3002 \u670d\u52a1\u5668\u5bf9 flag \u8ffd\u52a0\u6211\u4eec\u7684\u4fe1\u606f\uff0c\u5e76\u8fdb\u884c s \u76d2\u66ff\u6362\uff0c\u7ed3\u679c\u8d4b\u7ed9\u7c7b\u4e2d\u7684 flag \u53d8\u91cf\u3002 \u6211\u4eec\u518d\u6b21\u9009\u62e9 choice2\uff0c\u8fd9\u91cc\u7531\u4e8e\u6211\u4eec\u9700\u8981\u8ffd\u52a0\uff0c\u670d\u52a1\u5668\u4f1a\u5c06\u7c7b\u4e2d\u7684 flag \u53d8\u91cf\u53d6\u51fa\u8fdb\u884c\u9006 S \u76d2\u66ff\u6362\u548c unpad\uff0c\u8fd9\u6837\u6309\u7167\u8fd9\u4e2a unpad \u7b97\u6cd5\u4f1a\u628a\u540e\u9762 224 \u5b57\u8282\u7684\u5168\u90e8\u5f53\u6210 padding\u53bb\u6389\uff0c\u660e\u6587\u5269\u4e0b\u4e86\u771f\u6b63 flag \u7684\u524d32\u4f4d\u3002 \u6211\u4eec\u6b64\u65f6\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26 i,\u90a3\u4e48\u6b64\u65f6\u52a0\u5bc6\u7684\u5bf9\u8c61\u5c31\u662f flag[:32]+i \u3002 \u9009\u62e9 choice1 \u5bf9\u5f53\u524d flag \u52a0\u5bc6\uff0c\u63a7\u5236 i \u8fdb\u884c\u7206\u7834\uff0c\u5982\u679c\u5f97\u5230\u7684\u5bc6\u6587\u548c\u6700\u521d\u7684 flag \u52a0\u5bc6\u7684\u5bc6\u6587\u4e00\u6837\uff0c\u5c31\u5f97\u5230\u4e86 flag \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002 \u9010\u5b57\u8282\u7206\u7834\uff0c\u76f4\u81f3\u83b7\u53d6\u5168\u90e8\u7684 flag\u3002 exp \u5982\u4e0b\uff1a # -*- coding: utf-8 -*- from hashlib import sha256 import socket import string import itertools HOST = '106.75.13.64' PORT = 54321 sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( HOST , PORT )) def brute_force ( pad , shavalue ): for str in itertools . product ( string . ascii_letters + string . digits , repeat = 4 ): str = '' . join ( str ) if sha256 ( str + pad ) . hexdigest () == shavalue : print str return str def choice1 (): sock . send ( \"1 \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 30 :] sock . recv ( 1024 ) . strip () return result def choice2 ( pad ): sock . send ( \"2 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( pad + \" \\n \" ) sock . recv ( 1024 ) . strip () sock . recv ( 1024 ) . strip () def choice3 ( str ): sock . send ( \"3 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( str + \" \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 33 :] sock . recv ( 1024 ) . strip () return result content = sock . recv ( 1024 ) . strip () pad = content [ 12 : 12 + 16 ] hash = content [ 33 : 33 + 64 ] sock . recv ( 1024 ) . strip () sock . send ( str ( brute_force ( pad , hash )) + \" \\n \" ) print sock . recv ( 1024 ) . strip () flag_enc = choice1 () flag = \"\" for i in range ( 33 ): a = '' . join ([ 'a' for _ in range ( 223 )]) a = a [: - 1 ] + chr ( 224 + i ) for c in string . printable : print c + flag choice2 ( a ) choice2 ( c + flag ) if choice1 () == flag_enc : flag = c + flag print \"success:\" , flag break flag{H4ve_fun_w1th_p4d_and_unp4d}","title":"Padding zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#_1","text":"\u6b63\u5982\u6211\u4eec\u4e4b\u524d\u6240\u8bf4\uff0c\u5728\u5206\u7ec4\u52a0\u5bc6\u4e2d\uff0c\u660e\u6587\u7684\u957f\u5ea6\u5f80\u5f80\u5e76\u4e0d\u6ee1\u8db3\u8981\u6c42\uff0c\u9700\u8981\u8fdb\u884c padding\uff0c\u800c\u5982\u4f55 padding \u76ee\u524d\u4e5f\u5df2\u7ecf\u6709\u4e86\u4e0d\u5c11\u7684\u89c4\u5b9a\u3002 \u5e38\u89c1\u7684 \u586b\u5145\u89c4\u5219 \u5982\u4e0b\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5373\u4f7f\u6d88\u606f\u7684\u957f\u5ea6\u662f\u5757\u5927\u5c0f\u7684\u6574\u6570\u500d\uff0c\u4ecd\u7136\u9700\u8981\u586b\u5145\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u5982\u679c\u5728\u89e3\u5bc6\u4e4b\u540e\u53d1\u73b0 Padding \u4e0d\u6b63\u786e\uff0c\u5219\u5f80\u5f80\u4f1a\u629b\u51fa\u5f02\u5e38\u3002\u6211\u4eec\u4e5f\u56e0\u6b64\u53ef\u4ee5\u77e5\u9053 Paddig \u662f\u5426\u6b63\u786e\u3002","title":"\u586b\u5145\u89c4\u5219"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#pad-with-bytes-all-of-the-same-value-as-the-number-of-padding-bytes-pkcs5-padding","text":"\u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 05 05 05 05 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40","title":"Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#pad-with-0x80-followed-by-zero-bytes-oneandzeroes-padding","text":"\u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 80 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40 \u8fd9\u91cc\u5176\u5b9e\u5c31\u662f\u548c md5 \u548c sha1 \u7684 padding \u5dee\u4e0d\u591a\u3002","title":"Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes","text":"\u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8","title":"Pad with zeroes except make the last byte equal to the number of padding bytes"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#pad-with-zero-null-characters","text":"\u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75","title":"Pad with zero (null) characters"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#pad-with-spaces","text":"\u4e3e\u4f8b\u5b50\u5982\u4e0b DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 20 20 20 20 20 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25","title":"Pad with spaces"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#2018-aessss","text":"\u6709\u65f6\u5019\u53ef\u4ee5\u9488\u5bf9\u4e00\u4e9b\u4f7f\u7528\u4e0d\u5f53\u7684 Padding \u8fdb\u884c\u653b\u51fb\u3002\u8fd9\u91cc\u4ee5 2018 \u4e0a\u6d77\u5e02\u5927\u5b66\u751f\u7f51\u7edc\u5b89\u5168\u5927\u8d5b\u7684\u4e00\u9053\u9898\u76ee\u4e3a\u4f8b\uff1a \u9898\u76ee\u811a\u672c\u5982\u4e0b\uff1a import random import sys import string from hashlib import sha256 import SocketServer from Crypto.Cipher import AES from secret import FLAG , IV , KEY class Task ( SocketServer . BaseRequestHandler ): def proof_of_work ( self ): proof = '' . join ( [ random . choice ( string . ascii_letters + string . digits ) for _ in xrange ( 20 )]) # print proof digest = sha256 ( proof ) . hexdigest () self . request . send ( \"sha256(XXXX+ %s ) == %s \\n \" % ( proof [ 4 :], digest )) self . request . send ( 'Give me XXXX:' ) x = self . request . recv ( 10 ) x = x . strip () if len ( x ) != 4 or sha256 ( x + proof [ 4 :]) . hexdigest () != digest : return False return True def pad ( self , s ): s += ( 256 - len ( s )) * chr ( 256 - len ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return '' . join ( ret [ 0 : - ord ( ret [ - 1 ])]) s_box = [ 0x63 , 0x7C , 0x77 , 0x7B , 0xF2 , 0x6B , 0x6F , 0xC5 , 0x30 , 0x01 , 0x67 , 0x2B , 0xFE , 0xD7 , 0xAB , 0x76 , 0xCA , 0x82 , 0xC9 , 0x7D , 0xFA , 0x59 , 0x47 , 0xF0 , 0xAD , 0xD4 , 0xA2 , 0xAF , 0x9C , 0xA4 , 0x72 , 0xC0 , 0xB7 , 0xFD , 0x93 , 0x26 , 0x36 , 0x3F , 0xF7 , 0xCC , 0x34 , 0xA5 , 0xE5 , 0xF1 , 0x71 , 0xD8 , 0x31 , 0x15 , 0x04 , 0xC7 , 0x23 , 0xC3 , 0x18 , 0x96 , 0x05 , 0x9A , 0x07 , 0x12 , 0x80 , 0xE2 , 0xEB , 0x27 , 0xB2 , 0x75 , 0x09 , 0x83 , 0x2C , 0x1A , 0x1B , 0x6E , 0x5A , 0xA0 , 0x52 , 0x3B , 0xD6 , 0xB3 , 0x29 , 0xE3 , 0x2F , 0x84 , 0x53 , 0xD1 , 0x00 , 0xED , 0x20 , 0xFC , 0xB1 , 0x5B , 0x6A , 0xCB , 0xBE , 0x39 , 0x4A , 0x4C , 0x58 , 0xCF , 0xD0 , 0xEF , 0xAA , 0xFB , 0x43 , 0x4D , 0x33 , 0x85 , 0x45 , 0xF9 , 0x02 , 0x7F , 0x50 , 0x3C , 0x9F , 0xA8 , 0x51 , 0xA3 , 0x40 , 0x8F , 0x92 , 0x9D , 0x38 , 0xF5 , 0xBC , 0xB6 , 0xDA , 0x21 , 0x10 , 0xFF , 0xF3 , 0xD2 , 0xCD , 0x0C , 0x13 , 0xEC , 0x5F , 0x97 , 0x44 , 0x17 , 0xC4 , 0xA7 , 0x7E , 0x3D , 0x64 , 0x5D , 0x19 , 0x73 , 0x60 , 0x81 , 0x4F , 0xDC , 0x22 , 0x2A , 0x90 , 0x88 , 0x46 , 0xEE , 0xB8 , 0x14 , 0xDE , 0x5E , 0x0B , 0xDB , 0xE0 , 0x32 , 0x3A , 0x0A , 0x49 , 0x06 , 0x24 , 0x5C , 0xC2 , 0xD3 , 0xAC , 0x62 , 0x91 , 0x95 , 0xE4 , 0x79 , 0xE7 , 0xC8 , 0x37 , 0x6D , 0x8D , 0xD5 , 0x4E , 0xA9 , 0x6C , 0x56 , 0xF4 , 0xEA , 0x65 , 0x7A , 0xAE , 0x08 , 0xBA , 0x78 , 0x25 , 0x2E , 0x1C , 0xA6 , 0xB4 , 0xC6 , 0xE8 , 0xDD , 0x74 , 0x1F , 0x4B , 0xBD , 0x8B , 0x8A , 0x70 , 0x3E , 0xB5 , 0x66 , 0x48 , 0x03 , 0xF6 , 0x0E , 0x61 , 0x35 , 0x57 , 0xB9 , 0x86 , 0xC1 , 0x1D , 0x9E , 0xE1 , 0xF8 , 0x98 , 0x11 , 0x69 , 0xD9 , 0x8E , 0x94 , 0x9B , 0x1E , 0x87 , 0xE9 , 0xCE , 0x55 , 0x28 , 0xDF , 0x8C , 0xA1 , 0x89 , 0x0D , 0xBF , 0xE6 , 0x42 , 0x68 , 0x41 , 0x99 , 0x2D , 0x0F , 0xB0 , 0x54 , 0xBB , 0x16 ] invs_box = [ 0x52 , 0x09 , 0x6A , 0xD5 , 0x30 , 0x36 , 0xA5 , 0x38 , 0xBF , 0x40 , 0xA3 , 0x9E , 0x81 , 0xF3 , 0xD7 , 0xFB , 0x7C , 0xE3 , 0x39 , 0x82 , 0x9B , 0x2F , 0xFF , 0x87 , 0x34 , 0x8E , 0x43 , 0x44 , 0xC4 , 0xDE , 0xE9 , 0xCB , 0x54 , 0x7B , 0x94 , 0x32 , 0xA6 , 0xC2 , 0x23 , 0x3D , 0xEE , 0x4C , 0x95 , 0x0B , 0x42 , 0xFA , 0xC3 , 0x4E , 0x08 , 0x2E , 0xA1 , 0x66 , 0x28 , 0xD9 , 0x24 , 0xB2 , 0x76 , 0x5B , 0xA2 , 0x49 , 0x6D , 0x8B , 0xD1 , 0x25 , 0x72 , 0xF8 , 0xF6 , 0x64 , 0x86 , 0x68 , 0x98 , 0x16 , 0xD4 , 0xA4 , 0x5C , 0xCC , 0x5D , 0x65 , 0xB6 , 0x92 , 0x6C , 0x70 , 0x48 , 0x50 , 0xFD , 0xED , 0xB9 , 0xDA , 0x5E , 0x15 , 0x46 , 0x57 , 0xA7 , 0x8D , 0x9D , 0x84 , 0x90 , 0xD8 , 0xAB , 0x00 , 0x8C , 0xBC , 0xD3 , 0x0A , 0xF7 , 0xE4 , 0x58 , 0x05 , 0xB8 , 0xB3 , 0x45 , 0x06 , 0xD0 , 0x2C , 0x1E , 0x8F , 0xCA , 0x3F , 0x0F , 0x02 , 0xC1 , 0xAF , 0xBD , 0x03 , 0x01 , 0x13 , 0x8A , 0x6B , 0x3A , 0x91 , 0x11 , 0x41 , 0x4F , 0x67 , 0xDC , 0xEA , 0x97 , 0xF2 , 0xCF , 0xCE , 0xF0 , 0xB4 , 0xE6 , 0x73 , 0x96 , 0xAC , 0x74 , 0x22 , 0xE7 , 0xAD , 0x35 , 0x85 , 0xE2 , 0xF9 , 0x37 , 0xE8 , 0x1C , 0x75 , 0xDF , 0x6E , 0x47 , 0xF1 , 0x1A , 0x71 , 0x1D , 0x29 , 0xC5 , 0x89 , 0x6F , 0xB7 , 0x62 , 0x0E , 0xAA , 0x18 , 0xBE , 0x1B , 0xFC , 0x56 , 0x3E , 0x4B , 0xC6 , 0xD2 , 0x79 , 0x20 , 0x9A , 0xDB , 0xC0 , 0xFE , 0x78 , 0xCD , 0x5A , 0xF4 , 0x1F , 0xDD , 0xA8 , 0x33 , 0x88 , 0x07 , 0xC7 , 0x31 , 0xB1 , 0x12 , 0x10 , 0x59 , 0x27 , 0x80 , 0xEC , 0x5F , 0x60 , 0x51 , 0x7F , 0xA9 , 0x19 , 0xB5 , 0x4A , 0x0D , 0x2D , 0xE5 , 0x7A , 0x9F , 0x93 , 0xC9 , 0x9C , 0xEF , 0xA0 , 0xE0 , 0x3B , 0x4D , 0xAE , 0x2A , 0xF5 , 0xB0 , 0xC8 , 0xEB , 0xBB , 0x3C , 0x83 , 0x53 , 0x99 , 0x61 , 0x17 , 0x2B , 0x04 , 0x7E , 0xBA , 0x77 , 0xD6 , 0x26 , 0xE1 , 0x69 , 0x14 , 0x63 , 0x55 , 0x21 , 0x0C , 0x7D ] def encrypt ( self , msg ): cipher = AES . new ( KEY , AES . MODE_CBC , IV ) return cipher . encrypt ( msg ) . encode ( 'hex' ) def handle ( self ): if not self . proof_of_work (): return self . request . settimeout ( 15 ) req = self . request flag_len = len ( FLAG ) assert ( flag_len == 33 ) self . flag = self . pad ( FLAG ) assert ( len ( self . flag ) == 256 ) while True : req . sendall ( 'Welcome to AES(WXH) encrypt system. \\n 1. get encrypted flag. \\n 2. pad flag. \\n 3.Do some encrypt. \\n Your choice:' ) cmd = req . recv ( 2 ) . strip () try : cmd = int ( cmd ) except ValueError : cmd = 0 if cmd == 1 : enc = self . encrypt ( self . flag ) req . sendall ( 'Here is the encrypted flag: 0x %s \\n ' % enc ) elif cmd == 2 : req . sendall ( 'Pad me something:' ) self . flag = self . unpad ( self . flag )[ : flag_len ] + req . recv ( 1024 ) . strip () assert ( len ( self . flag ) <= 256 ) self . flag = self . pad ( self . flag ) req . sendall ( 'Done. \\n ' ) elif cmd == 3 : req . sendall ( 'What do you want to encrypt:' ) msg = self . pad ( req . recv ( 1024 ) . strip ()) assert ( len ( msg ) <= 256 ) enc = self . encrypt ( msg ) req . sendall ( 'Here is the encrypted message: 0x %s \\n ' % enc ) else : req . sendall ( 'Do not lose heart\uff5e \uff01% Once WXH AK IOI 2019 can Solved! WXH is the first in the tianxia!' ) req . close () return class ThreadedServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ): pass if __name__ == \"__main__\" : HOST , PORT = '0.0.0.0' , 23333 print 'Run in port:23333' server = ThreadedServer (( HOST , PORT ), Task ) server . allow_reuse_address = True server . serve_forever ()","title":"2018 \u4e0a\u6d77\u5e02\u5927\u5b66\u751f\u7f51\u7edc\u5b89\u5168\u5927\u8d5b aessss"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#_2","text":"\u8fd9\u4e2a\u9898\u76ee\u95ee\u9898\u51fa\u5728 padding \u7684\u65f6\u5019\uff0c\u7531\u4e8e\u4e0d\u8db3 256 \u4f4d\u8981\u8fdb\u884c padding\uff0cpadding \u7684\u5b57\u8282\u4e5f\u5c31\u662f\u7f3a\u7684\u5b57\u8282\u6570\uff0c\u4f46\u662f\u5982\u679c\u660e\u6587\u591f 256 \u5b57\u8282\uff0c\u90a3\u4e48\u6309\u7167\u4ee3\u7801\u903b\u8f91\u5c31\u4e0d\u8fdb\u884c padding\uff1a def pad ( self , s ): s += ( 256 - len ( s )) * chr ( 256 - len ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) \u6700\u5927\u7684\u95ee\u9898\u51fa\u5728 unpad \u4e0a\uff0cunpad \u6ca1\u6709\u8fdb\u884c\u68c0\u67e5\uff0c\u4ec5\u4ec5\u901a\u8fc7\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u6765\u5224\u65ad\u586b\u5145\u7684\u5b57\u8282\u6570\u3002 def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return '' . join ( ret [ 0 : - ord ( ret [ - 1 ])]) \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u7be1\u6539\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u6765\u63a7\u5236\u53bb\u6389\u7684 padding \u5b57\u8282\u6570\u3002","title":"\u5206\u6790"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding-zh/#_3","text":"\u9009\u62e9 choice2\uff0c\u8ffd\u52a0 256-33 =223 \u5b57\u8282\uff0c\u4f7f\u5f53\u524d flag \u4e0d\u9700\u8981\u586b\u5145\uff0c\u8ffd\u52a0\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u8bbe\u7f6e\u6210 chr(256-32) \u3002 \u670d\u52a1\u5668\u5bf9 flag \u8ffd\u52a0\u6211\u4eec\u7684\u4fe1\u606f\uff0c\u5e76\u8fdb\u884c s \u76d2\u66ff\u6362\uff0c\u7ed3\u679c\u8d4b\u7ed9\u7c7b\u4e2d\u7684 flag \u53d8\u91cf\u3002 \u6211\u4eec\u518d\u6b21\u9009\u62e9 choice2\uff0c\u8fd9\u91cc\u7531\u4e8e\u6211\u4eec\u9700\u8981\u8ffd\u52a0\uff0c\u670d\u52a1\u5668\u4f1a\u5c06\u7c7b\u4e2d\u7684 flag \u53d8\u91cf\u53d6\u51fa\u8fdb\u884c\u9006 S \u76d2\u66ff\u6362\u548c unpad\uff0c\u8fd9\u6837\u6309\u7167\u8fd9\u4e2a unpad \u7b97\u6cd5\u4f1a\u628a\u540e\u9762 224 \u5b57\u8282\u7684\u5168\u90e8\u5f53\u6210 padding\u53bb\u6389\uff0c\u660e\u6587\u5269\u4e0b\u4e86\u771f\u6b63 flag \u7684\u524d32\u4f4d\u3002 \u6211\u4eec\u6b64\u65f6\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26 i,\u90a3\u4e48\u6b64\u65f6\u52a0\u5bc6\u7684\u5bf9\u8c61\u5c31\u662f flag[:32]+i \u3002 \u9009\u62e9 choice1 \u5bf9\u5f53\u524d flag \u52a0\u5bc6\uff0c\u63a7\u5236 i \u8fdb\u884c\u7206\u7834\uff0c\u5982\u679c\u5f97\u5230\u7684\u5bc6\u6587\u548c\u6700\u521d\u7684 flag \u52a0\u5bc6\u7684\u5bc6\u6587\u4e00\u6837\uff0c\u5c31\u5f97\u5230\u4e86 flag \u7684\u6700\u540e\u4e00\u4e2a\u5b57\u8282\u3002 \u9010\u5b57\u8282\u7206\u7834\uff0c\u76f4\u81f3\u83b7\u53d6\u5168\u90e8\u7684 flag\u3002 exp \u5982\u4e0b\uff1a # -*- coding: utf-8 -*- from hashlib import sha256 import socket import string import itertools HOST = '106.75.13.64' PORT = 54321 sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( HOST , PORT )) def brute_force ( pad , shavalue ): for str in itertools . product ( string . ascii_letters + string . digits , repeat = 4 ): str = '' . join ( str ) if sha256 ( str + pad ) . hexdigest () == shavalue : print str return str def choice1 (): sock . send ( \"1 \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 30 :] sock . recv ( 1024 ) . strip () return result def choice2 ( pad ): sock . send ( \"2 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( pad + \" \\n \" ) sock . recv ( 1024 ) . strip () sock . recv ( 1024 ) . strip () def choice3 ( str ): sock . send ( \"3 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( str + \" \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 33 :] sock . recv ( 1024 ) . strip () return result content = sock . recv ( 1024 ) . strip () pad = content [ 12 : 12 + 16 ] hash = content [ 33 : 33 + 64 ] sock . recv ( 1024 ) . strip () sock . send ( str ( brute_force ( pad , hash )) + \" \\n \" ) print sock . recv ( 1024 ) . strip () flag_enc = choice1 () flag = \"\" for i in range ( 33 ): a = '' . join ([ 'a' for _ in range ( 223 )]) a = a [: - 1 ] + chr ( 224 + i ) for c in string . printable : print c + flag choice2 ( a ) choice2 ( c + flag ) if choice1 () == flag_enc : flag = c + flag print \"success:\" , flag break flag{H4ve_fun_w1th_p4d_and_unp4d}","title":"\u5229\u7528"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/","text":"EN | ZH Fill rule \u00b6 As we said before, in packet encryption, the length of the plaintext often does not meet the requirements, and padding is required. How to padding has a lot of rules. The common [fill rule] ( https://www.di-mgt.com.au/cryptopad.html ) is as follows. It should be noted that even if the length of the message is an integer multiple of the block size, it still needs to be filled. In general, if Padding is found to be incorrect after decryption, an exception is often thrown. We can therefore know if Paddig is correct. Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding) \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 05 05 05 05 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40 Pad with 0x80 followed by zero bytes (OneAndZeroes Padding) \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 80 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40 This is actually the same as the padding of md5 and sha1. Pad with zeroes except make the last byte equal to the number of padding bytes \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8 Pad with zero (null) characters \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75 Pad with spaces \u00b6 Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 20 20 20 20 20 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25 2018 Shanghai University Student Network Security Competition aessss \u00b6 Sometimes you can attack some improperly used Padding. Here is a topic of the 2018 Shanghai University Student Network Security Competition: The title script is as follows: import random import sys import string from hashlib import sha256 import SocketServer from Crypto.Cipher import AES from secret import FLAG , IV , KEY class Task ( SocketServer . BaseRequestHandler ): def proof_of_work ( self ): proof = '' . join ( [ random . choice ( string . ascii_letters + string . digits ) for _ in xrange ( 20 )]) # print proof digest = sha256 ( proof ) . hexdigest () self . request . send ( \"sha256(XXXX+ %s ) == %s \\n \" % ( proof [ 4 :], digest )) self . request . send ( 'Give me XXXX:' ) x = self . request . recv ( 10 ) x = x . strip () if len ( x ) != 4 or sha256 ( x + proof [ 4 :]) . hexdigest () != digest : return False return True def pad ( self , s ): s + = ( 256 - only ( s )) * chr ( 256 - only ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return & #39;&#39; .join (right [0: -word (right [-1])]) s_box = [ 0x63 , 0x7C , 0x77 , 0x7B , 0xF2 , 0x6B , 0x6F , 0xC5 , 0x30 , 0x01 , 0x67 , 0x2B , 0xFE , 0xD7 , 0xAB , 0x76 , 0xCA , 0x82 , 0xC9 , 0x7D , 0xFA , 0x59 , 0x47 , 0xF0 , 0xAD , 0xD4 , 0xA2 , 0xAF , 0x9C , 0xA4 , 0x72 , 0xC0 , 0xB7 , 0xFD , 0x93 , 0x26 , 0x36 , 0x3F , 0xF7 , 0xCC , 0x34 , 0xA5 , 0xE5 , 0xF1 , 0x71 , 0xD8 , 0x31 , 0x15 , 0x04 , 0xC7 , 0x23 , 0xC3 , 0x18 , 0x96 , 0x05 , 0x9A , 0x07 , 0x12 , 0x80 , 0xE2 , 0xEB , 0x27 , 0xB2 , 0x75 , 0x09 , 0x83 , 0x2C , 0x1A , 0x1B , 0x6E , 0x5A , 0xA0 , 0x52 , 0x3B , 0xD6 , 0xB3 , 0x29 , 0xE3 , 0x2F , 0x84 , 0x53 , 0xD1 , 0x00 , 0xED , 0x20 , 0xFC , 0xB1 , 0x5B , 0x6A , 0xCB , 0xBE , 0x39 , 0x4A , 0x4C , 0x58 , 0xCF , 0xD0 , 0xEF , 0xAA , 0xFB , 0x43 , 0x4D , 0x33 , 0x85 , 0x45 , 0xF9 , 0x02 , 0x7F , 0x50 , 0x3C , 0x9F , 0xA8 , 0x51 , 0xA3 , 0x40 , 0x8F , 0x92 , 0x9D , 0x38 , 0xF5 , 0xBC , 0xB6 , 0xDA , 0x21 , 0x10 , 0xFF , 0xF3 , 0xD2 , 0xCD , 0x0C , 0x13 , 0xEC , 0x5F , 0x97 , 0x44 , 0x17 , 0xC4 , 0xA7 , 0x7E , 0x3D , 0x64 , 0x5D , 0x19 , 0x73 , 0x60 , 0x81 , 0x4F , 0xDC , 0x22 , 0x2A , 0x90 , 0x88 , 0x46 , 0xEE , 0xB8 , 0x14 , 0xDE , 0x5E , 0x0B , 0xDB , 0xE0 , 0x32 , 0x3A , 0x0A , 0x49 , 0x06 , 0x24 , 0x5C , 0xC2 , 0xD3 , 0xAC , 0x62 , 0x91 , 0x95 , 0xE4 , 0x79 , 0xE7 , 0xC8 , 0x37 , 0x6D , 0x8D , 0xD5 , 0x4E , 0xA9 , 0x6C , 0x56 , 0xF4 , 0xEA , 0x65 , 0x7A , 0xAE , 0x08 , 0xBA , 0x78 , 0x25 , 0x2E , 0x1C , 0xA6 , 0xB4 , 0xC6 , 0xE8 , 0xDD , 0x74 , 0x1F , 0x4B , 0xBD , 0x8B , 0x8A , 0x70 , 0x3E , 0xB5 , 0x66 , 0x48 , 0x03 , 0xF6 , 0x0E , 0x61 , 0x35 , 0x57 , 0xB9 , 0x86 , 0xC1 , 0x1D , 0x9E , 0xE1 , 0xF8 , 0x98 , 0x11 , 0x69 , 0xD9 , 0x8E , 0x94 , 0x9B , 0x1E , 0x87 , 0xE9 , 0xCE , 0x55 , 0x28 , 0xDF , 0x8C , 0xA1 , 0x89 , 0x0D , 0xBF , 0xE6 , 0x42 , 0x68 , 0x41 , 0x99 , 0x2D , 0x0F , 0xB0 , 0x54 , 0xBB , 0x16 ] invs_box = [ 0x52 , 0x09 , 0x6A , 0xD5 , 0x30 , 0x36 , 0xA5 , 0x38 , 0xBF , 0x40 , 0xA3 , 0x9E , 0x81 , 0xF3 , 0xD7 , 0xFB , 0x7C , 0xE3 , 0x39 , 0x82 , 0x9B , 0x2F , 0xFF , 0x87 , 0x34 , 0x8E , 0x43 , 0x44 , 0xC4 , 0xDE , 0xE9 , 0xCB , 0x54 , 0x7B , 0x94 , 0x32 , 0xA6 , 0xC2 , 0x23 , 0x3D , 0xEE , 0x4C , 0x95 , 0x0B , 0x42 , 0xFA , 0xC3 , 0x4E , 0x08 , 0x2E , 0xA1 , 0x66 , 0x28 , 0xD9 , 0x24 , 0xB2 , 0x76 , 0x5B , 0xA2 , 0x49 , 0x6D , 0x8B , 0xD1 , 0x25 , 0x72 , 0xF8 , 0xF6 , 0x64 , 0x86 , 0x68 , 0x98 , 0x16 , 0xD4 , 0xA4 , 0x5C , 0xCC , 0x5D , 0x65 , 0xB6 , 0x92 , 0x6C , 0x70 , 0x48 , 0x50 , 0xFD , 0xED , 0xB9 , 0xDA , 0x5E , 0x15 , 0x46 , 0x57 , 0xA7 , 0x8D , 0x9D , 0x84 , 0x90 , 0xD8 , 0xAB , 0x00 , 0x8C , 0xBC , 0xD3 , 0x0A , 0xF7 , 0xE4 , 0x58 , 0x05 , 0xB8 , 0xB3 , 0x45 , 0x06 , 0xD0 , 0x2C , 0x1E , 0x8F , 0xCA , 0x3F , 0x0F , 0x02 , 0xC1 , 0xAF , 0xBD , 0x03 , 0x01 , 0x13 , 0x8A , 0x6B , 0x3A , 0x91 , 0x11 , 0x41 , 0x4F , 0x67 , 0xDC , 0xEA , 0x97 , 0xF2 , 0xCF , 0xCE , 0xF0 , 0xB4 , 0xE6 , 0x73 , 0x96 , 0xAC , 0x74 , 0x22 , 0xE7 , 0xAD , 0x35 , 0x85 , 0xE2 , 0xF9 , 0x37 , 0xE8 , 0x1C , 0x75 , 0xDF , 0x6E , 0x47 , 0xF1 , 0x1A , 0x71 , 0x1D , 0x29 , 0xC5 , 0x89 , 0x6F , 0xB7 , 0x62 , 0x0E , 0xAA , 0x18 , 0xBE , 0x1B , 0xFC , 0x56 , 0x3E , 0x4B , 0xC6 , 0xD2 , 0x79 , 0x20 , 0x9A , 0xDB , 0xC0 , 0xFE , 0x78 , 0xCD , 0x5A , 0xF4 , 0x1F , 0xDD , 0xA8 , 0x33 , 0x88 , 0x07 , 0xC7 , 0x31 , 0xB1 , 0x12 , 0x10 , 0x59 , 0x27 , 0x80 , 0xEC , 0x5F , 0x60 , 0x51 , 0x7F , 0xA9 , 0x19 , 0xB5 , 0x4A , 0x0D , 0x2D , 0xE5 , 0x7A , 0x9F , 0x93 , 0xC9 , 0x9C , 0xEF , 0xA0 , 0xE0 , 0x3B , 0x4D , 0xAE , 0x2A , 0xF5 , 0xB0 , 0xC8 , 0xEB , 0xBB , 0x3C , 0x83 , 0x53 , 0x99 , 0x61 , 0x17 , 0x2B , 0x04 , 0x7E , 0xBA , 0x77 , 0xD6 , 0x26 , 0xE1 , 0x69 , 0x14 , 0x63 , 0x55 , 0x21 , 0x0C , 0x7D ] def encrypt ( self , msg ): cipher = AES . new ( KEY , AES . MODE_CBC , IV ) return cipher . encrypt ( msg ) . encode ( 'hex' ) def handle ( self ): if not self . proof_of_work (): return self . request . settimeout ( 15 ) req = self . request flag_len = len ( FLAG ) assert ( flag_len == 33 ) self . flag = self . pad ( FLAG ) assert ( len ( self . flag ) == 256 ) while True : req . sendall ( 'Welcome to AES(WXH) encrypt system. \\n 1. get encrypted flag. \\n 2. pad flag. \\n 3.Do some encrypt. \\n Your choice:' ) cmd = req . recv ( 2 ) . strip () try : cmd = int ( cmd ) except ValueError : cmd = 0 if cmd == 1 : enc = self . encrypt ( self . flag ) req . sendall ( 'Here is the encrypted flag: 0x %s \\n ' % enc ) elif cmd == 2 : req . sendall ( 'Pad me something:' ) self . flag = self . unpad ( self . flag ) [ : flag_len ] + req . recv ( 1024 ) . strip () assert ( len ( self . flag ) <= 256 ) self . flag = self . pad ( self . flag ) req . sendall ( 'Done. \\n ' ) elif cmd == 3 : req . sendall ( 'What do you want to encrypt:' ) msg = self . pad ( req . recv ( 1024 ) . strip ()) assert ( len ( msg ) & lt ; = 256 ) enc = self . encrypt ( msg ) req . sendall ( 'Here is the encrypted message: 0x %s \\n ' % enc ) else : req . sendall ( 'Do not lose heart\uff5e \uff01% Once WXH AK IOI 2019 can Solved! WXH is the first in the tianxia!' ) req . close () return class ThreadedServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ): pass if __name__ == \"__main__\" : HOST , PORT = '0.0.0.0' , 23333 print 'Run in port:23333' server = ThreadedServer (( HOST , PORT ), Task ) server . allow_reuse_address = True server . serve_forever () Analysis \u00b6 The problem with this problem is in padding. Since there are less than 256 bits to padding, the padding bytes are the missing bytes, but if the plaintext is 256 bytes, then padding is not performed according to the code logic: def pad ( self , s ): s + = ( 256 - only ( s )) * chr ( 256 - only ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) The biggest problem is on the unpad, which is not checked by the unpad, only the last byte is used to determine the number of bytes to fill. def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return & #39;&#39; .join (right [0: -word (right [-1])]) We can control the number of padding bytes removed by tampering with the last byte. Use \u00b6 Select choice2 and append 256-33 = 223 bytes so that the current flag does not need to be filled. The last byte appended is set to chr(256-32) . The server appends our information to the flag and performs s box substitution, and the result is assigned to the flag variable in the class. We choose choice2 again, here we need to append, the server will take the flag variable in the class for reverse S box replacement and unpad, so according to this unpad algorithm will be the next 224 bytes as the padding removed, the plaintext is left The first 32 bits of the real flag. We enter a character i at this time, then the object encrypted at this time is flag[:32]+i . Select choice1 to encrypt the current flag, control i to blast, and if the resulting ciphertext is the same as the original flag encrypted ciphertext, the last byte of the flag is obtained. Bleak byte by byte until all flags are obtained. Exp is as follows: # -*- coding: utf-8 -*- from hashlib import sha256 import socket import string import itertools HOST = '106.75.13.64' PORT = 54321 sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( HOST , PORT )) def brute_force ( pad , shavalue ): for str in itertools . product ( string . ascii_letters + string . digits , repeat = 4 ): str = '' . join ( str ) if sha256 ( str + pad ) . hexdigest () == shavalue : print str return str def choice1 (): sock . send ( \"1 \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 30 :] sock . recv ( 1024 ) . strip () return result def choice2 ( pad ): sock . send ( \"2 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( pad + \" \\n \" ) sock . recv ( 1024 ) . strip () sock . recv ( 1024 ) . strip () def choice3 ( str ): sock . send ( \"3 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( str + \" \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 33 :] sock . recv ( 1024 ) . strip () return result content = sock . recv ( 1024 ) . strip () pad = content [ 12 : 12 + 16 ] hash = content [ 33 : 33 + 64 ] sock . recv ( 1024 ) . strip () sock . send ( str ( brute_force ( pad , hash )) + \" \\n \" ) print sock . recv ( 1024 ) . strip () flag_enc = choice1 () flag = \"\" for i in range ( 33 ): a = '' . join ([ 'a' for _ in range ( 223 )]) a = a [: - 1 ] + chr ( 224 + i ) for c in string . printable : print c + flag choice2 ( a ) choice2 ( c + flag ) if choice1 () == flag_enc : flag = c + flag print \"success:\" , flag break flag{H4ve_fun_w1th_p4d_and_unp4d}","title":"\u586b\u5145\u65b9\u5f0f"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#fill-rule","text":"As we said before, in packet encryption, the length of the plaintext often does not meet the requirements, and padding is required. How to padding has a lot of rules. The common [fill rule] ( https://www.di-mgt.com.au/cryptopad.html ) is as follows. It should be noted that even if the length of the message is an integer multiple of the block size, it still needs to be filled. In general, if Padding is found to be incorrect after decryption, an exception is often thrown. We can therefore know if Paddig is correct.","title":"Fill rule"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#pad-with-bytes-all-of-the-same-value-as-the-number-of-padding-bytes-pkcs5-padding","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 05 05 05 05 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = FD 29 85 C9 E8 DF 41 40","title":"Pad with bytes all of the same value as the number of padding bytes (PKCS5 padding)"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#pad-with-0x80-followed-by-zero-bytes-oneandzeroes-padding","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6F 72 80 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = BE 62 5D 9F F3 C6 C8 40 This is actually the same as the padding of md5 and sha1.","title":"Pad with 0x80 followed by zero bytes (OneAndZeroes Padding)"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#pad-with-zeroes-except-make-the-last-byte-equal-to-the-number-of-padding-bytes","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 05 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 91 19 2C 64 B5 5C 5D B8","title":"Pad with zeroes except make the last byte equal to the number of padding bytes"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#pad-with-zero-null-characters","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 00 00 00 00 00 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = 9E 14 FB 96 C5 FE EB 75","title":"Pad with zero (null) characters"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#pad-with-spaces","text":"Examples are as follows DES INPUT BLOCK = f o r _ _ _ _ _ (IN HEX) 66 6f 72 20 20 20 20 20 KEY = 01 23 45 67 89 AB CD EF DES OUTPUT BLOCK = E3 FF EC E5 21 1F 35 25","title":"Pad with spaces"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#2018-shanghai-university-student-network-security-competition-aessss","text":"Sometimes you can attack some improperly used Padding. Here is a topic of the 2018 Shanghai University Student Network Security Competition: The title script is as follows: import random import sys import string from hashlib import sha256 import SocketServer from Crypto.Cipher import AES from secret import FLAG , IV , KEY class Task ( SocketServer . BaseRequestHandler ): def proof_of_work ( self ): proof = '' . join ( [ random . choice ( string . ascii_letters + string . digits ) for _ in xrange ( 20 )]) # print proof digest = sha256 ( proof ) . hexdigest () self . request . send ( \"sha256(XXXX+ %s ) == %s \\n \" % ( proof [ 4 :], digest )) self . request . send ( 'Give me XXXX:' ) x = self . request . recv ( 10 ) x = x . strip () if len ( x ) != 4 or sha256 ( x + proof [ 4 :]) . hexdigest () != digest : return False return True def pad ( self , s ): s + = ( 256 - only ( s )) * chr ( 256 - only ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return & #39;&#39; .join (right [0: -word (right [-1])]) s_box = [ 0x63 , 0x7C , 0x77 , 0x7B , 0xF2 , 0x6B , 0x6F , 0xC5 , 0x30 , 0x01 , 0x67 , 0x2B , 0xFE , 0xD7 , 0xAB , 0x76 , 0xCA , 0x82 , 0xC9 , 0x7D , 0xFA , 0x59 , 0x47 , 0xF0 , 0xAD , 0xD4 , 0xA2 , 0xAF , 0x9C , 0xA4 , 0x72 , 0xC0 , 0xB7 , 0xFD , 0x93 , 0x26 , 0x36 , 0x3F , 0xF7 , 0xCC , 0x34 , 0xA5 , 0xE5 , 0xF1 , 0x71 , 0xD8 , 0x31 , 0x15 , 0x04 , 0xC7 , 0x23 , 0xC3 , 0x18 , 0x96 , 0x05 , 0x9A , 0x07 , 0x12 , 0x80 , 0xE2 , 0xEB , 0x27 , 0xB2 , 0x75 , 0x09 , 0x83 , 0x2C , 0x1A , 0x1B , 0x6E , 0x5A , 0xA0 , 0x52 , 0x3B , 0xD6 , 0xB3 , 0x29 , 0xE3 , 0x2F , 0x84 , 0x53 , 0xD1 , 0x00 , 0xED , 0x20 , 0xFC , 0xB1 , 0x5B , 0x6A , 0xCB , 0xBE , 0x39 , 0x4A , 0x4C , 0x58 , 0xCF , 0xD0 , 0xEF , 0xAA , 0xFB , 0x43 , 0x4D , 0x33 , 0x85 , 0x45 , 0xF9 , 0x02 , 0x7F , 0x50 , 0x3C , 0x9F , 0xA8 , 0x51 , 0xA3 , 0x40 , 0x8F , 0x92 , 0x9D , 0x38 , 0xF5 , 0xBC , 0xB6 , 0xDA , 0x21 , 0x10 , 0xFF , 0xF3 , 0xD2 , 0xCD , 0x0C , 0x13 , 0xEC , 0x5F , 0x97 , 0x44 , 0x17 , 0xC4 , 0xA7 , 0x7E , 0x3D , 0x64 , 0x5D , 0x19 , 0x73 , 0x60 , 0x81 , 0x4F , 0xDC , 0x22 , 0x2A , 0x90 , 0x88 , 0x46 , 0xEE , 0xB8 , 0x14 , 0xDE , 0x5E , 0x0B , 0xDB , 0xE0 , 0x32 , 0x3A , 0x0A , 0x49 , 0x06 , 0x24 , 0x5C , 0xC2 , 0xD3 , 0xAC , 0x62 , 0x91 , 0x95 , 0xE4 , 0x79 , 0xE7 , 0xC8 , 0x37 , 0x6D , 0x8D , 0xD5 , 0x4E , 0xA9 , 0x6C , 0x56 , 0xF4 , 0xEA , 0x65 , 0x7A , 0xAE , 0x08 , 0xBA , 0x78 , 0x25 , 0x2E , 0x1C , 0xA6 , 0xB4 , 0xC6 , 0xE8 , 0xDD , 0x74 , 0x1F , 0x4B , 0xBD , 0x8B , 0x8A , 0x70 , 0x3E , 0xB5 , 0x66 , 0x48 , 0x03 , 0xF6 , 0x0E , 0x61 , 0x35 , 0x57 , 0xB9 , 0x86 , 0xC1 , 0x1D , 0x9E , 0xE1 , 0xF8 , 0x98 , 0x11 , 0x69 , 0xD9 , 0x8E , 0x94 , 0x9B , 0x1E , 0x87 , 0xE9 , 0xCE , 0x55 , 0x28 , 0xDF , 0x8C , 0xA1 , 0x89 , 0x0D , 0xBF , 0xE6 , 0x42 , 0x68 , 0x41 , 0x99 , 0x2D , 0x0F , 0xB0 , 0x54 , 0xBB , 0x16 ] invs_box = [ 0x52 , 0x09 , 0x6A , 0xD5 , 0x30 , 0x36 , 0xA5 , 0x38 , 0xBF , 0x40 , 0xA3 , 0x9E , 0x81 , 0xF3 , 0xD7 , 0xFB , 0x7C , 0xE3 , 0x39 , 0x82 , 0x9B , 0x2F , 0xFF , 0x87 , 0x34 , 0x8E , 0x43 , 0x44 , 0xC4 , 0xDE , 0xE9 , 0xCB , 0x54 , 0x7B , 0x94 , 0x32 , 0xA6 , 0xC2 , 0x23 , 0x3D , 0xEE , 0x4C , 0x95 , 0x0B , 0x42 , 0xFA , 0xC3 , 0x4E , 0x08 , 0x2E , 0xA1 , 0x66 , 0x28 , 0xD9 , 0x24 , 0xB2 , 0x76 , 0x5B , 0xA2 , 0x49 , 0x6D , 0x8B , 0xD1 , 0x25 , 0x72 , 0xF8 , 0xF6 , 0x64 , 0x86 , 0x68 , 0x98 , 0x16 , 0xD4 , 0xA4 , 0x5C , 0xCC , 0x5D , 0x65 , 0xB6 , 0x92 , 0x6C , 0x70 , 0x48 , 0x50 , 0xFD , 0xED , 0xB9 , 0xDA , 0x5E , 0x15 , 0x46 , 0x57 , 0xA7 , 0x8D , 0x9D , 0x84 , 0x90 , 0xD8 , 0xAB , 0x00 , 0x8C , 0xBC , 0xD3 , 0x0A , 0xF7 , 0xE4 , 0x58 , 0x05 , 0xB8 , 0xB3 , 0x45 , 0x06 , 0xD0 , 0x2C , 0x1E , 0x8F , 0xCA , 0x3F , 0x0F , 0x02 , 0xC1 , 0xAF , 0xBD , 0x03 , 0x01 , 0x13 , 0x8A , 0x6B , 0x3A , 0x91 , 0x11 , 0x41 , 0x4F , 0x67 , 0xDC , 0xEA , 0x97 , 0xF2 , 0xCF , 0xCE , 0xF0 , 0xB4 , 0xE6 , 0x73 , 0x96 , 0xAC , 0x74 , 0x22 , 0xE7 , 0xAD , 0x35 , 0x85 , 0xE2 , 0xF9 , 0x37 , 0xE8 , 0x1C , 0x75 , 0xDF , 0x6E , 0x47 , 0xF1 , 0x1A , 0x71 , 0x1D , 0x29 , 0xC5 , 0x89 , 0x6F , 0xB7 , 0x62 , 0x0E , 0xAA , 0x18 , 0xBE , 0x1B , 0xFC , 0x56 , 0x3E , 0x4B , 0xC6 , 0xD2 , 0x79 , 0x20 , 0x9A , 0xDB , 0xC0 , 0xFE , 0x78 , 0xCD , 0x5A , 0xF4 , 0x1F , 0xDD , 0xA8 , 0x33 , 0x88 , 0x07 , 0xC7 , 0x31 , 0xB1 , 0x12 , 0x10 , 0x59 , 0x27 , 0x80 , 0xEC , 0x5F , 0x60 , 0x51 , 0x7F , 0xA9 , 0x19 , 0xB5 , 0x4A , 0x0D , 0x2D , 0xE5 , 0x7A , 0x9F , 0x93 , 0xC9 , 0x9C , 0xEF , 0xA0 , 0xE0 , 0x3B , 0x4D , 0xAE , 0x2A , 0xF5 , 0xB0 , 0xC8 , 0xEB , 0xBB , 0x3C , 0x83 , 0x53 , 0x99 , 0x61 , 0x17 , 0x2B , 0x04 , 0x7E , 0xBA , 0x77 , 0xD6 , 0x26 , 0xE1 , 0x69 , 0x14 , 0x63 , 0x55 , 0x21 , 0x0C , 0x7D ] def encrypt ( self , msg ): cipher = AES . new ( KEY , AES . MODE_CBC , IV ) return cipher . encrypt ( msg ) . encode ( 'hex' ) def handle ( self ): if not self . proof_of_work (): return self . request . settimeout ( 15 ) req = self . request flag_len = len ( FLAG ) assert ( flag_len == 33 ) self . flag = self . pad ( FLAG ) assert ( len ( self . flag ) == 256 ) while True : req . sendall ( 'Welcome to AES(WXH) encrypt system. \\n 1. get encrypted flag. \\n 2. pad flag. \\n 3.Do some encrypt. \\n Your choice:' ) cmd = req . recv ( 2 ) . strip () try : cmd = int ( cmd ) except ValueError : cmd = 0 if cmd == 1 : enc = self . encrypt ( self . flag ) req . sendall ( 'Here is the encrypted flag: 0x %s \\n ' % enc ) elif cmd == 2 : req . sendall ( 'Pad me something:' ) self . flag = self . unpad ( self . flag ) [ : flag_len ] + req . recv ( 1024 ) . strip () assert ( len ( self . flag ) <= 256 ) self . flag = self . pad ( self . flag ) req . sendall ( 'Done. \\n ' ) elif cmd == 3 : req . sendall ( 'What do you want to encrypt:' ) msg = self . pad ( req . recv ( 1024 ) . strip ()) assert ( len ( msg ) & lt ; = 256 ) enc = self . encrypt ( msg ) req . sendall ( 'Here is the encrypted message: 0x %s \\n ' % enc ) else : req . sendall ( 'Do not lose heart\uff5e \uff01% Once WXH AK IOI 2019 can Solved! WXH is the first in the tianxia!' ) req . close () return class ThreadedServer ( SocketServer . ThreadingMixIn , SocketServer . TCPServer ): pass if __name__ == \"__main__\" : HOST , PORT = '0.0.0.0' , 23333 print 'Run in port:23333' server = ThreadedServer (( HOST , PORT ), Task ) server . allow_reuse_address = True server . serve_forever ()","title":"2018 Shanghai University Student Network Security Competition aessss"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#analysis","text":"The problem with this problem is in padding. Since there are less than 256 bits to padding, the padding bytes are the missing bytes, but if the plaintext is 256 bytes, then padding is not performed according to the code logic: def pad ( self , s ): s + = ( 256 - only ( s )) * chr ( 256 - only ( s )) ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . s_box ): ret [ pos ] = s [ index ] return '' . join ( ret ) The biggest problem is on the unpad, which is not checked by the unpad, only the last byte is used to determine the number of bytes to fill. def unpad ( self , s ): ret = [ ' \\x00 ' for _ in range ( 256 )] for index , pos in enumerate ( self . invs_box ): ret [ pos ] = s [ index ] return & #39;&#39; .join (right [0: -word (right [-1])]) We can control the number of padding bytes removed by tampering with the last byte.","title":"Analysis"},{"location":"crypto/ctf-wiki/blockcipher/mode/padding/#use","text":"Select choice2 and append 256-33 = 223 bytes so that the current flag does not need to be filled. The last byte appended is set to chr(256-32) . The server appends our information to the flag and performs s box substitution, and the result is assigned to the flag variable in the class. We choose choice2 again, here we need to append, the server will take the flag variable in the class for reverse S box replacement and unpad, so according to this unpad algorithm will be the next 224 bytes as the padding removed, the plaintext is left The first 32 bits of the real flag. We enter a character i at this time, then the object encrypted at this time is flag[:32]+i . Select choice1 to encrypt the current flag, control i to blast, and if the resulting ciphertext is the same as the original flag encrypted ciphertext, the last byte of the flag is obtained. Bleak byte by byte until all flags are obtained. Exp is as follows: # -*- coding: utf-8 -*- from hashlib import sha256 import socket import string import itertools HOST = '106.75.13.64' PORT = 54321 sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( HOST , PORT )) def brute_force ( pad , shavalue ): for str in itertools . product ( string . ascii_letters + string . digits , repeat = 4 ): str = '' . join ( str ) if sha256 ( str + pad ) . hexdigest () == shavalue : print str return str def choice1 (): sock . send ( \"1 \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 30 :] sock . recv ( 1024 ) . strip () return result def choice2 ( pad ): sock . send ( \"2 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( pad + \" \\n \" ) sock . recv ( 1024 ) . strip () sock . recv ( 1024 ) . strip () def choice3 ( str ): sock . send ( \"3 \\n \" ) sock . recv ( 1024 ) . strip () sock . send ( str + \" \\n \" ) result = sock . recv ( 1024 ) . strip ()[ 33 :] sock . recv ( 1024 ) . strip () return result content = sock . recv ( 1024 ) . strip () pad = content [ 12 : 12 + 16 ] hash = content [ 33 : 33 + 64 ] sock . recv ( 1024 ) . strip () sock . send ( str ( brute_force ( pad , hash )) + \" \\n \" ) print sock . recv ( 1024 ) . strip () flag_enc = choice1 () flag = \"\" for i in range ( 33 ): a = '' . join ([ 'a' for _ in range ( 223 )]) a = a [: - 1 ] + chr ( 224 + i ) for c in string . printable : print c + flag choice2 ( a ) choice2 ( c + flag ) if choice1 () == flag_enc : flag = c + flag print \"success:\" , flag break flag{H4ve_fun_w1th_p4d_and_unp4d}","title":"Use"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc-zh/","text":"EN | ZH PCBC \u00b6 PCBC \u7684\u5168\u79f0\u4e3a\u660e\u6587\u5bc6\u7801\u5757\u94fe\u63a5\uff08Plaintext cipher-block chaining\uff09\u3002\u4e5f\u79f0\u4e3a\u586b\u5145\u5bc6\u7801\u5757\u94fe\u63a5\uff08Propagating cipher-block chaining\uff09\u3002 \u52a0\u5bc6 \u00b6 \u89e3\u5bc6 \u00b6 \u7279\u70b9 \u00b6 \u89e3\u5bc6\u8fc7\u7a0b\u96be\u4ee5\u5e76\u884c\u5316 \u4e92\u6362\u90bb\u63a5\u7684\u5bc6\u6587\u5757\u4e0d\u4f1a\u5bf9\u540e\u9762\u7684\u5bc6\u6587\u5757\u9020\u6210\u5f71\u54cd","title":"Pcbc zh"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc-zh/#pcbc","text":"PCBC \u7684\u5168\u79f0\u4e3a\u660e\u6587\u5bc6\u7801\u5757\u94fe\u63a5\uff08Plaintext cipher-block chaining\uff09\u3002\u4e5f\u79f0\u4e3a\u586b\u5145\u5bc6\u7801\u5757\u94fe\u63a5\uff08Propagating cipher-block chaining\uff09\u3002","title":"PCBC"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc-zh/#_1","text":"","title":"\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc-zh/#_2","text":"","title":"\u89e3\u5bc6"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc-zh/#_3","text":"\u89e3\u5bc6\u8fc7\u7a0b\u96be\u4ee5\u5e76\u884c\u5316 \u4e92\u6362\u90bb\u63a5\u7684\u5bc6\u6587\u5757\u4e0d\u4f1a\u5bf9\u540e\u9762\u7684\u5bc6\u6587\u5757\u9020\u6210\u5f71\u54cd","title":"\u7279\u70b9"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc/","text":"EN | ZH PCBC \u00b6 The full name of PCBC is Plaintext cipher-block chaining. Also known as Propagating cipher-block chaining. Encryption \u00b6 decryption \u00b6 Features \u00b6 The decryption process is difficult to parallelize Interchanging adjacent ciphertext blocks does not affect subsequent ciphertext blocks","title":"PCBC"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc/#pcbc","text":"The full name of PCBC is Plaintext cipher-block chaining. Also known as Propagating cipher-block chaining.","title":"PCBC"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc/#encryption","text":"","title":"Encryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc/#decryption","text":"","title":"decryption"},{"location":"crypto/ctf-wiki/blockcipher/mode/pcbc/#features","text":"The decryption process is difficult to parallelize Interchanging adjacent ciphertext blocks does not affect subsequent ciphertext blocks","title":"Features"},{"location":"crypto/ctf-wiki/certificate/introduction-zh/","text":"EN | ZH \u8bc1\u4e66\u683c\u5f0f \u00b6 DER \u00b6 \u4f7f\u7528\u8be5\u6269\u5c55\u540d\u7684\u8bc1\u4e66\u91c7\u7528 \u4e8c\u8fdb\u5236\u7f16\u7801 \uff0c\u5f53\u7136\uff0c\u8fd9\u4e9b\u8bc1\u4e66\u4e5f\u53ef\u4ee5\u4f7f\u7528 CER \u6216\u8005 CRT \u4f5c\u4e3a\u6269\u5c55\u540d\u3002 PEM \u00b6 \u4f7f\u7528\u8be5\u6269\u5c55\u540d\u7684\u8bc1\u4e66\u91c7\u7528 Base64 \u7f16\u7801\uff0c\u6587\u4ef6\u7684\u5f00\u59cb\u662f\u4e00\u884c -----BEGIN \u3002 \u683c\u5f0f\u8f6c\u6362 \u00b6 openssl x509 -outform der -in certificate.pem -out certificate.der openssl x509 -inform der -in certificate.cer -out certificate.pem","title":"Introduction zh"},{"location":"crypto/ctf-wiki/certificate/introduction-zh/#_1","text":"","title":"\u8bc1\u4e66\u683c\u5f0f"},{"location":"crypto/ctf-wiki/certificate/introduction-zh/#der","text":"\u4f7f\u7528\u8be5\u6269\u5c55\u540d\u7684\u8bc1\u4e66\u91c7\u7528 \u4e8c\u8fdb\u5236\u7f16\u7801 \uff0c\u5f53\u7136\uff0c\u8fd9\u4e9b\u8bc1\u4e66\u4e5f\u53ef\u4ee5\u4f7f\u7528 CER \u6216\u8005 CRT \u4f5c\u4e3a\u6269\u5c55\u540d\u3002","title":"DER"},{"location":"crypto/ctf-wiki/certificate/introduction-zh/#pem","text":"\u4f7f\u7528\u8be5\u6269\u5c55\u540d\u7684\u8bc1\u4e66\u91c7\u7528 Base64 \u7f16\u7801\uff0c\u6587\u4ef6\u7684\u5f00\u59cb\u662f\u4e00\u884c -----BEGIN \u3002","title":"PEM"},{"location":"crypto/ctf-wiki/certificate/introduction-zh/#_2","text":"openssl x509 -outform der -in certificate.pem -out certificate.der openssl x509 -inform der -in certificate.cer -out certificate.pem","title":"\u683c\u5f0f\u8f6c\u6362"},{"location":"crypto/ctf-wiki/certificate/introduction/","text":"EN | ZH \u8bc1\u4e66\u683c\u5f0f \u00b6 THE \u00b6 Certificates with this extension are binary encoding , of course, these certificates can also use CER or CRT as the extension. PEM \u00b6 Certificates that use this extension are Base64 encoded, starting with a line of -----BEGIN . Format Conversion \u00b6 openssl x509 -outform der -in certificate.pem -out certificate.der openssl x509 -inform der -in certificate.cer -out certificate.pem","title":"Introduction"},{"location":"crypto/ctf-wiki/certificate/introduction/#_1","text":"","title":"\u8bc1\u4e66\u683c\u5f0f"},{"location":"crypto/ctf-wiki/certificate/introduction/#the","text":"Certificates with this extension are binary encoding , of course, these certificates can also use CER or CRT as the extension.","title":"THE"},{"location":"crypto/ctf-wiki/certificate/introduction/#pem","text":"Certificates that use this extension are Base64 encoded, starting with a line of -----BEGIN .","title":"PEM"},{"location":"crypto/ctf-wiki/certificate/introduction/#format-conversion","text":"openssl x509 -outform der -in certificate.pem -out certificate.der openssl x509 -inform der -in certificate.cer -out certificate.pem","title":"Format Conversion"},{"location":"crypto/ctf-wiki/classical/introduction-zh/","text":"EN | ZH \u5728\u53e4\u5178\u5bc6\u7801\u5b66\u4e2d\uff0c\u6211\u4eec\u4e3b\u8981\u4ecb\u7ecd\u5355\u8868\u66ff\u4ee3\u5bc6\u7801\uff0c\u591a\u8868\u66ff\u4ee3\u5bc6\u7801\uff0c\u4ee5\u53ca\u4e00\u4e9b\u5176\u5b83\u6bd4\u8f83\u6709\u610f\u601d\u7684\u5bc6\u7801\u3002 \u503c\u5f97\u4e00\u63d0\u7684\u662f\uff0c\u5728\u53e4\u5178\u5bc6\u7801\u5b66\u4e2d\uff0c\u8bbe\u8ba1\u8005\u4e3b\u8981\u8003\u8651\u6d88\u606f\u7684\u4fdd\u5bc6\u6027\uff0c\u4f7f\u5f97\u53ea\u6709\u76f8\u5173\u5bc6\u94a5\u7684\u4eba\u624d\u53ef\u4ee5\u89e3\u5bc6\u5bc6\u6587\u83b7\u5f97\u6d88\u606f\u7684\u5185\u5bb9\uff0c\u5bf9\u4e8e\u6d88\u606f\u7684\u5b8c\u6574\u6027\u548c\u4e0d\u53ef\u5426\u8ba4\u6027\u5219\u5e76\u6ca1\u6709\u8fdb\u884c\u592a\u591a\u7684\u8003\u8651\u3002 \u62d3\u5c55\u9605\u8bfb CTF \u4e2d\u90a3\u4e9b\u8111\u6d1e\u5927\u5f00\u7684\u7f16\u7801\u548c\u52a0\u5bc6 \u53e4\u5178\u5bc6\u7801\u5b66\u53d1\u5c55\u53f2 \u53e4\u5178\u5bc6\u7801\u2014\u2014\u7ef4\u57fa\u767e\u79d1","title":"Introduction zh"},{"location":"crypto/ctf-wiki/classical/introduction/","text":"EN | ZH In classical cryptography, we mainly introduce single-table alternative passwords, multi-table alternative passwords, and some other more interesting passwords. It is worth mentioning that in classical cryptography, the designer mainly considers the confidentiality of the message, so that only the person with the relevant key can decrypt the ciphertext to obtain the content of the message, and the integrity and non-repudiation of the message are not carried out. Too many considerations. Expand reading [The coding and encryption of those brain holes in the CTF] ( http://www.tuicool.com/articles/2E3INnm ) [History of Classical Cryptography] ( http://www.oscca.gov.cn/sca/zxfw/2017-04/24/content_1011709.shtml ) [Classical Password - Wikipedia] ( https://en.wikipedia.org/wiki/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A2%BC )","title":"\u53e4\u5178\u5bc6\u7801\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/","text":"EN | ZH \u901a\u7528\u7279\u70b9 \u00b6 \u5728\u5355\u8868\u66ff\u6362\u52a0\u5bc6\u4e2d\uff0c\u6240\u6709\u7684\u52a0\u5bc6\u65b9\u5f0f\u51e0\u4e4e\u90fd\u6709\u4e00\u4e2a\u5171\u6027\uff0c\u90a3\u5c31\u662f\u660e\u5bc6\u6587\u4e00\u4e00\u5bf9\u5e94\u3002\u6240\u4ee5\u8bf4\uff0c\u4e00\u822c\u6709\u4ee5\u4e0b\u4e24\u79cd\u65b9\u5f0f\u6765\u8fdb\u884c\u7834\u89e3 \u5728\u5bc6\u94a5\u7a7a\u95f4\u8f83\u5c0f\u7684\u60c5\u51b5\u4e0b\uff0c\u91c7\u7528\u66b4\u529b\u7834\u89e3\u65b9\u5f0f \u5728\u5bc6\u6587\u957f\u5ea6\u8db3\u591f\u957f\u7684\u65f6\u5019\uff0c\u4f7f\u7528\u8bcd\u9891\u5206\u6790\uff0c http://quipqiup.com/ \u5f53\u5bc6\u94a5\u7a7a\u95f4\u8db3\u591f\u5927\uff0c\u800c\u5bc6\u6587\u957f\u5ea6\u8db3\u591f\u77ed\u7684\u60c5\u51b5\u4e0b\uff0c\u7834\u89e3\u8f83\u4e3a\u56f0\u96be\u3002 \u51ef\u6492\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u51ef\u6492\u5bc6\u7801\uff08Caesar\uff09\u52a0\u5bc6\u65f6\u4f1a\u5c06\u660e\u6587\u4e2d\u7684 \u6bcf\u4e2a\u5b57\u6bcd \u90fd\u6309\u7167\u5176\u5728\u5b57\u6bcd\u8868\u4e2d\u7684\u987a\u5e8f\u5411\u540e\uff08\u6216\u5411\u524d\uff09\u79fb\u52a8\u56fa\u5b9a\u6570\u76ee\uff08 \u5faa\u73af\u79fb\u52a8 \uff09\u4f5c\u4e3a\u5bc6\u6587\u3002\u4f8b\u5982\uff0c\u5f53\u504f\u79fb\u91cf\u662f\u5de6\u79fb 3 \u7684\u65f6\u5019\uff08\u89e3\u5bc6\u65f6\u7684\u5bc6\u94a5\u5c31\u662f 3\uff09\uff1a \u660e\u6587\u5b57\u6bcd\u8868\uff1aABCDEFGHIJKLMNOPQRSTUVWXYZ \u5bc6\u6587\u5b57\u6bcd\u8868\uff1aDEFGHIJKLMNOPQRSTUVWXYZABC \u4f7f\u7528\u65f6\uff0c\u52a0\u5bc6\u8005\u67e5\u627e\u660e\u6587\u5b57\u6bcd\u8868\u4e2d\u9700\u8981\u52a0\u5bc6\u7684\u6d88\u606f\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5b57\u6bcd\u6240\u5728\u4f4d\u7f6e\uff0c\u5e76\u4e14\u5199\u4e0b\u5bc6\u6587\u5b57\u6bcd\u8868\u4e2d\u5bf9\u5e94\u7684\u5b57\u6bcd\u3002\u9700\u8981\u89e3\u5bc6\u7684\u4eba\u5219\u6839\u636e\u4e8b\u5148\u5df2\u77e5\u7684\u5bc6\u94a5\u53cd\u8fc7\u6765\u64cd\u4f5c\uff0c\u5f97\u5230\u539f\u6765\u7684\u660e\u6587\u3002\u4f8b\u5982\uff1a \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG \u5bc6\u6587\uff1aWKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ \u6839\u636e\u504f\u79fb\u91cf\u7684\u4e0d\u540c\uff0c\u8fd8\u5b58\u5728 \u82e5\u5e72\u7279\u5b9a\u7684\u607a\u6492\u5bc6\u7801\u540d\u79f0 \uff1a \u504f\u79fb\u91cf\u4e3a 10\uff1aAvocat \uff08A\u2192K\uff09 \u504f\u79fb\u91cf\u4e3a 13\uff1a ROT13 \u504f\u79fb\u91cf\u4e3a -5\uff1aCassis \uff08K 6\uff09 \u504f\u79fb\u91cf\u4e3a -6\uff1aCassette \uff08K 7\uff09 \u6b64\u5916\uff0c\u8fd8\u6709\u8fd8\u6709\u4e00\u79cd\u57fa\u4e8e\u5bc6\u94a5\u7684\u51ef\u6492\u5bc6\u7801 Keyed Caesar\u3002\u5176\u57fa\u672c\u539f\u7406\u662f \u5229\u7528\u4e00\u4e2a\u5bc6\u94a5\uff0c\u5c06\u5bc6\u94a5\u7684\u6bcf\u4e00\u4f4d\u8f6c\u6362\u4e3a\u6570\u5b57\uff08\u4e00\u822c\u8f6c\u5316\u4e3a\u5b57\u6bcd\u8868\u5bf9\u5e94\u987a\u5e8f\u7684\u6570\u5b57\uff09\uff0c\u5206\u522b\u4ee5\u8fd9\u4e00\u6570\u5b57\u4e3a\u5bc6\u94a5\u52a0\u5bc6\u660e\u6587\u7684\u6bcf\u4e00\u4f4d\u5b57\u6bcd\u3002 \u8fd9\u91cc\u4ee5 XMan \u4e00\u671f\u590f\u4ee4\u8425\u5206\u4eab\u8d5b\u5bab\u4fdd\u9e21\u4e01\u961f Crypto 100 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002 \u5bc6\u6587\uff1as0a6u3u1s0bv1a \u5bc6\u94a5\uff1aguangtou \u504f\u79fb\uff1a6,20,0,13,6,19,14,20 \u660e\u6587\uff1ay0u6u3h1y0uj1u \u7834\u89e3 \u00b6 \u5bf9\u4e8e\u4e0d\u5e26\u5bc6\u94a5\u7684\u51ef\u6492\u5bc6\u7801\u6765\u8bf4\uff0c\u5176\u57fa\u672c\u7684\u7834\u89e3\u65b9\u6cd5\u6709\u4e24\u79cd\u65b9\u5f0f \u904d\u5386 26 \u4e2a\u504f\u79fb\u91cf\uff0c\u9002\u7528\u4e8e\u666e\u904d\u60c5\u51b5 \u5229\u7528\u8bcd\u9891\u5206\u6790\uff0c\u9002\u7528\u4e8e\u5bc6\u6587\u8f83\u957f\u7684\u60c5\u51b5\u3002 \u5176\u4e2d\uff0c\u7b2c\u4e00\u79cd\u65b9\u5f0f\u80af\u5b9a\u53ef\u4ee5\u5f97\u5230\u660e\u6587\uff0c\u800c\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u5219\u4e0d\u4e00\u5b9a\u53ef\u4ee5\u5f97\u5230\u6b63\u786e\u7684\u660e\u6587\u3002 \u800c\u5bf9\u4e8e\u57fa\u4e8e\u5bc6\u94a5\u7684\u51ef\u6492\u5bc6\u7801\u6765\u8bf4\uff0c\u4e00\u822c\u6765\u8bf4\u5fc5\u987b\u77e5\u9053\u5bf9\u5e94\u7684\u5bc6\u94a5\u3002 \u5de5\u5177 \u00b6 \u4e00\u822c\u6211\u4eec\u6709\u5982\u4e0b\u7684\u5de5\u5177\uff0c\u5176\u4e2dJPK\u6bd4\u8f83\u901a\u7528\u3002 JPK\uff0c\u53ef\u89e3\u5e26\u5bc6\u94a5\u4e0e\u4e0d\u5e26\u5bc6\u94a5 http://planetcalc.com/1434/ http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php \u79fb\u4f4d\u5bc6\u7801 \u00b6 \u4e0e\u51ef\u6492\u5bc6\u7801\u7c7b\u4f3c\uff0c\u533a\u522b\u5728\u4e8e\u79fb\u4f4d\u5bc6\u7801\u4e0d\u4ec5\u4f1a\u5904\u7406\u5b57\u6bcd\uff0c\u8fd8\u4f1a\u5904\u7406\u6570\u5b57\u548c\u7279\u6b8a\u5b57\u7b26\uff0c\u5e38\u7528 ASCII \u7801\u8868\u8fdb\u884c\u79fb\u4f4d\u3002\u5176\u7834\u89e3\u65b9\u6cd5\u4e5f\u662f\u904d\u5386\u6240\u6709\u7684\u53ef\u80fd\u6027\u6765\u5f97\u5230\u53ef\u80fd\u7684\u7ed3\u679c\u3002 Atbash Cipher \u00b6 \u539f\u7406 \u00b6 \u57c3\u7279\u5df4\u4ec0\u7801\uff08Atbash Cipher\uff09\u5176\u5b9e\u53ef\u4ee5\u89c6\u4e3a\u4e0b\u9762\u8981\u4ecb\u7ecd\u7684\u7b80\u5355\u66ff\u6362\u5bc6\u7801\u7684\u7279\u4f8b\uff0c\u5b83\u4f7f\u7528\u5b57\u6bcd\u8868\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4ee3\u8868\u7b2c\u4e00\u4e2a\u5b57\u6bcd\uff0c\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b57\u6bcd\u4ee3\u8868\u7b2c\u4e8c\u4e2a\u5b57\u6bcd\u3002\u5728\u7f57\u9a6c\u5b57\u6bcd\u8868\u4e2d\uff0c\u5b83\u662f\u8fd9\u6837\u51fa\u73b0\u7684\uff1a \u660e\u6587\uff1aA B C D E F G H I J K L M N O P Q R S T U V W X Y Z \u5bc6\u6587\uff1aZ Y X W V U T S R Q P O N M L K J I H G F E D C B A \u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50\uff1a \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6\u6587\uff1agsv jfrxp yildm ulc qfnkh levi gsv ozab wlt \u7834\u89e3 \u00b6 \u53ef\u4ee5\u770b\u51fa\u5176\u5bc6\u94a5\u7a7a\u95f4\u8db3\u591f\u77ed\uff0c\u540c\u65f6\u5f53\u5bc6\u6587\u8db3\u591f\u957f\u65f6\uff0c\u4ecd\u7136\u53ef\u4ee5\u91c7\u7528\u8bcd\u9891\u5206\u6790\u7684\u65b9\u6cd5\u89e3\u51b3\u3002 \u5de5\u5177 \u00b6 http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/ \u7b80\u5355\u66ff\u6362\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u7b80\u5355\u66ff\u6362\u5bc6\u7801\uff08Simple Substitution Cipher\uff09\u52a0\u5bc6\u65f6\uff0c\u5c06\u6bcf\u4e2a\u660e\u6587\u5b57\u6bcd\u66ff\u6362\u4e3a\u4e0e\u4e4b\u552f\u4e00\u5bf9\u5e94\u4e14\u4e0d\u540c\u7684\u5b57\u6bcd\u3002\u5b83\u4e0e\u607a\u6492\u5bc6\u7801\u4e4b\u95f4\u7684\u533a\u522b\u662f\u5176\u5bc6\u7801\u5b57\u6bcd\u8868\u7684\u5b57\u6bcd\u4e0d\u662f\u7b80\u5355\u7684\u79fb\u4f4d\uff0c\u800c\u662f\u5b8c\u5168\u662f\u6df7\u4e71\u7684\uff0c\u8fd9\u4e5f\u4f7f\u5f97\u5176\u7834\u89e3\u96be\u5ea6\u8981\u9ad8\u4e8e\u51ef\u6492\u5bc6\u7801\u3002 \u6bd4\u5982\uff1a \u660e\u6587\u5b57\u6bcd : abcdefghijklmnopqrstuvwxyz \u5bc6\u94a5\u5b57\u6bcd : phqgiumeaylnofdxjkrcvstzwb a \u5bf9\u5e94 p\uff0cd \u5bf9\u5e94 h\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002 \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6\u6587\uff1acei jvaql hkdtf udz yvoxr dsik cei npbw gdm \u800c\u89e3\u5bc6\u65f6\uff0c\u6211\u4eec\u4e00\u822c\u662f\u77e5\u9053\u4e86\u6bcf\u4e00\u4e2a\u5b57\u6bcd\u7684\u5bf9\u5e94\u89c4\u5219\uff0c\u624d\u53ef\u4ee5\u6b63\u5e38\u89e3\u5bc6\u3002 \u7834\u89e3 \u00b6 \u7531\u4e8e\u8fd9\u79cd\u52a0\u5bc6\u65b9\u5f0f\u5bfc\u81f4\u5176\u6240\u6709\u7684\u5bc6\u94a5\u4e2a\u6570\u662f 26! 26! \uff0c\u6240\u4ee5\u51e0\u4e4e\u4e0a\u4e0d\u53ef\u80fd\u4f7f\u7528\u66b4\u529b\u7684\u89e3\u51b3\u65b9\u5f0f\u3002\u6240\u4ee5\u6211\u4eec \u4e00\u822c\u91c7\u7528\u8bcd\u9891\u5206\u6790\u3002 \u5de5\u5177 \u00b6 http://quipqiup.com/ \u4eff\u5c04\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u4eff\u5c04\u5bc6\u7801\u7684\u52a0\u5bc6\u51fd\u6570\u662f E(x)=(ax+b)\\pmod m E(x)=(ax+b)\\pmod m \uff0c\u5176\u4e2d x x \u8868\u793a\u660e\u6587\u6309\u7167\u67d0\u79cd\u7f16\u7801\u5f97\u5230\u7684\u6570\u5b57 a a \u548c m m \u4e92\u8d28 m m \u662f\u7f16\u7801\u7cfb\u7edf\u4e2d\u5b57\u6bcd\u7684\u6570\u76ee\u3002 \u89e3\u5bc6\u51fd\u6570\u662f D(x)=a^{-1}(x-b)\\pmod m D(x)=a^{-1}(x-b)\\pmod m \uff0c\u5176\u4e2d a^{-1} a^{-1} \u662f a a \u5728 \\mathbb{Z}_{m} \\mathbb{Z}_{m} \u7fa4\u7684\u4e58\u6cd5\u9006\u5143\u3002 \u4e0b\u9762\u6211\u4eec\u4ee5 E(x) = (5x + 8) \\bmod 26 E(x) = (5x + 8) \\bmod 26 \u51fd\u6570\u4e3a\u4f8b\u5b50\u8fdb\u884c\u4ecb\u7ecd\uff0c\u52a0\u5bc6\u5b57\u7b26\u4e32\u4e3a AFFINE CIPHER \uff0c\u8fd9\u91cc\u6211\u4eec\u76f4\u63a5\u91c7\u7528\u5b57\u6bcd\u886826\u4e2a\u5b57\u6bcd\u4f5c\u4e3a\u7f16\u7801\u7cfb\u7edf \u660e\u6587 A F F I N E C I P H E R x 0 5 5 8 13 4 2 8 15 7 4 17 y=5x+8 y=5x+8 8 33 33 48 73 28 18 48 83 43 28 93 y\\mod26 y\\mod26 8 7 7 22 21 2 18 22 5 17 2 15 \u5bc6\u6587 I H H W V C S W F R C P \u5176\u5bf9\u5e94\u7684\u52a0\u5bc6\u7ed3\u679c\u662f IHHWVCSWFRCP \u3002 \u5bf9\u4e8e\u89e3\u5bc6\u8fc7\u7a0b\uff0c\u6b63\u5e38\u89e3\u5bc6\u8005\u5177\u6709a\u4e0eb\uff0c\u53ef\u4ee5\u8ba1\u7b97\u5f97\u5230 a^{-1} a^{-1} \u4e3a 21\uff0c\u6240\u4ee5\u5176\u89e3\u5bc6\u51fd\u6570\u662f D(x)=21(x-8)\\pmod {26} D(x)=21(x-8)\\pmod {26} \uff0c\u89e3\u5bc6\u5982\u4e0b \u5bc6\u6587 I H H W V C S W F R C P y y 8 7 7 22 21 2 18 22 5 17 2 15 x=21(y-8) x=21(y-8) 0 -21 -21 294 273 -126 210 294 -63 189 -126 147 x\\mod26 x\\mod26 0 5 5 8 13 4 2 8 15 7 4 17 \u660e\u6587 A F F I N E C I P H E R \u53ef\u4ee5\u770b\u51fa\u5176\u7279\u70b9\u5728\u4e8e\u53ea\u6709 26 \u4e2a\u82f1\u6587\u5b57\u6bcd\u3002 \u7834\u89e3 \u00b6 \u9996\u5148\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u7684\u662f\uff0c\u4eff\u5c04\u5bc6\u7801\u5bf9\u4e8e\u4efb\u610f\u4e24\u4e2a\u4e0d\u540c\u7684\u5b57\u6bcd\uff0c\u5176\u6700\u540e\u5f97\u5230\u7684\u5bc6\u6587\u5fc5\u7136\u4e0d\u4e00\u6837\uff0c\u6240\u4ee5\u5176\u4e5f\u5177\u6709\u6700\u901a\u7528\u7684\u7279\u70b9\u3002\u5f53\u5bc6\u6587\u957f\u5ea6\u8db3\u591f\u957f\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u9891\u7387\u5206\u6790\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u3002 \u5176\u6b21\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5982\u4f55\u653b\u51fb\u8be5\u5bc6\u7801\u3002\u53ef\u4ee5\u770b\u51fa\u5f53 a=1 a=1 \u65f6\uff0c\u4eff\u5c04\u52a0\u5bc6\u662f\u51ef\u6492\u52a0\u5bc6\u3002\u800c\u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u5229\u7528\u4eff\u5c04\u5bc6\u7801\u65f6\uff0c\u5176\u5b57\u7b26\u96c6\u90fd\u7528\u7684\u662f\u5b57\u6bcd\u8868\uff0c\u4e00\u822c\u53ea\u670926\u4e2a\u5b57\u6bcd\uff0c\u800c\u4e0d\u5927\u4e8e26\u7684\u4e0e26\u4e92\u7d20\u7684\u4e2a\u6570\u4e00\u5171\u6709 \\phi(26)=\\phi(2) \\times \\phi(13) = 12 \\phi(26)=\\phi(2) \\times \\phi(13) = 12 \u7b97\u4e0ab\u7684\u504f\u79fb\u53ef\u80fd\uff0c\u4e00\u5171\u6709\u53ef\u80fd\u7684\u5bc6\u94a5\u7a7a\u95f4\u5927\u5c0f\u4e5f\u5c31\u662f 12 \\times 26 = 312 12 \\times 26 = 312 \u4e00\u822c\u6765\u8bf4\uff0c\u5bf9\u4e8e\u8be5\u79cd\u5bc6\u7801\uff0c\u6211\u4eec\u81f3\u5c11\u5f97\u662f\u5728\u5df2\u77e5\u90e8\u5206\u660e\u6587\u7684\u60c5\u51b5\u4e0b\u624d\u53ef\u4ee5\u653b\u51fb\u3002\u4e0b\u9762\u8fdb\u884c\u7b80\u5355\u7684\u5206\u6790\u3002 \u8fd9\u79cd\u5bc6\u7801\u7531\u4e24\u79cd\u53c2\u6570\u6765\u63a7\u5236\uff0c\u5982\u679c\u6211\u4eec\u77e5\u9053\u5176\u4e2d\u4efb\u610f\u4e00\u4e2a\u53c2\u6570\uff0c\u90a3\u6211\u4eec\u4fbf\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u5feb\u901f\u679a\u4e3e\u53e6\u5916\u4e00\u4e2a\u53c2\u6570\u5f97\u5230\u7b54\u6848\u3002 \u4f46\u662f\uff0c\u5047\u8bbe\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u91c7\u7528\u7684\u5b57\u6bcd\u96c6\uff0c\u8fd9\u91cc\u5047\u8bbe\u4e3a26\u4e2a\u5b57\u6bcd\uff0c\u6211\u4eec\u8fd8\u6709\u53e6\u5916\u4e00\u79cd\u89e3\u5bc6\u65b9\u5f0f\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u4e24\u4e2a\u52a0\u5bc6\u540e\u7684\u5b57\u6bcd y_1,y_2 y_1,y_2 \u5373\u53ef\u8fdb\u884c\u89e3\u5bc6\u3002\u90a3\u4e48\u6211\u4eec\u8fd8\u53ef\u4ee5\u77e5\u9053 y_1=(ax_1+b)\\pmod{26} \\\\ y_2=(ax_2+b)\\pmod{26} y_1=(ax_1+b)\\pmod{26} \\\\ y_2=(ax_2+b)\\pmod{26} \u4e24\u5f0f\u76f8\u51cf\uff0c\u53ef\u5f97 y_1-y_2=a(x_1-x_2)\\pmod{26} y_1-y_2=a(x_1-x_2)\\pmod{26} \u8fd9\u91cc y_1,y_2 y_1,y_2 \u5df2\u77e5\uff0c\u5982\u679c\u6211\u4eec\u77e5\u9053\u5bc6\u6587\u5bf9\u5e94\u7684\u4e24\u4e2a\u4e0d\u4e00\u6837\u7684\u5b57\u7b26 x_1 x_1 \u4e0e x_2 x_2 \uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f88\u5bb9\u6613\u5f97\u5230 a a \uff0c\u8fdb\u800c\u5c31\u53ef\u4ee5\u5f97\u5230 b b \u4e86\u3002 \u4f8b\u5b50 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5TWCTF 2016 \u7684 super_express\u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002\u7b80\u5355\u770b\u4e00\u4e0b\u7ed9\u7684\u6e90\u7801 import sys key = '****CENSORED***************' flag = 'TWCTF{*******CENSORED********}' if len ( key ) % 2 == 1 : print ( \"Key Length Error\" ) sys . exit ( 1 ) n = len ( key ) / 2 encrypted = '' for c in flag : c = ord ( c ) for a , b in zip ( key [ 0 : n ], key [ n : 2 * n ]): c = ( ord ( a ) * c + ord ( b )) % 251 encrypted += ' %02x ' % c print encrypted \u53ef\u4ee5\u53d1\u73b0\uff0c\u867d\u7136\u5bf9\u4e8e flag \u4e2d\u7684\u6bcf\u4e2a\u5b57\u6bcd\u90fd\u52a0\u5bc6\u4e86 n \u6b21\uff0c\u5982\u679c\u6211\u4eec\u4ed4\u7ec6\u5206\u6790\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 \\begin{align*} c_1&=a_1c+b_1 \\\\ c_2&=a_2c_1+b_2 \\\\ &=a_1a_2c+a_2b_1+b_2 \\\\ &=kc+d \\end{align*} \\begin{align*} c_1&=a_1c+b_1 \\\\ c_2&=a_2c_1+b_2 \\\\ &=a_1a_2c+a_2b_1+b_2 \\\\ &=kc+d \\end{align*} \u6839\u636e\u7b2c\u4e8c\u884c\u7684\u63a8\u5bfc\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u5176\u5b9e c_n\u200b c_n\u200b \u4e5f\u662f\u8fd9\u6837\u7684\u5f62\u5f0f\uff0c\u53ef\u4ee5\u770b\u6210 c_n=xc+y\u200b c_n=xc+y\u200b \uff0c\u5e76\u4e14\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0ckey \u662f\u59cb\u7ec8\u4e0d\u53d8\u5316\u7684\uff0c\u6240\u4ee5\u8bf4\uff0c\u5176\u5b9e\u8fd9\u4e2a\u5c31\u662f\u4eff\u5c04\u5bc6\u7801\u3002 \u6b64\u5916\uff0c\u9898\u76ee\u4e2d\u8fd8\u7ed9\u51fa\u4e86\u5bc6\u6587\u4ee5\u53ca\u90e8\u5206\u90e8\u5206\u5bc6\u6587\u5bf9\u5e94\u7684\u660e\u6587\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u5f88\u5bb9\u6613\u5229\u7528\u5df2\u77e5\u660e\u6587\u653b\u51fb\u7684\u65b9\u6cd5\u6765\u653b\u51fb\u4e86\uff0c\u5229\u7528\u4ee3\u7801\u5982\u4e0b import gmpy key = '****CENSORED****************' flag = 'TWCTF{*******CENSORED********}' f = open ( 'encrypted' , 'r' ) data = f . read () . strip ( ' \\n ' ) encrypted = [ int ( data [ i : i + 2 ], 16 ) for i in range ( 0 , len ( data ), 2 )] plaindelta = ord ( flag [ 1 ]) - ord ( flag [ 0 ]) cipherdalte = encrypted [ 1 ] - encrypted [ 0 ] a = gmpy . invert ( plaindelta , 251 ) * cipherdalte % 251 b = ( encrypted [ 0 ] - a * ord ( flag [ 0 ])) % 251 a_inv = gmpy . invert ( a , 251 ) result = \"\" for c in encrypted : result += chr (( c - b ) * a_inv % 251 ) print result \u7ed3\u679c\u5982\u4e0b \u279c TWCTF2016-super_express git: ( master ) \u2717 python exploit.py TWCTF { Faster_Than_Shinkansen! }","title":"Monoalphabetic zh"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_1","text":"\u5728\u5355\u8868\u66ff\u6362\u52a0\u5bc6\u4e2d\uff0c\u6240\u6709\u7684\u52a0\u5bc6\u65b9\u5f0f\u51e0\u4e4e\u90fd\u6709\u4e00\u4e2a\u5171\u6027\uff0c\u90a3\u5c31\u662f\u660e\u5bc6\u6587\u4e00\u4e00\u5bf9\u5e94\u3002\u6240\u4ee5\u8bf4\uff0c\u4e00\u822c\u6709\u4ee5\u4e0b\u4e24\u79cd\u65b9\u5f0f\u6765\u8fdb\u884c\u7834\u89e3 \u5728\u5bc6\u94a5\u7a7a\u95f4\u8f83\u5c0f\u7684\u60c5\u51b5\u4e0b\uff0c\u91c7\u7528\u66b4\u529b\u7834\u89e3\u65b9\u5f0f \u5728\u5bc6\u6587\u957f\u5ea6\u8db3\u591f\u957f\u7684\u65f6\u5019\uff0c\u4f7f\u7528\u8bcd\u9891\u5206\u6790\uff0c http://quipqiup.com/ \u5f53\u5bc6\u94a5\u7a7a\u95f4\u8db3\u591f\u5927\uff0c\u800c\u5bc6\u6587\u957f\u5ea6\u8db3\u591f\u77ed\u7684\u60c5\u51b5\u4e0b\uff0c\u7834\u89e3\u8f83\u4e3a\u56f0\u96be\u3002","title":"\u901a\u7528\u7279\u70b9"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_2","text":"","title":"\u51ef\u6492\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_3","text":"\u51ef\u6492\u5bc6\u7801\uff08Caesar\uff09\u52a0\u5bc6\u65f6\u4f1a\u5c06\u660e\u6587\u4e2d\u7684 \u6bcf\u4e2a\u5b57\u6bcd \u90fd\u6309\u7167\u5176\u5728\u5b57\u6bcd\u8868\u4e2d\u7684\u987a\u5e8f\u5411\u540e\uff08\u6216\u5411\u524d\uff09\u79fb\u52a8\u56fa\u5b9a\u6570\u76ee\uff08 \u5faa\u73af\u79fb\u52a8 \uff09\u4f5c\u4e3a\u5bc6\u6587\u3002\u4f8b\u5982\uff0c\u5f53\u504f\u79fb\u91cf\u662f\u5de6\u79fb 3 \u7684\u65f6\u5019\uff08\u89e3\u5bc6\u65f6\u7684\u5bc6\u94a5\u5c31\u662f 3\uff09\uff1a \u660e\u6587\u5b57\u6bcd\u8868\uff1aABCDEFGHIJKLMNOPQRSTUVWXYZ \u5bc6\u6587\u5b57\u6bcd\u8868\uff1aDEFGHIJKLMNOPQRSTUVWXYZABC \u4f7f\u7528\u65f6\uff0c\u52a0\u5bc6\u8005\u67e5\u627e\u660e\u6587\u5b57\u6bcd\u8868\u4e2d\u9700\u8981\u52a0\u5bc6\u7684\u6d88\u606f\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5b57\u6bcd\u6240\u5728\u4f4d\u7f6e\uff0c\u5e76\u4e14\u5199\u4e0b\u5bc6\u6587\u5b57\u6bcd\u8868\u4e2d\u5bf9\u5e94\u7684\u5b57\u6bcd\u3002\u9700\u8981\u89e3\u5bc6\u7684\u4eba\u5219\u6839\u636e\u4e8b\u5148\u5df2\u77e5\u7684\u5bc6\u94a5\u53cd\u8fc7\u6765\u64cd\u4f5c\uff0c\u5f97\u5230\u539f\u6765\u7684\u660e\u6587\u3002\u4f8b\u5982\uff1a \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG \u5bc6\u6587\uff1aWKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ \u6839\u636e\u504f\u79fb\u91cf\u7684\u4e0d\u540c\uff0c\u8fd8\u5b58\u5728 \u82e5\u5e72\u7279\u5b9a\u7684\u607a\u6492\u5bc6\u7801\u540d\u79f0 \uff1a \u504f\u79fb\u91cf\u4e3a 10\uff1aAvocat \uff08A\u2192K\uff09 \u504f\u79fb\u91cf\u4e3a 13\uff1a ROT13 \u504f\u79fb\u91cf\u4e3a -5\uff1aCassis \uff08K 6\uff09 \u504f\u79fb\u91cf\u4e3a -6\uff1aCassette \uff08K 7\uff09 \u6b64\u5916\uff0c\u8fd8\u6709\u8fd8\u6709\u4e00\u79cd\u57fa\u4e8e\u5bc6\u94a5\u7684\u51ef\u6492\u5bc6\u7801 Keyed Caesar\u3002\u5176\u57fa\u672c\u539f\u7406\u662f \u5229\u7528\u4e00\u4e2a\u5bc6\u94a5\uff0c\u5c06\u5bc6\u94a5\u7684\u6bcf\u4e00\u4f4d\u8f6c\u6362\u4e3a\u6570\u5b57\uff08\u4e00\u822c\u8f6c\u5316\u4e3a\u5b57\u6bcd\u8868\u5bf9\u5e94\u987a\u5e8f\u7684\u6570\u5b57\uff09\uff0c\u5206\u522b\u4ee5\u8fd9\u4e00\u6570\u5b57\u4e3a\u5bc6\u94a5\u52a0\u5bc6\u660e\u6587\u7684\u6bcf\u4e00\u4f4d\u5b57\u6bcd\u3002 \u8fd9\u91cc\u4ee5 XMan \u4e00\u671f\u590f\u4ee4\u8425\u5206\u4eab\u8d5b\u5bab\u4fdd\u9e21\u4e01\u961f Crypto 100 \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002 \u5bc6\u6587\uff1as0a6u3u1s0bv1a \u5bc6\u94a5\uff1aguangtou \u504f\u79fb\uff1a6,20,0,13,6,19,14,20 \u660e\u6587\uff1ay0u6u3h1y0uj1u","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_4","text":"\u5bf9\u4e8e\u4e0d\u5e26\u5bc6\u94a5\u7684\u51ef\u6492\u5bc6\u7801\u6765\u8bf4\uff0c\u5176\u57fa\u672c\u7684\u7834\u89e3\u65b9\u6cd5\u6709\u4e24\u79cd\u65b9\u5f0f \u904d\u5386 26 \u4e2a\u504f\u79fb\u91cf\uff0c\u9002\u7528\u4e8e\u666e\u904d\u60c5\u51b5 \u5229\u7528\u8bcd\u9891\u5206\u6790\uff0c\u9002\u7528\u4e8e\u5bc6\u6587\u8f83\u957f\u7684\u60c5\u51b5\u3002 \u5176\u4e2d\uff0c\u7b2c\u4e00\u79cd\u65b9\u5f0f\u80af\u5b9a\u53ef\u4ee5\u5f97\u5230\u660e\u6587\uff0c\u800c\u7b2c\u4e8c\u79cd\u65b9\u5f0f\u5219\u4e0d\u4e00\u5b9a\u53ef\u4ee5\u5f97\u5230\u6b63\u786e\u7684\u660e\u6587\u3002 \u800c\u5bf9\u4e8e\u57fa\u4e8e\u5bc6\u94a5\u7684\u51ef\u6492\u5bc6\u7801\u6765\u8bf4\uff0c\u4e00\u822c\u6765\u8bf4\u5fc5\u987b\u77e5\u9053\u5bf9\u5e94\u7684\u5bc6\u94a5\u3002","title":"\u7834\u89e3"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_5","text":"\u4e00\u822c\u6211\u4eec\u6709\u5982\u4e0b\u7684\u5de5\u5177\uff0c\u5176\u4e2dJPK\u6bd4\u8f83\u901a\u7528\u3002 JPK\uff0c\u53ef\u89e3\u5e26\u5bc6\u94a5\u4e0e\u4e0d\u5e26\u5bc6\u94a5 http://planetcalc.com/1434/ http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_6","text":"\u4e0e\u51ef\u6492\u5bc6\u7801\u7c7b\u4f3c\uff0c\u533a\u522b\u5728\u4e8e\u79fb\u4f4d\u5bc6\u7801\u4e0d\u4ec5\u4f1a\u5904\u7406\u5b57\u6bcd\uff0c\u8fd8\u4f1a\u5904\u7406\u6570\u5b57\u548c\u7279\u6b8a\u5b57\u7b26\uff0c\u5e38\u7528 ASCII \u7801\u8868\u8fdb\u884c\u79fb\u4f4d\u3002\u5176\u7834\u89e3\u65b9\u6cd5\u4e5f\u662f\u904d\u5386\u6240\u6709\u7684\u53ef\u80fd\u6027\u6765\u5f97\u5230\u53ef\u80fd\u7684\u7ed3\u679c\u3002","title":"\u79fb\u4f4d\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#atbash-cipher","text":"","title":"Atbash Cipher"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_7","text":"\u57c3\u7279\u5df4\u4ec0\u7801\uff08Atbash Cipher\uff09\u5176\u5b9e\u53ef\u4ee5\u89c6\u4e3a\u4e0b\u9762\u8981\u4ecb\u7ecd\u7684\u7b80\u5355\u66ff\u6362\u5bc6\u7801\u7684\u7279\u4f8b\uff0c\u5b83\u4f7f\u7528\u5b57\u6bcd\u8868\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4ee3\u8868\u7b2c\u4e00\u4e2a\u5b57\u6bcd\uff0c\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b57\u6bcd\u4ee3\u8868\u7b2c\u4e8c\u4e2a\u5b57\u6bcd\u3002\u5728\u7f57\u9a6c\u5b57\u6bcd\u8868\u4e2d\uff0c\u5b83\u662f\u8fd9\u6837\u51fa\u73b0\u7684\uff1a \u660e\u6587\uff1aA B C D E F G H I J K L M N O P Q R S T U V W X Y Z \u5bc6\u6587\uff1aZ Y X W V U T S R Q P O N M L K J I H G F E D C B A \u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50\uff1a \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6\u6587\uff1agsv jfrxp yildm ulc qfnkh levi gsv ozab wlt","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_8","text":"\u53ef\u4ee5\u770b\u51fa\u5176\u5bc6\u94a5\u7a7a\u95f4\u8db3\u591f\u77ed\uff0c\u540c\u65f6\u5f53\u5bc6\u6587\u8db3\u591f\u957f\u65f6\uff0c\u4ecd\u7136\u53ef\u4ee5\u91c7\u7528\u8bcd\u9891\u5206\u6790\u7684\u65b9\u6cd5\u89e3\u51b3\u3002","title":"\u7834\u89e3"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_9","text":"http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_10","text":"","title":"\u7b80\u5355\u66ff\u6362\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_11","text":"\u7b80\u5355\u66ff\u6362\u5bc6\u7801\uff08Simple Substitution Cipher\uff09\u52a0\u5bc6\u65f6\uff0c\u5c06\u6bcf\u4e2a\u660e\u6587\u5b57\u6bcd\u66ff\u6362\u4e3a\u4e0e\u4e4b\u552f\u4e00\u5bf9\u5e94\u4e14\u4e0d\u540c\u7684\u5b57\u6bcd\u3002\u5b83\u4e0e\u607a\u6492\u5bc6\u7801\u4e4b\u95f4\u7684\u533a\u522b\u662f\u5176\u5bc6\u7801\u5b57\u6bcd\u8868\u7684\u5b57\u6bcd\u4e0d\u662f\u7b80\u5355\u7684\u79fb\u4f4d\uff0c\u800c\u662f\u5b8c\u5168\u662f\u6df7\u4e71\u7684\uff0c\u8fd9\u4e5f\u4f7f\u5f97\u5176\u7834\u89e3\u96be\u5ea6\u8981\u9ad8\u4e8e\u51ef\u6492\u5bc6\u7801\u3002 \u6bd4\u5982\uff1a \u660e\u6587\u5b57\u6bcd : abcdefghijklmnopqrstuvwxyz \u5bc6\u94a5\u5b57\u6bcd : phqgiumeaylnofdxjkrcvstzwb a \u5bf9\u5e94 p\uff0cd \u5bf9\u5e94 h\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002 \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6\u6587\uff1acei jvaql hkdtf udz yvoxr dsik cei npbw gdm \u800c\u89e3\u5bc6\u65f6\uff0c\u6211\u4eec\u4e00\u822c\u662f\u77e5\u9053\u4e86\u6bcf\u4e00\u4e2a\u5b57\u6bcd\u7684\u5bf9\u5e94\u89c4\u5219\uff0c\u624d\u53ef\u4ee5\u6b63\u5e38\u89e3\u5bc6\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_12","text":"\u7531\u4e8e\u8fd9\u79cd\u52a0\u5bc6\u65b9\u5f0f\u5bfc\u81f4\u5176\u6240\u6709\u7684\u5bc6\u94a5\u4e2a\u6570\u662f 26! 26! \uff0c\u6240\u4ee5\u51e0\u4e4e\u4e0a\u4e0d\u53ef\u80fd\u4f7f\u7528\u66b4\u529b\u7684\u89e3\u51b3\u65b9\u5f0f\u3002\u6240\u4ee5\u6211\u4eec \u4e00\u822c\u91c7\u7528\u8bcd\u9891\u5206\u6790\u3002","title":"\u7834\u89e3"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_13","text":"http://quipqiup.com/","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_14","text":"","title":"\u4eff\u5c04\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_15","text":"\u4eff\u5c04\u5bc6\u7801\u7684\u52a0\u5bc6\u51fd\u6570\u662f E(x)=(ax+b)\\pmod m E(x)=(ax+b)\\pmod m \uff0c\u5176\u4e2d x x \u8868\u793a\u660e\u6587\u6309\u7167\u67d0\u79cd\u7f16\u7801\u5f97\u5230\u7684\u6570\u5b57 a a \u548c m m \u4e92\u8d28 m m \u662f\u7f16\u7801\u7cfb\u7edf\u4e2d\u5b57\u6bcd\u7684\u6570\u76ee\u3002 \u89e3\u5bc6\u51fd\u6570\u662f D(x)=a^{-1}(x-b)\\pmod m D(x)=a^{-1}(x-b)\\pmod m \uff0c\u5176\u4e2d a^{-1} a^{-1} \u662f a a \u5728 \\mathbb{Z}_{m} \\mathbb{Z}_{m} \u7fa4\u7684\u4e58\u6cd5\u9006\u5143\u3002 \u4e0b\u9762\u6211\u4eec\u4ee5 E(x) = (5x + 8) \\bmod 26 E(x) = (5x + 8) \\bmod 26 \u51fd\u6570\u4e3a\u4f8b\u5b50\u8fdb\u884c\u4ecb\u7ecd\uff0c\u52a0\u5bc6\u5b57\u7b26\u4e32\u4e3a AFFINE CIPHER \uff0c\u8fd9\u91cc\u6211\u4eec\u76f4\u63a5\u91c7\u7528\u5b57\u6bcd\u886826\u4e2a\u5b57\u6bcd\u4f5c\u4e3a\u7f16\u7801\u7cfb\u7edf \u660e\u6587 A F F I N E C I P H E R x 0 5 5 8 13 4 2 8 15 7 4 17 y=5x+8 y=5x+8 8 33 33 48 73 28 18 48 83 43 28 93 y\\mod26 y\\mod26 8 7 7 22 21 2 18 22 5 17 2 15 \u5bc6\u6587 I H H W V C S W F R C P \u5176\u5bf9\u5e94\u7684\u52a0\u5bc6\u7ed3\u679c\u662f IHHWVCSWFRCP \u3002 \u5bf9\u4e8e\u89e3\u5bc6\u8fc7\u7a0b\uff0c\u6b63\u5e38\u89e3\u5bc6\u8005\u5177\u6709a\u4e0eb\uff0c\u53ef\u4ee5\u8ba1\u7b97\u5f97\u5230 a^{-1} a^{-1} \u4e3a 21\uff0c\u6240\u4ee5\u5176\u89e3\u5bc6\u51fd\u6570\u662f D(x)=21(x-8)\\pmod {26} D(x)=21(x-8)\\pmod {26} \uff0c\u89e3\u5bc6\u5982\u4e0b \u5bc6\u6587 I H H W V C S W F R C P y y 8 7 7 22 21 2 18 22 5 17 2 15 x=21(y-8) x=21(y-8) 0 -21 -21 294 273 -126 210 294 -63 189 -126 147 x\\mod26 x\\mod26 0 5 5 8 13 4 2 8 15 7 4 17 \u660e\u6587 A F F I N E C I P H E R \u53ef\u4ee5\u770b\u51fa\u5176\u7279\u70b9\u5728\u4e8e\u53ea\u6709 26 \u4e2a\u82f1\u6587\u5b57\u6bcd\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_16","text":"\u9996\u5148\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u7684\u662f\uff0c\u4eff\u5c04\u5bc6\u7801\u5bf9\u4e8e\u4efb\u610f\u4e24\u4e2a\u4e0d\u540c\u7684\u5b57\u6bcd\uff0c\u5176\u6700\u540e\u5f97\u5230\u7684\u5bc6\u6587\u5fc5\u7136\u4e0d\u4e00\u6837\uff0c\u6240\u4ee5\u5176\u4e5f\u5177\u6709\u6700\u901a\u7528\u7684\u7279\u70b9\u3002\u5f53\u5bc6\u6587\u957f\u5ea6\u8db3\u591f\u957f\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u9891\u7387\u5206\u6790\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u3002 \u5176\u6b21\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5982\u4f55\u653b\u51fb\u8be5\u5bc6\u7801\u3002\u53ef\u4ee5\u770b\u51fa\u5f53 a=1 a=1 \u65f6\uff0c\u4eff\u5c04\u52a0\u5bc6\u662f\u51ef\u6492\u52a0\u5bc6\u3002\u800c\u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u5229\u7528\u4eff\u5c04\u5bc6\u7801\u65f6\uff0c\u5176\u5b57\u7b26\u96c6\u90fd\u7528\u7684\u662f\u5b57\u6bcd\u8868\uff0c\u4e00\u822c\u53ea\u670926\u4e2a\u5b57\u6bcd\uff0c\u800c\u4e0d\u5927\u4e8e26\u7684\u4e0e26\u4e92\u7d20\u7684\u4e2a\u6570\u4e00\u5171\u6709 \\phi(26)=\\phi(2) \\times \\phi(13) = 12 \\phi(26)=\\phi(2) \\times \\phi(13) = 12 \u7b97\u4e0ab\u7684\u504f\u79fb\u53ef\u80fd\uff0c\u4e00\u5171\u6709\u53ef\u80fd\u7684\u5bc6\u94a5\u7a7a\u95f4\u5927\u5c0f\u4e5f\u5c31\u662f 12 \\times 26 = 312 12 \\times 26 = 312 \u4e00\u822c\u6765\u8bf4\uff0c\u5bf9\u4e8e\u8be5\u79cd\u5bc6\u7801\uff0c\u6211\u4eec\u81f3\u5c11\u5f97\u662f\u5728\u5df2\u77e5\u90e8\u5206\u660e\u6587\u7684\u60c5\u51b5\u4e0b\u624d\u53ef\u4ee5\u653b\u51fb\u3002\u4e0b\u9762\u8fdb\u884c\u7b80\u5355\u7684\u5206\u6790\u3002 \u8fd9\u79cd\u5bc6\u7801\u7531\u4e24\u79cd\u53c2\u6570\u6765\u63a7\u5236\uff0c\u5982\u679c\u6211\u4eec\u77e5\u9053\u5176\u4e2d\u4efb\u610f\u4e00\u4e2a\u53c2\u6570\uff0c\u90a3\u6211\u4eec\u4fbf\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u5feb\u901f\u679a\u4e3e\u53e6\u5916\u4e00\u4e2a\u53c2\u6570\u5f97\u5230\u7b54\u6848\u3002 \u4f46\u662f\uff0c\u5047\u8bbe\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u91c7\u7528\u7684\u5b57\u6bcd\u96c6\uff0c\u8fd9\u91cc\u5047\u8bbe\u4e3a26\u4e2a\u5b57\u6bcd\uff0c\u6211\u4eec\u8fd8\u6709\u53e6\u5916\u4e00\u79cd\u89e3\u5bc6\u65b9\u5f0f\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u4e24\u4e2a\u52a0\u5bc6\u540e\u7684\u5b57\u6bcd y_1,y_2 y_1,y_2 \u5373\u53ef\u8fdb\u884c\u89e3\u5bc6\u3002\u90a3\u4e48\u6211\u4eec\u8fd8\u53ef\u4ee5\u77e5\u9053 y_1=(ax_1+b)\\pmod{26} \\\\ y_2=(ax_2+b)\\pmod{26} y_1=(ax_1+b)\\pmod{26} \\\\ y_2=(ax_2+b)\\pmod{26} \u4e24\u5f0f\u76f8\u51cf\uff0c\u53ef\u5f97 y_1-y_2=a(x_1-x_2)\\pmod{26} y_1-y_2=a(x_1-x_2)\\pmod{26} \u8fd9\u91cc y_1,y_2 y_1,y_2 \u5df2\u77e5\uff0c\u5982\u679c\u6211\u4eec\u77e5\u9053\u5bc6\u6587\u5bf9\u5e94\u7684\u4e24\u4e2a\u4e0d\u4e00\u6837\u7684\u5b57\u7b26 x_1 x_1 \u4e0e x_2 x_2 \uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f88\u5bb9\u6613\u5f97\u5230 a a \uff0c\u8fdb\u800c\u5c31\u53ef\u4ee5\u5f97\u5230 b b \u4e86\u3002","title":"\u7834\u89e3"},{"location":"crypto/ctf-wiki/classical/monoalphabetic-zh/#_17","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5TWCTF 2016 \u7684 super_express\u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002\u7b80\u5355\u770b\u4e00\u4e0b\u7ed9\u7684\u6e90\u7801 import sys key = '****CENSORED***************' flag = 'TWCTF{*******CENSORED********}' if len ( key ) % 2 == 1 : print ( \"Key Length Error\" ) sys . exit ( 1 ) n = len ( key ) / 2 encrypted = '' for c in flag : c = ord ( c ) for a , b in zip ( key [ 0 : n ], key [ n : 2 * n ]): c = ( ord ( a ) * c + ord ( b )) % 251 encrypted += ' %02x ' % c print encrypted \u53ef\u4ee5\u53d1\u73b0\uff0c\u867d\u7136\u5bf9\u4e8e flag \u4e2d\u7684\u6bcf\u4e2a\u5b57\u6bcd\u90fd\u52a0\u5bc6\u4e86 n \u6b21\uff0c\u5982\u679c\u6211\u4eec\u4ed4\u7ec6\u5206\u6790\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 \\begin{align*} c_1&=a_1c+b_1 \\\\ c_2&=a_2c_1+b_2 \\\\ &=a_1a_2c+a_2b_1+b_2 \\\\ &=kc+d \\end{align*} \\begin{align*} c_1&=a_1c+b_1 \\\\ c_2&=a_2c_1+b_2 \\\\ &=a_1a_2c+a_2b_1+b_2 \\\\ &=kc+d \\end{align*} \u6839\u636e\u7b2c\u4e8c\u884c\u7684\u63a8\u5bfc\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u5176\u5b9e c_n\u200b c_n\u200b \u4e5f\u662f\u8fd9\u6837\u7684\u5f62\u5f0f\uff0c\u53ef\u4ee5\u770b\u6210 c_n=xc+y\u200b c_n=xc+y\u200b \uff0c\u5e76\u4e14\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0ckey \u662f\u59cb\u7ec8\u4e0d\u53d8\u5316\u7684\uff0c\u6240\u4ee5\u8bf4\uff0c\u5176\u5b9e\u8fd9\u4e2a\u5c31\u662f\u4eff\u5c04\u5bc6\u7801\u3002 \u6b64\u5916\uff0c\u9898\u76ee\u4e2d\u8fd8\u7ed9\u51fa\u4e86\u5bc6\u6587\u4ee5\u53ca\u90e8\u5206\u90e8\u5206\u5bc6\u6587\u5bf9\u5e94\u7684\u660e\u6587\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u5f88\u5bb9\u6613\u5229\u7528\u5df2\u77e5\u660e\u6587\u653b\u51fb\u7684\u65b9\u6cd5\u6765\u653b\u51fb\u4e86\uff0c\u5229\u7528\u4ee3\u7801\u5982\u4e0b import gmpy key = '****CENSORED****************' flag = 'TWCTF{*******CENSORED********}' f = open ( 'encrypted' , 'r' ) data = f . read () . strip ( ' \\n ' ) encrypted = [ int ( data [ i : i + 2 ], 16 ) for i in range ( 0 , len ( data ), 2 )] plaindelta = ord ( flag [ 1 ]) - ord ( flag [ 0 ]) cipherdalte = encrypted [ 1 ] - encrypted [ 0 ] a = gmpy . invert ( plaindelta , 251 ) * cipherdalte % 251 b = ( encrypted [ 0 ] - a * ord ( flag [ 0 ])) % 251 a_inv = gmpy . invert ( a , 251 ) result = \"\" for c in encrypted : result += chr (( c - b ) * a_inv % 251 ) print result \u7ed3\u679c\u5982\u4e0b \u279c TWCTF2016-super_express git: ( master ) \u2717 python exploit.py TWCTF { Faster_Than_Shinkansen! }","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/","text":"EN | ZH General Features \u00b6 In single-table replacement encryption, all encryption methods have almost one commonality, that is, the plaintext one-to-one correspondence. Therefore, there are generally two ways to crack In the case of a small key space, brute force Use word frequency analysis when the ciphertext length is long enough, http://quipqiup.com/ When the key space is large enough and the ciphertext length is short enough, the cracking is more difficult. Caesar Password \u00b6 Principle \u00b6 When Caesar is encrypted, each letter in the plaintext is moved backward (or forward) by a fixed number ( circular movement**) as ciphertext according to its order in the alphabet. For example, when the offset is shifted to the left by 3 (the key at decryption is 3): Plaintext alphabet: ABCDEFGHIJKLMNOPQRSTUVWXYZ The ciphertext alphabet: DEFGHIJKLMNOPQRSTUVWXYZABC In use, the encryptor finds the location of each letter in the message that needs to be encrypted in the plaintext alphabet, and writes the corresponding letter in the ciphertext alphabet. The person who needs to decrypt is reversed according to the previously known key to get the original plaintext. E.g: \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Secret: WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ Depending on the offset, there are also a number of specific Caesar password names**: Offset is 10: Avocat (A\u2192K) The offset is 13: [ROT13] ( https://zh.wikipedia.org/wiki/ROT13 ) Offset -5: Cassis (K 6) Offset -6: Cassette (K 7) In addition, there is a key-based Caesar cipher Keyed Caesar. The basic principle is that use a key to convert each bit of the key into a number (generally converted into a number corresponding to the alphabet), and use this number as the key to encrypt each letter of the plaintext. Here is an example of the XMan Phase I Summer Camp sharing the Kung Pao Chicken Crest Crypto 100 . Ciphertext: s0a6u3u1s0bv1a Key: guangtou Offset: 6, 20, 0, 13, 6, 19, 14, 20 Clear text: y0u6u3h1y0uj1u \u7834 \u00b6 For Caesar passwords without keys, there are two ways to break the basics. Traverse 26 offsets for general conditions Using word frequency analysis, it is suitable for the case of long ciphertext. Among them, the first way can definitely get plaintext, while the second way does not necessarily get the correct plaintext. For a key-based Caesar cipher, it is generally necessary to know the corresponding key. Tools \u00b6 Generally we have the following tools, of which JPK is more general. JPK, solvable with and without key http://planetcalc.com/1434/ http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php Shift password \u00b6 Similar to the Caesars password, the difference is that shifting passwords not only handles letters, but also numbers and special characters, which are commonly used in ASCII tables. The way to crack it is also to traverse all the possibilities to get the possible results. Atbash Cipher \u00b6 Principle \u00b6 Atbash Cipher can actually be considered as a special case of a simple replacement password to be introduced below. It uses the last letter of the alphabet to represent the first letter, and the second to last letter represents the second letter. In the Roman alphabet, it appears like this: Clear text: ABCDEFGHIJKLMNOPQRSTU VWXYZ Ciphertext: ZYXWVUTSRQPONMLKJIHGF EDCBA An example is given below: \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6 \u6587 \uff1a gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt \u7834 \u00b6 It can be seen that the key space is short enough, and when the ciphertext is long enough, it can still be solved by word frequency analysis. Tools \u00b6 http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/ Simple replacement password \u00b6 Principle \u00b6 When the Simple Substitution Cipher is encrypted, each plaintext letter is replaced with a letter that uniquely corresponds to it. The difference between it and the Caesar cipher is that the letters of its cipher alphabet are not simply shifted, but completely confusing, which makes it more difficult to crack than the Caesar cipher. such as: Plain text: abcdefghijklmnopqrstuvwxyz Key letter: phqgiumeaylnofdxjkrcvstzwb a corresponds to p, d corresponds to h, and so on. \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6 \u6587: those jvaql hkdtf udz yvoxr dsik those npbw gdm When decrypting, we generally know the corresponding rules of each letter before we can decrypt it normally. \u7834 \u00b6 Since this encryption method results in all of its keys being 26! 26! , it is almost impossible to use a violent solution. So we generally use word frequency analysis. Tools \u00b6 http://quipqiup.com/ affine password \u00b6 Principle \u00b6 The cryptographic function of the affine password is E(x)=(ax+b)\\pmod m E(x)=(ax+b)\\pmod m , where x x indicates the number of plaintexts obtained by some encoding a a and m m are qualitative m m is the number of letters in the encoding system. The decryption function is D(x)=a^{-1}(xb)\\pmod m D(x)=a^{-1}(xb)\\pmod m , where a^{-1} a^{-1} is a a at \\mathbb{Z}_{m} \\mathbb{Z}_{m} Multiplication inverse. Let's take the E(x) = (5x + 8) \\bmod 26 E(x) = (5x + 8) \\bmod 26 function as an example. The encrypted string is AFFINE CIPHER . Here we use the alphabet 26 letters as the encoding system. | \u660e\u6587 | A | F | F | I | N | E | C | I | P | H | E | R | | --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | | x | 0 | 5 | 5 | 8 | 13 | 4 | 2 | 8 | 15 | 7 | 4 | 17 | | $ y = 5x + 8 $ | 8 | 33 | 33 | 48 | 73 | 28 | 18 | 48 | 83 | 43 | 28 | 93 | | $ y mod26 $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | \u5bc6\u6587 | I | H | H | W | V | C | S | W | F | R | C | P | The corresponding encryption result is IHHWVCSWFRCP . For the decryption process, the normal decrypter has a and b, and can calculate a^{-1} a^{-1} to be 21, so its decryption function is D(x)=21(x-8)\\pmod {26} D(x)=21(x-8)\\pmod {26} , Decrypt as follows | \u5bc6\u6587 | I | H | H | W | V | C | S | W | F | R | C | P | | ----------- | :--- | :--- | --- | --- | --- | ---- | --- | --- | --- | --- | ---- | --- | | $ y $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | x=21(y-8) x=21(y-8) | 0 | -21 | -21 | 294 | 273 | -126 | 210 | 294 | -63 | 189 | -126 | 147 | | x\\mod26 x\\mod26 | 0 | 5 | 5 | 8 | 13 | 4 | 2 | 8 | 15 | 7 | 4 | 17 | | \u660e\u6587 | A | F | F | I | N | E | C | I | P | H | E | R | It can be seen that it is characterized by only 26 English letters. \u7834 \u00b6 First of all, we can see that the affine password is different for any two different letters, and the ciphertext obtained by it is different, so it also has the most common features. When the ciphertext length is long enough, we can use the frequency analysis method to solve it. Second, we can consider how to attack the password. It can be seen that when a=1 a=1 , the affine encryption is Caesar encryption. In general, when we use affine ciphers, the character set uses the alphabet, generally only 26 letters, and not more than 26 and 26 symbiotics. $$ (26) = (2) non (13) = 12 $$ Counting the offset of b, there is a total possible key space size. $$ 12 \\times 26 = 312 $$ In general, for this kind of password, we must at least attack the known part of the plaintext. A simple analysis is performed below. This kind of password is controlled by two parameters. If we know any one of them, then we can easily enumerate another parameter quickly to get the answer. However, suppose we already know the set of letters used, here we assume 26 letters, we have another way of decryption, we only need to know the two encrypted letters y_1, y_2 y_1, y_2 to decrypt. Then we can still know $$ y_1=(ax_1+b)\\pmod{26} \\ y_2=(ax_2+b)\\pmod{26} $$ Two types of subtraction, available $$ y_1-y_2=a(x_1-x_2)\\pmod{26} $$ Here y_1,y_2 y_1,y_2 is known. If we know the two different characters x_1 x_1 and x_2 x_2 for the cipher text, then we can easily get a a and then get b b . Examples \u00b6 Here we take TWCTF 2016's super_express as an example. Simply look at the source code import sys key = '****CENSORED***************' flag = 'TWCTF{*******CENSORED********}' if len ( key ) % 2 == 1 : print ( \"Key Length Error\" ) sys . exit ( 1 ) n = len ( key ) / 2 encrypted = '' for c in flag : c = word ( c ) for a , b in zip ( key [ 0 : n ], key [ n : 2 * n ]): c = ( ord ( a ) * c + ord ( b )) % 251 encrypted += ' %02x ' % c print encrypted It can be found that although each letter in the flag is encrypted n times, if we analyze it carefully, we can find $$ \\begin{align*} c_1&=a_1c+b_1 \\ c_2 & = a_2c_1 + b_2 \\ &=a_1a_2c+a_2b_1+b_2 \\ & = kc + d \\end{align*} $$ According to the second line of derivation, we can get the actual form of $c_n $, which can be seen as $c_n=xc+y $ , and we can know that the key is always unchanged, so that In fact, this is the affine password. In addition, the title also gives the plaintext and part of the partial ciphertext corresponding plaintext, then we can easily use the known plaintext attack method to attack, using the code as follows import gmpy key = '****CENSORED****************' flag = 'TWCTF{*******CENSORED********}' f = open ( 'encrypted' , 'r' ) data = f . read () . strip ( ' \\n ' ) encrypted = [ int ( data [ i : i + 2 ], 16 ) for i in range ( 0 , len ( data ), 2 )] plaindelta = words ( flag [ 1 ]) - words ( flag [ 0 ]) cipherdalte = encrypted [ 1 ] - encrypted [ 0 ] a = gmpy . invert ( plaindelta , 251 ) * cipheral % 251 b = ( encrypted [ 0 ] - a * ord ( flag [ 0 ])) % 251 a_inv = gmpy . invert ( a , 251 ) result = \"\" for c in encrypted : result += chr (( c - b ) * a_inv % 251 ) print result Results are as follows \u279c TWCTF2016-super_express git: ( master ) \u2717 python exploit.py TWCTF { Faster_Than_Shinkansen! }","title":"\u5355\u8868\u4ee3\u6362\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#general-features","text":"In single-table replacement encryption, all encryption methods have almost one commonality, that is, the plaintext one-to-one correspondence. Therefore, there are generally two ways to crack In the case of a small key space, brute force Use word frequency analysis when the ciphertext length is long enough, http://quipqiup.com/ When the key space is large enough and the ciphertext length is short enough, the cracking is more difficult.","title":"General Features"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#caesar-password","text":"","title":"Caesar Password"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#principle","text":"When Caesar is encrypted, each letter in the plaintext is moved backward (or forward) by a fixed number ( circular movement**) as ciphertext according to its order in the alphabet. For example, when the offset is shifted to the left by 3 (the key at decryption is 3): Plaintext alphabet: ABCDEFGHIJKLMNOPQRSTUVWXYZ The ciphertext alphabet: DEFGHIJKLMNOPQRSTUVWXYZABC In use, the encryptor finds the location of each letter in the message that needs to be encrypted in the plaintext alphabet, and writes the corresponding letter in the ciphertext alphabet. The person who needs to decrypt is reversed according to the previously known key to get the original plaintext. E.g: \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Secret: WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ Depending on the offset, there are also a number of specific Caesar password names**: Offset is 10: Avocat (A\u2192K) The offset is 13: [ROT13] ( https://zh.wikipedia.org/wiki/ROT13 ) Offset -5: Cassis (K 6) Offset -6: Cassette (K 7) In addition, there is a key-based Caesar cipher Keyed Caesar. The basic principle is that use a key to convert each bit of the key into a number (generally converted into a number corresponding to the alphabet), and use this number as the key to encrypt each letter of the plaintext. Here is an example of the XMan Phase I Summer Camp sharing the Kung Pao Chicken Crest Crypto 100 . Ciphertext: s0a6u3u1s0bv1a Key: guangtou Offset: 6, 20, 0, 13, 6, 19, 14, 20 Clear text: y0u6u3h1y0uj1u","title":"Principle"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#_1","text":"For Caesar passwords without keys, there are two ways to break the basics. Traverse 26 offsets for general conditions Using word frequency analysis, it is suitable for the case of long ciphertext. Among them, the first way can definitely get plaintext, while the second way does not necessarily get the correct plaintext. For a key-based Caesar cipher, it is generally necessary to know the corresponding key.","title":"\u7834"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#tools","text":"Generally we have the following tools, of which JPK is more general. JPK, solvable with and without key http://planetcalc.com/1434/ http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php","title":"Tools"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#shift-password","text":"Similar to the Caesars password, the difference is that shifting passwords not only handles letters, but also numbers and special characters, which are commonly used in ASCII tables. The way to crack it is also to traverse all the possibilities to get the possible results.","title":"Shift password"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#atbash-cipher","text":"","title":"Atbash Cipher"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#principle_1","text":"Atbash Cipher can actually be considered as a special case of a simple replacement password to be introduced below. It uses the last letter of the alphabet to represent the first letter, and the second to last letter represents the second letter. In the Roman alphabet, it appears like this: Clear text: ABCDEFGHIJKLMNOPQRSTU VWXYZ Ciphertext: ZYXWVUTSRQPONMLKJIHGF EDCBA An example is given below: \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6 \u6587 \uff1a gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt","title":"Principle"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#_2","text":"It can be seen that the key space is short enough, and when the ciphertext is long enough, it can still be solved by word frequency analysis.","title":"\u7834"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#tools_1","text":"http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/","title":"Tools"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#simple-replacement-password","text":"","title":"Simple replacement password"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#principle_2","text":"When the Simple Substitution Cipher is encrypted, each plaintext letter is replaced with a letter that uniquely corresponds to it. The difference between it and the Caesar cipher is that the letters of its cipher alphabet are not simply shifted, but completely confusing, which makes it more difficult to crack than the Caesar cipher. such as: Plain text: abcdefghijklmnopqrstuvwxyz Key letter: phqgiumeaylnofdxjkrcvstzwb a corresponds to p, d corresponds to h, and so on. \u660e\u6587\uff1athe quick brown fox jumps over the lazy dog \u5bc6 \u6587: those jvaql hkdtf udz yvoxr dsik those npbw gdm When decrypting, we generally know the corresponding rules of each letter before we can decrypt it normally.","title":"Principle"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#_3","text":"Since this encryption method results in all of its keys being 26! 26! , it is almost impossible to use a violent solution. So we generally use word frequency analysis.","title":"\u7834"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#tools_2","text":"http://quipqiup.com/","title":"Tools"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#affine-password","text":"","title":"affine password"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#principle_3","text":"The cryptographic function of the affine password is E(x)=(ax+b)\\pmod m E(x)=(ax+b)\\pmod m , where x x indicates the number of plaintexts obtained by some encoding a a and m m are qualitative m m is the number of letters in the encoding system. The decryption function is D(x)=a^{-1}(xb)\\pmod m D(x)=a^{-1}(xb)\\pmod m , where a^{-1} a^{-1} is a a at \\mathbb{Z}_{m} \\mathbb{Z}_{m} Multiplication inverse. Let's take the E(x) = (5x + 8) \\bmod 26 E(x) = (5x + 8) \\bmod 26 function as an example. The encrypted string is AFFINE CIPHER . Here we use the alphabet 26 letters as the encoding system. | \u660e\u6587 | A | F | F | I | N | E | C | I | P | H | E | R | | --------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | | x | 0 | 5 | 5 | 8 | 13 | 4 | 2 | 8 | 15 | 7 | 4 | 17 | | $ y = 5x + 8 $ | 8 | 33 | 33 | 48 | 73 | 28 | 18 | 48 | 83 | 43 | 28 | 93 | | $ y mod26 $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | \u5bc6\u6587 | I | H | H | W | V | C | S | W | F | R | C | P | The corresponding encryption result is IHHWVCSWFRCP . For the decryption process, the normal decrypter has a and b, and can calculate a^{-1} a^{-1} to be 21, so its decryption function is D(x)=21(x-8)\\pmod {26} D(x)=21(x-8)\\pmod {26} , Decrypt as follows | \u5bc6\u6587 | I | H | H | W | V | C | S | W | F | R | C | P | | ----------- | :--- | :--- | --- | --- | --- | ---- | --- | --- | --- | --- | ---- | --- | | $ y $ | 8 | 7 | 7 | 22 | 21 | 2 | 18 | 22 | 5 | 17 | 2 | 15 | | x=21(y-8) x=21(y-8) | 0 | -21 | -21 | 294 | 273 | -126 | 210 | 294 | -63 | 189 | -126 | 147 | | x\\mod26 x\\mod26 | 0 | 5 | 5 | 8 | 13 | 4 | 2 | 8 | 15 | 7 | 4 | 17 | | \u660e\u6587 | A | F | F | I | N | E | C | I | P | H | E | R | It can be seen that it is characterized by only 26 English letters.","title":"Principle"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#_4","text":"First of all, we can see that the affine password is different for any two different letters, and the ciphertext obtained by it is different, so it also has the most common features. When the ciphertext length is long enough, we can use the frequency analysis method to solve it. Second, we can consider how to attack the password. It can be seen that when a=1 a=1 , the affine encryption is Caesar encryption. In general, when we use affine ciphers, the character set uses the alphabet, generally only 26 letters, and not more than 26 and 26 symbiotics. $$ (26) = (2) non (13) = 12 $$ Counting the offset of b, there is a total possible key space size. $$ 12 \\times 26 = 312 $$ In general, for this kind of password, we must at least attack the known part of the plaintext. A simple analysis is performed below. This kind of password is controlled by two parameters. If we know any one of them, then we can easily enumerate another parameter quickly to get the answer. However, suppose we already know the set of letters used, here we assume 26 letters, we have another way of decryption, we only need to know the two encrypted letters y_1, y_2 y_1, y_2 to decrypt. Then we can still know $$ y_1=(ax_1+b)\\pmod{26} \\ y_2=(ax_2+b)\\pmod{26} $$ Two types of subtraction, available $$ y_1-y_2=a(x_1-x_2)\\pmod{26} $$ Here y_1,y_2 y_1,y_2 is known. If we know the two different characters x_1 x_1 and x_2 x_2 for the cipher text, then we can easily get a a and then get b b .","title":"\u7834"},{"location":"crypto/ctf-wiki/classical/monoalphabetic/#examples","text":"Here we take TWCTF 2016's super_express as an example. Simply look at the source code import sys key = '****CENSORED***************' flag = 'TWCTF{*******CENSORED********}' if len ( key ) % 2 == 1 : print ( \"Key Length Error\" ) sys . exit ( 1 ) n = len ( key ) / 2 encrypted = '' for c in flag : c = word ( c ) for a , b in zip ( key [ 0 : n ], key [ n : 2 * n ]): c = ( ord ( a ) * c + ord ( b )) % 251 encrypted += ' %02x ' % c print encrypted It can be found that although each letter in the flag is encrypted n times, if we analyze it carefully, we can find $$ \\begin{align*} c_1&=a_1c+b_1 \\ c_2 & = a_2c_1 + b_2 \\ &=a_1a_2c+a_2b_1+b_2 \\ & = kc + d \\end{align*} $$ According to the second line of derivation, we can get the actual form of $c_n $, which can be seen as $c_n=xc+y $ , and we can know that the key is always unchanged, so that In fact, this is the affine password. In addition, the title also gives the plaintext and part of the partial ciphertext corresponding plaintext, then we can easily use the known plaintext attack method to attack, using the code as follows import gmpy key = '****CENSORED****************' flag = 'TWCTF{*******CENSORED********}' f = open ( 'encrypted' , 'r' ) data = f . read () . strip ( ' \\n ' ) encrypted = [ int ( data [ i : i + 2 ], 16 ) for i in range ( 0 , len ( data ), 2 )] plaindelta = words ( flag [ 1 ]) - words ( flag [ 0 ]) cipherdalte = encrypted [ 1 ] - encrypted [ 0 ] a = gmpy . invert ( plaindelta , 251 ) * cipheral % 251 b = ( encrypted [ 0 ] - a * ord ( flag [ 0 ])) % 251 a_inv = gmpy . invert ( a , 251 ) result = \"\" for c in encrypted : result += chr (( c - b ) * a_inv % 251 ) print result Results are as follows \u279c TWCTF2016-super_express git: ( master ) \u2717 python exploit.py TWCTF { Faster_Than_Shinkansen! }","title":"Examples"},{"location":"crypto/ctf-wiki/classical/others-zh/","text":"EN | ZH \u57f9\u6839\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u57f9\u6839\u5bc6\u7801\u4f7f\u7528\u4e24\u79cd\u4e0d\u540c\u7684\u5b57\u4f53\uff0c\u4ee3\u8868 A \u548c B\uff0c\u7ed3\u5408\u52a0\u5bc6\u8868\u8fdb\u884c\u52a0\u89e3\u5bc6\u3002 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB \u4e0a\u9762\u7684\u662f\u5e38\u7528\u7684\u52a0\u5bc6\u8868\u3002\u8fd8\u6709\u53e6\u5916\u7684\u4e00\u79cd\u52a0\u5bc6\u8868\uff0c\u53ef\u8ba4\u4e3a\u662f\u5c06 26 \u4e2a\u5b57\u6bcd\u4ece 0 \u5230 25 \u6392\u5e8f\uff0c\u4ee5\u4e8c\u8fdb\u5236\u8868\u793a\uff0cA \u4ee3\u8868 0\uff0cB \u4ee3\u8868 1\u3002 \u4e0b\u9762\u8fd9\u4e00\u6bb5\u5185\u5bb9\u5c31\u662f\u660e\u6587 steganography \u52a0\u5bc6\u540e\u7684\u5185\u5bb9\uff0c\u6b63\u5e38\u5b57\u4f53\u662f A\uff0c\u7c97\u4f53\u662f B\uff1a T o en co de a mes s age e ac h letter of the pl a i nt ex t i s replaced b y a g rou p of f i ve of th e lett ers 'A' o r 'B' . \u53ef\u4ee5\u770b\u5230\uff0c\u57f9\u6839\u5bc6\u7801\u4e3b\u8981\u6709\u4ee5\u4e0b\u7279\u70b9 \u53ea\u6709\u4e24\u79cd\u5b57\u7b26 \u6bcf\u4e00\u6bb5\u7684\u957f\u5ea6\u4e3a 5 \u52a0\u5bc6\u5185\u5bb9\u4f1a\u6709\u7279\u6b8a\u7684\u5b57\u4f53\u4e4b\u5206\uff0c\u4ea6\u6216\u8005\u5927\u5c0f\u5199\u4e4b\u5206\u3002 \u5de5\u5177 \u00b6 http://rumkin.com/tools/cipher/baconian.php \u6805\u680f\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u6805\u680f\u5bc6\u7801\u628a\u8981\u52a0\u5bc6\u7684\u660e\u6587\u5206\u6210 N \u4e2a\u4e00\u7ec4\uff0c\u7136\u540e\u628a\u6bcf\u7ec4\u7684\u7b2c 1 \u4e2a\u5b57\u8fde\u8d77\u6765\uff0c\u5f62\u6210\u4e00\u6bb5\u65e0\u89c4\u5f8b\u7684\u8bdd\u3002\u8fd9\u91cc\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50 \u660e\u6587\uff1aTHERE IS A CIPHER \u53bb\u6389\u7a7a\u683c\u540e\u53d8\u4e3a THEREISACIPHER \u5206\u6210\u4e24\u680f\uff0c\u4e24\u4e2a\u4e00\u7ec4\u5f97\u5230 TH ER EI SA CI PH ER \u5148\u53d6\u51fa\u7b2c\u4e00\u4e2a\u5b57\u6bcd\uff0c\u518d\u53d6\u51fa\u7b2c\u4e8c\u4e2a\u5b57\u6bcd TEESCPE HRIAIHR \u8fde\u5728\u4e00\u8d77\u5c31\u662f TEESCPEHRIAIHR \u4e0a\u8ff0\u660e\u6587\u4e5f\u53ef\u4ee5\u5206\u4e3a2\u680f\u3002 THEREIS ACIPHER \u7ec4\u5408\u5f97\u5230\u5bc6\u6587 TAHCEIRPEHIESR \u5de5\u5177 \u00b6 https://www.qqxiuzi.cn/bianma/zhalanmima.php \u66f2\u8def\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u66f2\u8def\u5bc6\u7801\uff08Curve Cipher\uff09\u662f\u4e00\u79cd\u6362\u4f4d\u5bc6\u7801\uff0c\u9700\u8981\u4e8b\u5148\u53cc\u65b9\u7ea6\u5b9a\u5bc6\u94a5\uff08\u4e5f\u5c31\u662f\u66f2\u8def\u8def\u5f84\uff09\u3002\u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50 \u660e\u6587\uff1aThe quick brown fox jumps over the lazy dog \u586b\u5165 5 \u884c 7 \u5217\u8868\uff08\u4e8b\u5148\u7ea6\u5b9a\u586b\u5145\u7684\u884c\u5217\u6570\uff09 \u52a0\u5bc6\u7684\u56de\u8def\u7ebf\uff08\u4e8b\u5148\u7ea6\u5b9a\u586b\u5145\u7684\u884c\u5217\u6570\uff09 \u5bc6\u6587\uff1agesfc inpho dtmwu qoury zejre hbxva lookT \u5217\u79fb\u4f4d\u52a0\u5bc6 \u00b6 \u539f\u7406 \u00b6 \u5217\u79fb\u4f4d\u5bc6\u7801\uff08Columnar Transposition Cipher\uff09\u662f\u4e00\u79cd\u6bd4\u8f83\u7b80\u5355\uff0c\u6613\u4e8e\u5b9e\u73b0\u7684\u6362\u4f4d\u5bc6\u7801\uff0c\u901a\u8fc7\u4e00\u4e2a\u7b80\u5355\u7684\u89c4\u5219\u5c06\u660e\u6587\u6253\u4e71\u6df7\u5408\u6210\u5bc6\u6587\u3002\u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50\u3002 \u6211\u4eec\u4ee5\u660e\u6587 The quick brown fox jumps over the lazy dog \uff0c\u5bc6\u94a5 how are u \u4e3a\u4f8b\uff1a \u5c06\u660e\u6587\u586b\u5165 5 \u884c 7 \u5217\u8868\uff08\u4e8b\u5148\u7ea6\u5b9a\u586b\u5145\u7684\u884c\u5217\u6570\uff0c\u5982\u679c\u660e\u6587\u4e0d\u80fd\u586b\u5145\u5b8c\u8868\u683c\u53ef\u4ee5\u7ea6\u5b9a\u4f7f\u7528\u67d0\u4e2a\u5b57\u6bcd\u8fdb\u884c\u586b\u5145\uff09 \u5bc6\u94a5\uff1a how are u \uff0c\u6309 how are u \u5728\u5b57\u6bcd\u8868\u4e2d\u7684\u51fa\u73b0\u7684\u5148\u540e\u987a\u5e8f\u8fdb\u884c\u7f16\u53f7\uff0c\u6211\u4eec\u5c31\u6709 a \u4e3a 1\uff0ce \u4e3a 2\uff0ch \u4e3a 3\uff0co \u4e3a 4\uff0cr \u4e3a 5\uff0cu \u4e3a 6\uff0cw \u4e3a 7\uff0c\u6240\u4ee5\u5148\u5199\u51fa a \u5217\uff0c\u5176\u6b21 e \u5217\uff0c\u4ee5\u6b64\u7c7b\u63a8\u5199\u51fa\u7684\u7ed3\u679c\u4fbf\u662f\u5bc6\u6587\uff1a \u5bc6\u6587\uff1a qoury inpho Tkool hbxva uwmtd cfseg erjez \u5de5\u5177 \u00b6 http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/ \u884c\u5217\u6570\u76f8\u7b49 01248 \u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u8be5\u5bc6\u7801\u53c8\u79f0\u4e3a\u4e91\u5f71\u5bc6\u7801\uff0c\u4f7f\u7528 0\uff0c1\uff0c2\uff0c4\uff0c8 \u56db\u4e2a\u6570\u5b57\uff0c\u5176\u4e2d 0 \u7528\u6765\u8868\u793a\u95f4\u9694\uff0c\u5176\u4ed6\u6570\u5b57\u4ee5\u52a0\u6cd5\u53ef\u4ee5\u8868\u793a\u51fa \u5982\uff1a28=10\uff0c124=7\uff0c18=9\uff0c\u518d\u7528 1->26 \u8868\u793a A->Z\u3002 \u53ef\u4ee5\u770b\u51fa\u8be5\u5bc6\u7801\u6709\u4ee5\u4e0b\u7279\u70b9 \u53ea\u6709 0\uff0c1\uff0c2\uff0c4\uff0c8 \u4f8b\u5b50 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5CFF 2016 \u5f71\u4e4b\u5bc6\u7801\u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9898\u76ee 8842101220480224404014224202480122 \u6211\u4eec\u6309\u71670\u6765\u8fdb\u884c\u5206\u5272\uff0c\u5982\u4e0b \u5185\u5bb9 \u6570\u5b57 \u5b57\u7b26 88421 8+8+4+2+1=23 W 122 1+2+2=5 E 48 4+8=12 L 2244 2+2+4+4=12 L 4 4 D 142242 1+4+2+2+4+2=15 O 248 2+4+8=14 N 122 1+2+2=5 E \u6240\u4ee5\u6700\u540e\u7684 flag \u4e3a WELLDONE\u3002 JSFuck \u00b6 \u539f\u7406 \u00b6 JSFuck \u53ef\u4ee5\u53ea\u7528 6 \u4e2a\u5b57\u7b26 []()!+ \u6765\u7f16\u5199 JavaScript \u7a0b\u5e8f\u3002\u6bd4\u5982\u6211\u4eec\u60f3\u7528 JSFuck \u6765\u5b9e\u73b0 alert(1) \u4ee3\u7801\u5982\u4e0b [][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]][([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ([][[]] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ([][[]] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]](( ! [] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + [ +!+ []] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]])() \u5176\u4ed6\u4e00\u4e9b\u57fa\u672c\u7684\u8868\u8fbe\uff1a false => ! [] true => !! [] undefined => [][[]] NaN => + [ ! []] 0 => + [] 1 => +!+ [] 2 => !+ [] +!+ [] 10 => [ +!+ []] + [ + []] Array => [] Number => + [] String => [] + [] Boolean => ! [] Function => [][ \"filter\" ] eval => [][ \"filter\" ][ \"constructor\" ]( CODE )() window => [][ \"filter\" ][ \"constructor\" ]( \"return this\" )() \u5de5\u5177 \u00b6 JSFuck \u5728\u7ebf\u52a0\u5bc6\u7f51\u7ad9 BrainFuck \u00b6 \u539f\u7406 \u00b6 Brainfuck\uff0c\u662f\u4e00\u79cd\u6781\u5c0f\u5316\u7684\u8ba1\u7b97\u673a\u8bed\u8a00\uff0c\u5b83\u662f\u7531 Urban M\u00fcller \u5728 1993 \u5e74\u521b\u5efa\u7684\u3002\u6211\u4eec\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c\u6211\u4eec\u60f3\u8981\u4e00\u4e2a\u5728\u5c4f\u5e55\u4e0a\u6253\u5370Hello World\uff01\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u7a0b\u5e8f\u5982\u4e0b\u3002\u5bf9\u4e8e\u5176\u4e2d\u7684\u539f\u7406\uff0c\u611f\u5174\u8da3\u7684\u53ef\u4ee5\u81ea\u884c\u7f51\u4e0a\u641c\u7d22\u3002 ++++++++++[>+++++++>++++++++++>+++>+<<<<-] >++.>+.+++++++..+++.>++.<<+++++++++++++++. >.+++.------.--------.>+.>. \u4e0e\u5176\u5bf9\u5e94\u7684\u8fd8\u6709 ook\u3002 \u5de5\u5177 \u00b6 https://www.splitbrain.org/services/ook \u732a\u5708\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u732a\u5708\u5bc6\u7801\u662f\u4e00\u79cd\u4ee5\u683c\u5b50\u4e3a\u57fa\u7840\u7684\u7b80\u5355\u66ff\u4ee3\u5f0f\u5bc6\u7801\uff0c\u683c\u5b50\u5982\u4e0b \u6211\u4eec\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5982\u660e\u6587\u4e3a X marks the spot \uff0c\u90a3\u4e48\u5bc6\u6587\u5982\u4e0b \u5de5\u5177 \u00b6 http://www.simonsingh.net/The_Black_Chamber/pigpen.html \u821e\u52a8\u7684\u5c0f\u4eba\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u8fd9\u79cd\u5bc6\u7801\u51fa\u81ea\u4e8e\u798f\u5c14\u6469\u65af\u63a2\u6848\u96c6\u3002\u6bcf\u4e00\u4e2a\u8df3\u821e\u7684\u5c0f\u4eba\u5b9e\u9645\u4e0a\u5bf9\u5e94\u7684\u662f\u82f1\u6587\u4e8c\u5341\u516d\u4e2a\u5b57\u6bcd\u4e2d\u7684\u4e00\u4e2a\uff0c\u800c\u5c0f\u4eba\u624b\u4e2d\u7684\u65d7\u5b50\u5219\u8868\u660e\u8be5\u5b57\u6bcd\u662f\u5355\u8bcd\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\uff0c\u5982\u679c\u4ec5\u4ec5\u662f\u4e00\u4e2a\u5355\u8bcd\u800c\u4e0d\u662f\u53e5\u5b50\uff0c\u6216\u8005\u662f\u53e5\u5b50\u4e2d\u6700\u540e\u7684\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5355\u8bcd\u4e2d\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4e0d\u5fc5\u4e3e\u65d7\u3002 \u952e\u76d8\u5bc6\u7801 \u00b6 \u6240\u8c13\u952e\u76d8\u5bc6\u7801\uff0c\u5c31\u662f\u91c7\u7528\u624b\u673a\u952e\u76d8\u6216\u8005\u7535\u8111\u952e\u76d8\u8fdb\u884c\u52a0\u5bc6\u3002 \u624b\u673a\u952e\u76d8\u5bc6\u7801 \u00b6 \u624b\u673a\u952e\u76d8\u52a0\u5bc6\u65b9\u5f0f\uff0c\u662f\u6bcf\u4e2a\u6570\u5b57\u952e\u4e0a\u6709 3-4 \u4e2a\u5b57\u6bcd\uff0c\u7528\u4e24\u4f4d\u6570\u5b57\u6765\u8868\u793a\u5b57\u6bcd\uff0c\u4f8b\u5982\uff1aru \u7528\u624b\u673a\u952e\u76d8\u8868\u793a\u5c31\u662f\uff1a7382\uff0c\u90a3\u4e48\u8fd9\u91cc\u5c31\u53ef\u4ee5\u77e5\u9053\u4e86\uff0c\u624b\u673a\u952e\u76d8\u52a0\u5bc6\u65b9\u5f0f\u4e0d\u53ef\u80fd\u7528 1 \u5f00\u5934\uff0c\u7b2c\u4e8c\u4f4d\u6570\u5b57\u4e0d\u53ef\u80fd\u8d85\u8fc7 4\uff0c\u89e3\u5bc6\u7684\u65f6\u5019\u53c2\u8003\u6b64 \u5173\u4e8e\u624b\u673a\u952e\u76d8\u52a0\u5bc6\u8fd8\u6709\u53e6\u4e00\u79cd\u65b9\u5f0f\uff0c\u5c31\u662f\u300c\u97f3\u7684\u300d\u5f0f\uff08\u8fd9\u4e00\u70b9\u53ef\u80fd\u6839\u636e\u624b\u673a\u7684\u4e0d\u540c\u4f1a\u6709\u6240\u4e0d\u540c\uff09\uff0c\u5177\u4f53\u53c2\u7167\u624b\u673a\u952e\u76d8\u6765\u6253\uff0c\u4f8b\u5982\uff1a\u300c\u6570\u5b57\u300d\u8868\u793a\u51fa\u6765\u5c31\u662f\uff1a748 94\u3002\u5728\u624b\u673a\u952e\u76d8\u4e0a\u9762\u6309\u4e0b\u8fd9\u51e0\u4e2a\u6570\uff0c\u5c31\u4f1a\u51fa\uff1a\u300c\u6570\u5b57\u300d\u7684\u62fc\u97f3\u3002 \u7535\u8111\u952e\u76d8\u68cb\u76d8 \u00b6 \u7535\u8111\u952e\u76d8\u68cb\u76d8\u52a0\u5bc6\uff0c\u5229\u7528\u4e86\u7535\u8111\u7684\u68cb\u76d8\u65b9\u9635\u3002 \u7535\u8111\u952e\u76d8\u5750\u6807 \u00b6 \u7535\u8111\u952e\u76d8\u5750\u6807\u52a0\u5bc6\uff0c\u5229\u7528\u952e\u76d8\u4e0a\u9762\u7684\u5b57\u6bcd\u884c\u548c\u6570\u5b57\u884c\u6765\u52a0\u5bc6\uff0c\u4f8b\uff1abye \u7528\u7535\u8111\u952e\u76d8 XY \u8868\u793a\u5c31\u662f\uff1a351613 \u7535\u8111\u952e\u76d8 QWE \u00b6 \u7535\u8111\u952e\u76d8 QWE \u52a0\u5bc6\u6cd5\uff0c\u5c31\u662f\u7528\u5b57\u6bcd\u8868\u66ff\u6362\u952e\u76d8\u4e0a\u9762\u7684\u6392\u5217\u987a\u5e8f\u3002 \u952e\u76d8\u5e03\u5c40\u52a0\u5bc6 \u00b6 \u7b80\u5355\u5730\u8bf4\u5c31\u662f\u6839\u636e\u7ed9\u5b9a\u7684\u5b57\u7b26\u5728\u952e\u76d8\u4e0a\u7684\u6837\u5b50\u6765\u8fdb\u884c\u52a0\u5bc6\u3002 0CTF 2014 classic \u00b6 \u5c0f\u4e01\u4e01\u53d1\u73b0\u81ea\u5df1\u7f6e\u8eab\u4e8e\u4e00\u4e2a\u8be1\u5f02\u7684\u623f\u95f4\uff0c\u9762\u524d\u53ea\u6709\u4e00\u6247\u523b\u7740\u5947\u602a\u5b57\u7b26\u7684\u95e8\u3002 \u4ed6\u53d1\u73b0\u95e8\u8fb9\u4e0a\u8fd8\u6709\u4e00\u9053\u5bc6\u7801\u9501\uff0c\u4f3c\u4e4e\u8981\u8f93\u5165\u5bc6\u7801\u624d\u80fd\u5f00\u95e8\u3002\u30024esxcft5 rdcvgt 6tfc78uhg 098ukmnb \u53d1\u73b0\u8fd9\u4e48\u4e71\uff0c\u8fd8\u540c\u65f6\u5305\u62ec\u6570\u5b57\u548c\u5b57\u6bcd\u731c\u60f3\u53ef\u80fd\u662f\u952e\u76d8\u5bc6\u7801\uff0c\u8bd5\u7740\u5728\u952e\u76d8\u4e0a\u6309\u7167\u5b57\u6bcd\u987a\u5e8f\u63cf\u7ed8\u4e00\u4e0b\uff0c\u53ef\u5f97\u52300ops\u5b57\u6837\uff0c\u731c\u6d4b\u5c31\u662fflag\u4e86\u3002 2017\u5e74xman\u9009\u62d4\u8d5b\u2014\u2014\u4e00\u4e8c\u4e09\uff0c\u6728\u5934\u4eba \u00b6 \u6211\u6570123\u6728\u5934\u4eba\uff0c\u518d\u4e0d\u884c\u52a8\u5c31\u8981\u88ab\u6263\u5206\u3002 23731263111628163518122316391715262121 \u5bc6\u7801\u683c\u5f0fxman{flag} \u9898\u76ee\u4e2d\u6709\u5f88\u660e\u663e\u7684\u63d0\u793a123\uff0c\u90a3\u4e48\u5c31\u81ea\u7136\u9700\u8981\u8054\u60f3\u5230\u952e\u76d8\u5bc6\u7801\u4e2d\u7535\u8111\u952e\u76d8\u5750\u6807\u5bc6\u7801\uff0c\u53ef\u4ee5\u53d1\u73b0\u524d\u51e0\u4e2a\u6570\u5b57\u7b2c\u4e8c\u4e2a\u6570\u5b57\u90fd\u662f1-3\u8303\u56f4\u5185\u7684\uff0c\u4e5f\u9a8c\u8bc1\u4e86\u6211\u4eec\u7684\u731c\u6d4b\u3002\u4e8e\u662f 23-x 73-m 12-a 63-n 11-q \u4e0d\u5bf9\u5440\uff0c\u5bc6\u7801\u683c\u5f0f\u662f xman{ \uff0c\u7b2c\u56db\u4e2a\u5b57\u7b26\u662f { \uff0c\u4e8e\u662f\u770b\u4e86\u770b { \u7684\u4f4d\u7f6e\uff0c\u5176\u5e76\u6ca1\u6709\u5bf9\u5e94\u7684\u6a2a\u5750\u6807\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u624b\u52a8\u628a\u5b83\u89c6\u4e3a 11 \u7684\u8bdd\uff0c\u90a3\u4e48111\u5c31\u662f { \u3002\u7136\u540e\u4f9d\u6b21\u5f80\u540e\u63a8\uff0c\u53d1\u73b0\u786e\u5b9e\u53ef\u884c\uff0c\uff0c\u6700\u540e\u518d\u628a 121 \u89c6\u4e3a } \u5373\u53ef\u5f97\u5230 flag\u3002 xman{hintisenough} \u4ece\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u8fd8\u662f\u8981\u6ce8\u610f\u8fc1\u79fb\u6027\uff0c\u4e0d\u80fd\u5355\u7eaf\u5730\u7167\u642c\u4e00\u4e9b\u5df2\u6709\u7684\u77e5\u8bc6\u3002 \u9898\u76ee \u00b6 \u5b9e\u9a8c\u5427 \u5947\u602a\u7684\u77ed\u4fe1","title":"Others zh"},{"location":"crypto/ctf-wiki/classical/others-zh/#_1","text":"","title":"\u57f9\u6839\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others-zh/#_2","text":"\u57f9\u6839\u5bc6\u7801\u4f7f\u7528\u4e24\u79cd\u4e0d\u540c\u7684\u5b57\u4f53\uff0c\u4ee3\u8868 A \u548c B\uff0c\u7ed3\u5408\u52a0\u5bc6\u8868\u8fdb\u884c\u52a0\u89e3\u5bc6\u3002 a AAAAA g AABBA n ABBAA t BAABA b AAAAB h AABBB o ABBAB u-v BAABB c AAABA i-j ABAAA p ABBBA w BABAA d AAABB k ABAAB q ABBBB x BABAB e AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB \u4e0a\u9762\u7684\u662f\u5e38\u7528\u7684\u52a0\u5bc6\u8868\u3002\u8fd8\u6709\u53e6\u5916\u7684\u4e00\u79cd\u52a0\u5bc6\u8868\uff0c\u53ef\u8ba4\u4e3a\u662f\u5c06 26 \u4e2a\u5b57\u6bcd\u4ece 0 \u5230 25 \u6392\u5e8f\uff0c\u4ee5\u4e8c\u8fdb\u5236\u8868\u793a\uff0cA \u4ee3\u8868 0\uff0cB \u4ee3\u8868 1\u3002 \u4e0b\u9762\u8fd9\u4e00\u6bb5\u5185\u5bb9\u5c31\u662f\u660e\u6587 steganography \u52a0\u5bc6\u540e\u7684\u5185\u5bb9\uff0c\u6b63\u5e38\u5b57\u4f53\u662f A\uff0c\u7c97\u4f53\u662f B\uff1a T o en co de a mes s age e ac h letter of the pl a i nt ex t i s replaced b y a g rou p of f i ve of th e lett ers 'A' o r 'B' . \u53ef\u4ee5\u770b\u5230\uff0c\u57f9\u6839\u5bc6\u7801\u4e3b\u8981\u6709\u4ee5\u4e0b\u7279\u70b9 \u53ea\u6709\u4e24\u79cd\u5b57\u7b26 \u6bcf\u4e00\u6bb5\u7684\u957f\u5ea6\u4e3a 5 \u52a0\u5bc6\u5185\u5bb9\u4f1a\u6709\u7279\u6b8a\u7684\u5b57\u4f53\u4e4b\u5206\uff0c\u4ea6\u6216\u8005\u5927\u5c0f\u5199\u4e4b\u5206\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_3","text":"http://rumkin.com/tools/cipher/baconian.php","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/others-zh/#_4","text":"","title":"\u6805\u680f\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others-zh/#_5","text":"\u6805\u680f\u5bc6\u7801\u628a\u8981\u52a0\u5bc6\u7684\u660e\u6587\u5206\u6210 N \u4e2a\u4e00\u7ec4\uff0c\u7136\u540e\u628a\u6bcf\u7ec4\u7684\u7b2c 1 \u4e2a\u5b57\u8fde\u8d77\u6765\uff0c\u5f62\u6210\u4e00\u6bb5\u65e0\u89c4\u5f8b\u7684\u8bdd\u3002\u8fd9\u91cc\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50 \u660e\u6587\uff1aTHERE IS A CIPHER \u53bb\u6389\u7a7a\u683c\u540e\u53d8\u4e3a THEREISACIPHER \u5206\u6210\u4e24\u680f\uff0c\u4e24\u4e2a\u4e00\u7ec4\u5f97\u5230 TH ER EI SA CI PH ER \u5148\u53d6\u51fa\u7b2c\u4e00\u4e2a\u5b57\u6bcd\uff0c\u518d\u53d6\u51fa\u7b2c\u4e8c\u4e2a\u5b57\u6bcd TEESCPE HRIAIHR \u8fde\u5728\u4e00\u8d77\u5c31\u662f TEESCPEHRIAIHR \u4e0a\u8ff0\u660e\u6587\u4e5f\u53ef\u4ee5\u5206\u4e3a2\u680f\u3002 THEREIS ACIPHER \u7ec4\u5408\u5f97\u5230\u5bc6\u6587 TAHCEIRPEHIESR","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_6","text":"https://www.qqxiuzi.cn/bianma/zhalanmima.php","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/others-zh/#_7","text":"","title":"\u66f2\u8def\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others-zh/#_8","text":"\u66f2\u8def\u5bc6\u7801\uff08Curve Cipher\uff09\u662f\u4e00\u79cd\u6362\u4f4d\u5bc6\u7801\uff0c\u9700\u8981\u4e8b\u5148\u53cc\u65b9\u7ea6\u5b9a\u5bc6\u94a5\uff08\u4e5f\u5c31\u662f\u66f2\u8def\u8def\u5f84\uff09\u3002\u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50 \u660e\u6587\uff1aThe quick brown fox jumps over the lazy dog \u586b\u5165 5 \u884c 7 \u5217\u8868\uff08\u4e8b\u5148\u7ea6\u5b9a\u586b\u5145\u7684\u884c\u5217\u6570\uff09 \u52a0\u5bc6\u7684\u56de\u8def\u7ebf\uff08\u4e8b\u5148\u7ea6\u5b9a\u586b\u5145\u7684\u884c\u5217\u6570\uff09 \u5bc6\u6587\uff1agesfc inpho dtmwu qoury zejre hbxva lookT","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_9","text":"","title":"\u5217\u79fb\u4f4d\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/classical/others-zh/#_10","text":"\u5217\u79fb\u4f4d\u5bc6\u7801\uff08Columnar Transposition Cipher\uff09\u662f\u4e00\u79cd\u6bd4\u8f83\u7b80\u5355\uff0c\u6613\u4e8e\u5b9e\u73b0\u7684\u6362\u4f4d\u5bc6\u7801\uff0c\u901a\u8fc7\u4e00\u4e2a\u7b80\u5355\u7684\u89c4\u5219\u5c06\u660e\u6587\u6253\u4e71\u6df7\u5408\u6210\u5bc6\u6587\u3002\u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50\u3002 \u6211\u4eec\u4ee5\u660e\u6587 The quick brown fox jumps over the lazy dog \uff0c\u5bc6\u94a5 how are u \u4e3a\u4f8b\uff1a \u5c06\u660e\u6587\u586b\u5165 5 \u884c 7 \u5217\u8868\uff08\u4e8b\u5148\u7ea6\u5b9a\u586b\u5145\u7684\u884c\u5217\u6570\uff0c\u5982\u679c\u660e\u6587\u4e0d\u80fd\u586b\u5145\u5b8c\u8868\u683c\u53ef\u4ee5\u7ea6\u5b9a\u4f7f\u7528\u67d0\u4e2a\u5b57\u6bcd\u8fdb\u884c\u586b\u5145\uff09 \u5bc6\u94a5\uff1a how are u \uff0c\u6309 how are u \u5728\u5b57\u6bcd\u8868\u4e2d\u7684\u51fa\u73b0\u7684\u5148\u540e\u987a\u5e8f\u8fdb\u884c\u7f16\u53f7\uff0c\u6211\u4eec\u5c31\u6709 a \u4e3a 1\uff0ce \u4e3a 2\uff0ch \u4e3a 3\uff0co \u4e3a 4\uff0cr \u4e3a 5\uff0cu \u4e3a 6\uff0cw \u4e3a 7\uff0c\u6240\u4ee5\u5148\u5199\u51fa a \u5217\uff0c\u5176\u6b21 e \u5217\uff0c\u4ee5\u6b64\u7c7b\u63a8\u5199\u51fa\u7684\u7ed3\u679c\u4fbf\u662f\u5bc6\u6587\uff1a \u5bc6\u6587\uff1a qoury inpho Tkool hbxva uwmtd cfseg erjez","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_11","text":"http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/ \u884c\u5217\u6570\u76f8\u7b49","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/others-zh/#01248","text":"","title":"01248 \u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others-zh/#_12","text":"\u8be5\u5bc6\u7801\u53c8\u79f0\u4e3a\u4e91\u5f71\u5bc6\u7801\uff0c\u4f7f\u7528 0\uff0c1\uff0c2\uff0c4\uff0c8 \u56db\u4e2a\u6570\u5b57\uff0c\u5176\u4e2d 0 \u7528\u6765\u8868\u793a\u95f4\u9694\uff0c\u5176\u4ed6\u6570\u5b57\u4ee5\u52a0\u6cd5\u53ef\u4ee5\u8868\u793a\u51fa \u5982\uff1a28=10\uff0c124=7\uff0c18=9\uff0c\u518d\u7528 1->26 \u8868\u793a A->Z\u3002 \u53ef\u4ee5\u770b\u51fa\u8be5\u5bc6\u7801\u6709\u4ee5\u4e0b\u7279\u70b9 \u53ea\u6709 0\uff0c1\uff0c2\uff0c4\uff0c8","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_13","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5CFF 2016 \u5f71\u4e4b\u5bc6\u7801\u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9898\u76ee 8842101220480224404014224202480122 \u6211\u4eec\u6309\u71670\u6765\u8fdb\u884c\u5206\u5272\uff0c\u5982\u4e0b \u5185\u5bb9 \u6570\u5b57 \u5b57\u7b26 88421 8+8+4+2+1=23 W 122 1+2+2=5 E 48 4+8=12 L 2244 2+2+4+4=12 L 4 4 D 142242 1+4+2+2+4+2=15 O 248 2+4+8=14 N 122 1+2+2=5 E \u6240\u4ee5\u6700\u540e\u7684 flag \u4e3a WELLDONE\u3002","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/classical/others-zh/#jsfuck","text":"","title":"JSFuck"},{"location":"crypto/ctf-wiki/classical/others-zh/#_14","text":"JSFuck \u53ef\u4ee5\u53ea\u7528 6 \u4e2a\u5b57\u7b26 []()!+ \u6765\u7f16\u5199 JavaScript \u7a0b\u5e8f\u3002\u6bd4\u5982\u6211\u4eec\u60f3\u7528 JSFuck \u6765\u5b9e\u73b0 alert(1) \u4ee3\u7801\u5982\u4e0b [][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]][([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ([][[]] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ([][[]] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]](( ! [] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + [ +!+ []] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]])() \u5176\u4ed6\u4e00\u4e9b\u57fa\u672c\u7684\u8868\u8fbe\uff1a false => ! [] true => !! [] undefined => [][[]] NaN => + [ ! []] 0 => + [] 1 => +!+ [] 2 => !+ [] +!+ [] 10 => [ +!+ []] + [ + []] Array => [] Number => + [] String => [] + [] Boolean => ! [] Function => [][ \"filter\" ] eval => [][ \"filter\" ][ \"constructor\" ]( CODE )() window => [][ \"filter\" ][ \"constructor\" ]( \"return this\" )()","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_15","text":"JSFuck \u5728\u7ebf\u52a0\u5bc6\u7f51\u7ad9","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/others-zh/#brainfuck","text":"","title":"BrainFuck"},{"location":"crypto/ctf-wiki/classical/others-zh/#_16","text":"Brainfuck\uff0c\u662f\u4e00\u79cd\u6781\u5c0f\u5316\u7684\u8ba1\u7b97\u673a\u8bed\u8a00\uff0c\u5b83\u662f\u7531 Urban M\u00fcller \u5728 1993 \u5e74\u521b\u5efa\u7684\u3002\u6211\u4eec\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c\u6211\u4eec\u60f3\u8981\u4e00\u4e2a\u5728\u5c4f\u5e55\u4e0a\u6253\u5370Hello World\uff01\uff0c\u90a3\u4e48\u5bf9\u5e94\u7684\u7a0b\u5e8f\u5982\u4e0b\u3002\u5bf9\u4e8e\u5176\u4e2d\u7684\u539f\u7406\uff0c\u611f\u5174\u8da3\u7684\u53ef\u4ee5\u81ea\u884c\u7f51\u4e0a\u641c\u7d22\u3002 ++++++++++[>+++++++>++++++++++>+++>+<<<<-] >++.>+.+++++++..+++.>++.<<+++++++++++++++. >.+++.------.--------.>+.>. \u4e0e\u5176\u5bf9\u5e94\u7684\u8fd8\u6709 ook\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_17","text":"https://www.splitbrain.org/services/ook","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/others-zh/#_18","text":"","title":"\u732a\u5708\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others-zh/#_19","text":"\u732a\u5708\u5bc6\u7801\u662f\u4e00\u79cd\u4ee5\u683c\u5b50\u4e3a\u57fa\u7840\u7684\u7b80\u5355\u66ff\u4ee3\u5f0f\u5bc6\u7801\uff0c\u683c\u5b50\u5982\u4e0b \u6211\u4eec\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5982\u660e\u6587\u4e3a X marks the spot \uff0c\u90a3\u4e48\u5bc6\u6587\u5982\u4e0b","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_20","text":"http://www.simonsingh.net/The_Black_Chamber/pigpen.html","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/others-zh/#_21","text":"","title":"\u821e\u52a8\u7684\u5c0f\u4eba\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others-zh/#_22","text":"\u8fd9\u79cd\u5bc6\u7801\u51fa\u81ea\u4e8e\u798f\u5c14\u6469\u65af\u63a2\u6848\u96c6\u3002\u6bcf\u4e00\u4e2a\u8df3\u821e\u7684\u5c0f\u4eba\u5b9e\u9645\u4e0a\u5bf9\u5e94\u7684\u662f\u82f1\u6587\u4e8c\u5341\u516d\u4e2a\u5b57\u6bcd\u4e2d\u7684\u4e00\u4e2a\uff0c\u800c\u5c0f\u4eba\u624b\u4e2d\u7684\u65d7\u5b50\u5219\u8868\u660e\u8be5\u5b57\u6bcd\u662f\u5355\u8bcd\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\uff0c\u5982\u679c\u4ec5\u4ec5\u662f\u4e00\u4e2a\u5355\u8bcd\u800c\u4e0d\u662f\u53e5\u5b50\uff0c\u6216\u8005\u662f\u53e5\u5b50\u4e2d\u6700\u540e\u7684\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5355\u8bcd\u4e2d\u6700\u540e\u4e00\u4e2a\u5b57\u6bcd\u4e0d\u5fc5\u4e3e\u65d7\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/others-zh/#_23","text":"\u6240\u8c13\u952e\u76d8\u5bc6\u7801\uff0c\u5c31\u662f\u91c7\u7528\u624b\u673a\u952e\u76d8\u6216\u8005\u7535\u8111\u952e\u76d8\u8fdb\u884c\u52a0\u5bc6\u3002","title":"\u952e\u76d8\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others-zh/#_24","text":"\u624b\u673a\u952e\u76d8\u52a0\u5bc6\u65b9\u5f0f\uff0c\u662f\u6bcf\u4e2a\u6570\u5b57\u952e\u4e0a\u6709 3-4 \u4e2a\u5b57\u6bcd\uff0c\u7528\u4e24\u4f4d\u6570\u5b57\u6765\u8868\u793a\u5b57\u6bcd\uff0c\u4f8b\u5982\uff1aru \u7528\u624b\u673a\u952e\u76d8\u8868\u793a\u5c31\u662f\uff1a7382\uff0c\u90a3\u4e48\u8fd9\u91cc\u5c31\u53ef\u4ee5\u77e5\u9053\u4e86\uff0c\u624b\u673a\u952e\u76d8\u52a0\u5bc6\u65b9\u5f0f\u4e0d\u53ef\u80fd\u7528 1 \u5f00\u5934\uff0c\u7b2c\u4e8c\u4f4d\u6570\u5b57\u4e0d\u53ef\u80fd\u8d85\u8fc7 4\uff0c\u89e3\u5bc6\u7684\u65f6\u5019\u53c2\u8003\u6b64 \u5173\u4e8e\u624b\u673a\u952e\u76d8\u52a0\u5bc6\u8fd8\u6709\u53e6\u4e00\u79cd\u65b9\u5f0f\uff0c\u5c31\u662f\u300c\u97f3\u7684\u300d\u5f0f\uff08\u8fd9\u4e00\u70b9\u53ef\u80fd\u6839\u636e\u624b\u673a\u7684\u4e0d\u540c\u4f1a\u6709\u6240\u4e0d\u540c\uff09\uff0c\u5177\u4f53\u53c2\u7167\u624b\u673a\u952e\u76d8\u6765\u6253\uff0c\u4f8b\u5982\uff1a\u300c\u6570\u5b57\u300d\u8868\u793a\u51fa\u6765\u5c31\u662f\uff1a748 94\u3002\u5728\u624b\u673a\u952e\u76d8\u4e0a\u9762\u6309\u4e0b\u8fd9\u51e0\u4e2a\u6570\uff0c\u5c31\u4f1a\u51fa\uff1a\u300c\u6570\u5b57\u300d\u7684\u62fc\u97f3\u3002","title":"\u624b\u673a\u952e\u76d8\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others-zh/#_25","text":"\u7535\u8111\u952e\u76d8\u68cb\u76d8\u52a0\u5bc6\uff0c\u5229\u7528\u4e86\u7535\u8111\u7684\u68cb\u76d8\u65b9\u9635\u3002","title":"\u7535\u8111\u952e\u76d8\u68cb\u76d8"},{"location":"crypto/ctf-wiki/classical/others-zh/#_26","text":"\u7535\u8111\u952e\u76d8\u5750\u6807\u52a0\u5bc6\uff0c\u5229\u7528\u952e\u76d8\u4e0a\u9762\u7684\u5b57\u6bcd\u884c\u548c\u6570\u5b57\u884c\u6765\u52a0\u5bc6\uff0c\u4f8b\uff1abye \u7528\u7535\u8111\u952e\u76d8 XY \u8868\u793a\u5c31\u662f\uff1a351613","title":"\u7535\u8111\u952e\u76d8\u5750\u6807"},{"location":"crypto/ctf-wiki/classical/others-zh/#qwe","text":"\u7535\u8111\u952e\u76d8 QWE \u52a0\u5bc6\u6cd5\uff0c\u5c31\u662f\u7528\u5b57\u6bcd\u8868\u66ff\u6362\u952e\u76d8\u4e0a\u9762\u7684\u6392\u5217\u987a\u5e8f\u3002","title":"\u7535\u8111\u952e\u76d8 QWE"},{"location":"crypto/ctf-wiki/classical/others-zh/#_27","text":"\u7b80\u5355\u5730\u8bf4\u5c31\u662f\u6839\u636e\u7ed9\u5b9a\u7684\u5b57\u7b26\u5728\u952e\u76d8\u4e0a\u7684\u6837\u5b50\u6765\u8fdb\u884c\u52a0\u5bc6\u3002","title":"\u952e\u76d8\u5e03\u5c40\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/classical/others-zh/#0ctf-2014-classic","text":"\u5c0f\u4e01\u4e01\u53d1\u73b0\u81ea\u5df1\u7f6e\u8eab\u4e8e\u4e00\u4e2a\u8be1\u5f02\u7684\u623f\u95f4\uff0c\u9762\u524d\u53ea\u6709\u4e00\u6247\u523b\u7740\u5947\u602a\u5b57\u7b26\u7684\u95e8\u3002 \u4ed6\u53d1\u73b0\u95e8\u8fb9\u4e0a\u8fd8\u6709\u4e00\u9053\u5bc6\u7801\u9501\uff0c\u4f3c\u4e4e\u8981\u8f93\u5165\u5bc6\u7801\u624d\u80fd\u5f00\u95e8\u3002\u30024esxcft5 rdcvgt 6tfc78uhg 098ukmnb \u53d1\u73b0\u8fd9\u4e48\u4e71\uff0c\u8fd8\u540c\u65f6\u5305\u62ec\u6570\u5b57\u548c\u5b57\u6bcd\u731c\u60f3\u53ef\u80fd\u662f\u952e\u76d8\u5bc6\u7801\uff0c\u8bd5\u7740\u5728\u952e\u76d8\u4e0a\u6309\u7167\u5b57\u6bcd\u987a\u5e8f\u63cf\u7ed8\u4e00\u4e0b\uff0c\u53ef\u5f97\u52300ops\u5b57\u6837\uff0c\u731c\u6d4b\u5c31\u662fflag\u4e86\u3002","title":"0CTF 2014 classic"},{"location":"crypto/ctf-wiki/classical/others-zh/#2017xman","text":"\u6211\u6570123\u6728\u5934\u4eba\uff0c\u518d\u4e0d\u884c\u52a8\u5c31\u8981\u88ab\u6263\u5206\u3002 23731263111628163518122316391715262121 \u5bc6\u7801\u683c\u5f0fxman{flag} \u9898\u76ee\u4e2d\u6709\u5f88\u660e\u663e\u7684\u63d0\u793a123\uff0c\u90a3\u4e48\u5c31\u81ea\u7136\u9700\u8981\u8054\u60f3\u5230\u952e\u76d8\u5bc6\u7801\u4e2d\u7535\u8111\u952e\u76d8\u5750\u6807\u5bc6\u7801\uff0c\u53ef\u4ee5\u53d1\u73b0\u524d\u51e0\u4e2a\u6570\u5b57\u7b2c\u4e8c\u4e2a\u6570\u5b57\u90fd\u662f1-3\u8303\u56f4\u5185\u7684\uff0c\u4e5f\u9a8c\u8bc1\u4e86\u6211\u4eec\u7684\u731c\u6d4b\u3002\u4e8e\u662f 23-x 73-m 12-a 63-n 11-q \u4e0d\u5bf9\u5440\uff0c\u5bc6\u7801\u683c\u5f0f\u662f xman{ \uff0c\u7b2c\u56db\u4e2a\u5b57\u7b26\u662f { \uff0c\u4e8e\u662f\u770b\u4e86\u770b { \u7684\u4f4d\u7f6e\uff0c\u5176\u5e76\u6ca1\u6709\u5bf9\u5e94\u7684\u6a2a\u5750\u6807\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u624b\u52a8\u628a\u5b83\u89c6\u4e3a 11 \u7684\u8bdd\uff0c\u90a3\u4e48111\u5c31\u662f { \u3002\u7136\u540e\u4f9d\u6b21\u5f80\u540e\u63a8\uff0c\u53d1\u73b0\u786e\u5b9e\u53ef\u884c\uff0c\uff0c\u6700\u540e\u518d\u628a 121 \u89c6\u4e3a } \u5373\u53ef\u5f97\u5230 flag\u3002 xman{hintisenough} \u4ece\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u8fd8\u662f\u8981\u6ce8\u610f\u8fc1\u79fb\u6027\uff0c\u4e0d\u80fd\u5355\u7eaf\u5730\u7167\u642c\u4e00\u4e9b\u5df2\u6709\u7684\u77e5\u8bc6\u3002","title":"2017\u5e74xman\u9009\u62d4\u8d5b\u2014\u2014\u4e00\u4e8c\u4e09\uff0c\u6728\u5934\u4eba"},{"location":"crypto/ctf-wiki/classical/others-zh/#_28","text":"\u5b9e\u9a8c\u5427 \u5947\u602a\u7684\u77ed\u4fe1","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/classical/others/","text":"EN | ZH Bacon Password \u00b6 Principle \u00b6 The Bacon password uses two different fonts, representing A and B, combined with an encryption table for encryption and decryption. a AAAAA g AABBA n ABBAA t BAABA | b AAAAB | h. | AABBB | o | ABBAB | uv | BAABB | | c | AAABA | ij | ABAAA | p | ABBBA | w | BABAA | | d | AAABB | k | ABAAB | q | ABBBB | x | BABAB | | e | AABAA | l | ABABA | r | BAAAA | y | BABBA | | f AABAB m ABABB | s BAAAB z BABBB The above is a commonly used encryption table. There is another type of encryption table that can be thought of as sorting 26 letters from 0 to 25, expressed in binary, with A representing 0 and B representing 1. The following paragraph is the encrypted content of plain text steganography, the normal font is A, and the bold is B: T o en co de a mes s age e ac h letter of the pl a i nt ex t i s replaced b y a g rou p of f i ve of th e lett ers 'A' o r 'B' . It can be seen that the Bacon password mainly has the following characteristics. only two characters the length of each segment is 5 Encrypted content will have a special font, or case. Tools \u00b6 http://rumkin.com/tools/cipher/baconian.php fence password \u00b6 Principle \u00b6 The fence password divides the plaintext to be encrypted into N groups, and then connects the first word of each group to form an irregular word. Here is an example \u660e\u6587\uff1aTHERE IS A CIPHER Changed after removing the space THEREISACIPHER Divided into two columns, two groups get TH IS EI SA CI PH ER First take the first letter and then take the second letter TEESCPE HRIAIHR Connected together TEESCPEHRIAIHR The above plain text can also be divided into 2 columns. THEREIS ACIPHER Combine to get ciphertext TAHCEIRPEHIESR Tools \u00b6 To be added. \u66f2\u8def\u5bc6\u7801 \u00b6 Principle \u00b6 Curve Cipher is a transposition password that requires the two parties to agree on the key (that is, the path of the curve). An example is given below \u660e\u6587\uff1aThe quick brown fox jumps over the lazy dog Fill in 5 rows and 7 lists (pre-agreed the number of rows and columns filled) Encrypted loop line (pre-agreed the number of rows and columns filled) \u5bc6 \u6587: gesfc inpho dtmwu qoury zejre hbxva lookT Column Shift Encryption \u00b6 Principle \u00b6 Column Transposition Cipher is a relatively simple and easy-to-implement transposition cipher that mixes plaintext into ciphertext through a simple rule. An example is given below. We use the clear text The quick brown fox jumps over the lazy dog , the key how are u as an example: Fill in the clear line with 5 rows and 7 lists (pre-agreed the number of rows and columns to be filled in. If the plain text cannot be filled in, the form can be filled with a letter) Key: how are u , press how are u to number in the order in which the alphabet appears. We have a for 1, e for 2, h for 3, o for 4, and r for 5. u is 6, and w is 7, so write a column first, followed by column e, and so on. The result is cipher text: \u5bc6 \u6587: qoury inpho takool hbxva uwmtd cfseg erjez Tools \u00b6 http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/ The number of rows and columns is equal 01248 Password \u00b6 Principle \u00b6 This password, also known as cloud shadow password, uses 0, 1, 2, 4, 8 four digits, where 0 is used to indicate the interval, and other numbers can be expressed by addition: 28=10,124=7,18=9 Then use 1->26 to indicate A->Z. It can be seen that the password has the following characteristics only 0, 1, 2, 4, 8 Examples \u00b6 Here we take CFF 2016 shadow password as an example, the topic 8842101220480224404014224202480122 We divide by 0, as follows Content Numbers Characters | 88421 | 8 + 8 + 4 + 2 + 1 = 23 W | | 122 | 1 + 2 + 2 = 5 | E | | 48 | 4 + 8 = 12 | L | | 2244 | 2 + 2 + 4 + 4 = 12 | L | | 4 | 4 | D | | 142242 | 1 + 4 + 2 + 2 + 4 + 2 = 15 | O | | 248 | 2+4+8=14 | N | | 122 | 1 + 2 + 2 = 5 | E | So the final flag is WELLDONE. JSFuck \u00b6 Principle \u00b6 JSFuck can write JavaScript programs with only 6 characters []()!+ . For example, we want to use JSFuck to implement the alert(1) code as follows [][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]][([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ([][[]] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ([][[]] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]](( ! [] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + [ +!+ []] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]])() Some other basic expressions: false => ! [] true => !! [] undefined => [][[]] NaN =& gt ; + [ ! []] 0 => + [] 1 => +!+ [] 2 => !+ [] +!+ [] 10 => [ +!+ []] + [ + []] Array => [] Number => + [] String => [] + [] Boolean => ! [] Function => [][ \"filter\" ] eval => [][ \"filter\" ][ \"constructor\" ]( CODE )() window => [][ \"filter\" ][ \"constructor\" ]( \"return this\" )() Tools \u00b6 [JSFuck Online Encryption Website] ( http://www.jsfuck.com/ ) BrainFuck \u00b6 Principle \u00b6 Brainfuck, a minimal computer language, was created in 1993 by Urban M\u00fcller. Let's take an example if we want to print Hello World on the screen! , then the corresponding program is as follows. For the principles, you can search online for your own interest. ++++++++++[>+++++++>++++++++++>+++>+<<<<-] >++.>+.+++++++..+++.>++.<<+++++++++++++++. >.+++.------.--------.>+.>. Corresponding to it is ook. Tools \u00b6 https://www.splitbrain.org/services/ook Pigsty password \u00b6 Principle \u00b6 The pigsty password is a simple alternative password based on the grid. The grid is as follows ![Pig password comparison table] (./figure/pigpen.png) Let's take an example, such as the plain text is X marks the spot , then the ciphertext is as follows ![pig password example] (./figure/pigpen_example.png) Tools \u00b6 http://www.simonsingh.net/The_Black_Chamber/pigpen.html Dancing villain password \u00b6 Principle \u00b6 This password comes from the Sherlock Holmes collection. Each dancing villain actually corresponds to one of the twenty-six letters in English, while the flag in the hand of the villain indicates that the letter is the last letter of the word, if it is just a word instead of a sentence, or a sentence The last word in the word, the last letter in the word does not have to be raised. ![Dancing Man's Password] (./figure/dancingman.jpg) Keyboard password \u00b6 The so-called keyboard password is encrypted using a mobile phone keyboard or a computer keyboard. Mobile keyboard password \u00b6 The phone keyboard encryption method is that there are 3-4 letters on each number key, and the two-digit number is used to represent the letter. For example: ru is represented by the phone keypad: 7382, then you can know here, the phone keyboard encryption method is impossible. Start with 1, the second digit cannot exceed 4, refer to this when decrypting Another way to encrypt your phone's keyboard is the \"sound\" style (this may vary depending on the phone). Refer to the phone keypad for details. For example, \"Number\" means: 748 94. Pressing these numbers on the phone keypad will bring out the pinyin of \"number\". Computer keyboard board \u00b6 The computer keyboard is encrypted and uses the square of the computer's board. Computer keyboard coordinates \u00b6 Encryption of the computer keyboard coordinates, using the letter lines and numbers on the keyboard to encrypt, for example: bye using the computer keyboard XY means: 351613 ![Computer keyboard coordinate encryption] (./figure/computer-xy.jpg) Computer keyboard QWE \u00b6 Computer keyboard QWE encryption method is to replace the order of the keyboard with the alphabet. Keyboard layout encryption \u00b6 Simply put, it is encrypted according to how the given character looks on the keyboard. 0CTF 2014 classic \u00b6 > Xiaoding Ding found himself in a strange room with only a door with strange characters in front of him. He found a password lock on the side of the door, which seemed to require a password to open the door. . 4esxcft5 rdcvgt 6tfc78uhg 098ukmnb Found so chaotic, but also including the number and letter guess may be the keyboard password, try to draw in the alphabetical order on the keyboard, you can get 0ops, guess is the flag. 2017 xman trials - one two three, wood people \u00b6 > I count 123 wood people, and I will be deducted if I don't act. 23731263111628163518122316391715262121 > password format xman{flag} There are obvious hints 123 in the title, then it is natural to think of the computer keyboard coordinate password in the keyboard password. You can find that the second digits of the first few digits are in the range of 1-3, which also verifies our guess. then 23-x 73-m 12-a 63-n 11-q No, the password format is xman{ , the fourth character is { , so I look at the position of { , which does not have a corresponding abscissa, but if we manually treat it as 11, then 111 is { . Then push back in turn and find that it is feasible. Finally, treat 121 as } to get the flag. xman{hintisenough} From here we can see that we still have to pay attention to mobility, and we cannot simply copy some existing knowledge. Title \u00b6 Experiment with strange text messages","title":"\u5176\u4ed6\u7c7b\u578b\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/classical/others/#bacon-password","text":"","title":"Bacon Password"},{"location":"crypto/ctf-wiki/classical/others/#principle","text":"The Bacon password uses two different fonts, representing A and B, combined with an encryption table for encryption and decryption. a AAAAA g AABBA n ABBAA t BAABA | b AAAAB | h. | AABBB | o | ABBAB | uv | BAABB | | c | AAABA | ij | ABAAA | p | ABBBA | w | BABAA | | d | AAABB | k | ABAAB | q | ABBBB | x | BABAB | | e | AABAA | l | ABABA | r | BAAAA | y | BABBA | | f AABAB m ABABB | s BAAAB z BABBB The above is a commonly used encryption table. There is another type of encryption table that can be thought of as sorting 26 letters from 0 to 25, expressed in binary, with A representing 0 and B representing 1. The following paragraph is the encrypted content of plain text steganography, the normal font is A, and the bold is B: T o en co de a mes s age e ac h letter of the pl a i nt ex t i s replaced b y a g rou p of f i ve of th e lett ers 'A' o r 'B' . It can be seen that the Bacon password mainly has the following characteristics. only two characters the length of each segment is 5 Encrypted content will have a special font, or case.","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#tools","text":"http://rumkin.com/tools/cipher/baconian.php","title":"Tools"},{"location":"crypto/ctf-wiki/classical/others/#fence-password","text":"","title":"fence password"},{"location":"crypto/ctf-wiki/classical/others/#principle_1","text":"The fence password divides the plaintext to be encrypted into N groups, and then connects the first word of each group to form an irregular word. Here is an example \u660e\u6587\uff1aTHERE IS A CIPHER Changed after removing the space THEREISACIPHER Divided into two columns, two groups get TH IS EI SA CI PH ER First take the first letter and then take the second letter TEESCPE HRIAIHR Connected together TEESCPEHRIAIHR The above plain text can also be divided into 2 columns. THEREIS ACIPHER Combine to get ciphertext TAHCEIRPEHIESR","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#tools_1","text":"To be added.","title":"Tools"},{"location":"crypto/ctf-wiki/classical/others/#_1","text":"","title":"\u66f2\u8def\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/others/#principle_2","text":"Curve Cipher is a transposition password that requires the two parties to agree on the key (that is, the path of the curve). An example is given below \u660e\u6587\uff1aThe quick brown fox jumps over the lazy dog Fill in 5 rows and 7 lists (pre-agreed the number of rows and columns filled) Encrypted loop line (pre-agreed the number of rows and columns filled) \u5bc6 \u6587: gesfc inpho dtmwu qoury zejre hbxva lookT","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#column-shift-encryption","text":"","title":"Column Shift Encryption"},{"location":"crypto/ctf-wiki/classical/others/#principle_3","text":"Column Transposition Cipher is a relatively simple and easy-to-implement transposition cipher that mixes plaintext into ciphertext through a simple rule. An example is given below. We use the clear text The quick brown fox jumps over the lazy dog , the key how are u as an example: Fill in the clear line with 5 rows and 7 lists (pre-agreed the number of rows and columns to be filled in. If the plain text cannot be filled in, the form can be filled with a letter) Key: how are u , press how are u to number in the order in which the alphabet appears. We have a for 1, e for 2, h for 3, o for 4, and r for 5. u is 6, and w is 7, so write a column first, followed by column e, and so on. The result is cipher text: \u5bc6 \u6587: qoury inpho takool hbxva uwmtd cfseg erjez","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#tools_2","text":"http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/ The number of rows and columns is equal","title":"Tools"},{"location":"crypto/ctf-wiki/classical/others/#01248-password","text":"","title":"01248 Password"},{"location":"crypto/ctf-wiki/classical/others/#principle_4","text":"This password, also known as cloud shadow password, uses 0, 1, 2, 4, 8 four digits, where 0 is used to indicate the interval, and other numbers can be expressed by addition: 28=10,124=7,18=9 Then use 1->26 to indicate A->Z. It can be seen that the password has the following characteristics only 0, 1, 2, 4, 8","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#examples","text":"Here we take CFF 2016 shadow password as an example, the topic 8842101220480224404014224202480122 We divide by 0, as follows Content Numbers Characters | 88421 | 8 + 8 + 4 + 2 + 1 = 23 W | | 122 | 1 + 2 + 2 = 5 | E | | 48 | 4 + 8 = 12 | L | | 2244 | 2 + 2 + 4 + 4 = 12 | L | | 4 | 4 | D | | 142242 | 1 + 4 + 2 + 2 + 4 + 2 = 15 | O | | 248 | 2+4+8=14 | N | | 122 | 1 + 2 + 2 = 5 | E | So the final flag is WELLDONE.","title":"Examples"},{"location":"crypto/ctf-wiki/classical/others/#jsfuck","text":"","title":"JSFuck"},{"location":"crypto/ctf-wiki/classical/others/#principle_5","text":"JSFuck can write JavaScript programs with only 6 characters []()!+ . For example, we want to use JSFuck to implement the alert(1) code as follows [][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]][([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ([][[]] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ([][[]] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]](( ! [] + [])[ + [[ +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + [ +!+ []] + ([][( ! [] + [])[ + [[ + []]]] + ([][[]] + [])[ + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ []]]] + ( ! [] + [])[ + [[ !+ [] +!+ []]]] + ( !! [] + [])[ + [[ + []]]] + ( !! [] + [])[ + [[ !+ [] +!+ [] +!+ []]]] + ( !! [] + [])[ + [[ +!+ []]]]] + [])[ + [[ +!+ []]] + [[ !+ [] +!+ [] +!+ [] +!+ [] +!+ [] +!+ []]]])() Some other basic expressions: false => ! [] true => !! [] undefined => [][[]] NaN =& gt ; + [ ! []] 0 => + [] 1 => +!+ [] 2 => !+ [] +!+ [] 10 => [ +!+ []] + [ + []] Array => [] Number => + [] String => [] + [] Boolean => ! [] Function => [][ \"filter\" ] eval => [][ \"filter\" ][ \"constructor\" ]( CODE )() window => [][ \"filter\" ][ \"constructor\" ]( \"return this\" )()","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#tools_3","text":"[JSFuck Online Encryption Website] ( http://www.jsfuck.com/ )","title":"Tools"},{"location":"crypto/ctf-wiki/classical/others/#brainfuck","text":"","title":"BrainFuck"},{"location":"crypto/ctf-wiki/classical/others/#principle_6","text":"Brainfuck, a minimal computer language, was created in 1993 by Urban M\u00fcller. Let's take an example if we want to print Hello World on the screen! , then the corresponding program is as follows. For the principles, you can search online for your own interest. ++++++++++[>+++++++>++++++++++>+++>+<<<<-] >++.>+.+++++++..+++.>++.<<+++++++++++++++. >.+++.------.--------.>+.>. Corresponding to it is ook.","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#tools_4","text":"https://www.splitbrain.org/services/ook","title":"Tools"},{"location":"crypto/ctf-wiki/classical/others/#pigsty-password","text":"","title":"Pigsty password"},{"location":"crypto/ctf-wiki/classical/others/#principle_7","text":"The pigsty password is a simple alternative password based on the grid. The grid is as follows ![Pig password comparison table] (./figure/pigpen.png) Let's take an example, such as the plain text is X marks the spot , then the ciphertext is as follows ![pig password example] (./figure/pigpen_example.png)","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#tools_5","text":"http://www.simonsingh.net/The_Black_Chamber/pigpen.html","title":"Tools"},{"location":"crypto/ctf-wiki/classical/others/#dancing-villain-password","text":"","title":"Dancing villain password"},{"location":"crypto/ctf-wiki/classical/others/#principle_8","text":"This password comes from the Sherlock Holmes collection. Each dancing villain actually corresponds to one of the twenty-six letters in English, while the flag in the hand of the villain indicates that the letter is the last letter of the word, if it is just a word instead of a sentence, or a sentence The last word in the word, the last letter in the word does not have to be raised. ![Dancing Man's Password] (./figure/dancingman.jpg)","title":"Principle"},{"location":"crypto/ctf-wiki/classical/others/#keyboard-password","text":"The so-called keyboard password is encrypted using a mobile phone keyboard or a computer keyboard.","title":"Keyboard password"},{"location":"crypto/ctf-wiki/classical/others/#mobile-keyboard-password","text":"The phone keyboard encryption method is that there are 3-4 letters on each number key, and the two-digit number is used to represent the letter. For example: ru is represented by the phone keypad: 7382, then you can know here, the phone keyboard encryption method is impossible. Start with 1, the second digit cannot exceed 4, refer to this when decrypting Another way to encrypt your phone's keyboard is the \"sound\" style (this may vary depending on the phone). Refer to the phone keypad for details. For example, \"Number\" means: 748 94. Pressing these numbers on the phone keypad will bring out the pinyin of \"number\".","title":"Mobile keyboard password"},{"location":"crypto/ctf-wiki/classical/others/#computer-keyboard-board","text":"The computer keyboard is encrypted and uses the square of the computer's board.","title":"Computer keyboard board"},{"location":"crypto/ctf-wiki/classical/others/#computer-keyboard-coordinates","text":"Encryption of the computer keyboard coordinates, using the letter lines and numbers on the keyboard to encrypt, for example: bye using the computer keyboard XY means: 351613 ![Computer keyboard coordinate encryption] (./figure/computer-xy.jpg)","title":"Computer keyboard coordinates"},{"location":"crypto/ctf-wiki/classical/others/#computer-keyboard-qwe","text":"Computer keyboard QWE encryption method is to replace the order of the keyboard with the alphabet.","title":"Computer keyboard QWE"},{"location":"crypto/ctf-wiki/classical/others/#keyboard-layout-encryption","text":"Simply put, it is encrypted according to how the given character looks on the keyboard.","title":"Keyboard layout encryption"},{"location":"crypto/ctf-wiki/classical/others/#0ctf-2014-classic","text":"> Xiaoding Ding found himself in a strange room with only a door with strange characters in front of him. He found a password lock on the side of the door, which seemed to require a password to open the door. . 4esxcft5 rdcvgt 6tfc78uhg 098ukmnb Found so chaotic, but also including the number and letter guess may be the keyboard password, try to draw in the alphabetical order on the keyboard, you can get 0ops, guess is the flag.","title":"0CTF 2014 classic"},{"location":"crypto/ctf-wiki/classical/others/#2017-xman-trials-one-two-three-wood-people","text":"> I count 123 wood people, and I will be deducted if I don't act. 23731263111628163518122316391715262121 > password format xman{flag} There are obvious hints 123 in the title, then it is natural to think of the computer keyboard coordinate password in the keyboard password. You can find that the second digits of the first few digits are in the range of 1-3, which also verifies our guess. then 23-x 73-m 12-a 63-n 11-q No, the password format is xman{ , the fourth character is { , so I look at the position of { , which does not have a corresponding abscissa, but if we manually treat it as 11, then 111 is { . Then push back in turn and find that it is feasible. Finally, treat 121 as } to get the flag. xman{hintisenough} From here we can see that we still have to pay attention to mobility, and we cannot simply copy some existing knowledge.","title":"2017 xman trials - one two three, wood people"},{"location":"crypto/ctf-wiki/classical/others/#title","text":"Experiment with strange text messages","title":"Title"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/","text":"EN | ZH \u5bf9\u4e8e\u591a\u8868\u66ff\u6362\u52a0\u5bc6\u6765\u8bf4\uff0c\u52a0\u5bc6\u540e\u7684\u5b57\u6bcd\u51e0\u4e4e\u4e0d\u518d\u4fdd\u6301\u539f\u6765\u7684\u9891\u7387\uff0c\u6240\u4ee5\u6211\u4eec\u4e00\u822c\u53ea\u80fd\u901a\u8fc7\u5bfb\u627e\u7b97\u6cd5\u5b9e\u73b0\u5bf9\u5e94\u7684\u5f31\u70b9\u8fdb\u884c\u7834\u89e3\u3002 Playfair \u00b6 \u539f\u7406 \u00b6 Playfair \u5bc6\u7801\uff08Playfair cipher or Playfair square\uff09\u662f\u4e00\u79cd\u66ff\u6362\u5bc6\u7801\uff0c1854 \u5e74\u7531\u82f1\u56fd\u4eba\u67e5\u5c14\u65af\u00b7\u60e0\u65af\u901a\uff08Charles Wheatstone\uff09\u53d1\u660e\uff0c\u57fa\u672c\u7b97\u6cd5\u5982\u4e0b\uff1a \u9009\u53d6\u4e00\u4e32\u82f1\u6587\u5b57\u6bcd\uff0c\u9664\u53bb\u91cd\u590d\u51fa\u73b0\u7684\u5b57\u6bcd\uff0c\u5c06\u5269\u4e0b\u7684\u5b57\u6bcd\u9010\u4e2a\u9010\u4e2a\u52a0\u5165 5 \u00d7 5 \u7684\u77e9\u9635\u5185\uff0c\u5269\u4e0b\u7684\u7a7a\u95f4\u7531\u672a\u52a0\u5165\u7684\u82f1\u6587\u5b57\u6bcd\u4f9d a-z \u7684\u987a\u5e8f\u52a0\u5165\u3002\u6ce8\u610f\uff0c\u5c06 q \u53bb\u9664\uff0c\u6216\u5c06 i \u548c j \u89c6\u4f5c\u540c\u4e00\u5b57\u3002 \u5c06\u8981\u52a0\u5bc6\u7684\u660e\u6587\u5206\u6210\u4e24\u4e2a\u4e00\u7ec4\u3002\u82e5\u7ec4\u5185\u7684\u5b57\u6bcd\u76f8\u540c\uff0c\u5c06 X\uff08\u6216 Q\uff09\u52a0\u5230\u8be5\u7ec4\u7684\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u540e\uff0c\u91cd\u65b0\u5206\u7ec4\u3002\u82e5\u5269\u4e0b\u4e00\u4e2a\u5b57\uff0c\u4e5f\u52a0\u5165 X \u3002 \u5728\u6bcf\u7ec4\u4e2d\uff0c\u627e\u51fa\u4e24\u4e2a\u5b57\u6bcd\u5728\u77e9\u9635\u4e2d\u7684\u5730\u65b9\u3002 \u82e5\u4e24\u4e2a\u5b57\u6bcd\u4e0d\u540c\u884c\u4e5f\u4e0d\u540c\u5217\uff0c\u5728\u77e9\u9635\u4e2d\u627e\u51fa\u53e6\u5916\u4e24\u4e2a\u5b57\u6bcd\uff08\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u5bf9\u5e94\u884c\u4f18\u5148\uff09\uff0c\u4f7f\u8fd9\u56db\u4e2a\u5b57\u6bcd\u6210\u4e3a\u4e00\u4e2a\u957f\u65b9\u5f62\u7684\u56db\u4e2a\u89d2\u3002 \u82e5\u4e24\u4e2a\u5b57\u6bcd\u540c\u884c\uff0c\u53d6\u8fd9\u4e24\u4e2a\u5b57\u6bcd\u53f3\u65b9\u7684\u5b57\u6bcd\uff08\u82e5\u5b57\u6bcd\u5728\u6700\u53f3\u65b9\u5219\u53d6\u6700\u5de6\u65b9\u7684\u5b57\u6bcd\uff09\u3002 \u82e5\u4e24\u4e2a\u5b57\u6bcd\u540c\u5217\uff0c\u53d6\u8fd9\u4e24\u4e2a\u5b57\u6bcd\u4e0b\u65b9\u7684\u5b57\u6bcd\uff08\u82e5\u5b57\u6bcd\u5728\u6700\u4e0b\u65b9\u5219\u53d6\u6700\u4e0a\u65b9\u7684\u5b57\u6bcd\uff09\u3002 \u65b0\u627e\u5230\u7684\u4e24\u4e2a\u5b57\u6bcd\u5c31\u662f\u539f\u672c\u7684\u4e24\u4e2a\u5b57\u6bcd\u52a0\u5bc6\u7684\u7ed3\u679c\u3002 \u4ee5 playfair example \u4e3a\u5bc6\u5319\uff0c\u5f97 P L A Y F I R E X M B C D G H K N O Q S T U V W Z \u8981\u52a0\u5bc6\u7684\u8baf\u606f\u4e3a Hide the gold in the tree stump HI DE TH EG OL DI NT HE TR EX ES TU MP \u5c31\u4f1a\u5f97\u5230 BM OD ZB XD NA BE KU DM UI XM MO UV IF \u5de5\u5177 \u00b6 CAP4 Polybius \u00b6 \u539f\u7406 \u00b6 Polybius\u5bc6\u7801\u53c8\u79f0\u4e3a\u68cb\u76d8\u5bc6\u7801\uff0c\u5176\u4e00\u822c\u662f\u5c06\u7ed9\u5b9a\u7684\u660e\u6587\u52a0\u5bc6\u4e3a\u4e24\u4e24\u7ec4\u5408\u7684\u6570\u5b57\uff0c\u5176\u5e38\u7528\u5bc6\u7801\u8868 1 2 3 4 5 1 A B C D E 2 F G H I/J K 3 L M N O P 4 Q R S T U 5 V W X Y Z \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u660e\u6587 HELLO\uff0c\u52a0\u5bc6\u540e\u5c31\u662f 23 15 31 31 34\u3002 \u53e6\u4e00\u79cd\u5bc6\u7801\u8868 A D F G X A b t a l p D d h o z k F q f v s n G g j c u x X m r e w y \u6ce8\u610f\uff0c\u8fd9\u91cc\u5b57\u6bcd\u7684\u987a\u5e8f\u88ab\u6253\u4e71\u4e86\u3002 A D F G X \u7684\u7531\u6765\uff1a 1918 \u5e74\uff0c\u7b2c\u4e00\u6b21\u4e16\u754c\u5927\u6218\u5c06\u8981\u7ed3\u675f\u65f6\uff0c\u6cd5\u519b\u622a\u83b7\u4e86\u4e00\u4efd\u5fb7\u519b\u7535\u62a5\uff0c\u7535\u6587\u4e2d\u7684\u6240\u6709\u5355\u8bcd\u90fd\u7531 A\u3001D\u3001F\u3001G\u3001X \u4e94\u4e2a\u5b57\u6bcd\u62fc\u6210\uff0c\u56e0\u6b64\u88ab\u79f0\u4e3a ADFGX \u5bc6\u7801\u3002ADFGX \u5bc6\u7801\u662f 1918 \u5e74 3 \u6708\u7531\u5fb7\u519b\u4e0a\u6821 Fritz Nebel \u53d1\u660e\u7684\uff0c\u662f\u7ed3\u5408\u4e86 Polybius \u5bc6\u7801\u548c\u7f6e\u6362\u5bc6\u7801\u7684\u53cc\u91cd\u52a0\u5bc6\u65b9\u6848\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0cHELLO\uff0c\u4f7f\u7528\u8fd9\u4e2a\u8868\u683c\u52a0\u5bc6\uff0c\u5c31\u662f DD XF AG AG DF\u3002 \u5de5\u5177 \u00b6 CrypTool \u4f8b\u5b50 \u00b6 \u8fd9\u91cc\u4ee5\u5b89\u6052\u676f 9 \u6708 Crypto \u8d5b\u9898 Go \u4e3a\u4f8b\uff0c\u9898\u76ee\u4e3a\uff1a \u5bc6\u6587\uff1ailnllliiikkninlekile \u538b\u7f29\u5305\u7ed9\u4e86\u4e00\u884c\u5341\u516d\u8fdb\u5236\uff1a546865206c656e677468206f66207468697320706c61696e746578743a203130 \u8bf7\u5bf9\u5bc6\u6587\u89e3\u5bc6 \u9996\u5148\u5bf9\u5341\u516d\u8fdb\u5236\u8fdb\u884c hex \u89e3\u7801\uff0c\u5f97\u5230\u5b57\u7b26\u4e32\uff1a\"The length of this plaintext: 10\" \u5bc6\u6587\u957f\u5ea6\u4e3a 20 \uff0c\u800c\u660e\u6587\u957f\u5ea6\u4e3a 10 \uff0c\u5bc6\u6587\u53ea\u6709 \" l \",\" i \",\" n \",\" k \",\" e \" \u8fd9\u4e94\u4e2a\u5b57\u7b26\uff0c\u8054\u60f3\u5230\u68cb\u76d8\u5bc6\u7801\u3002 \u9996\u5148\u8bd5\u4e00\u4e0b\u4e94\u4e2a\u5b57\u7b26\u6309\u5b57\u6bcd\u8868\u987a\u5e8f\u6392\u5217\uff1a e i k l n e A B C D E i F G H I/J K k L M N O P l Q R S T U n V W X Y Z \u6839\u636e\u5bc6\u6587\u89e3\u5bc6\u5f97\uff1aiytghpkqmq\u3002 \u8fd9\u5e94\u8be5\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684 flag \u7b54\u6848\u3002 \u770b\u6765\u8fd9\u4e94\u4e2a\u5b57\u7b26\u6392\u5217\u4e0d\u662f\u8fd9\u4e48\u6392\u5217\u7684\uff0c\u4e00\u5171\u6709 5! \u79cd\u60c5\u51b5\uff0c\u5199\u811a\u672c\u7206\u7834\uff1a import itertools key = [] cipher = \"ilnllliiikkninlekile\" for i in itertools . permutations ( 'ilnke' , 5 ): key . append ( '' . join ( i )) for now_key in key : solve_c = \"\" res = \"\" for now_c in cipher : solve_c += str ( now_key . index ( now_c )) for i in range ( 0 , len ( solve_c ), 2 ): now_ascii = int ( solve_c [ i ]) * 5 + int ( solve_c [ i + 1 ]) + 97 if now_ascii > ord ( 'i' ): now_ascii += 1 res += chr ( now_ascii ) if \"flag\" in res : print now_key , res \u811a\u672c\u5176\u5b9e\u5c31\u662f\u5b9e\u73b0\u68cb\u76d8\u5bc6\u7801\u8fd9\u4e2a\u7b97\u6cd5\uff0c\u53ea\u662f\u8fd9\u4e94\u4e2a\u5b57\u7b26\u7684\u987a\u5e8f\u4e0d\u5b9a\u3002 \u8dd1\u51fa\u4e0b\u9762\u4e24\u4e2a\u7ed3\u679c\uff1a linke flagishere linek flagkxhdwd \u663e\u7136\u7b2c\u4e00\u4e2a\u662f\u6211\u4eec\u60f3\u8981\u7684\u7b54\u6848\u3002 \u9644\u4e0a\u6b63\u786e\u7684\u5bc6\u7801\u8868\uff1a l i n k e l A B C D E i F G H I/J K n L M N O P k Q R S T U e V W X Y Z Vigenere \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801 \u00b6 \u539f\u7406 \u00b6 \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\uff08Vigenere\uff09\u662f\u4f7f\u7528\u4e00\u7cfb\u5217\u51ef\u6492\u5bc6\u7801\u7ec4\u6210\u5bc6\u7801\u5b57\u6bcd\u8868\u7684\u52a0\u5bc6\u7b97\u6cd5\uff0c\u5c5e\u4e8e\u591a\u8868\u5bc6\u7801\u7684\u4e00\u79cd\u7b80\u5355\u5f62\u5f0f\u3002 \u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50 \u660e\u6587\uff1acome greatwall \u5bc6\u94a5\uff1acrypto \u9996\u5148\uff0c\u5bf9\u5bc6\u94a5\u8fdb\u884c\u586b\u5145\u4f7f\u5176\u957f\u5ea6\u4e0e\u660e\u6587\u957f\u5ea6\u4e00\u6837\u3002 \u660e\u6587 c o m e g r e a t w a l l \u5bc6\u94a5 c r y p t o c r y p t o c \u5176\u6b21\uff0c\u67e5\u8868\u5f97\u5bc6\u6587 \u660e\u6587\uff1acome greatwall \u5bc6\u94a5\uff1acrypto \u5bc6\u6587\uff1aefkt zferrltzn \u7834\u89e3 \u00b6 \u5bf9\u5305\u62ec\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u5728\u5185\u7684\u6240\u6709\u591a\u8868\u5bc6\u7801\u7684\u7834\u8bd1\u90fd\u662f\u4ee5\u5b57\u6bcd\u9891\u7387\u4e3a\u57fa\u7840\u7684\uff0c\u4f46\u76f4\u63a5\u7684\u9891\u7387\u5206\u6790\u5374\u5e76\u4e0d\u9002\u7528\uff0c\u8fd9\u662f\u56e0\u4e3a\u5728\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u4e2d\uff0c\u4e00\u4e2a\u5b57\u6bcd\u53ef\u4ee5\u88ab\u52a0\u5bc6\u6210\u4e0d\u540c\u7684\u5bc6\u6587\uff0c\u56e0\u800c\u7b80\u5355\u7684\u9891\u7387\u5206\u6790\u5728\u8fd9\u91cc\u5e76\u6ca1\u6709\u7528\u3002 \u7834\u8bd1\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u7684\u5173\u952e\u5728\u4e8e\u5b83\u7684\u5bc6\u94a5\u662f\u5faa\u73af\u91cd\u590d\u7684\u3002 \u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86\u5bc6\u94a5\u7684\u957f\u5ea6\uff0c\u90a3\u5bc6\u6587\u5c31\u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u4ea4\u7ec7\u5728\u4e00\u8d77\u7684\u51ef\u6492\u5bc6\u7801\uff0c\u800c\u5176\u4e2d\u6bcf\u4e00\u4e2a\u90fd\u53ef\u4ee5\u5355\u72ec\u7834\u89e3\u3002\u5173\u4e8e\u5bc6\u7801\u7684\u957f\u5ea6\uff0c\u6211\u4eec\u53ef\u4ee5 \u4f7f\u7528\u5361\u897f\u65af\u57fa\u8bd5\u9a8c\u548c\u5f17\u91cc\u5fb7\u66fc\u8bd5\u9a8c\u6765\u83b7\u53d6\u3002 \u5361\u897f\u65af\u57fa\u8bd5\u9a8c\u662f\u57fa\u4e8e\u7c7b\u4f3c the \u8fd9\u6837\u7684\u5e38\u7528\u5355\u8bcd\u6709\u53ef\u80fd\u88ab\u540c\u6837\u7684\u5bc6\u94a5\u5b57\u6bcd\u8fdb\u884c\u52a0\u5bc6\uff0c\u4ece\u800c\u5728\u5bc6\u6587\u4e2d\u91cd\u590d\u51fa\u73b0\u3002\u4f8b\u5982\uff0c\u660e\u6587\u4e2d\u4e0d\u540c\u7684 CRYPTO \u53ef\u80fd\u88ab\u5bc6\u94a5 ABCDEF \u52a0\u5bc6\u6210\u4e0d\u540c\u7684\u5bc6\u6587\uff1a \u5bc6\u94a5\uff1aABCDEF AB CDEFA BCD EFABCDEFABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6\u6587\uff1aCSASXT IT UKSWT GQU GWYQVRKWAQJB \u6b64\u65f6\u660e\u6587\u4e2d\u91cd\u590d\u7684\u5143\u7d20\u5728\u5bc6\u6587\u4e2d\u5e76\u4e0d\u91cd\u590d\u3002\u7136\u800c\uff0c\u5982\u679c\u5bc6\u94a5\u76f8\u540c\u7684\u8bdd\uff0c\u7ed3\u679c\u53ef\u80fd\u4fbf\u4e3a\uff08\u4f7f\u7528\u5bc6\u94a5 ABCD\uff09\uff1a \u5bc6\u94a5\uff1aABCDAB CD ABCDA BCD ABCDABCDABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6\u6587\uff1aCSASTP KV SIQUT GQU CSASTPIUAQJB \u6b64\u65f6\u5361\u897f\u65af\u57fa\u8bd5\u9a8c\u5c31\u80fd\u4ea7\u751f\u6548\u679c\u3002\u5bf9\u4e8e\u66f4\u957f\u7684\u6bb5\u843d\u6b64\u65b9\u6cd5\u66f4\u4e3a\u6709\u6548\uff0c\u56e0\u4e3a\u901a\u5e38\u5bc6\u6587\u4e2d\u91cd\u590d\u7684\u7247\u6bb5\u4f1a\u66f4\u591a\u3002\u5982\u901a\u8fc7\u4e0b\u9762\u7684\u5bc6\u6587\u5c31\u80fd\u7834\u8bd1\u51fa\u5bc6\u94a5\u7684\u957f\u5ea6\uff1a \u5bc6\u6587\uff1aDYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD \u5176\u4e2d\uff0c\u4e24\u4e2a DYDUXRMH \u7684\u51fa\u73b0\u76f8\u9694\u4e86 18 \u4e2a\u5b57\u6bcd\u3002\u56e0\u6b64\uff0c\u53ef\u4ee5\u5047\u5b9a\u5bc6\u94a5\u7684\u957f\u5ea6\u662f 18 \u7684\u7ea6\u6570\uff0c\u5373\u957f\u5ea6\u4e3a 18\u30019\u30016\u30013 \u6216 2\u3002\u800c\u4e24\u4e2a NQD \u5219\u76f8\u8ddd 20 \u4e2a\u5b57\u6bcd\uff0c\u610f\u5473\u7740\u5bc6\u94a5\u957f\u5ea6\u5e94\u4e3a 20\u300110\u30015\u30014 \u6216 2\u3002\u53d6\u4e24\u8005\u7684\u4ea4\u96c6\uff0c\u5219\u53ef\u4ee5\u57fa\u672c\u786e\u5b9a\u5bc6\u94a5\u957f\u5ea6\u4e3a 2\u3002\u63a5\u4e0b\u6765\u5c31\u662f\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u64cd\u4f5c\u4e86\u3002 \u5173\u4e8e\u66f4\u52a0\u8be6\u7ec6\u7684\u7834\u89e3\u539f\u7406\uff0c\u8fd9\u91cc\u6682\u65f6\u4e0d\u505a\u8fc7\u591a\u7684\u4ecb\u7ecd\u3002\u53ef\u4ee5\u53c2\u8003http:// www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/ \u3002 \u5de5\u5177 \u00b6 \u5df2\u77e5\u5bc6\u94a5 Python \u7684 pycipher \u5e93 \u5728\u7ebf\u89e3\u5bc6 Vigen\u00e8re cipher CAP4 \u672a\u77e5\u5bc6\u94a5 Vigen\u00e8re Cipher Codebreaker Vigenere Solver \uff0c\u4e0d\u591f\u5b8c\u5584\u3002 Nihilist \u00b6 \u539f\u7406 \u00b6 Nihilist\u5bc6\u7801\u53c8\u79f0\u5173\u952e\u5b57\u5bc6\u7801\uff1a\u660e\u6587 + \u5173\u952e\u5b57 = \u5bc6\u6587\u3002\u4ee5\u5173\u952e\u5b57 helloworld \u4e3a\u4f8b\u3002 \u9996\u5148\u5229\u7528\u5bc6\u94a5\u6784\u9020\u68cb\u76d8\u77e9\u9635\uff08\u7c7b\u4f3c Polybius \u5bc6\u7801\uff09 - \u65b0\u5efa\u4e00\u4e2a 5 \u00d7 5 \u77e9\u9635 - \u5c06\u5b57\u7b26\u4e0d\u91cd\u590d\u5730\u4f9d\u6b21\u586b\u5165\u77e9\u9635 - \u5269\u4e0b\u90e8\u5206\u6309\u5b57\u6bcd\u987a\u5e8f\u586b\u5165 - \u5b57\u6bcd i \u548c j \u7b49\u4ef7 1 2 3 4 5 1 h e l o w 2 r d a b c 3 f g i / j k m 4 n p q s t 5 u v x y z \u5bf9\u4e8e\u52a0\u5bc6\u8fc7\u7a0b\u53c2\u7167\u77e9\u9635 M \u8fdb\u884c\u52a0\u5bc6\uff1a a -> M[2,3] -> 23 t -> M[4,5] -> 45 \u5bf9\u4e8e\u89e3\u5bc6\u8fc7\u7a0b \u53c2\u7167\u77e9\u9635 M \u8fdb\u884c\u89e3\u5bc6\uff1a 23 -> M[2,3] -> a 45 -> M[4,5] -> t \u53ef\u4ee5\u770b\u51fa\uff0c\u5bc6\u6587\u7684\u7279\u5f81\u6709\u5982\u4e0b\u51e0\u70b9 \u7eaf\u6570\u5b57 \u53ea\u5305\u542b 1 \u5230 5 \u5bc6\u6587\u957f\u5ea6\u5076\u6570\u3002 Hill \u00b6 \u539f\u7406 \u00b6 \u5e0c\u5c14\u5bc6\u7801\uff08Hill\uff09\u4f7f\u7528\u6bcf\u4e2a\u5b57\u6bcd\u5728\u5b57\u6bcd\u8868\u4e2d\u7684\u987a\u5e8f\u4f5c\u4e3a\u5176\u5bf9\u5e94\u7684\u6570\u5b57\uff0c\u5373A=0\uff0cB=1\uff0cC=2 \u7b49\uff0c\u7136\u540e\u5c06\u660e\u6587\u8f6c\u5316\u4e3a n \u7ef4\u5411\u91cf\uff0c\u8ddf\u4e00\u4e2a n \u00d7 n \u7684\u77e9\u9635\u76f8\u4e58\uff0c\u518d\u5c06\u5f97\u51fa\u7684\u7ed3\u679c\u6a21 26\u3002\u6ce8\u610f\u7528\u4f5c\u52a0\u5bc6\u7684\u77e9\u9635\uff08\u5373\u5bc6\u5319\uff09\u5728 \\mathbb{Z}_{26}^{n} \\mathbb{Z}_{26}^{n} \u5fc5\u987b\u662f\u53ef\u9006\u7684\uff0c\u5426\u5219\u5c31\u4e0d\u53ef\u80fd\u89e3\u7801\u3002\u53ea\u6709\u77e9\u9635\u7684\u884c\u5217\u5f0f\u548c 26 \u4e92\u8d28\uff0c\u624d\u662f\u53ef\u9006\u7684\u3002\u4e0b\u9762\u4e3e\u4e00\u4e2a\u4f8b\u5b50 \u660e\u6587\uff1aACT \u5c06\u660e\u6587\u5316\u4e3a\u77e9\u9635\u3002 \\begin{bmatrix} 0\\\\ 2\\\\ 19 \\end{bmatrix} \\begin{bmatrix} 0\\\\ 2\\\\ 19 \\end{bmatrix} \u5047\u8bbe\u5bc6\u94a5\u4e3a\uff1a \\begin{bmatrix} 6 & 24 & 1\\\\ 13 & 16 & 10\\\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 6 & 24 & 1\\\\ 13 & 16 & 10\\\\ 20 & 17 & 15 \\end{bmatrix} \u52a0\u5bc6\u8fc7\u7a0b\u4e3a\uff1a \\begin{bmatrix} 6 & 24 & 1\\\\ 13 & 16 & 10\\\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 0\\\\ 2\\\\ 19 \\end{bmatrix} \\equiv \\begin{bmatrix} 67\\\\ 222\\\\ 319 \\end{bmatrix} \\equiv \\begin{bmatrix} 15\\\\ 14\\\\ 7 \\end{bmatrix} \\bmod 26 \\begin{bmatrix} 6 & 24 & 1\\\\ 13 & 16 & 10\\\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 0\\\\ 2\\\\ 19 \\end{bmatrix} \\equiv \\begin{bmatrix} 67\\\\ 222\\\\ 319 \\end{bmatrix} \\equiv \\begin{bmatrix} 15\\\\ 14\\\\ 7 \\end{bmatrix} \\bmod 26 \u5bc6\u6587\u5373\u4e3a \u5bc6\u6587\uff1aPOH \u5de5\u5177 \u00b6 http://www.practicalcryptography.com/ciphers/hill-cipher/ CAP4 Cryptool \u4f8b\u5b50 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5ISCC 2015 base decrypt 150\u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9898\u76ee\u4e3a \u5bc6\u6587\uff1a 22,09,00,12,03,01,10,03,04,08,01,17 \uff08wjamdbkdeibr\uff09 \u4f7f\u7528\u7684\u77e9\u9635\u662f 1 2 3 4 5 6 7 8 10 \u8bf7\u5bf9\u5bc6\u6587\u89e3\u5bc6. \u9996\u5148\uff0c\u77e9\u9635\u662f 3 \u00d7 3 \u7684\u3002\u8bf4\u660e\u6bcf\u6b21\u52a0\u5bc63\u4e2a\u5b57\u7b26\u3002\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 Cryptool\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u4e2a\u77e9\u9635\u662f\u6309\u7167\u5217\u6765\u6392\u5e03\u7684\u3002\u5373\u5982\u4e0b 1 4 7 2 5 8 3 6 10 \u6700\u540e\u7684\u7ed3\u679c\u4e3a overthehillx \u3002 AutokeyCipher \u00b6 \u539f\u7406 \u00b6 \u81ea\u52a8\u5bc6\u94a5\u5bc6\u7801\uff08Autokey Cipher\uff09\u4e5f\u662f\u591a\u8868\u66ff\u6362\u5bc6\u7801\uff0c\u4e0e\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u5bc6\u7801\u7c7b\u4f3c\uff0c\u4f46\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u6cd5\u751f\u6210\u5bc6\u94a5\u3002\u901a\u5e38\u6765\u8bf4\u5b83\u8981\u6bd4\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u66f4\u5b89\u5168\u3002\u81ea\u52a8\u5bc6\u94a5\u5bc6\u7801\u4e3b\u8981\u6709\u4e24\u79cd\uff0c\u5173\u952e\u8bcd\u81ea\u52a8\u5bc6\u94a5\u5bc6\u7801\u548c\u539f\u6587\u81ea\u52a8\u5bc6\u94a5\u5bc6\u7801\u3002\u4e0b\u9762\u6211\u4eec\u4ee5\u5173\u952e\u8bcd\u81ea\u52a8\u5bc6\u94a5\u4e3a\u4f8b\uff1a \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG \u5173\u952e\u8bcd\uff1aCULTURE \u81ea\u52a8\u751f\u6210\u5bc6\u94a5\uff1a CULTURE THE QUICK BROWN FOX JUMPS OVER THE \u63a5\u4e0b\u6765\u7684\u52a0\u5bc6\u8fc7\u7a0b\u548c\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u7c7b\u4f3c\uff0c\u4ece\u76f8\u5e94\u7684\u8868\u683c\u53ef\u5f97\uff1a \u5bc6\u6587 VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK \u5de5\u5177 \u00b6 \u5df2\u77e5\u5173\u952e\u8bcd Python \u7684 pycipher \u5e93 \u672a\u77e5\u5173\u952e\u8bcd http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ tools \u6587\u4ef6\u5939\u4e0b break_autokey.py\uff0c\u5f85\u5b8c\u6210\u3002","title":"Polyalphabetic zh"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#playfair","text":"","title":"Playfair"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_1","text":"Playfair \u5bc6\u7801\uff08Playfair cipher or Playfair square\uff09\u662f\u4e00\u79cd\u66ff\u6362\u5bc6\u7801\uff0c1854 \u5e74\u7531\u82f1\u56fd\u4eba\u67e5\u5c14\u65af\u00b7\u60e0\u65af\u901a\uff08Charles Wheatstone\uff09\u53d1\u660e\uff0c\u57fa\u672c\u7b97\u6cd5\u5982\u4e0b\uff1a \u9009\u53d6\u4e00\u4e32\u82f1\u6587\u5b57\u6bcd\uff0c\u9664\u53bb\u91cd\u590d\u51fa\u73b0\u7684\u5b57\u6bcd\uff0c\u5c06\u5269\u4e0b\u7684\u5b57\u6bcd\u9010\u4e2a\u9010\u4e2a\u52a0\u5165 5 \u00d7 5 \u7684\u77e9\u9635\u5185\uff0c\u5269\u4e0b\u7684\u7a7a\u95f4\u7531\u672a\u52a0\u5165\u7684\u82f1\u6587\u5b57\u6bcd\u4f9d a-z \u7684\u987a\u5e8f\u52a0\u5165\u3002\u6ce8\u610f\uff0c\u5c06 q \u53bb\u9664\uff0c\u6216\u5c06 i \u548c j \u89c6\u4f5c\u540c\u4e00\u5b57\u3002 \u5c06\u8981\u52a0\u5bc6\u7684\u660e\u6587\u5206\u6210\u4e24\u4e2a\u4e00\u7ec4\u3002\u82e5\u7ec4\u5185\u7684\u5b57\u6bcd\u76f8\u540c\uff0c\u5c06 X\uff08\u6216 Q\uff09\u52a0\u5230\u8be5\u7ec4\u7684\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u540e\uff0c\u91cd\u65b0\u5206\u7ec4\u3002\u82e5\u5269\u4e0b\u4e00\u4e2a\u5b57\uff0c\u4e5f\u52a0\u5165 X \u3002 \u5728\u6bcf\u7ec4\u4e2d\uff0c\u627e\u51fa\u4e24\u4e2a\u5b57\u6bcd\u5728\u77e9\u9635\u4e2d\u7684\u5730\u65b9\u3002 \u82e5\u4e24\u4e2a\u5b57\u6bcd\u4e0d\u540c\u884c\u4e5f\u4e0d\u540c\u5217\uff0c\u5728\u77e9\u9635\u4e2d\u627e\u51fa\u53e6\u5916\u4e24\u4e2a\u5b57\u6bcd\uff08\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u5bf9\u5e94\u884c\u4f18\u5148\uff09\uff0c\u4f7f\u8fd9\u56db\u4e2a\u5b57\u6bcd\u6210\u4e3a\u4e00\u4e2a\u957f\u65b9\u5f62\u7684\u56db\u4e2a\u89d2\u3002 \u82e5\u4e24\u4e2a\u5b57\u6bcd\u540c\u884c\uff0c\u53d6\u8fd9\u4e24\u4e2a\u5b57\u6bcd\u53f3\u65b9\u7684\u5b57\u6bcd\uff08\u82e5\u5b57\u6bcd\u5728\u6700\u53f3\u65b9\u5219\u53d6\u6700\u5de6\u65b9\u7684\u5b57\u6bcd\uff09\u3002 \u82e5\u4e24\u4e2a\u5b57\u6bcd\u540c\u5217\uff0c\u53d6\u8fd9\u4e24\u4e2a\u5b57\u6bcd\u4e0b\u65b9\u7684\u5b57\u6bcd\uff08\u82e5\u5b57\u6bcd\u5728\u6700\u4e0b\u65b9\u5219\u53d6\u6700\u4e0a\u65b9\u7684\u5b57\u6bcd\uff09\u3002 \u65b0\u627e\u5230\u7684\u4e24\u4e2a\u5b57\u6bcd\u5c31\u662f\u539f\u672c\u7684\u4e24\u4e2a\u5b57\u6bcd\u52a0\u5bc6\u7684\u7ed3\u679c\u3002 \u4ee5 playfair example \u4e3a\u5bc6\u5319\uff0c\u5f97 P L A Y F I R E X M B C D G H K N O Q S T U V W Z \u8981\u52a0\u5bc6\u7684\u8baf\u606f\u4e3a Hide the gold in the tree stump HI DE TH EG OL DI NT HE TR EX ES TU MP \u5c31\u4f1a\u5f97\u5230 BM OD ZB XD NA BE KU DM UI XM MO UV IF","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_2","text":"CAP4","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#polybius","text":"","title":"Polybius"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_3","text":"Polybius\u5bc6\u7801\u53c8\u79f0\u4e3a\u68cb\u76d8\u5bc6\u7801\uff0c\u5176\u4e00\u822c\u662f\u5c06\u7ed9\u5b9a\u7684\u660e\u6587\u52a0\u5bc6\u4e3a\u4e24\u4e24\u7ec4\u5408\u7684\u6570\u5b57\uff0c\u5176\u5e38\u7528\u5bc6\u7801\u8868 1 2 3 4 5 1 A B C D E 2 F G H I/J K 3 L M N O P 4 Q R S T U 5 V W X Y Z \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u660e\u6587 HELLO\uff0c\u52a0\u5bc6\u540e\u5c31\u662f 23 15 31 31 34\u3002 \u53e6\u4e00\u79cd\u5bc6\u7801\u8868 A D F G X A b t a l p D d h o z k F q f v s n G g j c u x X m r e w y \u6ce8\u610f\uff0c\u8fd9\u91cc\u5b57\u6bcd\u7684\u987a\u5e8f\u88ab\u6253\u4e71\u4e86\u3002 A D F G X \u7684\u7531\u6765\uff1a 1918 \u5e74\uff0c\u7b2c\u4e00\u6b21\u4e16\u754c\u5927\u6218\u5c06\u8981\u7ed3\u675f\u65f6\uff0c\u6cd5\u519b\u622a\u83b7\u4e86\u4e00\u4efd\u5fb7\u519b\u7535\u62a5\uff0c\u7535\u6587\u4e2d\u7684\u6240\u6709\u5355\u8bcd\u90fd\u7531 A\u3001D\u3001F\u3001G\u3001X \u4e94\u4e2a\u5b57\u6bcd\u62fc\u6210\uff0c\u56e0\u6b64\u88ab\u79f0\u4e3a ADFGX \u5bc6\u7801\u3002ADFGX \u5bc6\u7801\u662f 1918 \u5e74 3 \u6708\u7531\u5fb7\u519b\u4e0a\u6821 Fritz Nebel \u53d1\u660e\u7684\uff0c\u662f\u7ed3\u5408\u4e86 Polybius \u5bc6\u7801\u548c\u7f6e\u6362\u5bc6\u7801\u7684\u53cc\u91cd\u52a0\u5bc6\u65b9\u6848\u3002 \u4e3e\u4e2a\u4f8b\u5b50\uff0cHELLO\uff0c\u4f7f\u7528\u8fd9\u4e2a\u8868\u683c\u52a0\u5bc6\uff0c\u5c31\u662f DD XF AG AG DF\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_4","text":"CrypTool","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_5","text":"\u8fd9\u91cc\u4ee5\u5b89\u6052\u676f 9 \u6708 Crypto \u8d5b\u9898 Go \u4e3a\u4f8b\uff0c\u9898\u76ee\u4e3a\uff1a \u5bc6\u6587\uff1ailnllliiikkninlekile \u538b\u7f29\u5305\u7ed9\u4e86\u4e00\u884c\u5341\u516d\u8fdb\u5236\uff1a546865206c656e677468206f66207468697320706c61696e746578743a203130 \u8bf7\u5bf9\u5bc6\u6587\u89e3\u5bc6 \u9996\u5148\u5bf9\u5341\u516d\u8fdb\u5236\u8fdb\u884c hex \u89e3\u7801\uff0c\u5f97\u5230\u5b57\u7b26\u4e32\uff1a\"The length of this plaintext: 10\" \u5bc6\u6587\u957f\u5ea6\u4e3a 20 \uff0c\u800c\u660e\u6587\u957f\u5ea6\u4e3a 10 \uff0c\u5bc6\u6587\u53ea\u6709 \" l \",\" i \",\" n \",\" k \",\" e \" \u8fd9\u4e94\u4e2a\u5b57\u7b26\uff0c\u8054\u60f3\u5230\u68cb\u76d8\u5bc6\u7801\u3002 \u9996\u5148\u8bd5\u4e00\u4e0b\u4e94\u4e2a\u5b57\u7b26\u6309\u5b57\u6bcd\u8868\u987a\u5e8f\u6392\u5217\uff1a e i k l n e A B C D E i F G H I/J K k L M N O P l Q R S T U n V W X Y Z \u6839\u636e\u5bc6\u6587\u89e3\u5bc6\u5f97\uff1aiytghpkqmq\u3002 \u8fd9\u5e94\u8be5\u4e0d\u662f\u6211\u4eec\u60f3\u8981\u7684 flag \u7b54\u6848\u3002 \u770b\u6765\u8fd9\u4e94\u4e2a\u5b57\u7b26\u6392\u5217\u4e0d\u662f\u8fd9\u4e48\u6392\u5217\u7684\uff0c\u4e00\u5171\u6709 5! \u79cd\u60c5\u51b5\uff0c\u5199\u811a\u672c\u7206\u7834\uff1a import itertools key = [] cipher = \"ilnllliiikkninlekile\" for i in itertools . permutations ( 'ilnke' , 5 ): key . append ( '' . join ( i )) for now_key in key : solve_c = \"\" res = \"\" for now_c in cipher : solve_c += str ( now_key . index ( now_c )) for i in range ( 0 , len ( solve_c ), 2 ): now_ascii = int ( solve_c [ i ]) * 5 + int ( solve_c [ i + 1 ]) + 97 if now_ascii > ord ( 'i' ): now_ascii += 1 res += chr ( now_ascii ) if \"flag\" in res : print now_key , res \u811a\u672c\u5176\u5b9e\u5c31\u662f\u5b9e\u73b0\u68cb\u76d8\u5bc6\u7801\u8fd9\u4e2a\u7b97\u6cd5\uff0c\u53ea\u662f\u8fd9\u4e94\u4e2a\u5b57\u7b26\u7684\u987a\u5e8f\u4e0d\u5b9a\u3002 \u8dd1\u51fa\u4e0b\u9762\u4e24\u4e2a\u7ed3\u679c\uff1a linke flagishere linek flagkxhdwd \u663e\u7136\u7b2c\u4e00\u4e2a\u662f\u6211\u4eec\u60f3\u8981\u7684\u7b54\u6848\u3002 \u9644\u4e0a\u6b63\u786e\u7684\u5bc6\u7801\u8868\uff1a l i n k e l A B C D E i F G H I/J K n L M N O P k Q R S T U e V W X Y Z","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#vigenere","text":"","title":"Vigenere \u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_6","text":"\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\uff08Vigenere\uff09\u662f\u4f7f\u7528\u4e00\u7cfb\u5217\u51ef\u6492\u5bc6\u7801\u7ec4\u6210\u5bc6\u7801\u5b57\u6bcd\u8868\u7684\u52a0\u5bc6\u7b97\u6cd5\uff0c\u5c5e\u4e8e\u591a\u8868\u5bc6\u7801\u7684\u4e00\u79cd\u7b80\u5355\u5f62\u5f0f\u3002 \u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a\u4f8b\u5b50 \u660e\u6587\uff1acome greatwall \u5bc6\u94a5\uff1acrypto \u9996\u5148\uff0c\u5bf9\u5bc6\u94a5\u8fdb\u884c\u586b\u5145\u4f7f\u5176\u957f\u5ea6\u4e0e\u660e\u6587\u957f\u5ea6\u4e00\u6837\u3002 \u660e\u6587 c o m e g r e a t w a l l \u5bc6\u94a5 c r y p t o c r y p t o c \u5176\u6b21\uff0c\u67e5\u8868\u5f97\u5bc6\u6587 \u660e\u6587\uff1acome greatwall \u5bc6\u94a5\uff1acrypto \u5bc6\u6587\uff1aefkt zferrltzn","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_7","text":"\u5bf9\u5305\u62ec\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u5728\u5185\u7684\u6240\u6709\u591a\u8868\u5bc6\u7801\u7684\u7834\u8bd1\u90fd\u662f\u4ee5\u5b57\u6bcd\u9891\u7387\u4e3a\u57fa\u7840\u7684\uff0c\u4f46\u76f4\u63a5\u7684\u9891\u7387\u5206\u6790\u5374\u5e76\u4e0d\u9002\u7528\uff0c\u8fd9\u662f\u56e0\u4e3a\u5728\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u4e2d\uff0c\u4e00\u4e2a\u5b57\u6bcd\u53ef\u4ee5\u88ab\u52a0\u5bc6\u6210\u4e0d\u540c\u7684\u5bc6\u6587\uff0c\u56e0\u800c\u7b80\u5355\u7684\u9891\u7387\u5206\u6790\u5728\u8fd9\u91cc\u5e76\u6ca1\u6709\u7528\u3002 \u7834\u8bd1\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u7684\u5173\u952e\u5728\u4e8e\u5b83\u7684\u5bc6\u94a5\u662f\u5faa\u73af\u91cd\u590d\u7684\u3002 \u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86\u5bc6\u94a5\u7684\u957f\u5ea6\uff0c\u90a3\u5bc6\u6587\u5c31\u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u4ea4\u7ec7\u5728\u4e00\u8d77\u7684\u51ef\u6492\u5bc6\u7801\uff0c\u800c\u5176\u4e2d\u6bcf\u4e00\u4e2a\u90fd\u53ef\u4ee5\u5355\u72ec\u7834\u89e3\u3002\u5173\u4e8e\u5bc6\u7801\u7684\u957f\u5ea6\uff0c\u6211\u4eec\u53ef\u4ee5 \u4f7f\u7528\u5361\u897f\u65af\u57fa\u8bd5\u9a8c\u548c\u5f17\u91cc\u5fb7\u66fc\u8bd5\u9a8c\u6765\u83b7\u53d6\u3002 \u5361\u897f\u65af\u57fa\u8bd5\u9a8c\u662f\u57fa\u4e8e\u7c7b\u4f3c the \u8fd9\u6837\u7684\u5e38\u7528\u5355\u8bcd\u6709\u53ef\u80fd\u88ab\u540c\u6837\u7684\u5bc6\u94a5\u5b57\u6bcd\u8fdb\u884c\u52a0\u5bc6\uff0c\u4ece\u800c\u5728\u5bc6\u6587\u4e2d\u91cd\u590d\u51fa\u73b0\u3002\u4f8b\u5982\uff0c\u660e\u6587\u4e2d\u4e0d\u540c\u7684 CRYPTO \u53ef\u80fd\u88ab\u5bc6\u94a5 ABCDEF \u52a0\u5bc6\u6210\u4e0d\u540c\u7684\u5bc6\u6587\uff1a \u5bc6\u94a5\uff1aABCDEF AB CDEFA BCD EFABCDEFABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6\u6587\uff1aCSASXT IT UKSWT GQU GWYQVRKWAQJB \u6b64\u65f6\u660e\u6587\u4e2d\u91cd\u590d\u7684\u5143\u7d20\u5728\u5bc6\u6587\u4e2d\u5e76\u4e0d\u91cd\u590d\u3002\u7136\u800c\uff0c\u5982\u679c\u5bc6\u94a5\u76f8\u540c\u7684\u8bdd\uff0c\u7ed3\u679c\u53ef\u80fd\u4fbf\u4e3a\uff08\u4f7f\u7528\u5bc6\u94a5 ABCD\uff09\uff1a \u5bc6\u94a5\uff1aABCDAB CD ABCDA BCD ABCDABCDABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6\u6587\uff1aCSASTP KV SIQUT GQU CSASTPIUAQJB \u6b64\u65f6\u5361\u897f\u65af\u57fa\u8bd5\u9a8c\u5c31\u80fd\u4ea7\u751f\u6548\u679c\u3002\u5bf9\u4e8e\u66f4\u957f\u7684\u6bb5\u843d\u6b64\u65b9\u6cd5\u66f4\u4e3a\u6709\u6548\uff0c\u56e0\u4e3a\u901a\u5e38\u5bc6\u6587\u4e2d\u91cd\u590d\u7684\u7247\u6bb5\u4f1a\u66f4\u591a\u3002\u5982\u901a\u8fc7\u4e0b\u9762\u7684\u5bc6\u6587\u5c31\u80fd\u7834\u8bd1\u51fa\u5bc6\u94a5\u7684\u957f\u5ea6\uff1a \u5bc6\u6587\uff1aDYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD \u5176\u4e2d\uff0c\u4e24\u4e2a DYDUXRMH \u7684\u51fa\u73b0\u76f8\u9694\u4e86 18 \u4e2a\u5b57\u6bcd\u3002\u56e0\u6b64\uff0c\u53ef\u4ee5\u5047\u5b9a\u5bc6\u94a5\u7684\u957f\u5ea6\u662f 18 \u7684\u7ea6\u6570\uff0c\u5373\u957f\u5ea6\u4e3a 18\u30019\u30016\u30013 \u6216 2\u3002\u800c\u4e24\u4e2a NQD \u5219\u76f8\u8ddd 20 \u4e2a\u5b57\u6bcd\uff0c\u610f\u5473\u7740\u5bc6\u94a5\u957f\u5ea6\u5e94\u4e3a 20\u300110\u30015\u30014 \u6216 2\u3002\u53d6\u4e24\u8005\u7684\u4ea4\u96c6\uff0c\u5219\u53ef\u4ee5\u57fa\u672c\u786e\u5b9a\u5bc6\u94a5\u957f\u5ea6\u4e3a 2\u3002\u63a5\u4e0b\u6765\u5c31\u662f\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u64cd\u4f5c\u4e86\u3002 \u5173\u4e8e\u66f4\u52a0\u8be6\u7ec6\u7684\u7834\u89e3\u539f\u7406\uff0c\u8fd9\u91cc\u6682\u65f6\u4e0d\u505a\u8fc7\u591a\u7684\u4ecb\u7ecd\u3002\u53ef\u4ee5\u53c2\u8003http:// www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/ \u3002","title":"\u7834\u89e3"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_8","text":"\u5df2\u77e5\u5bc6\u94a5 Python \u7684 pycipher \u5e93 \u5728\u7ebf\u89e3\u5bc6 Vigen\u00e8re cipher CAP4 \u672a\u77e5\u5bc6\u94a5 Vigen\u00e8re Cipher Codebreaker Vigenere Solver \uff0c\u4e0d\u591f\u5b8c\u5584\u3002","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#nihilist","text":"","title":"Nihilist"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_9","text":"Nihilist\u5bc6\u7801\u53c8\u79f0\u5173\u952e\u5b57\u5bc6\u7801\uff1a\u660e\u6587 + \u5173\u952e\u5b57 = \u5bc6\u6587\u3002\u4ee5\u5173\u952e\u5b57 helloworld \u4e3a\u4f8b\u3002 \u9996\u5148\u5229\u7528\u5bc6\u94a5\u6784\u9020\u68cb\u76d8\u77e9\u9635\uff08\u7c7b\u4f3c Polybius \u5bc6\u7801\uff09 - \u65b0\u5efa\u4e00\u4e2a 5 \u00d7 5 \u77e9\u9635 - \u5c06\u5b57\u7b26\u4e0d\u91cd\u590d\u5730\u4f9d\u6b21\u586b\u5165\u77e9\u9635 - \u5269\u4e0b\u90e8\u5206\u6309\u5b57\u6bcd\u987a\u5e8f\u586b\u5165 - \u5b57\u6bcd i \u548c j \u7b49\u4ef7 1 2 3 4 5 1 h e l o w 2 r d a b c 3 f g i / j k m 4 n p q s t 5 u v x y z \u5bf9\u4e8e\u52a0\u5bc6\u8fc7\u7a0b\u53c2\u7167\u77e9\u9635 M \u8fdb\u884c\u52a0\u5bc6\uff1a a -> M[2,3] -> 23 t -> M[4,5] -> 45 \u5bf9\u4e8e\u89e3\u5bc6\u8fc7\u7a0b \u53c2\u7167\u77e9\u9635 M \u8fdb\u884c\u89e3\u5bc6\uff1a 23 -> M[2,3] -> a 45 -> M[4,5] -> t \u53ef\u4ee5\u770b\u51fa\uff0c\u5bc6\u6587\u7684\u7279\u5f81\u6709\u5982\u4e0b\u51e0\u70b9 \u7eaf\u6570\u5b57 \u53ea\u5305\u542b 1 \u5230 5 \u5bc6\u6587\u957f\u5ea6\u5076\u6570\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#hill","text":"","title":"Hill"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_10","text":"\u5e0c\u5c14\u5bc6\u7801\uff08Hill\uff09\u4f7f\u7528\u6bcf\u4e2a\u5b57\u6bcd\u5728\u5b57\u6bcd\u8868\u4e2d\u7684\u987a\u5e8f\u4f5c\u4e3a\u5176\u5bf9\u5e94\u7684\u6570\u5b57\uff0c\u5373A=0\uff0cB=1\uff0cC=2 \u7b49\uff0c\u7136\u540e\u5c06\u660e\u6587\u8f6c\u5316\u4e3a n \u7ef4\u5411\u91cf\uff0c\u8ddf\u4e00\u4e2a n \u00d7 n \u7684\u77e9\u9635\u76f8\u4e58\uff0c\u518d\u5c06\u5f97\u51fa\u7684\u7ed3\u679c\u6a21 26\u3002\u6ce8\u610f\u7528\u4f5c\u52a0\u5bc6\u7684\u77e9\u9635\uff08\u5373\u5bc6\u5319\uff09\u5728 \\mathbb{Z}_{26}^{n} \\mathbb{Z}_{26}^{n} \u5fc5\u987b\u662f\u53ef\u9006\u7684\uff0c\u5426\u5219\u5c31\u4e0d\u53ef\u80fd\u89e3\u7801\u3002\u53ea\u6709\u77e9\u9635\u7684\u884c\u5217\u5f0f\u548c 26 \u4e92\u8d28\uff0c\u624d\u662f\u53ef\u9006\u7684\u3002\u4e0b\u9762\u4e3e\u4e00\u4e2a\u4f8b\u5b50 \u660e\u6587\uff1aACT \u5c06\u660e\u6587\u5316\u4e3a\u77e9\u9635\u3002 \\begin{bmatrix} 0\\\\ 2\\\\ 19 \\end{bmatrix} \\begin{bmatrix} 0\\\\ 2\\\\ 19 \\end{bmatrix} \u5047\u8bbe\u5bc6\u94a5\u4e3a\uff1a \\begin{bmatrix} 6 & 24 & 1\\\\ 13 & 16 & 10\\\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 6 & 24 & 1\\\\ 13 & 16 & 10\\\\ 20 & 17 & 15 \\end{bmatrix} \u52a0\u5bc6\u8fc7\u7a0b\u4e3a\uff1a \\begin{bmatrix} 6 & 24 & 1\\\\ 13 & 16 & 10\\\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 0\\\\ 2\\\\ 19 \\end{bmatrix} \\equiv \\begin{bmatrix} 67\\\\ 222\\\\ 319 \\end{bmatrix} \\equiv \\begin{bmatrix} 15\\\\ 14\\\\ 7 \\end{bmatrix} \\bmod 26 \\begin{bmatrix} 6 & 24 & 1\\\\ 13 & 16 & 10\\\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 0\\\\ 2\\\\ 19 \\end{bmatrix} \\equiv \\begin{bmatrix} 67\\\\ 222\\\\ 319 \\end{bmatrix} \\equiv \\begin{bmatrix} 15\\\\ 14\\\\ 7 \\end{bmatrix} \\bmod 26 \u5bc6\u6587\u5373\u4e3a \u5bc6\u6587\uff1aPOH","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_11","text":"http://www.practicalcryptography.com/ciphers/hill-cipher/ CAP4 Cryptool","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_12","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5ISCC 2015 base decrypt 150\u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\uff0c\u9898\u76ee\u4e3a \u5bc6\u6587\uff1a 22,09,00,12,03,01,10,03,04,08,01,17 \uff08wjamdbkdeibr\uff09 \u4f7f\u7528\u7684\u77e9\u9635\u662f 1 2 3 4 5 6 7 8 10 \u8bf7\u5bf9\u5bc6\u6587\u89e3\u5bc6. \u9996\u5148\uff0c\u77e9\u9635\u662f 3 \u00d7 3 \u7684\u3002\u8bf4\u660e\u6bcf\u6b21\u52a0\u5bc63\u4e2a\u5b57\u7b26\u3002\u6211\u4eec\u76f4\u63a5\u4f7f\u7528 Cryptool\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u4e2a\u77e9\u9635\u662f\u6309\u7167\u5217\u6765\u6392\u5e03\u7684\u3002\u5373\u5982\u4e0b 1 4 7 2 5 8 3 6 10 \u6700\u540e\u7684\u7ed3\u679c\u4e3a overthehillx \u3002","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#autokeycipher","text":"","title":"AutokeyCipher"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_13","text":"\u81ea\u52a8\u5bc6\u94a5\u5bc6\u7801\uff08Autokey Cipher\uff09\u4e5f\u662f\u591a\u8868\u66ff\u6362\u5bc6\u7801\uff0c\u4e0e\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u5bc6\u7801\u7c7b\u4f3c\uff0c\u4f46\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u6cd5\u751f\u6210\u5bc6\u94a5\u3002\u901a\u5e38\u6765\u8bf4\u5b83\u8981\u6bd4\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u66f4\u5b89\u5168\u3002\u81ea\u52a8\u5bc6\u94a5\u5bc6\u7801\u4e3b\u8981\u6709\u4e24\u79cd\uff0c\u5173\u952e\u8bcd\u81ea\u52a8\u5bc6\u94a5\u5bc6\u7801\u548c\u539f\u6587\u81ea\u52a8\u5bc6\u94a5\u5bc6\u7801\u3002\u4e0b\u9762\u6211\u4eec\u4ee5\u5173\u952e\u8bcd\u81ea\u52a8\u5bc6\u94a5\u4e3a\u4f8b\uff1a \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG \u5173\u952e\u8bcd\uff1aCULTURE \u81ea\u52a8\u751f\u6210\u5bc6\u94a5\uff1a CULTURE THE QUICK BROWN FOX JUMPS OVER THE \u63a5\u4e0b\u6765\u7684\u52a0\u5bc6\u8fc7\u7a0b\u548c\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u7c7b\u4f3c\uff0c\u4ece\u76f8\u5e94\u7684\u8868\u683c\u53ef\u5f97\uff1a \u5bc6\u6587 VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/classical/polyalphabetic-zh/#_14","text":"\u5df2\u77e5\u5173\u952e\u8bcd Python \u7684 pycipher \u5e93 \u672a\u77e5\u5173\u952e\u8bcd http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ tools \u6587\u4ef6\u5939\u4e0b break_autokey.py\uff0c\u5f85\u5b8c\u6210\u3002","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/","text":"EN | ZH For multi-table replacement encryption, the encrypted letters almost no longer maintain the original frequency, so we can only use the algorithm to achieve the corresponding weakness to crack. Playfair \u00b6 Principle \u00b6 The Playfair cipher or Playfair square is a replacement password, invented by the British Charles Wheatstone in 1854. The basic algorithm is as follows: Select a string of English letters, remove the repeated letters, and add the remaining letters one by one to the 5 \u00d7 5 matrix. The remaining space is added by the unjoined English letters in the order of az. Note that q is removed, or i and j are treated as the same word. Divide the plaintext to be encrypted into two groups. If the letters in the group are the same, add X (or Q) to the first letter of the group and regroup. If there is one word left, also add X. In each group, find out where the two letters are in the matrix. If the two letters have different rows and different columns, find the other two letters in the matrix (the first letter corresponds to the row first), so that the four letters become the four corners of a rectangle. If the two letters are accompanied, take the letters to the right of the two letters (if the letter is at the far right, take the leftmost letter). If the two letters are in the same column, take the letters below the two letters (if the letter is at the bottom, take the top letter). The two newly found letters are the result of the original two-letter encryption. Use playfair example as the key, get P L A Y F iREX B C D G H K N O Q S T U V W Z The message to be encrypted is Hide the gold in the tree stump THAT IS TH EG OL DI NT HE TR EX IS YOUR MP Will get BM OD ZB XD WILL BE DM UI XM FOR UV IF Tools \u00b6 CAP4 , Polybius \u00b6 Principle \u00b6 Polybius passwords are also known as board passwords, which are generally used to encrypt a given plaintext into a pair of numbers. | | 1 | 2 | 3 | 4 | 5 | | :--- | --- | --- | --- | --- | :--- | | 1 | A | B | C | D | E | | 2 | F | G | H | I/J | K | | 3 | L | M | N | O | P | | 4 | Q | R | S | T | U | | 5 V W | X Y | Z | For example, plain text HELLO, encrypted is 23 15 31 31 34. Another password table | | A | D | F | G | X | | --- | --- | --- | --- | --- | --- | | A | b | t | a | l | p | | D | d | h | o | z | k | | F | q | f | v | s | n | | G | g | j | c | u | x | | X | m | r | e | w | y | Note that the order of the letters here is upset. The origin of ADFGX: > In 1918, when the First World War was about to end, the French army intercepted a German telegram. All the words in the message were composed of five letters A, D, F, G, and X, hence the name ADFGX. . The ADFGX password was invented by German Colonel Fritz Nebel in March 1918 and is a dual encryption scheme that combines Polybius passwords and replacement passwords. For example, HELLO, using this form of encryption, is DD XF AG AG DF. Tools \u00b6 CrypTool Examples \u00b6 Here is an example of the An Heng Cup September Crypto competition Go. The title is: > \u5bc6 \u6587 \uff1a > The zip package gives a line of hex: 546865206c656e677468206f66207468697320706c61696e746578743a203130 > Please decrypt the ciphertext First, hexadecimal hexadecimal decoding, get the string: \"The length of this plaintext: 10\" The length of the ciphertext is 20, and the length of the plaintext is 10. The ciphertext has only five characters: \"l\", \"i\", \"n\", \"k\", \"e\", which is associated with the chessboard password. First try the five characters in alphabetical order: e i k l n | e | A | B | C | D | E | | i | F | G | H | I/J | K | | k | L | M | N | O | P | | l | Q | R | S | T | U | | n | V | W | X | Y | Z | Decrypted according to ciphertext: iytghpkqmq. This should not be the flag answer we want. It seems that the five-character arrangement is not arranged in this way. There are a total of 5! import itertools key = [] cipher = \"ilnllliiikkninlekile\" for i in itertools . permutations ( 'ilnke' , 5 ): key . append ( '' . join ( i )) for now_key in key : solve_c = \"\" true = & quot ; & quot ; for now_c in cipher : solve_c += str ( now_key . index ( now_c )) for i in range ( 0 , len ( solve_c ), 2 ): now_ascii = int ( solve_c [ i ]) * 5 + int ( solve_c [ i + 1 ]) + 97 if now_ascii > ord ( 'i' ): now_ascii += 1 res += chr ( now_ascii ) if \"flag\" in res : print now_key , res The script is actually the algorithm for implementing the checkerboard password, but the order of the five characters is not fixed. Run the following two results: > linke flagishere > lines flagkxhdwd Obviously the first one is the answer we want. Attach the correct password form: l i n k e | l | A | B | C | D | E | | i | F | G | H | I/J | K | | n | L | M | N | O | P | | k | Q | R | S | T | U | | e | V W | X Y | Z | Vigenere Virginia Password \u00b6 Principle \u00b6 The Virginia code (Vigenere) is an encryption algorithm that uses a series of Caesar ciphers to form a cipher alphabet, a simple form of multi-table ciphers. ![Virginia Form] (./figure/vigenere1.jpg) An example is given below Clear text: come greatwall Key: crypto First, the key is padded to the same length as the plaintext. \u660e\u6587 c o m e g r e a t w a l l | \u5bc6\u94a5 | c | r | y | p | t | o | c | r | y | p | t | o | c | Second, check the ciphertext ![Virginia Encryption] (./figure/vigenere2.jpg) Clear text: come greatwall Key: crypto Ciphertext: efkt zferrltzn \u7834 \u00b6 The deciphering of all multi-table ciphers, including the Virginia code, is based on the frequency of letters, but direct frequency analysis does not apply because in the Virginia code, a letter can be Encrypted into different ciphertexts, so simple frequency analysis is not useful here. The key to deciphering a Virginia password is that its key is cyclically repeated. If we know the length of the key, the ciphertext can be seen as an interlaced Caesar cipher, and each of them can be cracked separately. Regarding the length of the password, we can use the Kasiki test and the Friedman test to get it. The Kasiki test is based on the fact that common words like the one may be encrypted by the same key letter and thus repeated in the ciphertext. For example, different CRYPTOs in plaintext may be encrypted into different ciphertexts by the key ABCDEF: Key: ABCDEF AB CDEFA BCD EFABCDEFABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6\u6587\uff1aCSASXT IT UKSWT GQU GWYQVRKWAQJB The elements repeated in the plaintext at this time are not repeated in the ciphertext. However, if the keys are the same, the result might be (using the key ABCD): \u5bc6\u94a5 \uff1a ABCDAB CD ABCDA BCD ABCDABCDABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6 \u6587: CSASTP KV SIQUT GQU CSASTPIUAQJB At this point, the Kasiki test can produce results. This method is more efficient for longer paragraphs because there are usually more repeating fragments in the ciphertext. The length of the key can be deciphered by the following ciphertext: \u5bc6\u6587\uff1aDYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD Among them, the appearance of two DYDUXRMH is separated by 18 letters. Therefore, it can be assumed that the length of the key is a divisor of 18, that is, the length is 18, 9, 6, 3 or 2. The two NQDs are 20 letters apart, meaning the key length should be 20, 10, 5, 4 or 2. Taking the intersection of the two, the key length can be basically determined to be 2. The next step is to proceed further. For more detailed cracking principles, I will not do too much introduction here. See http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/ . Tools \u00b6 Known key Python's pycipher library [Online decryption Vigen\u00e8re cipher] ( http://planetcalc.com/2468/ ) CAP4 Unknown key Vigen\u00e8re Cipher Codebreaker [Vigenere Solver] ( https://www.guballa.de/vigenere-solver ) is not perfect. Nihilist \u00b6 Principle \u00b6 The Nihilist password is also known as the keyword password: plain text + keyword = cipher text. Take the keyword helloworld as an example. First construct a checkerboard matrix using a key (similar to a Polybius password) - Create a new 5 \u00d7 5 matrix - Fill characters into the matrix without repeating them in order - The rest is filled in alphabetical order - the letters i and j are equivalent | | 1 | 2 | 3 | 4 | 5 | | --- | --- | --- | ----- | --- | --- | | 1 | h | e | l | of | w | | 2 | r | d | a | b | c | | 3 | f | g | i / j | k | m | | 4 | n | p | q | s | t | | 5 | u | v | x | y | z | Encrypt the encryption process reference matrix M: a -> M[2,3] -> 23 t -> M[4,5] -> 45 For the decryption process Decrypt with reference matrix M: 23 -> M[2,3] -> a 45 -> M[4,5] -> t It can be seen that the characteristics of ciphertext have the following points pure numbers only 1 to 5 Even ciphertext length. Hill \u00b6 Principle \u00b6 Hill (Hill) uses the order of each letter in the alphabet as its corresponding number, ie A=0, B=1, C=2, etc., and then converts the plaintext into an n-dimensional vector, followed by an n \u00d7 n The matrix is multiplied and the resulting result is modulo 26. Note that the matrix used for encryption (ie, the key) must be reversible at \\mathbb{Z}_{26}^{n} \\mathbb{Z}_{26}^{n} , otherwise it is impossible to decode. Only the determinant of the matrix and the 26 prime are reversible. Here is an example Clear text: ACT Ming culture is a matrix. $$ \\begin{bmatrix} 0\\ 2\\ 19 \\end{bmatrix} $$ Suppose the key is: $$ \\begin{bmatrix} 6 & 24 & 1\\ 13 & 16 & 10\\ 20 & 17 & 15 \\end{bmatrix} $$ The encryption process is: $$ \\begin{bmatrix} 6 & 24 & 1\\ 13 & 16 & 10\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 0\\ 2\\ 19 \\end{bmatrix} \\equiv \\begin{bmatrix} 67\\ 222\\ 319 \\end{bmatrix} \\equiv \\begin{bmatrix} 15\\ 14\\ 7 \\end{bmatrix} Way 26 $$ Ciphertext is Ciphertext: POH Tools \u00b6 http://www.practicalcryptography.com/ciphers/hill-cipher/ CAP4 Cryptool Examples \u00b6 Here we take ISCC 2015 base decrypt 150 as an example, the title is > ciphertext: 22,09,00,12,03,01,10,03,04,08,01,17 (wjamdbkdeibr) > The matrix used is 1 2 3 4 5 6 7 8 10 > Please decrypt the ciphertext. First, the matrix is 3 \u00d7 3 . Description Encrypts 3 characters each time. We use Cryptool directly. It should be noted that this matrix is arranged in columns. That is as follows 1 4 7 2 5 8 3 6 10 The final result is overthehillx . AutokeyCipher \u00b6 Principle \u00b6 Autokey Cipher is also a multi-table replacement password, similar to a Virginia password, but uses a different method to generate a key. It is generally safer than a Virginia password. There are two main types of automatic key passwords: keyword automatic key password and original automatic key password. Let's take the keyword automatic key as an example: \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Keywords: CULTURE Automatically generate a key: CULTURE THE QUICK BROWN FOX JUMPS OVER THE The next encryption process is similar to the Virginia password, available from the corresponding table: Ciphertext VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK Tools \u00b6 Known keywords Python's pycipher library Unknown keywords http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ break_autokey.py under the tools folder, to be completed.","title":"\u591a\u8868\u4ee3\u6362\u52a0\u5bc6"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#playfair","text":"","title":"Playfair"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#principle","text":"The Playfair cipher or Playfair square is a replacement password, invented by the British Charles Wheatstone in 1854. The basic algorithm is as follows: Select a string of English letters, remove the repeated letters, and add the remaining letters one by one to the 5 \u00d7 5 matrix. The remaining space is added by the unjoined English letters in the order of az. Note that q is removed, or i and j are treated as the same word. Divide the plaintext to be encrypted into two groups. If the letters in the group are the same, add X (or Q) to the first letter of the group and regroup. If there is one word left, also add X. In each group, find out where the two letters are in the matrix. If the two letters have different rows and different columns, find the other two letters in the matrix (the first letter corresponds to the row first), so that the four letters become the four corners of a rectangle. If the two letters are accompanied, take the letters to the right of the two letters (if the letter is at the far right, take the leftmost letter). If the two letters are in the same column, take the letters below the two letters (if the letter is at the bottom, take the top letter). The two newly found letters are the result of the original two-letter encryption. Use playfair example as the key, get P L A Y F iREX B C D G H K N O Q S T U V W Z The message to be encrypted is Hide the gold in the tree stump THAT IS TH EG OL DI NT HE TR EX IS YOUR MP Will get BM OD ZB XD WILL BE DM UI XM FOR UV IF","title":"Principle"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#tools","text":"CAP4","title":"Tools"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#polybius","text":"","title":", Polybius"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#principle_1","text":"Polybius passwords are also known as board passwords, which are generally used to encrypt a given plaintext into a pair of numbers. | | 1 | 2 | 3 | 4 | 5 | | :--- | --- | --- | --- | --- | :--- | | 1 | A | B | C | D | E | | 2 | F | G | H | I/J | K | | 3 | L | M | N | O | P | | 4 | Q | R | S | T | U | | 5 V W | X Y | Z | For example, plain text HELLO, encrypted is 23 15 31 31 34. Another password table | | A | D | F | G | X | | --- | --- | --- | --- | --- | --- | | A | b | t | a | l | p | | D | d | h | o | z | k | | F | q | f | v | s | n | | G | g | j | c | u | x | | X | m | r | e | w | y | Note that the order of the letters here is upset. The origin of ADFGX: > In 1918, when the First World War was about to end, the French army intercepted a German telegram. All the words in the message were composed of five letters A, D, F, G, and X, hence the name ADFGX. . The ADFGX password was invented by German Colonel Fritz Nebel in March 1918 and is a dual encryption scheme that combines Polybius passwords and replacement passwords. For example, HELLO, using this form of encryption, is DD XF AG AG DF.","title":"Principle"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#tools_1","text":"CrypTool","title":"Tools"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#examples","text":"Here is an example of the An Heng Cup September Crypto competition Go. The title is: > \u5bc6 \u6587 \uff1a > The zip package gives a line of hex: 546865206c656e677468206f66207468697320706c61696e746578743a203130 > Please decrypt the ciphertext First, hexadecimal hexadecimal decoding, get the string: \"The length of this plaintext: 10\" The length of the ciphertext is 20, and the length of the plaintext is 10. The ciphertext has only five characters: \"l\", \"i\", \"n\", \"k\", \"e\", which is associated with the chessboard password. First try the five characters in alphabetical order: e i k l n | e | A | B | C | D | E | | i | F | G | H | I/J | K | | k | L | M | N | O | P | | l | Q | R | S | T | U | | n | V | W | X | Y | Z | Decrypted according to ciphertext: iytghpkqmq. This should not be the flag answer we want. It seems that the five-character arrangement is not arranged in this way. There are a total of 5! import itertools key = [] cipher = \"ilnllliiikkninlekile\" for i in itertools . permutations ( 'ilnke' , 5 ): key . append ( '' . join ( i )) for now_key in key : solve_c = \"\" true = & quot ; & quot ; for now_c in cipher : solve_c += str ( now_key . index ( now_c )) for i in range ( 0 , len ( solve_c ), 2 ): now_ascii = int ( solve_c [ i ]) * 5 + int ( solve_c [ i + 1 ]) + 97 if now_ascii > ord ( 'i' ): now_ascii += 1 res += chr ( now_ascii ) if \"flag\" in res : print now_key , res The script is actually the algorithm for implementing the checkerboard password, but the order of the five characters is not fixed. Run the following two results: > linke flagishere > lines flagkxhdwd Obviously the first one is the answer we want. Attach the correct password form: l i n k e | l | A | B | C | D | E | | i | F | G | H | I/J | K | | n | L | M | N | O | P | | k | Q | R | S | T | U | | e | V W | X Y | Z |","title":"Examples"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#vigenere-virginia-password","text":"","title":"Vigenere Virginia Password"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#principle_2","text":"The Virginia code (Vigenere) is an encryption algorithm that uses a series of Caesar ciphers to form a cipher alphabet, a simple form of multi-table ciphers. ![Virginia Form] (./figure/vigenere1.jpg) An example is given below Clear text: come greatwall Key: crypto First, the key is padded to the same length as the plaintext. \u660e\u6587 c o m e g r e a t w a l l | \u5bc6\u94a5 | c | r | y | p | t | o | c | r | y | p | t | o | c | Second, check the ciphertext ![Virginia Encryption] (./figure/vigenere2.jpg) Clear text: come greatwall Key: crypto Ciphertext: efkt zferrltzn","title":"Principle"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#_1","text":"The deciphering of all multi-table ciphers, including the Virginia code, is based on the frequency of letters, but direct frequency analysis does not apply because in the Virginia code, a letter can be Encrypted into different ciphertexts, so simple frequency analysis is not useful here. The key to deciphering a Virginia password is that its key is cyclically repeated. If we know the length of the key, the ciphertext can be seen as an interlaced Caesar cipher, and each of them can be cracked separately. Regarding the length of the password, we can use the Kasiki test and the Friedman test to get it. The Kasiki test is based on the fact that common words like the one may be encrypted by the same key letter and thus repeated in the ciphertext. For example, different CRYPTOs in plaintext may be encrypted into different ciphertexts by the key ABCDEF: Key: ABCDEF AB CDEFA BCD EFABCDEFABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6\u6587\uff1aCSASXT IT UKSWT GQU GWYQVRKWAQJB The elements repeated in the plaintext at this time are not repeated in the ciphertext. However, if the keys are the same, the result might be (using the key ABCD): \u5bc6\u94a5 \uff1a ABCDAB CD ABCDA BCD ABCDABCDABCD \u660e\u6587\uff1aCRYPTO IS SHORT FOR CRYPTOGRAPHY \u5bc6 \u6587: CSASTP KV SIQUT GQU CSASTPIUAQJB At this point, the Kasiki test can produce results. This method is more efficient for longer paragraphs because there are usually more repeating fragments in the ciphertext. The length of the key can be deciphered by the following ciphertext: \u5bc6\u6587\uff1aDYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD Among them, the appearance of two DYDUXRMH is separated by 18 letters. Therefore, it can be assumed that the length of the key is a divisor of 18, that is, the length is 18, 9, 6, 3 or 2. The two NQDs are 20 letters apart, meaning the key length should be 20, 10, 5, 4 or 2. Taking the intersection of the two, the key length can be basically determined to be 2. The next step is to proceed further. For more detailed cracking principles, I will not do too much introduction here. See http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/ .","title":"\u7834"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#tools_2","text":"Known key Python's pycipher library [Online decryption Vigen\u00e8re cipher] ( http://planetcalc.com/2468/ ) CAP4 Unknown key Vigen\u00e8re Cipher Codebreaker [Vigenere Solver] ( https://www.guballa.de/vigenere-solver ) is not perfect.","title":"Tools"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#nihilist","text":"","title":"Nihilist"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#principle_3","text":"The Nihilist password is also known as the keyword password: plain text + keyword = cipher text. Take the keyword helloworld as an example. First construct a checkerboard matrix using a key (similar to a Polybius password) - Create a new 5 \u00d7 5 matrix - Fill characters into the matrix without repeating them in order - The rest is filled in alphabetical order - the letters i and j are equivalent | | 1 | 2 | 3 | 4 | 5 | | --- | --- | --- | ----- | --- | --- | | 1 | h | e | l | of | w | | 2 | r | d | a | b | c | | 3 | f | g | i / j | k | m | | 4 | n | p | q | s | t | | 5 | u | v | x | y | z | Encrypt the encryption process reference matrix M: a -> M[2,3] -> 23 t -> M[4,5] -> 45 For the decryption process Decrypt with reference matrix M: 23 -> M[2,3] -> a 45 -> M[4,5] -> t It can be seen that the characteristics of ciphertext have the following points pure numbers only 1 to 5 Even ciphertext length.","title":"Principle"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#hill","text":"","title":"Hill"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#principle_4","text":"Hill (Hill) uses the order of each letter in the alphabet as its corresponding number, ie A=0, B=1, C=2, etc., and then converts the plaintext into an n-dimensional vector, followed by an n \u00d7 n The matrix is multiplied and the resulting result is modulo 26. Note that the matrix used for encryption (ie, the key) must be reversible at \\mathbb{Z}_{26}^{n} \\mathbb{Z}_{26}^{n} , otherwise it is impossible to decode. Only the determinant of the matrix and the 26 prime are reversible. Here is an example Clear text: ACT Ming culture is a matrix. $$ \\begin{bmatrix} 0\\ 2\\ 19 \\end{bmatrix} $$ Suppose the key is: $$ \\begin{bmatrix} 6 & 24 & 1\\ 13 & 16 & 10\\ 20 & 17 & 15 \\end{bmatrix} $$ The encryption process is: $$ \\begin{bmatrix} 6 & 24 & 1\\ 13 & 16 & 10\\ 20 & 17 & 15 \\end{bmatrix} \\begin{bmatrix} 0\\ 2\\ 19 \\end{bmatrix} \\equiv \\begin{bmatrix} 67\\ 222\\ 319 \\end{bmatrix} \\equiv \\begin{bmatrix} 15\\ 14\\ 7 \\end{bmatrix} Way 26 $$ Ciphertext is Ciphertext: POH","title":"Principle"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#tools_3","text":"http://www.practicalcryptography.com/ciphers/hill-cipher/ CAP4 Cryptool","title":"Tools"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#examples_1","text":"Here we take ISCC 2015 base decrypt 150 as an example, the title is > ciphertext: 22,09,00,12,03,01,10,03,04,08,01,17 (wjamdbkdeibr) > The matrix used is 1 2 3 4 5 6 7 8 10 > Please decrypt the ciphertext. First, the matrix is 3 \u00d7 3 . Description Encrypts 3 characters each time. We use Cryptool directly. It should be noted that this matrix is arranged in columns. That is as follows 1 4 7 2 5 8 3 6 10 The final result is overthehillx .","title":"Examples"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#autokeycipher","text":"","title":"AutokeyCipher"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#principle_5","text":"Autokey Cipher is also a multi-table replacement password, similar to a Virginia password, but uses a different method to generate a key. It is generally safer than a Virginia password. There are two main types of automatic key passwords: keyword automatic key password and original automatic key password. Let's take the keyword automatic key as an example: \u660e\u6587\uff1aTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG Keywords: CULTURE Automatically generate a key: CULTURE THE QUICK BROWN FOX JUMPS OVER THE The next encryption process is similar to the Virginia password, available from the corresponding table: Ciphertext VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK","title":"Principle"},{"location":"crypto/ctf-wiki/classical/polyalphabetic/#tools_4","text":"Known keywords Python's pycipher library Unknown keywords http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ break_autokey.py under the tools folder, to be completed.","title":"Tools"},{"location":"crypto/ctf-wiki/classical/summary-zh/","text":"EN | ZH \u603b\u7ed3 \u00b6 \u53e4\u5178\u5bc6\u7801\u5206\u6790\u601d\u8def \u00b6 CTF \u4e2d\u6709\u5173\u53e4\u5178\u5bc6\u7801\u7684\u9898\u76ee\uff0c\u901a\u5e38\u662f\u6839\u636e\u5bc6\u6587\u6c42\u51fa\u660e\u6587\uff0c\u56e0\u6b64\u91c7\u7528 \u552f\u5bc6\u6587\u653b\u51fb \u5c45\u591a\uff0c\u57fa\u672c\u5206\u6790\u601d\u8def\u603b\u7ed3\u5982\u4e0b\uff1a \u786e\u5b9a\u5bc6\u7801\u7c7b\u578b\uff1a\u6839\u636e\u9898\u76ee\u63d0\u793a\u3001\u52a0\u5bc6\u65b9\u5f0f\u3001\u5bc6\u6587\u5b57\u7b26\u96c6\u3001\u5bc6\u6587\u5c55\u73b0\u5f62\u5f0f\u7b49\u4fe1\u606f\u3002 \u786e\u5b9a\u653b\u51fb\u65b9\u6cd5\uff1a\u5305\u62ec\u76f4\u63a5\u5206\u6790\u3001\u86ee\u529b\u653b\u51fb\u3001\u7edf\u8ba1\u5206\u6790\u7b49\u65b9\u6cd5\u3002\u5bf9\u4e8e\u65e0\u6cd5\u786e\u5b9a\u7c7b\u578b\u7684\u7279\u6b8a\u5bc6\u7801\uff0c\u5e94\u6839\u636e\u5176\u5bc6\u7801\u7279\u6027\u9009\u7528\u5408\u9002\u7684\u653b\u51fb\u65b9\u6cd5\u3002 \u786e\u5b9a\u5206\u6790\u5de5\u5177\uff1a\u4ee5\u5728\u7ebf\u5bc6\u7801\u5206\u6790\u5de5\u5177\u4e0e Python \u811a\u672c\u5de5\u5177\u5305\u4e3a\u4e3b\uff0c\u4ee5\u79bb\u7ebf\u5bc6\u7801\u5206\u6790\u5de5\u5177\u4e0e\u624b\u5de5\u5206\u6790\u4e3a\u8f85\u3002 \u4ee5\u4e0a\u552f\u5bc6\u6587\u653b\u51fb\u65b9\u6cd5\u7684\u9002\u7528\u573a\u666f\u4e0e\u4e3e\u4f8b\u5982\u4e0b\uff1a \u653b\u51fb\u65b9\u6cd5 \u9002\u7528\u573a\u666f \u4e3e\u4f8b \u76f4\u63a5\u5206\u6790\u6cd5 \u7531\u5bc6\u7801\u7c7b\u578b\u53ef\u786e\u5b9a\u6620\u5c04\u5173\u7cfb\u7684\u4ee3\u6362\u5bc6\u7801 \u51ef\u6492\u5bc6\u7801\u3001\u732a\u5708\u5bc6\u7801\u3001\u952e\u76d8\u5bc6\u7801\u7b49 \u86ee\u529b\u653b\u51fb\u6cd5 \u5bc6\u94a5\u7a7a\u95f4\u8f83\u5c0f\u7684\u4ee3\u6362\u5bc6\u7801\u6216\u7f6e\u6362\u5bc6\u7801 \u79fb\u4f4d\u5bc6\u7801\u3001\u6805\u680f\u5bc6\u7801\u7b49 \u7edf\u8ba1\u5206\u6790\u6cd5 \u5bc6\u94a5\u7a7a\u95f4\u8f83\u5927\u7684\u4ee3\u6362\u5bc6\u7801 \u7b80\u5355\u66ff\u6362\u5bc6\u7801\u3001\u4eff\u5c04\u5bc6\u7801\u3001\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u7b49 \u5b9e\u9a8c\u5427 \u56f4\u5728\u6805\u680f\u91cc\u7684\u7231 \u00b6 \u9898\u76ee\u63cf\u8ff0 \u6700\u8fd1\u4e00\u76f4\u5728\u597d\u5947\u4e00\u4e2a\u95ee\u9898\uff0cQWE \u5230\u5e95\u7b49\u4e0d\u7b49\u4e8e ABC\uff1f -.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- --- flag\u683c\u5f0f\uff1aCTF{xxx} \u9996\u5148\uff0c\u6839\u636e\u5bc6\u7801\u6837\u5f0f\u5224\u65ad\u662f\u6469\u65af\u7535\u7801\uff0c\u89e3\u5bc6\u540e\u5f97\u5230 KIQLWTFCQGNSOO \uff0c\u770b\u7740\u4e5f\u4e0d\u50cf flag\uff0c\u9898\u76ee\u4e2d\u8fd8\u6709\u8fd8\u6709\u6805\u680f\u4e0e QWE\u5230\u5e95\u7b49\u4e0d\u7b49\u4e8eABC \uff0c\u4e24\u4e2a\u90fd\u8bd5\u4e86\u8bd5\u4e4b\u540e\uff0c\u53d1\u73b0\u662f\u5148 QWE \u7136\u540e\u6805\u680f\u53ef\u5f97\u5230\u7ed3\u679c\u3002 \u9996\u5148\u952e\u76d8 QWE \u89e3\u5bc6\uff0c\u8bd5\u7740\u89e3\u5bc6\u5f97\u5230 IILYOAVNEBSAHR \u3002\u7ee7\u800c\u6805\u680f\u89e3\u5bc6\u5f97\u5230 ILOVESHIYANBAR \u3002 2017 SECCON Vigenere3d \u00b6 \u7a0b\u5e8f\u5982\u4e0b # Vigenere3d.py import sys def _l ( idx , s ): return s [ idx :] + s [: idx ] def main ( p , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 c = \"\" for a in p : c += t [ s . find ( a )][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] i1 = ( i1 + 1 ) % len ( k1 ) i2 = ( i2 + 1 ) % len ( k2 ) return c print main ( sys . argv [ 1 ], sys . argv [ 2 ], sys . argv [ 2 ][:: - 1 ]) $ python Vigenere3d . py SECCON { ************************** } ************** POR4dnyTLHBfwbxAAZhe }} ocZR3Cxcftw9 \u89e3\u6cd5\u4e00 \uff1a \u9996\u5148\uff0c\u6211\u4eec\u5148\u6765\u5206\u6790\u4e00\u4e0b t \u7684\u6784\u6210 $$ t[i][j]=s[i+j:]+s[:i+j] \\ t[i][k]=s[i+k:]+s[:i+k] $$ t[i][j][k] t[i][j][k] \u4e3a t[i][j] t[i][j] \u4e2d\u7684\u7b2c k \u4e2a\u5b57\u7b26\uff0c t[i][k][j] t[i][k][j] \u4e3a t[i][k] t[i][k] \u4e2d\u7684\u7b2c j \u4e2a\u5b57\u7b26\u3002\u65e0\u8bba\u662f i+j+k i+j+k \u662f\u5426\u8d85\u8fc7 len(s) \u4e24\u8005\u90fd\u59cb\u7ec8\u4fdd\u6301\u4e00\u81f4\uff0c\u5373 t[i][j][k]=t[i][k][j] t[i][j][k]=t[i][k][j] \u3002 \u6545\u800c\uff0c\u5176\u5b9e\u5bf9\u4e8e\u76f8\u540c\u7684\u660e\u6587\u6765\u8bf4\uff0c\u53ef\u80fd\u6709\u591a\u4e2a\u5bc6\u94a5\u4f7f\u5176\u751f\u6210\u76f8\u540c\u7684\u5bc6\u6587\u3002 \u7136\u800c\u4e0a\u9762\u5206\u6790\u5c31\u662f\u5355\u7eaf\u5730\u5206\u6790\u800c\u5df2\uff0c\uff0c\u4e0b\u9762\u5f00\u59cb\u6b63\u9898\u3002 \u4e0d\u96be\u770b\u51fa\uff0c\u5bc6\u6587\u7684\u6bcf\u4e00\u4f4d\u53ea\u4e0e\u660e\u6587\u7684\u76f8\u5e94\u4f4d\u76f8\u5173\uff0c\u800c\u4e14\uff0c\u5bc6\u94a5\u7684\u6bcf\u4e00\u4f4d\u7684\u7a7a\u95f4\u6700\u5927\u4e5f\u5c31\u662f s \u7684\u5927\u5c0f\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u7206\u7834\u6765\u83b7\u53d6\u5bc6\u94a5\u3002\u8fd9\u91cc\u6839\u636e\u4e0a\u8ff0\u547d\u4ee4\u884c\u63d0\u793a\uff0c\u53ef\u4ee5\u77e5\u9053\u5bc6\u94a5\u957f\u5ea6\u4e3a 14\uff0c\u6070\u597d\u660e\u6587\u524d\u97627\u4e2a\u5b57\u8282\u5df2\u77e5\u3002\u6062\u590d\u5bc6\u94a5\u7684 exp \u5982\u4e0b def get_key ( plain , cipher ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 key = [ '*' ] * 14 for i in range ( len ( plain )): for i1 in range ( len ( s )): for i2 in range ( len ( s )): if t [ s . find ( plain [ i ])][ s . find ( s [ i1 ])][ s . find ( s [ i2 ])] == cipher [ i ]: key [ i ] = s [ i1 ] key [ 13 - i ] = s [ i2 ] return '' . join ( key ) \u6062\u590d\u660e\u6587\u7684\u811a\u672c\u5982\u4e0b def decrypt ( cipher , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 plain = \"\" for a in cipher : for i in range ( len ( s )): if t [ i ][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] == a : plain += s [ i ] break i1 = ( i1 + 1 ) % len ( k1 ) i2 = ( i2 + 1 ) % len ( k2 ) return plain \u5f97\u5230\u660e\u6587\u5982\u4e0b \u279c 2017_seccon_vigenere3d git: ( master ) python exp.py SECCON { Welc0me_to_SECCON_CTF_2017 } \u89e3\u6cd5\u4e8c \u5173\u4e8e\u6b64\u9898\u7684\u5206\u6790\uff1a \u8003\u8651\u5230\u5728\u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\u4e0b\uff0c\u6570\u7ec4\u8bbf\u95ee\u4e0d\u4f1a\u8d8a\u754c\uff0c\u6211\u4eec\u5728\u8ba8\u8bba\u65f6\u505a\u4ee5\u4e0b\u7ea6\u5b9a\uff1a arr[index] \\Leftrightarrow arr[index \\% len(arr)] arr[index] \\Leftrightarrow arr[index \\% len(arr)] \u5173\u4e8e python \u7a0b\u5e8f\u4e2d\u5b9a\u4e49\u7684 _l \u51fd\u6570\uff0c\u53d1\u73b0\u4ee5\u4e0b\u7b49\u4ef7\u5173\u7cfb\uff1a \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] \u5173\u4e8e python \u7684 main \u51fd\u6570\u4e2d\u4e09\u7ef4\u77e9\u9635 t \u7684\u5b9a\u4e49\uff0c\u53d1\u73b0\u4ee5\u4e0b\u7b49\u4ef7\u5173\u7cfb\uff1a t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] \u7efc\u5408\u7b2c 2 \u7b2c 3 \u70b9\u7684\u89c2\u5bdf\uff0c\u6709\u5982\u4e0b\u7b49\u4ef7\u5173\u7cfb\uff1a t[a][b][c] \\Leftrightarrow s[a+b+c] t[a][b][c] \\Leftrightarrow s[a+b+c] \u6211\u4eec\u5c06 s \u89c6\u4e3a\u4e00\u79cd\u7f16\u7801\u683c\u5f0f\uff0c\u5373\uff1a\u7f16\u7801\u8fc7\u7a0b s.find(x)\uff0c\u89e3\u7801\u8fc7\u7a0b s[x]\u3002\u5e76\u76f4\u63a5\u4f7f\u7528\u5176\u7f16\u7801\u7ed3\u679c\u7684\u6570\u5b57\u66ff\u4ee3\u5176\u6240\u4ee3\u6307\u7684\u5b57\u7b26\u4e32\uff0c\u90a3\u4e48\u52a0\u5bc6\u8fc7\u7a0b\u53ef\u4ee5\u7528\u4ee5\u4e0b\u516c\u5f0f\u8868\u793a\uff1a e = f + k1 +k2 e = f + k1 +k2 \u5176\u4e2d\uff0ce \u662f\u5bc6\u6587\uff0cf \u662f\u660e\u6587\uff0ck1 \u4e0e k2 \u662f\u901a\u8fc7\u590d\u5236\u65b9\u6cd5\u5f97\u5230\u3001\u4e0e f \u957f\u5ea6\u4e00\u6837\u7684\u5bc6\u94a5\uff0c \u52a0\u6cd5\u662f\u5411\u91cf\u52a0 \u3002 \u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u901a\u8fc7\u8ba1\u7b97 k1+k2 \uff0c\u6a21\u62df\u5bc6\u94a5\uff0c\u5373\u53ef\u89e3\u5bc6\u3002\u5173\u4e8e\u6b64\u9898\u7684\u89e3\u5bc6 python \u811a\u672c\uff1a # exp2.py enc_str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} ' dec_dic = { k : v for v , k in enumerate ( enc_str )} encrypt = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9' flag_bg = 'SECCON{**************************}' sim_key = [ dec_dic [ encrypt [ i ]] - dec_dic [ flag_bg [ i ]] for i in range ( 7 )] # \u7834\u89e3\u6a21\u62df\u5bc6\u94a5 sim_key = sim_key + sim_key [:: - 1 ] flag_ed = [ dec_dic [ v ] - sim_key [ k % 14 ] for k , v in enumerate ( encrypt )] # \u6a21\u62df\u5bc6\u94a5\u89e3\u5bc6 flag_ed = '' . join ([ enc_str [ i % len ( enc_str )] for i in flag_ed ]) # \u89e3\u7801 print ( flag_ed ) \u5f97\u5230\u660e\u6587\u5982\u4e0b\uff1a $ python exp2.py SECCON { Welc0me_to_SECCON_CTF_2017 } \u6d88\u5931\u7684\u4e09\u91cd\u5bc6\u7801 \u00b6 \u5bc6\u6587 of zit kggd zitkt qkt ygxk ortfzoeqs wqlatzwqssl qfr zvg ortfzoeqs yggzwqssl. fgv oy ngx vqfz zg hxz zitd of gft soft.piv dgfn lgsxzogfl qkt zitkt? zohl:hstqlt eiqfut zit ygkd gy zit fxdwtk ngx utz.zit hkgukqddtkl! \u4f7f\u7528 quipquip \u76f4\u63a5\u89e3\u5bc6\u3002","title":"Summary zh"},{"location":"crypto/ctf-wiki/classical/summary-zh/#_1","text":"","title":"\u603b\u7ed3"},{"location":"crypto/ctf-wiki/classical/summary-zh/#_2","text":"CTF \u4e2d\u6709\u5173\u53e4\u5178\u5bc6\u7801\u7684\u9898\u76ee\uff0c\u901a\u5e38\u662f\u6839\u636e\u5bc6\u6587\u6c42\u51fa\u660e\u6587\uff0c\u56e0\u6b64\u91c7\u7528 \u552f\u5bc6\u6587\u653b\u51fb \u5c45\u591a\uff0c\u57fa\u672c\u5206\u6790\u601d\u8def\u603b\u7ed3\u5982\u4e0b\uff1a \u786e\u5b9a\u5bc6\u7801\u7c7b\u578b\uff1a\u6839\u636e\u9898\u76ee\u63d0\u793a\u3001\u52a0\u5bc6\u65b9\u5f0f\u3001\u5bc6\u6587\u5b57\u7b26\u96c6\u3001\u5bc6\u6587\u5c55\u73b0\u5f62\u5f0f\u7b49\u4fe1\u606f\u3002 \u786e\u5b9a\u653b\u51fb\u65b9\u6cd5\uff1a\u5305\u62ec\u76f4\u63a5\u5206\u6790\u3001\u86ee\u529b\u653b\u51fb\u3001\u7edf\u8ba1\u5206\u6790\u7b49\u65b9\u6cd5\u3002\u5bf9\u4e8e\u65e0\u6cd5\u786e\u5b9a\u7c7b\u578b\u7684\u7279\u6b8a\u5bc6\u7801\uff0c\u5e94\u6839\u636e\u5176\u5bc6\u7801\u7279\u6027\u9009\u7528\u5408\u9002\u7684\u653b\u51fb\u65b9\u6cd5\u3002 \u786e\u5b9a\u5206\u6790\u5de5\u5177\uff1a\u4ee5\u5728\u7ebf\u5bc6\u7801\u5206\u6790\u5de5\u5177\u4e0e Python \u811a\u672c\u5de5\u5177\u5305\u4e3a\u4e3b\uff0c\u4ee5\u79bb\u7ebf\u5bc6\u7801\u5206\u6790\u5de5\u5177\u4e0e\u624b\u5de5\u5206\u6790\u4e3a\u8f85\u3002 \u4ee5\u4e0a\u552f\u5bc6\u6587\u653b\u51fb\u65b9\u6cd5\u7684\u9002\u7528\u573a\u666f\u4e0e\u4e3e\u4f8b\u5982\u4e0b\uff1a \u653b\u51fb\u65b9\u6cd5 \u9002\u7528\u573a\u666f \u4e3e\u4f8b \u76f4\u63a5\u5206\u6790\u6cd5 \u7531\u5bc6\u7801\u7c7b\u578b\u53ef\u786e\u5b9a\u6620\u5c04\u5173\u7cfb\u7684\u4ee3\u6362\u5bc6\u7801 \u51ef\u6492\u5bc6\u7801\u3001\u732a\u5708\u5bc6\u7801\u3001\u952e\u76d8\u5bc6\u7801\u7b49 \u86ee\u529b\u653b\u51fb\u6cd5 \u5bc6\u94a5\u7a7a\u95f4\u8f83\u5c0f\u7684\u4ee3\u6362\u5bc6\u7801\u6216\u7f6e\u6362\u5bc6\u7801 \u79fb\u4f4d\u5bc6\u7801\u3001\u6805\u680f\u5bc6\u7801\u7b49 \u7edf\u8ba1\u5206\u6790\u6cd5 \u5bc6\u94a5\u7a7a\u95f4\u8f83\u5927\u7684\u4ee3\u6362\u5bc6\u7801 \u7b80\u5355\u66ff\u6362\u5bc6\u7801\u3001\u4eff\u5c04\u5bc6\u7801\u3001\u7ef4\u5409\u5c3c\u4e9a\u5bc6\u7801\u7b49","title":"\u53e4\u5178\u5bc6\u7801\u5206\u6790\u601d\u8def"},{"location":"crypto/ctf-wiki/classical/summary-zh/#_3","text":"\u9898\u76ee\u63cf\u8ff0 \u6700\u8fd1\u4e00\u76f4\u5728\u597d\u5947\u4e00\u4e2a\u95ee\u9898\uff0cQWE \u5230\u5e95\u7b49\u4e0d\u7b49\u4e8e ABC\uff1f -.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- --- flag\u683c\u5f0f\uff1aCTF{xxx} \u9996\u5148\uff0c\u6839\u636e\u5bc6\u7801\u6837\u5f0f\u5224\u65ad\u662f\u6469\u65af\u7535\u7801\uff0c\u89e3\u5bc6\u540e\u5f97\u5230 KIQLWTFCQGNSOO \uff0c\u770b\u7740\u4e5f\u4e0d\u50cf flag\uff0c\u9898\u76ee\u4e2d\u8fd8\u6709\u8fd8\u6709\u6805\u680f\u4e0e QWE\u5230\u5e95\u7b49\u4e0d\u7b49\u4e8eABC \uff0c\u4e24\u4e2a\u90fd\u8bd5\u4e86\u8bd5\u4e4b\u540e\uff0c\u53d1\u73b0\u662f\u5148 QWE \u7136\u540e\u6805\u680f\u53ef\u5f97\u5230\u7ed3\u679c\u3002 \u9996\u5148\u952e\u76d8 QWE \u89e3\u5bc6\uff0c\u8bd5\u7740\u89e3\u5bc6\u5f97\u5230 IILYOAVNEBSAHR \u3002\u7ee7\u800c\u6805\u680f\u89e3\u5bc6\u5f97\u5230 ILOVESHIYANBAR \u3002","title":"\u5b9e\u9a8c\u5427 \u56f4\u5728\u6805\u680f\u91cc\u7684\u7231"},{"location":"crypto/ctf-wiki/classical/summary-zh/#2017-seccon-vigenere3d","text":"\u7a0b\u5e8f\u5982\u4e0b # Vigenere3d.py import sys def _l ( idx , s ): return s [ idx :] + s [: idx ] def main ( p , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 c = \"\" for a in p : c += t [ s . find ( a )][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] i1 = ( i1 + 1 ) % len ( k1 ) i2 = ( i2 + 1 ) % len ( k2 ) return c print main ( sys . argv [ 1 ], sys . argv [ 2 ], sys . argv [ 2 ][:: - 1 ]) $ python Vigenere3d . py SECCON { ************************** } ************** POR4dnyTLHBfwbxAAZhe }} ocZR3Cxcftw9 \u89e3\u6cd5\u4e00 \uff1a \u9996\u5148\uff0c\u6211\u4eec\u5148\u6765\u5206\u6790\u4e00\u4e0b t \u7684\u6784\u6210 $$ t[i][j]=s[i+j:]+s[:i+j] \\ t[i][k]=s[i+k:]+s[:i+k] $$ t[i][j][k] t[i][j][k] \u4e3a t[i][j] t[i][j] \u4e2d\u7684\u7b2c k \u4e2a\u5b57\u7b26\uff0c t[i][k][j] t[i][k][j] \u4e3a t[i][k] t[i][k] \u4e2d\u7684\u7b2c j \u4e2a\u5b57\u7b26\u3002\u65e0\u8bba\u662f i+j+k i+j+k \u662f\u5426\u8d85\u8fc7 len(s) \u4e24\u8005\u90fd\u59cb\u7ec8\u4fdd\u6301\u4e00\u81f4\uff0c\u5373 t[i][j][k]=t[i][k][j] t[i][j][k]=t[i][k][j] \u3002 \u6545\u800c\uff0c\u5176\u5b9e\u5bf9\u4e8e\u76f8\u540c\u7684\u660e\u6587\u6765\u8bf4\uff0c\u53ef\u80fd\u6709\u591a\u4e2a\u5bc6\u94a5\u4f7f\u5176\u751f\u6210\u76f8\u540c\u7684\u5bc6\u6587\u3002 \u7136\u800c\u4e0a\u9762\u5206\u6790\u5c31\u662f\u5355\u7eaf\u5730\u5206\u6790\u800c\u5df2\uff0c\uff0c\u4e0b\u9762\u5f00\u59cb\u6b63\u9898\u3002 \u4e0d\u96be\u770b\u51fa\uff0c\u5bc6\u6587\u7684\u6bcf\u4e00\u4f4d\u53ea\u4e0e\u660e\u6587\u7684\u76f8\u5e94\u4f4d\u76f8\u5173\uff0c\u800c\u4e14\uff0c\u5bc6\u94a5\u7684\u6bcf\u4e00\u4f4d\u7684\u7a7a\u95f4\u6700\u5927\u4e5f\u5c31\u662f s \u7684\u5927\u5c0f\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u7206\u7834\u6765\u83b7\u53d6\u5bc6\u94a5\u3002\u8fd9\u91cc\u6839\u636e\u4e0a\u8ff0\u547d\u4ee4\u884c\u63d0\u793a\uff0c\u53ef\u4ee5\u77e5\u9053\u5bc6\u94a5\u957f\u5ea6\u4e3a 14\uff0c\u6070\u597d\u660e\u6587\u524d\u97627\u4e2a\u5b57\u8282\u5df2\u77e5\u3002\u6062\u590d\u5bc6\u94a5\u7684 exp \u5982\u4e0b def get_key ( plain , cipher ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 key = [ '*' ] * 14 for i in range ( len ( plain )): for i1 in range ( len ( s )): for i2 in range ( len ( s )): if t [ s . find ( plain [ i ])][ s . find ( s [ i1 ])][ s . find ( s [ i2 ])] == cipher [ i ]: key [ i ] = s [ i1 ] key [ 13 - i ] = s [ i2 ] return '' . join ( key ) \u6062\u590d\u660e\u6587\u7684\u811a\u672c\u5982\u4e0b def decrypt ( cipher , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 plain = \"\" for a in cipher : for i in range ( len ( s )): if t [ i ][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] == a : plain += s [ i ] break i1 = ( i1 + 1 ) % len ( k1 ) i2 = ( i2 + 1 ) % len ( k2 ) return plain \u5f97\u5230\u660e\u6587\u5982\u4e0b \u279c 2017_seccon_vigenere3d git: ( master ) python exp.py SECCON { Welc0me_to_SECCON_CTF_2017 } \u89e3\u6cd5\u4e8c \u5173\u4e8e\u6b64\u9898\u7684\u5206\u6790\uff1a \u8003\u8651\u5230\u5728\u7a0b\u5e8f\u6b63\u5e38\u8fd0\u884c\u4e0b\uff0c\u6570\u7ec4\u8bbf\u95ee\u4e0d\u4f1a\u8d8a\u754c\uff0c\u6211\u4eec\u5728\u8ba8\u8bba\u65f6\u505a\u4ee5\u4e0b\u7ea6\u5b9a\uff1a arr[index] \\Leftrightarrow arr[index \\% len(arr)] arr[index] \\Leftrightarrow arr[index \\% len(arr)] \u5173\u4e8e python \u7a0b\u5e8f\u4e2d\u5b9a\u4e49\u7684 _l \u51fd\u6570\uff0c\u53d1\u73b0\u4ee5\u4e0b\u7b49\u4ef7\u5173\u7cfb\uff1a \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] \u5173\u4e8e python \u7684 main \u51fd\u6570\u4e2d\u4e09\u7ef4\u77e9\u9635 t \u7684\u5b9a\u4e49\uff0c\u53d1\u73b0\u4ee5\u4e0b\u7b49\u4ef7\u5173\u7cfb\uff1a t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] \u7efc\u5408\u7b2c 2 \u7b2c 3 \u70b9\u7684\u89c2\u5bdf\uff0c\u6709\u5982\u4e0b\u7b49\u4ef7\u5173\u7cfb\uff1a t[a][b][c] \\Leftrightarrow s[a+b+c] t[a][b][c] \\Leftrightarrow s[a+b+c] \u6211\u4eec\u5c06 s \u89c6\u4e3a\u4e00\u79cd\u7f16\u7801\u683c\u5f0f\uff0c\u5373\uff1a\u7f16\u7801\u8fc7\u7a0b s.find(x)\uff0c\u89e3\u7801\u8fc7\u7a0b s[x]\u3002\u5e76\u76f4\u63a5\u4f7f\u7528\u5176\u7f16\u7801\u7ed3\u679c\u7684\u6570\u5b57\u66ff\u4ee3\u5176\u6240\u4ee3\u6307\u7684\u5b57\u7b26\u4e32\uff0c\u90a3\u4e48\u52a0\u5bc6\u8fc7\u7a0b\u53ef\u4ee5\u7528\u4ee5\u4e0b\u516c\u5f0f\u8868\u793a\uff1a e = f + k1 +k2 e = f + k1 +k2 \u5176\u4e2d\uff0ce \u662f\u5bc6\u6587\uff0cf \u662f\u660e\u6587\uff0ck1 \u4e0e k2 \u662f\u901a\u8fc7\u590d\u5236\u65b9\u6cd5\u5f97\u5230\u3001\u4e0e f \u957f\u5ea6\u4e00\u6837\u7684\u5bc6\u94a5\uff0c \u52a0\u6cd5\u662f\u5411\u91cf\u52a0 \u3002 \u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u901a\u8fc7\u8ba1\u7b97 k1+k2 \uff0c\u6a21\u62df\u5bc6\u94a5\uff0c\u5373\u53ef\u89e3\u5bc6\u3002\u5173\u4e8e\u6b64\u9898\u7684\u89e3\u5bc6 python \u811a\u672c\uff1a # exp2.py enc_str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} ' dec_dic = { k : v for v , k in enumerate ( enc_str )} encrypt = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9' flag_bg = 'SECCON{**************************}' sim_key = [ dec_dic [ encrypt [ i ]] - dec_dic [ flag_bg [ i ]] for i in range ( 7 )] # \u7834\u89e3\u6a21\u62df\u5bc6\u94a5 sim_key = sim_key + sim_key [:: - 1 ] flag_ed = [ dec_dic [ v ] - sim_key [ k % 14 ] for k , v in enumerate ( encrypt )] # \u6a21\u62df\u5bc6\u94a5\u89e3\u5bc6 flag_ed = '' . join ([ enc_str [ i % len ( enc_str )] for i in flag_ed ]) # \u89e3\u7801 print ( flag_ed ) \u5f97\u5230\u660e\u6587\u5982\u4e0b\uff1a $ python exp2.py SECCON { Welc0me_to_SECCON_CTF_2017 }","title":"2017 SECCON Vigenere3d"},{"location":"crypto/ctf-wiki/classical/summary-zh/#_4","text":"\u5bc6\u6587 of zit kggd zitkt qkt ygxk ortfzoeqs wqlatzwqssl qfr zvg ortfzoeqs yggzwqssl. fgv oy ngx vqfz zg hxz zitd of gft soft.piv dgfn lgsxzogfl qkt zitkt? zohl:hstqlt eiqfut zit ygkd gy zit fxdwtk ngx utz.zit hkgukqddtkl! \u4f7f\u7528 quipquip \u76f4\u63a5\u89e3\u5bc6\u3002","title":"\u6d88\u5931\u7684\u4e09\u91cd\u5bc6\u7801"},{"location":"crypto/ctf-wiki/classical/summary/","text":"EN | ZH to sum up \u00b6 Classical Password Analysis \u00b6 The questions about classical ciphers in CTF are usually based on ciphertext to obtain plaintext. Therefore, ciphertext attack is mostly used. The basic analysis ideas are summarized as follows: Determine the password type: according to the prompt, encryption method, ciphertext character set, cipher text display form and other information. Determine the attack method: including direct analysis, brute force attack, statistical analysis and other methods. For special passwords of unknown type, the appropriate attack method should be selected according to their password characteristics. Identify analysis tools: Focus on online password analysis tools and Python scripting tools, supplemented by offline cryptanalysis tools and manual analysis. The applicable scenarios and examples of the above ciphertext attack methods are as follows: Attack Methods Applicable Scenarios Examples Direct Analysis Method | The password for the mapping relationship can be determined by the password type | Caesar password, pig password, keyboard password, etc. | | Brute force attack method | Replacement password or replacement password with small key space | Shift password, fence password, etc. | | Statistical Analysis | Replacement passwords with large key spaces | Simple replacement passwords, affine passwords, Virginia passwords, etc. | Experiment, love in the fence \u00b6 Description of the topic > I have been wondering about a question recently. Is QWE not equal to ABC? -.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- --- > flag format: CTF{xxx} First of all, according to the password style, it is Moss code. After decryption, it gets KIQLWTFCQGNSOO . It doesn't look like flag. There are still fences and QWE in the end. It doesn&#39;t equal ABC . After both try it, It is found that QWE and then the fence can get the result. First, the keyboard QWE decrypts and tries to decrypt it to get IILYOAVNEBSAHR . Then the fence decrypts to get ILOVESHIYANBAR . 2017 SECCON Vigenere3d \u00b6 The procedure is as follows # Vigenere3d.py import sys def _l ( idx , s ): return s [ idx :] + s [: idx ] def main ( p , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 c = \"\" for a in p : c += t [ s . find ( a )][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] i1 = ( i1 + 1 ) % only ( k1 ) i2 = ( i2 + 1 ) % yen ( k2 ) return c print main ( sys . argv [ 1 ], sys . argv [ 2 ], sys . argv [ 2 ][:: - 1 ]) $ python Vigenere3d . py SECCON { *************************** ************** POR4dnyTLHBfwbxAAZhe }} ocZR3Cxcftw9 Solution 1 : First, let\u2019s first analyze the composition of t. $$ t[i][j]=s[i+j:]+s[:i+j] \\ t[i][k]=s[i+k:]+s[:i+k] $$ t[i][j][k] t[i][j][k] is the kth character in t[i][j] t[i][j] , t[i][k][j] t[i][k][j] is $t[i][k] The jth character in $. Whether i+j+k i+j+k exceeds len(s) is always consistent, ie t[i][j][k]=t[i][k][j] t[i][j][k]=t[i][k][j] . Therefore, in fact, for the same plaintext, there may be multiple keys to generate the same ciphertext. However, the above analysis is simply analysis, and the following begins. It is not difficult to see that each bit of the ciphertext is only related to the corresponding bit of the plaintext, and the space of each bit of the key is the size of s, so we can use the blast to obtain the key. Here, according to the above command line prompt, it can be known that the key length is 14, just the first 7 bytes of the plaintext are known. The recovery key exp is as follows def get_key ( plain , cipher ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 key = [ '*' ] * 14 for i in range ( len ( plain )): for i1 in range ( len ( s )): for i2 in range ( len ( s )): if t [ s . find ( plain [ i ])][ s . find ( s [ i1 ])][ s . find ( s [ i2 ])] == cipher [ i ]: key [ i ] = s [ i1 ] key [ 13 - i ] = s [ i2 ] return '' . join ( key ) The script to restore the plaintext is as follows def decrypt ( cipher , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 plain = \"\" for a in cipher : for i in range ( len ( s )): if t [ i ][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] == a : plain += s [ i ] break i1 = ( i1 + 1 ) % only ( k1 ) i2 = ( i2 + 1 ) % yen ( k2 ) return plain Get the plain text below \u279c 2017_seccon_vigenere3d git: ( master ) python exp.py SECCON { Welc0me_to_SECCON_CTF_2017 } Solution 2 Analysis of this question: Considering that the array access will not cross the boundary under normal program operation, we will make the following convention when discussing: arr[index] \\Leftrightarrow arr[index \\% len(arr)] arr[index] \\Leftrightarrow arr[index \\% len(arr)] For the _l function defined in the python program, find the following equivalence relationship: \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] For the definition of the three-dimensional matrix t in python's main function, find the following equivalence relation: t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] Based on the observation of the second point 3, there is the following equivalence relation: t[a][b][c] \\Leftrightarrow s[a+b+c] t[a][b][c] \\Leftrightarrow s[a+b+c] We consider s as an encoding format, namely: encoding process s.find(x), decoding process s[x]. And directly replace the string it refers to by using the number of its encoded result, then the encryption process can be expressed by the following formula: - e = f + k1 +k2 e = f + k1 +k2 where e is ciphertext, f is plaintext, k1 and k2 are keys obtained by the copy method and of the same length as f, and addition is vector plus . So we only need to calculate the key by calculating k1+k2 and decrypt it. Decrypt the python script for this question: # exp2.py enc_str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} ' dec_dic = { k : v for v , k in enumerate ( enc_str )} encrypt = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9' flag_bg = 'SECCON{**************************}' Sim_key = [ dec_dic [ encrypt [ i ]] - dec_dic [ flag_bg [ i ]] for i in range ( 7 )] #crack the emulation key sim_key = sim_key + sim_key [:: - 1 ] Flag_ed = [ dec_dic [ v ] - sim_key [ k % 14 ] for k , v in enumerate ( encrypt )] #imitation key decryption flag_ed = '' . join ([ enc_str [ i % len ( enc_str )] for i in flag_ed ]) # \u89e3\u7801 print ( flag_ed ) Get the plain text as follows: $ python exp2.py SECCON { Welc0me_to_SECCON_CTF_2017 } The disappearing triple password \u00b6 Ciphertext or sit kggd sit qkt ygxk ortfzoeqs wqlatzwqssl qfr zvg ortfzoeqs yggzwqssl. fgv oy ngx vqfz so-called hxz zitd or gft soft.piv dgfn lgsxzogfl qkt zitkt? zohl: hstqlt eiqfut is ygkd gy is fxdwtk ngx utz.zit hkgukqddtkl! Use quipquip to decrypt directly.","title":"\u603b\u7ed3"},{"location":"crypto/ctf-wiki/classical/summary/#to-sum-up","text":"","title":"to sum up"},{"location":"crypto/ctf-wiki/classical/summary/#classical-password-analysis","text":"The questions about classical ciphers in CTF are usually based on ciphertext to obtain plaintext. Therefore, ciphertext attack is mostly used. The basic analysis ideas are summarized as follows: Determine the password type: according to the prompt, encryption method, ciphertext character set, cipher text display form and other information. Determine the attack method: including direct analysis, brute force attack, statistical analysis and other methods. For special passwords of unknown type, the appropriate attack method should be selected according to their password characteristics. Identify analysis tools: Focus on online password analysis tools and Python scripting tools, supplemented by offline cryptanalysis tools and manual analysis. The applicable scenarios and examples of the above ciphertext attack methods are as follows: Attack Methods Applicable Scenarios Examples Direct Analysis Method | The password for the mapping relationship can be determined by the password type | Caesar password, pig password, keyboard password, etc. | | Brute force attack method | Replacement password or replacement password with small key space | Shift password, fence password, etc. | | Statistical Analysis | Replacement passwords with large key spaces | Simple replacement passwords, affine passwords, Virginia passwords, etc. |","title":"Classical Password Analysis"},{"location":"crypto/ctf-wiki/classical/summary/#experiment-love-in-the-fence","text":"Description of the topic > I have been wondering about a question recently. Is QWE not equal to ABC? -.- .. --.- .-.. .-- - ..-. -.-. --.- --. -. ... --- --- > flag format: CTF{xxx} First of all, according to the password style, it is Moss code. After decryption, it gets KIQLWTFCQGNSOO . It doesn't look like flag. There are still fences and QWE in the end. It doesn&#39;t equal ABC . After both try it, It is found that QWE and then the fence can get the result. First, the keyboard QWE decrypts and tries to decrypt it to get IILYOAVNEBSAHR . Then the fence decrypts to get ILOVESHIYANBAR .","title":"Experiment, love in the fence"},{"location":"crypto/ctf-wiki/classical/summary/#2017-seccon-vigenere3d","text":"The procedure is as follows # Vigenere3d.py import sys def _l ( idx , s ): return s [ idx :] + s [: idx ] def main ( p , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 c = \"\" for a in p : c += t [ s . find ( a )][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] i1 = ( i1 + 1 ) % only ( k1 ) i2 = ( i2 + 1 ) % yen ( k2 ) return c print main ( sys . argv [ 1 ], sys . argv [ 2 ], sys . argv [ 2 ][:: - 1 ]) $ python Vigenere3d . py SECCON { *************************** ************** POR4dnyTLHBfwbxAAZhe }} ocZR3Cxcftw9 Solution 1 : First, let\u2019s first analyze the composition of t. $$ t[i][j]=s[i+j:]+s[:i+j] \\ t[i][k]=s[i+k:]+s[:i+k] $$ t[i][j][k] t[i][j][k] is the kth character in t[i][j] t[i][j] , t[i][k][j] t[i][k][j] is $t[i][k] The jth character in $. Whether i+j+k i+j+k exceeds len(s) is always consistent, ie t[i][j][k]=t[i][k][j] t[i][j][k]=t[i][k][j] . Therefore, in fact, for the same plaintext, there may be multiple keys to generate the same ciphertext. However, the above analysis is simply analysis, and the following begins. It is not difficult to see that each bit of the ciphertext is only related to the corresponding bit of the plaintext, and the space of each bit of the key is the size of s, so we can use the blast to obtain the key. Here, according to the above command line prompt, it can be known that the key length is 14, just the first 7 bytes of the plaintext are known. The recovery key exp is as follows def get_key ( plain , cipher ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 key = [ '*' ] * 14 for i in range ( len ( plain )): for i1 in range ( len ( s )): for i2 in range ( len ( s )): if t [ s . find ( plain [ i ])][ s . find ( s [ i1 ])][ s . find ( s [ i2 ])] == cipher [ i ]: key [ i ] = s [ i1 ] key [ 13 - i ] = s [ i2 ] return '' . join ( key ) The script to restore the plaintext is as follows def decrypt ( cipher , k1 , k2 ): s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} \" t = [[ _l (( i + j ) % len ( s ), s ) for j in range ( len ( s ))] for i in range ( len ( s ))] i1 = 0 i2 = 0 plain = \"\" for a in cipher : for i in range ( len ( s )): if t [ i ][ s . find ( k1 [ i1 ])][ s . find ( k2 [ i2 ])] == a : plain += s [ i ] break i1 = ( i1 + 1 ) % only ( k1 ) i2 = ( i2 + 1 ) % yen ( k2 ) return plain Get the plain text below \u279c 2017_seccon_vigenere3d git: ( master ) python exp.py SECCON { Welc0me_to_SECCON_CTF_2017 } Solution 2 Analysis of this question: Considering that the array access will not cross the boundary under normal program operation, we will make the following convention when discussing: arr[index] \\Leftrightarrow arr[index \\% len(arr)] arr[index] \\Leftrightarrow arr[index \\% len(arr)] For the _l function defined in the python program, find the following equivalence relationship: \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] \\_l(offset, arr)[index] \\Leftrightarrow arr[index + offset] For the definition of the three-dimensional matrix t in python's main function, find the following equivalence relation: t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] t[a][b][c] \\Leftrightarrow \\_l(a+b, s)[c] Based on the observation of the second point 3, there is the following equivalence relation: t[a][b][c] \\Leftrightarrow s[a+b+c] t[a][b][c] \\Leftrightarrow s[a+b+c] We consider s as an encoding format, namely: encoding process s.find(x), decoding process s[x]. And directly replace the string it refers to by using the number of its encoded result, then the encryption process can be expressed by the following formula: - e = f + k1 +k2 e = f + k1 +k2 where e is ciphertext, f is plaintext, k1 and k2 are keys obtained by the copy method and of the same length as f, and addition is vector plus . So we only need to calculate the key by calculating k1+k2 and decrypt it. Decrypt the python script for this question: # exp2.py enc_str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_ {} ' dec_dic = { k : v for v , k in enumerate ( enc_str )} encrypt = 'POR4dnyTLHBfwbxAAZhe}}ocZR3Cxcftw9' flag_bg = 'SECCON{**************************}' Sim_key = [ dec_dic [ encrypt [ i ]] - dec_dic [ flag_bg [ i ]] for i in range ( 7 )] #crack the emulation key sim_key = sim_key + sim_key [:: - 1 ] Flag_ed = [ dec_dic [ v ] - sim_key [ k % 14 ] for k , v in enumerate ( encrypt )] #imitation key decryption flag_ed = '' . join ([ enc_str [ i % len ( enc_str )] for i in flag_ed ]) # \u89e3\u7801 print ( flag_ed ) Get the plain text as follows: $ python exp2.py SECCON { Welc0me_to_SECCON_CTF_2017 }","title":"2017 SECCON Vigenere3d"},{"location":"crypto/ctf-wiki/classical/summary/#the-disappearing-triple-password","text":"Ciphertext or sit kggd sit qkt ygxk ortfzoeqs wqlatzwqssl qfr zvg ortfzoeqs yggzwqssl. fgv oy ngx vqfz so-called hxz zitd or gft soft.piv dgfn lgsxzogfl qkt zitkt? zohl: hstqlt eiqfut is ygkd gy is fxdwtk ngx utz.zit hkgukqddtkl! Use quipquip to decrypt directly.","title":"The disappearing triple password"},{"location":"crypto/ctf-wiki/hash/attack-zh/","text":"EN | ZH Hash Attack \u00b6 \u5e38\u89c1\u7684Hash\u51fd\u6570\u7684\u653b\u51fb\u65b9\u6cd5\u4e3b\u8981\u6709 \u66b4\u529b\u653b\u51fb\uff1a\u4e0d\u4f9d\u8d56\u4e8e\u4efb\u4f55\u7b97\u6cd5\u7ec6\u8282\uff0c\u4ec5\u4e0eHash\u503c\u957f\u5ea6\u6709\u5173\uff1b \u751f\u65e5\u653b\u51fb\u6cd5(Birthday Attack)\uff1a\u6ca1\u6709\u5229\u7528Hash\u51fd\u6570\u7684\u7ed3\u6784\u548c\u4efb\u4f55\u4ee3\u6570\u5f31\u6027\u8d28\uff0c\u53ea\u4f9d\u8d56\u4e8e\u6d88\u606f\u6458\u8981\u7684\u957f\u5ea6\uff0c\u5373Hash\u503c\u7684\u957f\u5ea6\u3002 \u4e2d\u70b9\u4ea4\u4f1a\u653b\u51fb\u6cd5(Meet-In-The-Middle)\uff1a\u662f\u751f\u65e5\u653b\u51fb\u7684\u4e00\u79cd\u53d8\u5f62\uff0c\u4e0d\u6bd4\u8f83Hash\u503c\uff0c\u800c\u662f\u6bd4\u8f83\u4e2d\u95f4\u53d8\u91cf\u3002\u8fd9\u79cd\u653b\u51fb\u4e3b\u8981\u9002\u7528\u4e8e\u653b\u51fb\u5177\u6709\u5206\u7ec4\u94fe\u7ed3\u6784\u7684Hash\u65b9\u6848\u3002 \u5bc6\u7801\u5206\u6790\uff1a\u4f9d\u8d56\u4e8e\u5177\u4f53\u7b97\u6cd5\u7684\u8bbe\u8ba1\u7f3a\u70b9\u3002 \u66b4\u529b\u653b\u51fb \u00b6 HashCat \u5de5\u5177 \u53ef\u4ee5\u8bf4\u662f\u76ee\u524d\u6700\u597d\u7684\u57fa\u4e8e CPU \u548c GPU \u7834\u89e3 Hash \u7684\u8f6f\u4ef6\uff0c\u76f8\u5173\u94fe\u63a5\u5982\u4e0b HashCat \u5b98\u7f51 HashCat \u7b80\u5355\u4f7f\u7528 \u54c8\u5e0c\u957f\u5ea6\u62d3\u5c55\u653b\u51fb\uff08hash length extension attacks\uff09 \u00b6 \u4ecb\u7ecd \u00b6 \u57fa\u672c\u5b9a\u4e49\u5982\u4e0b\uff0c\u6e90\u81ea \u7ef4\u57fa\u767e\u79d1 \u3002 \u54c8\u5e0c\u957f\u5ea6\u6269\u5c55\u653b\u51fb(Hash Length Extension Attacks)\u662f\u6307\u9488\u5bf9\u67d0\u4e9b\u5141\u8bb8\u5305\u542b\u989d\u5916\u4fe1\u606f\u7684\u52a0\u5bc6\u6563\u5217\u51fd\u6570\u7684\u653b\u51fb\u624b\u6bb5\u3002\u8be5\u653b\u51fb\u9002\u7528\u4e8e\u5728 \u6d88\u606f\u4e0e\u5bc6\u94a5\u7684\u957f\u5ea6\u5df2\u77e5 \u7684\u60c5\u5f62\u4e0b\uff0c\u6240\u6709\u91c7\u53d6\u4e86 H(key \u2225 message) \u6b64\u7c7b\u6784\u9020\u7684\u6563\u5217\u51fd\u6570\u3002MD5\u548cSHA-1 \u7b49\u57fa\u4e8e Merkle\u2013Damg\u00e5rd \u6784\u9020\u7684\u7b97\u6cd5\u5747\u5bf9\u6b64\u7c7b\u653b\u51fb\u663e\u793a\u51fa\u8106\u5f31\u6027\u3002 \u8fd9\u7c7b\u54c8\u5e0c\u51fd\u6570\u6709\u4ee5\u4e0b\u7279\u70b9 \u6d88\u606f\u586b\u5145\u65b9\u5f0f\u90fd\u6bd4\u8f83\u7c7b\u4f3c\uff0c\u9996\u5148\u5728\u6d88\u606f\u540e\u9762\u6dfb\u52a0\u4e00\u4e2a1\uff0c\u7136\u540e\u586b\u5145\u82e5\u5e72\u4e2a0\uff0c\u76f4\u81f3\u603b\u957f\u5ea6\u4e0e 448 \u540c\u4f59\uff0c\u6700\u540e\u5728\u5176\u540e\u9644\u4e0a64\u4f4d\u7684\u6d88\u606f\u957f\u5ea6\uff08\u586b\u5145\u524d\uff09\u3002 \u6bcf\u4e00\u5757\u5f97\u5230\u7684\u94fe\u63a5\u53d8\u91cf\u90fd\u4f1a\u88ab\u4f5c\u4e3a\u4e0b\u4e00\u6b21\u6267\u884chash\u51fd\u6570\u7684\u521d\u59cb\u5411\u91cfIV\u3002\u5728\u6700\u540e\u4e00\u5757\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u5c06\u5176\u5bf9\u5e94\u7684\u94fe\u63a5\u53d8\u91cf\u8f6c\u6362\u4e3ahash\u503c\u3002 \u4e00\u822c\u653b\u51fb\u65f6\u5e94\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6 \u6211\u4eec\u5df2\u77e5 key \u7684\u957f\u5ea6\uff0c\u5982\u679c\u4e0d\u77e5\u9053\u7684\u8bdd\uff0c\u9700\u8981\u7206\u7834\u51fa\u6765 \u6211\u4eec\u53ef\u4ee5\u63a7\u5236 message \u7684\u6d88\u606f\u3002 \u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u5305\u542b key \u7684\u4e00\u4e2a\u6d88\u606f\u7684hash\u503c\u3002 \u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230\u4e00\u5bf9(messge,x)\u6ee1\u8db3x=H(key \u2225 message)\u867d\u7136\u6211\u4eec\u5e76\u4e0d\u6e05\u695akey\u7684\u5185\u5bb9\u3002 \u653b\u51fb\u539f\u7406 \u00b6 \u8fd9\u91cc\u4e0d\u59a8\u5047\u8bbe\u6211\u4eec\u6211\u4eec\u77e5\u9053\u4e86 hash(key+s) \u7684 hash \u503c\uff0c\u5176\u4e2d s \u662f\u5df2\u77e5\u7684\uff0c\u90a3\u4e48\u5176\u672c\u8eab\u5728\u8ba1\u7b97\u7684\u65f6\u5019\uff0c\u5fc5\u7136\u4f1a\u8fdb\u884c\u586b\u5145\u3002\u90a3\u4e48\u6211\u4eec\u9996\u5148\u53ef\u4ee5\u5f97\u5230 key+s \u6269\u5c55\u540e\u7684\u5b57\u7b26\u4e32 now\uff0c\u5373 now=key|s|padding \u90a3\u4e48\u5982\u679c\u6211\u4eec\u5728 now \u7684\u540e\u9762\u518d\u6b21\u9644\u52a0\u4e0a\u4e00\u90e8\u5206\u4fe1\u606fextra\uff0c\u5373 key|s|padding|extra \u8fd9\u6837\u518d\u53bb\u8ba1\u7b97hash\u503c\u7684\u65f6\u5019\uff0c \u4f1a\u5bf9 extra \u8fdb\u884c\u586b\u5145\u76f4\u5230\u6ee1\u8db3\u6761\u4ef6\u3002 \u5148\u8ba1\u7b97 now \u5bf9\u5e94\u7684\u94fe\u63a5\u53d8\u91cf IV1\uff0c\u800c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u8fd9\u90e8\u5206\u7684 hash \u503c\uff0c\u5e76\u4e14\u94fe\u63a5\u53d8\u91cf\u4ea7\u751f hash \u503c\u7684\u7b97\u6cd5\u662f\u53ef\u9006\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u94fe\u63a5\u53d8\u91cf\u3002 \u4e0b\u9762\u4f1a\u6839\u636e\u5f97\u5230\u7684\u94fe\u63a5\u53d8\u91cf IV1\uff0c\u5bf9 extra \u90e8\u5206\u8fdb\u884c\u54c8\u5e0c\u7b97\u6cd5\uff0c\u5e76\u8fd4\u56dehash\u503c\u3002 \u90a3\u4e48\u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u7b2c\u4e00\u90e8\u5206\u7684 hash \u503c\uff0c\u5e76\u4e14\uff0c\u6211\u4eec\u8fd8\u77e5\u9053 extra \u7684\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u4fbf\u53ef\u4ee5\u5f97\u5230\u6700\u540e\u7684hash\u503c\u3002 \u800c\u4e4b\u524d\u6211\u4eec\u4e5f\u8bf4\u4e86\u6211\u4eec\u53ef\u4ee5\u63a7\u5236 message \u7684\u503c\u3002\u90a3\u4e48\u5176\u5b9e s\uff0cpadding\uff0cextra \u6211\u4eec\u90fd\u662f\u53ef\u4ee5\u63a7\u5236\u7684\u3002\u6240\u4ee5\u6211\u4eec\u81ea\u7136\u53ef\u4ee5\u627e\u5230\u5bf9\u5e94\u7684(message,x)\u6ee1\u8db3x=hash(key|message)\u3002 \u4f8b\u5b50 \u00b6 \u4f3c\u4e4e\u5927\u90fd\u662fweb\u91cc\u9762\u7684\uff0c\uff0c\u4e0d\u592a\u61c2web\uff0c\u6682\u65f6\u5148\u4e0d\u7ed9\u4f8b\u5b50\u4e86\u3002 \u5de5\u5177 \u00b6 hashpump \u5982\u4f55\u4f7f\u7528\u8bf7\u53c2\u8003github\u4e0a\u7684readme\u3002 hash\u7b97\u6cd5\u8bbe\u8ba1\u6709\u8bef \u00b6 \u4e00\u4e9b\u81ea\u5b9a\u4e49\u7684hash\u7b97\u6cd5\u53ef\u80fd\u662f\u53ef\u9006\u7684\u3002 Hashinator \u00b6 \u9898\u76ee\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u4ece\u4e00\u4e2a\u77e5\u540d\u7684\u5bc6\u7801\u5b57\u5178\"rockyou\"\u6311\u9009\u51fa\u4e00\u4e2a password \uff0c\u5e76\u4e14\u4f7f\u7528\u591a\u79cdhash\u7b97\u6cd5\u968f\u673a\u7684\u54c8\u5e0c32\u8f6e\u3002\u6211\u4eec\u9700\u8981\u4ece\u6700\u540e\u7684hash\u7ed3\u679c\u4e2d\u7834\u89e3\u51fa\u539f\u59cb\u7684 password \u3002 \u5206\u6790 \u00b6 \u9898\u76ee\u91c7\u7528\u7684hash\u7b97\u6cd5\u6709\uff1a md5 \uff0c sha1 \uff0c blake \uff0c scrypt \u3002 \u5173\u952e\u7684\u4ee3\u7801\u5982\u4e0b\uff1a password = self . generate_password () # from rock_you.txt salt = self . generate_salt ( password ) # \u4e0epassword\u7684\u957f\u5ea6\u6709\u5173 hash_rounds = self . generate_rounds () # \u751f\u6210\u8fdb\u884chash\u7b97\u6cd5\u7684\u987a\u5e8f password_hash = self . calculate_hash ( salt + password , hash_rounds ) 1. \u7a0b\u5e8f\u9996\u5148\u901a\u8fc7\u4ece rockyou.txt \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a password \uff0c\u4f5c\u4e3a\u52a0\u5bc6\u7684\u660e\u6587\u3002 2. \u7136\u540e\u6839\u636e\u62bd\u53d6\u7684 password \u7684\u957f\u5ea6\uff0c\u751f\u6210\u4e00\u4e2a\u957f\u5ea6\u4e3a 128 - len(password) \u7684 salt \u3002 3. \u4ece\u4e4b\u524d\u5217\u4e3e\u76844\u79cdhash\u7b97\u6cd5\u4e2d\u62bd\u53d6\uff0c\u7ec4\u621032\u8f6e\u7684\u54c8\u5e0c\u8fd0\u7b97\u3002 4. \u6839\u636e\u4e4b\u524d\u5f97\u5230\u7684 password \u3001 salt \u8ba1\u7b97\u51fa\u6700\u540e\u7ed9\u6211\u4eec\u7684 password_hash \u3002 \u5f88\u660e\u663e\uff0c\u6211\u4eec\u4e0d\u53ef\u80fd\u901a\u8fc7\u9006\u5411hash\u7b97\u6cd5\u6765\u5b8c\u6210\u9898\u76ee\u3002 \u6211\u4eec\u77e5\u9053\u6240\u6709\u7684\u53ef\u80fd\u7684\u660e\u6587\uff0c\u9996\u5148\u8003\u8651\u80fd\u5426\u901a\u8fc7\u6784\u9020\u5f69\u8679\u8868\u6765\u5b8c\u6210\u7a77\u4e3e\u3002\u4f46\u662f\u6ce8\u610f\u5230 generate_salt() \u51fd\u6570\u4e2d\uff0c salt \u548c password \u7684\u957f\u5ea6\u7ec4\u5408\u8d85\u8fc7\u4e86128byte\u7684\u957f\u5ea6\uff0c\u5e76\u4e14\u88ab\u6ce8\u91ca\u4e86 msize = 128 # f-you hashcat :D so\uff0c\u53ea\u80fd\u65e0\u5948\u653e\u5f03\u3002 \u90a3\u8fd9\u6837\u7684\u8bdd\uff0c\u53ea\u5b58\u5728\u4e00\u79cd\u53ef\u80fd\uff0c\u4e5f\u5373\u7b97\u6cd5\u53ef\u9006\u3002\u67e5\u770b calculate_hash() \u51fd\u6570\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u53ef\u4ee5\u53d1\u73b0\u5982\u4e0b\u53ef\u7591\u7684\u4ee3\u7801\uff1a for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) final_hash = interim_salt + interim_hash \u91cd\u65b0\u68b3\u7406\u4e00\u4e0b\u6211\u4eec\u77e5\u9053\u7684\u4fe1\u606f\uff1a 1. hash_rounds\u4e2d\u4fdd\u5b58\u4e8632\u8f6e\uff0c\u5373\u6bcf\u8f6e\u8981\u4f7f\u7528\u7684hash\u51fd\u6570\u53e5\u67c4\u3002 2. final_hash\u662f\u6700\u540e\u7ed9\u6211\u4eec\u7684hash\u7ed3\u679c\u3002 3. hash_rounds\u4e2d\u7684\u5185\u5bb9\u4e5f\u4f1a\u5728\u751f\u6210\u4e4b\u540e\u6253\u5370\u7ed9\u6211\u4eec\u3002 4. \u6211\u4eec\u5e0c\u671b\u5f97\u5230 interim_salt \u548c interim_hash \u5728\u7b2c\u4e00\u8f6e\u7684\u503c\u3002 5. interim_salt \u548c interim_hash \u7684\u957f\u5ea6\u5747\u4e3a64byte\u3002 \u4ed4\u7ec6\u89c2\u5bdf\u4e00\u4e0b interim_salt \u548c interim_hash \u7684\u8ba1\u7b97\u65b9\u6cd5\uff0c\u53ef\u4ee5\u53d1\u73b0\u5b83\u662f\u53ef\u9006\u7684\u3002 interim\\_hash_1 = interim\\_hash_2 \\oplus hash\\_rounds[i](interim\\_salt_3) interim\\_hash_1 = interim\\_hash_2 \\oplus hash\\_rounds[i](interim\\_salt_3) \u8fd9\u884c\u4ee3\u7801\u91cc\uff0c\u6211\u4eec\u5df2\u77e5 interim\\_hash_1 interim\\_hash_1 \u548c interim\\_salt_3 interim\\_salt_3 \uff0c\u7531\u6b64\u53ef\u4ee5\u63a8\u51fa interim\\_hash_2 interim\\_hash_2 \u7684\u503c\uff0c\u800c interim\\_hash_2 interim\\_hash_2 \u5219\u662f\u4e0a\u4e00\u8f6e\u7684 interim_hash \u3002 \u4ee5\u6b64\u65b9\u6cd5\u9006\u63a832\u6b21\uff0c\u5219\u53ef\u4ee5\u5f97\u5230\u6700\u521d\u7684 password \u548c salt \u3002 \u5177\u4f53\u7684\u89e3\u5bc6\u811a\u672c\u4e3a\uff1a import os import hashlib import socket import threading import socketserver import struct import time import threading # import pyscrypt from base64 import b64encode , b64decode from pwn import * def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1, dkLen=64) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) def main (): # io = socket.socket(family=socket.AF_INET) # io.connect(('47.88.216.38', 20013)) io = remote ( '47.88.216.38' , 20013 ) print ( io . recv ( 1000 )) ans_array = bytearray () while True : buf = io . recv ( 1 ) if buf : ans_array . extend ( buf ) if buf == b '!' : break password_hash_base64 = ans_array [ ans_array . find ( b \"b'\" ) + 2 : ans_array . find ( b \"' \\n \" )] password_hash = b64decode ( password_hash_base64 ) print ( 'password:' , password_hash ) method_bytes = ans_array [ ans_array . find ( b 'used: \\n ' ) + 6 : ans_array . find ( b ' \\n Your' ) ] methods = method_bytes . split ( b ' \\n ' ) methods = [ bytes ( x . strip ( b '- ' )) . decode () for x in methods ] print ( methods ) in_salt = password_hash [: 64 ] in_hash = password_hash [ 64 :] for pos , neg in zip ( methods , methods [:: - 1 ]): ''' interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash)) interim_hash = xor(interim_hash, hash_rounds[i](interim_salt)) ''' in_hash = xor ( in_hash , eval ( \" {} (in_salt)\" . format ( neg ))) in_salt = xor ( in_salt , eval ( \" {} (in_hash)\" . format ( pos ))) print ( in_hash , in_salt ) print ( in_hash [ - 20 :]) io . interactive () main () \u539fhash\u7b97\u6cd5 \u00b6 import os import hashlib import socket import threading import socketserver import struct import time # import pyscrypt from base64 import b64encode def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) class HashHandler ( socketserver . BaseRequestHandler ): welcome_message = \"\"\" Welcome, young wanna-be Cracker, to the Hashinator. To prove your worthiness, you must display the power of your cracking skills. The test is easy: 1. We send you a password from the rockyou list, hashed using multiple randomly chosen algorithms. 2. You crack the hash and send back the original password. As you already know the dictionary and won't need any fancy password rules, {} seconds should be plenty, right? Please wait while we generate your hash... \"\"\" hashes = [ md5 , sha , blake , scrypt ] timeout = 10 total_rounds = 32 def handle ( self ): self . request . sendall ( self . welcome_message . format ( self . timeout ) . encode ()) password = self . generate_password () # from rock_you.txt salt = self . generate_salt ( password ) # \u4e0epassword\u7684\u957f\u5ea6\u6709\u5173 hash_rounds = self . generate_rounds () # \u751f\u6210\u8fdb\u884chash\u7b97\u6cd5\u7684\u987a\u5e8f password_hash = self . calculate_hash ( salt + password , hash_rounds ) self . generate_delay () self . request . sendall ( \"Challenge password hash: {} \\n \" . format ( b64encode ( password_hash )) . encode ()) self . request . sendall ( \"Rounds used: \\n \" . encode ()) test_rounds = [] for r in hash_rounds : test_rounds . append ( r ) for r in hash_rounds : self . request . sendall ( \"- {} \\n \" . format ( r . __name__ ) . encode ()) self . request . sendall ( \"Your time starts now! \\n \" . encode ()) self . request . settimeout ( self . timeout ) try : response = self . request . recv ( 1024 ) if response . strip () == password : self . request . sendall ( \"Congratulations! You are a true cracking master! \\n \" . encode ()) self . request . sendall ( \"Welcome to the club: {} \\n \" . format ( flag ) . encode ()) return except socket . timeout : pass self . request . sendall ( \"Your cracking skills are bad, and you should feel bad!\" . encode ()) def generate_password ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] lines = 14344391 # size of rockyou line = rand % lines password = \"\" f = open ( 'rockyou.txt' , 'rb' ) for i in range ( line ): password = f . readline () return password . strip () def generate_salt ( self , p ): msize = 128 # f-you hashcat :D salt_size = msize - len ( p ) return os . urandom ( salt_size ) def generate_rounds ( self ): rand = struct . unpack ( \"Q\" , os . urandom ( 8 ))[ 0 ] rounds = [] for i in range ( self . total_rounds ): rounds . append ( self . hashes [ rand % len ( self . hashes )]) rand = rand >> 2 return rounds def calculate_hash ( self , payload , hash_rounds ): interim_salt = payload [: 64 ] interim_hash = payload [ 64 :] for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) ''' interim_hash = xor( interim_hash, hash_rounds[i]( xor(interim_salt, hash_rounds[-1-i](interim_hash)) ) ) ''' final_hash = interim_salt + interim_hash return final_hash def generate_delay ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] time . sleep ( rand / 1000000000.0 ) class ThreadedTCPServer ( socketserver . ThreadingMixIn , socketserver . TCPServer ): allow_reuse_address = True PORT = 1337 HOST = '0.0.0.0' flag = \"\" with open ( \"flag.txt\" ) as f : flag = f . read () def main (): server = ThreadedTCPServer (( HOST , PORT ), HashHandler ) server_thread = threading . Thread ( target = server . serve_forever ) server_thread . start () server_thread . join () if __name__ == \"__main__\" : main ()","title":"Attack zh"},{"location":"crypto/ctf-wiki/hash/attack-zh/#hash-attack","text":"\u5e38\u89c1\u7684Hash\u51fd\u6570\u7684\u653b\u51fb\u65b9\u6cd5\u4e3b\u8981\u6709 \u66b4\u529b\u653b\u51fb\uff1a\u4e0d\u4f9d\u8d56\u4e8e\u4efb\u4f55\u7b97\u6cd5\u7ec6\u8282\uff0c\u4ec5\u4e0eHash\u503c\u957f\u5ea6\u6709\u5173\uff1b \u751f\u65e5\u653b\u51fb\u6cd5(Birthday Attack)\uff1a\u6ca1\u6709\u5229\u7528Hash\u51fd\u6570\u7684\u7ed3\u6784\u548c\u4efb\u4f55\u4ee3\u6570\u5f31\u6027\u8d28\uff0c\u53ea\u4f9d\u8d56\u4e8e\u6d88\u606f\u6458\u8981\u7684\u957f\u5ea6\uff0c\u5373Hash\u503c\u7684\u957f\u5ea6\u3002 \u4e2d\u70b9\u4ea4\u4f1a\u653b\u51fb\u6cd5(Meet-In-The-Middle)\uff1a\u662f\u751f\u65e5\u653b\u51fb\u7684\u4e00\u79cd\u53d8\u5f62\uff0c\u4e0d\u6bd4\u8f83Hash\u503c\uff0c\u800c\u662f\u6bd4\u8f83\u4e2d\u95f4\u53d8\u91cf\u3002\u8fd9\u79cd\u653b\u51fb\u4e3b\u8981\u9002\u7528\u4e8e\u653b\u51fb\u5177\u6709\u5206\u7ec4\u94fe\u7ed3\u6784\u7684Hash\u65b9\u6848\u3002 \u5bc6\u7801\u5206\u6790\uff1a\u4f9d\u8d56\u4e8e\u5177\u4f53\u7b97\u6cd5\u7684\u8bbe\u8ba1\u7f3a\u70b9\u3002","title":"Hash Attack"},{"location":"crypto/ctf-wiki/hash/attack-zh/#_1","text":"HashCat \u5de5\u5177 \u53ef\u4ee5\u8bf4\u662f\u76ee\u524d\u6700\u597d\u7684\u57fa\u4e8e CPU \u548c GPU \u7834\u89e3 Hash \u7684\u8f6f\u4ef6\uff0c\u76f8\u5173\u94fe\u63a5\u5982\u4e0b HashCat \u5b98\u7f51 HashCat \u7b80\u5355\u4f7f\u7528","title":"\u66b4\u529b\u653b\u51fb"},{"location":"crypto/ctf-wiki/hash/attack-zh/#hash-length-extension-attacks","text":"","title":"\u54c8\u5e0c\u957f\u5ea6\u62d3\u5c55\u653b\u51fb\uff08hash length extension attacks\uff09"},{"location":"crypto/ctf-wiki/hash/attack-zh/#_2","text":"\u57fa\u672c\u5b9a\u4e49\u5982\u4e0b\uff0c\u6e90\u81ea \u7ef4\u57fa\u767e\u79d1 \u3002 \u54c8\u5e0c\u957f\u5ea6\u6269\u5c55\u653b\u51fb(Hash Length Extension Attacks)\u662f\u6307\u9488\u5bf9\u67d0\u4e9b\u5141\u8bb8\u5305\u542b\u989d\u5916\u4fe1\u606f\u7684\u52a0\u5bc6\u6563\u5217\u51fd\u6570\u7684\u653b\u51fb\u624b\u6bb5\u3002\u8be5\u653b\u51fb\u9002\u7528\u4e8e\u5728 \u6d88\u606f\u4e0e\u5bc6\u94a5\u7684\u957f\u5ea6\u5df2\u77e5 \u7684\u60c5\u5f62\u4e0b\uff0c\u6240\u6709\u91c7\u53d6\u4e86 H(key \u2225 message) \u6b64\u7c7b\u6784\u9020\u7684\u6563\u5217\u51fd\u6570\u3002MD5\u548cSHA-1 \u7b49\u57fa\u4e8e Merkle\u2013Damg\u00e5rd \u6784\u9020\u7684\u7b97\u6cd5\u5747\u5bf9\u6b64\u7c7b\u653b\u51fb\u663e\u793a\u51fa\u8106\u5f31\u6027\u3002 \u8fd9\u7c7b\u54c8\u5e0c\u51fd\u6570\u6709\u4ee5\u4e0b\u7279\u70b9 \u6d88\u606f\u586b\u5145\u65b9\u5f0f\u90fd\u6bd4\u8f83\u7c7b\u4f3c\uff0c\u9996\u5148\u5728\u6d88\u606f\u540e\u9762\u6dfb\u52a0\u4e00\u4e2a1\uff0c\u7136\u540e\u586b\u5145\u82e5\u5e72\u4e2a0\uff0c\u76f4\u81f3\u603b\u957f\u5ea6\u4e0e 448 \u540c\u4f59\uff0c\u6700\u540e\u5728\u5176\u540e\u9644\u4e0a64\u4f4d\u7684\u6d88\u606f\u957f\u5ea6\uff08\u586b\u5145\u524d\uff09\u3002 \u6bcf\u4e00\u5757\u5f97\u5230\u7684\u94fe\u63a5\u53d8\u91cf\u90fd\u4f1a\u88ab\u4f5c\u4e3a\u4e0b\u4e00\u6b21\u6267\u884chash\u51fd\u6570\u7684\u521d\u59cb\u5411\u91cfIV\u3002\u5728\u6700\u540e\u4e00\u5757\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u5c06\u5176\u5bf9\u5e94\u7684\u94fe\u63a5\u53d8\u91cf\u8f6c\u6362\u4e3ahash\u503c\u3002 \u4e00\u822c\u653b\u51fb\u65f6\u5e94\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6 \u6211\u4eec\u5df2\u77e5 key \u7684\u957f\u5ea6\uff0c\u5982\u679c\u4e0d\u77e5\u9053\u7684\u8bdd\uff0c\u9700\u8981\u7206\u7834\u51fa\u6765 \u6211\u4eec\u53ef\u4ee5\u63a7\u5236 message \u7684\u6d88\u606f\u3002 \u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u5305\u542b key \u7684\u4e00\u4e2a\u6d88\u606f\u7684hash\u503c\u3002 \u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230\u4e00\u5bf9(messge,x)\u6ee1\u8db3x=H(key \u2225 message)\u867d\u7136\u6211\u4eec\u5e76\u4e0d\u6e05\u695akey\u7684\u5185\u5bb9\u3002","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/hash/attack-zh/#_3","text":"\u8fd9\u91cc\u4e0d\u59a8\u5047\u8bbe\u6211\u4eec\u6211\u4eec\u77e5\u9053\u4e86 hash(key+s) \u7684 hash \u503c\uff0c\u5176\u4e2d s \u662f\u5df2\u77e5\u7684\uff0c\u90a3\u4e48\u5176\u672c\u8eab\u5728\u8ba1\u7b97\u7684\u65f6\u5019\uff0c\u5fc5\u7136\u4f1a\u8fdb\u884c\u586b\u5145\u3002\u90a3\u4e48\u6211\u4eec\u9996\u5148\u53ef\u4ee5\u5f97\u5230 key+s \u6269\u5c55\u540e\u7684\u5b57\u7b26\u4e32 now\uff0c\u5373 now=key|s|padding \u90a3\u4e48\u5982\u679c\u6211\u4eec\u5728 now \u7684\u540e\u9762\u518d\u6b21\u9644\u52a0\u4e0a\u4e00\u90e8\u5206\u4fe1\u606fextra\uff0c\u5373 key|s|padding|extra \u8fd9\u6837\u518d\u53bb\u8ba1\u7b97hash\u503c\u7684\u65f6\u5019\uff0c \u4f1a\u5bf9 extra \u8fdb\u884c\u586b\u5145\u76f4\u5230\u6ee1\u8db3\u6761\u4ef6\u3002 \u5148\u8ba1\u7b97 now \u5bf9\u5e94\u7684\u94fe\u63a5\u53d8\u91cf IV1\uff0c\u800c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u8fd9\u90e8\u5206\u7684 hash \u503c\uff0c\u5e76\u4e14\u94fe\u63a5\u53d8\u91cf\u4ea7\u751f hash \u503c\u7684\u7b97\u6cd5\u662f\u53ef\u9006\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u94fe\u63a5\u53d8\u91cf\u3002 \u4e0b\u9762\u4f1a\u6839\u636e\u5f97\u5230\u7684\u94fe\u63a5\u53d8\u91cf IV1\uff0c\u5bf9 extra \u90e8\u5206\u8fdb\u884c\u54c8\u5e0c\u7b97\u6cd5\uff0c\u5e76\u8fd4\u56dehash\u503c\u3002 \u90a3\u4e48\u65e2\u7136\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86\u7b2c\u4e00\u90e8\u5206\u7684 hash \u503c\uff0c\u5e76\u4e14\uff0c\u6211\u4eec\u8fd8\u77e5\u9053 extra \u7684\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u4fbf\u53ef\u4ee5\u5f97\u5230\u6700\u540e\u7684hash\u503c\u3002 \u800c\u4e4b\u524d\u6211\u4eec\u4e5f\u8bf4\u4e86\u6211\u4eec\u53ef\u4ee5\u63a7\u5236 message \u7684\u503c\u3002\u90a3\u4e48\u5176\u5b9e s\uff0cpadding\uff0cextra \u6211\u4eec\u90fd\u662f\u53ef\u4ee5\u63a7\u5236\u7684\u3002\u6240\u4ee5\u6211\u4eec\u81ea\u7136\u53ef\u4ee5\u627e\u5230\u5bf9\u5e94\u7684(message,x)\u6ee1\u8db3x=hash(key|message)\u3002","title":"\u653b\u51fb\u539f\u7406"},{"location":"crypto/ctf-wiki/hash/attack-zh/#_4","text":"\u4f3c\u4e4e\u5927\u90fd\u662fweb\u91cc\u9762\u7684\uff0c\uff0c\u4e0d\u592a\u61c2web\uff0c\u6682\u65f6\u5148\u4e0d\u7ed9\u4f8b\u5b50\u4e86\u3002","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/hash/attack-zh/#_5","text":"hashpump \u5982\u4f55\u4f7f\u7528\u8bf7\u53c2\u8003github\u4e0a\u7684readme\u3002","title":"\u5de5\u5177"},{"location":"crypto/ctf-wiki/hash/attack-zh/#hash","text":"\u4e00\u4e9b\u81ea\u5b9a\u4e49\u7684hash\u7b97\u6cd5\u53ef\u80fd\u662f\u53ef\u9006\u7684\u3002","title":"hash\u7b97\u6cd5\u8bbe\u8ba1\u6709\u8bef"},{"location":"crypto/ctf-wiki/hash/attack-zh/#hashinator","text":"\u9898\u76ee\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u4ece\u4e00\u4e2a\u77e5\u540d\u7684\u5bc6\u7801\u5b57\u5178\"rockyou\"\u6311\u9009\u51fa\u4e00\u4e2a password \uff0c\u5e76\u4e14\u4f7f\u7528\u591a\u79cdhash\u7b97\u6cd5\u968f\u673a\u7684\u54c8\u5e0c32\u8f6e\u3002\u6211\u4eec\u9700\u8981\u4ece\u6700\u540e\u7684hash\u7ed3\u679c\u4e2d\u7834\u89e3\u51fa\u539f\u59cb\u7684 password \u3002","title":"Hashinator"},{"location":"crypto/ctf-wiki/hash/attack-zh/#_6","text":"\u9898\u76ee\u91c7\u7528\u7684hash\u7b97\u6cd5\u6709\uff1a md5 \uff0c sha1 \uff0c blake \uff0c scrypt \u3002 \u5173\u952e\u7684\u4ee3\u7801\u5982\u4e0b\uff1a password = self . generate_password () # from rock_you.txt salt = self . generate_salt ( password ) # \u4e0epassword\u7684\u957f\u5ea6\u6709\u5173 hash_rounds = self . generate_rounds () # \u751f\u6210\u8fdb\u884chash\u7b97\u6cd5\u7684\u987a\u5e8f password_hash = self . calculate_hash ( salt + password , hash_rounds ) 1. \u7a0b\u5e8f\u9996\u5148\u901a\u8fc7\u4ece rockyou.txt \u4e2d\u968f\u673a\u62bd\u53d6\u4e00\u4e2a password \uff0c\u4f5c\u4e3a\u52a0\u5bc6\u7684\u660e\u6587\u3002 2. \u7136\u540e\u6839\u636e\u62bd\u53d6\u7684 password \u7684\u957f\u5ea6\uff0c\u751f\u6210\u4e00\u4e2a\u957f\u5ea6\u4e3a 128 - len(password) \u7684 salt \u3002 3. \u4ece\u4e4b\u524d\u5217\u4e3e\u76844\u79cdhash\u7b97\u6cd5\u4e2d\u62bd\u53d6\uff0c\u7ec4\u621032\u8f6e\u7684\u54c8\u5e0c\u8fd0\u7b97\u3002 4. \u6839\u636e\u4e4b\u524d\u5f97\u5230\u7684 password \u3001 salt \u8ba1\u7b97\u51fa\u6700\u540e\u7ed9\u6211\u4eec\u7684 password_hash \u3002 \u5f88\u660e\u663e\uff0c\u6211\u4eec\u4e0d\u53ef\u80fd\u901a\u8fc7\u9006\u5411hash\u7b97\u6cd5\u6765\u5b8c\u6210\u9898\u76ee\u3002 \u6211\u4eec\u77e5\u9053\u6240\u6709\u7684\u53ef\u80fd\u7684\u660e\u6587\uff0c\u9996\u5148\u8003\u8651\u80fd\u5426\u901a\u8fc7\u6784\u9020\u5f69\u8679\u8868\u6765\u5b8c\u6210\u7a77\u4e3e\u3002\u4f46\u662f\u6ce8\u610f\u5230 generate_salt() \u51fd\u6570\u4e2d\uff0c salt \u548c password \u7684\u957f\u5ea6\u7ec4\u5408\u8d85\u8fc7\u4e86128byte\u7684\u957f\u5ea6\uff0c\u5e76\u4e14\u88ab\u6ce8\u91ca\u4e86 msize = 128 # f-you hashcat :D so\uff0c\u53ea\u80fd\u65e0\u5948\u653e\u5f03\u3002 \u90a3\u8fd9\u6837\u7684\u8bdd\uff0c\u53ea\u5b58\u5728\u4e00\u79cd\u53ef\u80fd\uff0c\u4e5f\u5373\u7b97\u6cd5\u53ef\u9006\u3002\u67e5\u770b calculate_hash() \u51fd\u6570\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u53ef\u4ee5\u53d1\u73b0\u5982\u4e0b\u53ef\u7591\u7684\u4ee3\u7801\uff1a for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) final_hash = interim_salt + interim_hash \u91cd\u65b0\u68b3\u7406\u4e00\u4e0b\u6211\u4eec\u77e5\u9053\u7684\u4fe1\u606f\uff1a 1. hash_rounds\u4e2d\u4fdd\u5b58\u4e8632\u8f6e\uff0c\u5373\u6bcf\u8f6e\u8981\u4f7f\u7528\u7684hash\u51fd\u6570\u53e5\u67c4\u3002 2. final_hash\u662f\u6700\u540e\u7ed9\u6211\u4eec\u7684hash\u7ed3\u679c\u3002 3. hash_rounds\u4e2d\u7684\u5185\u5bb9\u4e5f\u4f1a\u5728\u751f\u6210\u4e4b\u540e\u6253\u5370\u7ed9\u6211\u4eec\u3002 4. \u6211\u4eec\u5e0c\u671b\u5f97\u5230 interim_salt \u548c interim_hash \u5728\u7b2c\u4e00\u8f6e\u7684\u503c\u3002 5. interim_salt \u548c interim_hash \u7684\u957f\u5ea6\u5747\u4e3a64byte\u3002 \u4ed4\u7ec6\u89c2\u5bdf\u4e00\u4e0b interim_salt \u548c interim_hash \u7684\u8ba1\u7b97\u65b9\u6cd5\uff0c\u53ef\u4ee5\u53d1\u73b0\u5b83\u662f\u53ef\u9006\u7684\u3002 interim\\_hash_1 = interim\\_hash_2 \\oplus hash\\_rounds[i](interim\\_salt_3) interim\\_hash_1 = interim\\_hash_2 \\oplus hash\\_rounds[i](interim\\_salt_3) \u8fd9\u884c\u4ee3\u7801\u91cc\uff0c\u6211\u4eec\u5df2\u77e5 interim\\_hash_1 interim\\_hash_1 \u548c interim\\_salt_3 interim\\_salt_3 \uff0c\u7531\u6b64\u53ef\u4ee5\u63a8\u51fa interim\\_hash_2 interim\\_hash_2 \u7684\u503c\uff0c\u800c interim\\_hash_2 interim\\_hash_2 \u5219\u662f\u4e0a\u4e00\u8f6e\u7684 interim_hash \u3002 \u4ee5\u6b64\u65b9\u6cd5\u9006\u63a832\u6b21\uff0c\u5219\u53ef\u4ee5\u5f97\u5230\u6700\u521d\u7684 password \u548c salt \u3002 \u5177\u4f53\u7684\u89e3\u5bc6\u811a\u672c\u4e3a\uff1a import os import hashlib import socket import threading import socketserver import struct import time import threading # import pyscrypt from base64 import b64encode , b64decode from pwn import * def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1, dkLen=64) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) def main (): # io = socket.socket(family=socket.AF_INET) # io.connect(('47.88.216.38', 20013)) io = remote ( '47.88.216.38' , 20013 ) print ( io . recv ( 1000 )) ans_array = bytearray () while True : buf = io . recv ( 1 ) if buf : ans_array . extend ( buf ) if buf == b '!' : break password_hash_base64 = ans_array [ ans_array . find ( b \"b'\" ) + 2 : ans_array . find ( b \"' \\n \" )] password_hash = b64decode ( password_hash_base64 ) print ( 'password:' , password_hash ) method_bytes = ans_array [ ans_array . find ( b 'used: \\n ' ) + 6 : ans_array . find ( b ' \\n Your' ) ] methods = method_bytes . split ( b ' \\n ' ) methods = [ bytes ( x . strip ( b '- ' )) . decode () for x in methods ] print ( methods ) in_salt = password_hash [: 64 ] in_hash = password_hash [ 64 :] for pos , neg in zip ( methods , methods [:: - 1 ]): ''' interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash)) interim_hash = xor(interim_hash, hash_rounds[i](interim_salt)) ''' in_hash = xor ( in_hash , eval ( \" {} (in_salt)\" . format ( neg ))) in_salt = xor ( in_salt , eval ( \" {} (in_hash)\" . format ( pos ))) print ( in_hash , in_salt ) print ( in_hash [ - 20 :]) io . interactive () main ()","title":"\u5206\u6790"},{"location":"crypto/ctf-wiki/hash/attack-zh/#hash_1","text":"import os import hashlib import socket import threading import socketserver import struct import time # import pyscrypt from base64 import b64encode def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) class HashHandler ( socketserver . BaseRequestHandler ): welcome_message = \"\"\" Welcome, young wanna-be Cracker, to the Hashinator. To prove your worthiness, you must display the power of your cracking skills. The test is easy: 1. We send you a password from the rockyou list, hashed using multiple randomly chosen algorithms. 2. You crack the hash and send back the original password. As you already know the dictionary and won't need any fancy password rules, {} seconds should be plenty, right? Please wait while we generate your hash... \"\"\" hashes = [ md5 , sha , blake , scrypt ] timeout = 10 total_rounds = 32 def handle ( self ): self . request . sendall ( self . welcome_message . format ( self . timeout ) . encode ()) password = self . generate_password () # from rock_you.txt salt = self . generate_salt ( password ) # \u4e0epassword\u7684\u957f\u5ea6\u6709\u5173 hash_rounds = self . generate_rounds () # \u751f\u6210\u8fdb\u884chash\u7b97\u6cd5\u7684\u987a\u5e8f password_hash = self . calculate_hash ( salt + password , hash_rounds ) self . generate_delay () self . request . sendall ( \"Challenge password hash: {} \\n \" . format ( b64encode ( password_hash )) . encode ()) self . request . sendall ( \"Rounds used: \\n \" . encode ()) test_rounds = [] for r in hash_rounds : test_rounds . append ( r ) for r in hash_rounds : self . request . sendall ( \"- {} \\n \" . format ( r . __name__ ) . encode ()) self . request . sendall ( \"Your time starts now! \\n \" . encode ()) self . request . settimeout ( self . timeout ) try : response = self . request . recv ( 1024 ) if response . strip () == password : self . request . sendall ( \"Congratulations! You are a true cracking master! \\n \" . encode ()) self . request . sendall ( \"Welcome to the club: {} \\n \" . format ( flag ) . encode ()) return except socket . timeout : pass self . request . sendall ( \"Your cracking skills are bad, and you should feel bad!\" . encode ()) def generate_password ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] lines = 14344391 # size of rockyou line = rand % lines password = \"\" f = open ( 'rockyou.txt' , 'rb' ) for i in range ( line ): password = f . readline () return password . strip () def generate_salt ( self , p ): msize = 128 # f-you hashcat :D salt_size = msize - len ( p ) return os . urandom ( salt_size ) def generate_rounds ( self ): rand = struct . unpack ( \"Q\" , os . urandom ( 8 ))[ 0 ] rounds = [] for i in range ( self . total_rounds ): rounds . append ( self . hashes [ rand % len ( self . hashes )]) rand = rand >> 2 return rounds def calculate_hash ( self , payload , hash_rounds ): interim_salt = payload [: 64 ] interim_hash = payload [ 64 :] for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) ''' interim_hash = xor( interim_hash, hash_rounds[i]( xor(interim_salt, hash_rounds[-1-i](interim_hash)) ) ) ''' final_hash = interim_salt + interim_hash return final_hash def generate_delay ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] time . sleep ( rand / 1000000000.0 ) class ThreadedTCPServer ( socketserver . ThreadingMixIn , socketserver . TCPServer ): allow_reuse_address = True PORT = 1337 HOST = '0.0.0.0' flag = \"\" with open ( \"flag.txt\" ) as f : flag = f . read () def main (): server = ThreadedTCPServer (( HOST , PORT ), HashHandler ) server_thread = threading . Thread ( target = server . serve_forever ) server_thread . start () server_thread . join () if __name__ == \"__main__\" : main ()","title":"\u539fhash\u7b97\u6cd5"},{"location":"crypto/ctf-wiki/hash/attack/","text":"EN | ZH Hash Attack \u00b6 Common hash function attack methods are mainly Violent attack: does not depend on any algorithm details, only related to the length of the hash value; Birthday Attack: The structure and any algebraic weak nature of the hash function are not used, depending only on the length of the message digest, which is the length of the hash value. Meet-In-The-Middle: It is a variant of a birthday attack. Instead of comparing hash values, it compares intermediate variables. This type of attack is mainly used to attack Hash schemes with a packet chain structure. Password analysis: Depends on the design shortcomings of specific algorithms. violent attack \u00b6 HashCat tool can be said to be the best CPU and GPU-based cracking Hash software, the related links are as follows [HashCat official website] ( http://www.hashcat.net/hashcat/ ) [HashCat Simple to use] ( http://www.freebuf.com/sectool/112479.html ) hash length extension attacks \u00b6 Introduction \u00b6 The basic definition is as follows, from [Wikipedia] ( https://en.wikipedia.org/wiki/%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6 % 94% BB% E5% 87% BB). Hash Length Extension Attacks are pointers to certain cryptographic hash functions that allow additional information. This attack applies to all hash functions that take the H(key \u2225 message) construct in the case where the length of the message and the key is known . Algorithms based on the Merkle\u2013Damg\u00e5rd constructs such as MD5 and SHA-1 show vulnerabilities to such attacks. This type of hash function has the following characteristics The message padding method is similar. First, add a 1 after the message, then fill in a number of 0s until the total length is congruent with 448, and finally attach a 64-bit message length (before filling). Each link variable obtained will be used as the initial vector IV for the next execution of the hash function. In the last block, the corresponding link variable will be converted to a hash value. The following conditions should be met during a general attack. We know the length of the key, if you don't know, you need to burst it out. We can control the message of the message. We already know the hash value of a message containing a key. So we can get a pair (messge, x) to satisfy x = H (key \u2225 message) although we are not sure about the contents of the key. Attack principle \u00b6 Here we can assume that we know the hash value of hash(key+s), where s is known, then it will be filled when it is calculated. Then we can first get the key+s extended by key+s, ie now=key|s|padding Then if we attach a part of the information extra after the now, ie key|s|padding|extra When you go to calculate the hash value, The extra is filled until the condition is met. Calculate the link variable IV1 corresponding to now, and we already know the hash value of this part, and the algorithm that the link variable produces the hash value is reversible, so we can get the link variable. The hash algorithm is performed on the extra part according to the obtained link variable IV1, and the hash value is returned. So now that we know the hash value of the first part, and we also know the value of extra, then we can get the last hash value. And before we said that we can control the value of the message. So in fact, s, padding, extra, we can all control. So we can naturally find the corresponding (message, x) to satisfy x = hash (key | mesage). Examples \u00b6 It seems that most of them are inside the web, and I don't know much about the web. I will not give examples for the time being. Tools \u00b6 hashpump Please refer to the readme on github for how to use it. hash algorithm is incorrectly designed \u00b6 Some custom hash algorithms may be reversible. Hashinator \u00b6 The logic of the topic is very simple. Pick a password from a well-known password dictionary \"rockyou\" and use a variety of hash algorithms to randomly hash 32 rounds. We need to crack the original password from the final hash result. Analysis \u00b6 The hash algorithms used in the title are: md5 , sha1 , blake , scrypt . The key code is as follows: password = self . generate_password () # from rock_you.txt Salt = self . generate_salt ( password ) # related to the length of the password Hash_rounds = self . generate_rounds () # Generate the order in which the hash algorithm is executed password_hash = self . calculate_hash ( salt + password , hash_rounds ) The program first randomly extracts a password from rockyou.txt as the encrypted plaintext. Then generate a salt of length 128 - len(password) based on the length of the extracted password . Extract from the four hash algorithms listed above to form 32 rounds of hash operations. Calculate the last password_hash given to us based on the previously obtained password , salt . Obviously, we can't complete the problem by the inverse hash algorithm. We know all the possible plaintexts, first considering whether we can complete the exhaustion by constructing a rainbow table. But notice that in the generate_salt() function, the length combination of salt and password exceeds the length of 128 bytes and is annotated. msize = 128 # f-you hashcat :D So, can only helplessly give up. In that case, there is only one possibility, that is, the algorithm is reversible. Looking at the concrete implementation of the calculate_hash() function, you can find the following suspicious code: for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) final_hash = interim_salt + interim_hash Reorganize the information we know: 1. There are 32 rounds stored in hash_rounds, which is the hash function handle to be used in each round. 2. final_hash is the last hash result for us. 3. The contents of hash_rounds will also be printed to us after generation. 4. We want to get the values of interim_salt and interim_hash in the first round. 5. interim_salt and interim_hash are both 64bytes in length. A closer look at the calculations of interim_salt and interim_hash reveals that it is reversible. $$ interim_hash_1 = interim_hash_2 \\oplus hash_rounds i $$ In this line of code, we know interim\\_hash_1 interim\\_hash_1 and interim\\_salt_3 interim\\_salt_3 , so we can get the value of interim\\_hash_2 interim\\_hash_2 , and interim\\_hash_2 interim\\_hash_2 is the last round of interim_hash . By pushing back 32 times in this way, you can get the initial password and salt . The specific decryption script is: import import hashlib import socket import threading import socketserver import struct import time import threading # import pyscrypt from base64 import b64encode , b64decode from pwn import * def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1, dkLen=64) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) def main (): # io = socket.socket (family = socket.AF_INET) # io.connect ((&#39;47.88.216.38&#39;, 20013)) io = remote ( & #39;47 .88.216.38 &#39;, 20013) print ( io . recv ( 1000 )) ans_array = bytearray () while True : buf = io . recv ( 1 ) if buf : ans_array . extend ( buf ) if buf == b '!' : break password_hash_base64 = ans_array [ ans_array . find ( b \"b'\" ) + 2 : ans_array . find ( b \"' \\n \" )] password_hash = b64decode ( password_hash_base64 ) print ( 'password:' , password_hash ) method_bytes = ans_array [ ans_array . find ( b 'used: \\n ' ) + 6 : ans_array . find ( b ' \\n Your' ) ] methods = method_bytes . split ( b ' \\n ' ) methods = [ bytes ( x . strip ( b '- ' )) . decode () for x in methods ] print ( methods ) in_salt = password_hash [: 64 ] in_hash = password_hash [ 64 :] for pos , neg in zip ( methods , methods [:: - 1 ]): ''' interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash)) interim_hash = xor(interim_hash, hash_rounds[i](interim_salt)) ''' in_hash = xor ( in_hash , eval ( \" {} (in_salt)\" . format ( neg ))) in_salt = xor ( in_salt , eval ( \" {} (in_hash)\" . format ( pos ))) print ( in_hash , in_salt ) print ( in_hash [ - 20 :]) io . interactive () main () Original hash algorithm \u00b6 import import hashlib import socket import threading import socketserver import struct import time # import pyscrypt from base64 import b64encode def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) class HashHandler ( socketserver . BaseRequestHandler ): welcome_message = \"\"\" Welcome, young wanna-be Cracker, to the Hashinator. To prove your worthiness, you must display the power of your cracking skills. The test is easy: 1. We send you a password from the rockyou list, hashed using multiple randomly chosen algorithms. 2. You crack the hash and send back the original password. As you already know the dictionary and won't need any fancy password rules, {} seconds should be plenty, right? Please wait while we generate your hash... \"\"\" hashes = [ md5 , sha , blake , scrypt ] timeout = 10 total_rounds = 32 def handle ( self ): self . request . sendall ( self . welcome_message . format ( self . timeout ) . encode ()) password = self . generate_password () # from rock_you.txt Salt = self . generate_salt ( password ) # related to the length of the password Hash_rounds = self . generate_rounds () # Generate the order in which the hash algorithm is executed password_hash = self . calculate_hash ( salt + password , hash_rounds ) self . generate_delay () self . request . sendall ( \"Challenge password hash: {} \\n \" . format ( b64encode ( password_hash )) . encode ()) self . request . sendall ( \"Rounds used: \\n \" . encode ()) test_rounds = [] for r in hash_rounds : test_rounds . append ( r ) for r in hash_rounds : self . request . sendall ( \"- {} \\n \" . format ( r . __name__ ) . encode ()) self . request . sendall ( \"Your time starts now! \\n \" . encode ()) self . request . settimeout ( self . timeout ) try : response = self . request . recv ( 1024 ) if response . strip () == password : self . request . sendall ( \"Congratulations! You are a true cracking master! \\n \" . encode ()) self . request . sendall ( \"Welcome to the club: {} \\n \" . format ( flag ) . encode ()) return except socket . timeout : pass self . request . sendall ( \"Your cracking skills are bad, and you should feel bad!\" . encode ()) def generate_password ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] lines = 14344391 # size of rockyou line = rand % lines password = \"\" f = open ( 'rockyou.txt' , 'rb' ) for i in range ( line ): password = f . readline () return password . strip () def generate_salt ( self , p ): msize = 128 # f-you hashcat :D salt_size = msize - len ( p ) return os . urandom ( salt_size ) def generate_rounds ( self ): rand = struct . unpack ( \"Q\" , os . urandom ( 8 ))[ 0 ] rounds = [] for i in range ( self . total_rounds ): rounds . append ( self . hashes [ rand % len ( self . hashes )]) rand = rand & gt ; & gt ; 2 return rounds def calculate_hash ( self , payload , hash_rounds ): interim_salt = payload [: 64 ] interim_hash = payload [ 64 :] for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) ''' interim_hash = xor( interim_hash, hash_rounds[i]( xor(interim_salt, hash_rounds[-1-i](interim_hash)) ) ) ''' final_hash = interim_salt + interim_hash return final_hash def generate_delay ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] time . sleep ( rand / 1000000000.0 ) class ThreadedTCPServer ( socketserver . ThreadingMixIn , socketserver . TCPServer ): allow_reuse_address = True PORT = 1337 HOST = '0.0.0.0' flag = \"\" with open ( \"flag.txt\" ) as f : flag = f . read () def main (): server = ThreadedTCPServer (( HOST , PORT ), HashHandler ) server_thread = threading . Thread ( target = server . serve_forever ) server_thread . start () server_thread . join () if __name__ == \"__main__\" : main ()","title":"Hash Attack"},{"location":"crypto/ctf-wiki/hash/attack/#hash-attack","text":"Common hash function attack methods are mainly Violent attack: does not depend on any algorithm details, only related to the length of the hash value; Birthday Attack: The structure and any algebraic weak nature of the hash function are not used, depending only on the length of the message digest, which is the length of the hash value. Meet-In-The-Middle: It is a variant of a birthday attack. Instead of comparing hash values, it compares intermediate variables. This type of attack is mainly used to attack Hash schemes with a packet chain structure. Password analysis: Depends on the design shortcomings of specific algorithms.","title":"Hash Attack"},{"location":"crypto/ctf-wiki/hash/attack/#violent-attack","text":"HashCat tool can be said to be the best CPU and GPU-based cracking Hash software, the related links are as follows [HashCat official website] ( http://www.hashcat.net/hashcat/ ) [HashCat Simple to use] ( http://www.freebuf.com/sectool/112479.html )","title":"violent attack"},{"location":"crypto/ctf-wiki/hash/attack/#hash-length-extension-attacks","text":"","title":"hash length extension attacks"},{"location":"crypto/ctf-wiki/hash/attack/#introduction","text":"The basic definition is as follows, from [Wikipedia] ( https://en.wikipedia.org/wiki/%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6 % 94% BB% E5% 87% BB). Hash Length Extension Attacks are pointers to certain cryptographic hash functions that allow additional information. This attack applies to all hash functions that take the H(key \u2225 message) construct in the case where the length of the message and the key is known . Algorithms based on the Merkle\u2013Damg\u00e5rd constructs such as MD5 and SHA-1 show vulnerabilities to such attacks. This type of hash function has the following characteristics The message padding method is similar. First, add a 1 after the message, then fill in a number of 0s until the total length is congruent with 448, and finally attach a 64-bit message length (before filling). Each link variable obtained will be used as the initial vector IV for the next execution of the hash function. In the last block, the corresponding link variable will be converted to a hash value. The following conditions should be met during a general attack. We know the length of the key, if you don't know, you need to burst it out. We can control the message of the message. We already know the hash value of a message containing a key. So we can get a pair (messge, x) to satisfy x = H (key \u2225 message) although we are not sure about the contents of the key.","title":"Introduction"},{"location":"crypto/ctf-wiki/hash/attack/#attack-principle","text":"Here we can assume that we know the hash value of hash(key+s), where s is known, then it will be filled when it is calculated. Then we can first get the key+s extended by key+s, ie now=key|s|padding Then if we attach a part of the information extra after the now, ie key|s|padding|extra When you go to calculate the hash value, The extra is filled until the condition is met. Calculate the link variable IV1 corresponding to now, and we already know the hash value of this part, and the algorithm that the link variable produces the hash value is reversible, so we can get the link variable. The hash algorithm is performed on the extra part according to the obtained link variable IV1, and the hash value is returned. So now that we know the hash value of the first part, and we also know the value of extra, then we can get the last hash value. And before we said that we can control the value of the message. So in fact, s, padding, extra, we can all control. So we can naturally find the corresponding (message, x) to satisfy x = hash (key | mesage).","title":"Attack principle"},{"location":"crypto/ctf-wiki/hash/attack/#examples","text":"It seems that most of them are inside the web, and I don't know much about the web. I will not give examples for the time being.","title":"Examples"},{"location":"crypto/ctf-wiki/hash/attack/#tools","text":"hashpump Please refer to the readme on github for how to use it.","title":"Tools"},{"location":"crypto/ctf-wiki/hash/attack/#hash-algorithm-is-incorrectly-designed","text":"Some custom hash algorithms may be reversible.","title":"hash algorithm is incorrectly designed"},{"location":"crypto/ctf-wiki/hash/attack/#hashinator","text":"The logic of the topic is very simple. Pick a password from a well-known password dictionary \"rockyou\" and use a variety of hash algorithms to randomly hash 32 rounds. We need to crack the original password from the final hash result.","title":"Hashinator"},{"location":"crypto/ctf-wiki/hash/attack/#analysis","text":"The hash algorithms used in the title are: md5 , sha1 , blake , scrypt . The key code is as follows: password = self . generate_password () # from rock_you.txt Salt = self . generate_salt ( password ) # related to the length of the password Hash_rounds = self . generate_rounds () # Generate the order in which the hash algorithm is executed password_hash = self . calculate_hash ( salt + password , hash_rounds ) The program first randomly extracts a password from rockyou.txt as the encrypted plaintext. Then generate a salt of length 128 - len(password) based on the length of the extracted password . Extract from the four hash algorithms listed above to form 32 rounds of hash operations. Calculate the last password_hash given to us based on the previously obtained password , salt . Obviously, we can't complete the problem by the inverse hash algorithm. We know all the possible plaintexts, first considering whether we can complete the exhaustion by constructing a rainbow table. But notice that in the generate_salt() function, the length combination of salt and password exceeds the length of 128 bytes and is annotated. msize = 128 # f-you hashcat :D So, can only helplessly give up. In that case, there is only one possibility, that is, the algorithm is reversible. Looking at the concrete implementation of the calculate_hash() function, you can find the following suspicious code: for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) final_hash = interim_salt + interim_hash Reorganize the information we know: 1. There are 32 rounds stored in hash_rounds, which is the hash function handle to be used in each round. 2. final_hash is the last hash result for us. 3. The contents of hash_rounds will also be printed to us after generation. 4. We want to get the values of interim_salt and interim_hash in the first round. 5. interim_salt and interim_hash are both 64bytes in length. A closer look at the calculations of interim_salt and interim_hash reveals that it is reversible. $$ interim_hash_1 = interim_hash_2 \\oplus hash_rounds i $$ In this line of code, we know interim\\_hash_1 interim\\_hash_1 and interim\\_salt_3 interim\\_salt_3 , so we can get the value of interim\\_hash_2 interim\\_hash_2 , and interim\\_hash_2 interim\\_hash_2 is the last round of interim_hash . By pushing back 32 times in this way, you can get the initial password and salt . The specific decryption script is: import import hashlib import socket import threading import socketserver import struct import time import threading # import pyscrypt from base64 import b64encode , b64decode from pwn import * def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1, dkLen=64) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) def main (): # io = socket.socket (family = socket.AF_INET) # io.connect ((&#39;47.88.216.38&#39;, 20013)) io = remote ( & #39;47 .88.216.38 &#39;, 20013) print ( io . recv ( 1000 )) ans_array = bytearray () while True : buf = io . recv ( 1 ) if buf : ans_array . extend ( buf ) if buf == b '!' : break password_hash_base64 = ans_array [ ans_array . find ( b \"b'\" ) + 2 : ans_array . find ( b \"' \\n \" )] password_hash = b64decode ( password_hash_base64 ) print ( 'password:' , password_hash ) method_bytes = ans_array [ ans_array . find ( b 'used: \\n ' ) + 6 : ans_array . find ( b ' \\n Your' ) ] methods = method_bytes . split ( b ' \\n ' ) methods = [ bytes ( x . strip ( b '- ' )) . decode () for x in methods ] print ( methods ) in_salt = password_hash [: 64 ] in_hash = password_hash [ 64 :] for pos , neg in zip ( methods , methods [:: - 1 ]): ''' interim_salt = xor(interim_salt, hash_rounds[-1-i](interim_hash)) interim_hash = xor(interim_hash, hash_rounds[i](interim_salt)) ''' in_hash = xor ( in_hash , eval ( \" {} (in_salt)\" . format ( neg ))) in_salt = xor ( in_salt , eval ( \" {} (in_hash)\" . format ( pos ))) print ( in_hash , in_salt ) print ( in_hash [ - 20 :]) io . interactive () main ()","title":"Analysis"},{"location":"crypto/ctf-wiki/hash/attack/#original-hash-algorithm","text":"import import hashlib import socket import threading import socketserver import struct import time # import pyscrypt from base64 import b64encode def md5 ( bytestring ): return hashlib . md5 ( bytestring ) . digest () def sha ( bytestring ): return hashlib . sha1 ( bytestring ) . digest () def blake ( bytestring ): return hashlib . blake2b ( bytestring ) . digest () def scrypt ( bytestring ): l = int ( len ( bytestring ) / 2 ) salt = bytestring [: l ] p = bytestring [ l :] return hashlib . scrypt ( p , salt = salt , n = 2 ** 16 , r = 8 , p = 1 , maxmem = 67111936 ) # return pyscrypt.hash(p, salt, 2**16, 8, 1) def xor ( s1 , s2 ): return b '' . join ([ bytes ([ s1 [ i ] ^ s2 [ i % len ( s2 )]]) for i in range ( len ( s1 ))]) class HashHandler ( socketserver . BaseRequestHandler ): welcome_message = \"\"\" Welcome, young wanna-be Cracker, to the Hashinator. To prove your worthiness, you must display the power of your cracking skills. The test is easy: 1. We send you a password from the rockyou list, hashed using multiple randomly chosen algorithms. 2. You crack the hash and send back the original password. As you already know the dictionary and won't need any fancy password rules, {} seconds should be plenty, right? Please wait while we generate your hash... \"\"\" hashes = [ md5 , sha , blake , scrypt ] timeout = 10 total_rounds = 32 def handle ( self ): self . request . sendall ( self . welcome_message . format ( self . timeout ) . encode ()) password = self . generate_password () # from rock_you.txt Salt = self . generate_salt ( password ) # related to the length of the password Hash_rounds = self . generate_rounds () # Generate the order in which the hash algorithm is executed password_hash = self . calculate_hash ( salt + password , hash_rounds ) self . generate_delay () self . request . sendall ( \"Challenge password hash: {} \\n \" . format ( b64encode ( password_hash )) . encode ()) self . request . sendall ( \"Rounds used: \\n \" . encode ()) test_rounds = [] for r in hash_rounds : test_rounds . append ( r ) for r in hash_rounds : self . request . sendall ( \"- {} \\n \" . format ( r . __name__ ) . encode ()) self . request . sendall ( \"Your time starts now! \\n \" . encode ()) self . request . settimeout ( self . timeout ) try : response = self . request . recv ( 1024 ) if response . strip () == password : self . request . sendall ( \"Congratulations! You are a true cracking master! \\n \" . encode ()) self . request . sendall ( \"Welcome to the club: {} \\n \" . format ( flag ) . encode ()) return except socket . timeout : pass self . request . sendall ( \"Your cracking skills are bad, and you should feel bad!\" . encode ()) def generate_password ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] lines = 14344391 # size of rockyou line = rand % lines password = \"\" f = open ( 'rockyou.txt' , 'rb' ) for i in range ( line ): password = f . readline () return password . strip () def generate_salt ( self , p ): msize = 128 # f-you hashcat :D salt_size = msize - len ( p ) return os . urandom ( salt_size ) def generate_rounds ( self ): rand = struct . unpack ( \"Q\" , os . urandom ( 8 ))[ 0 ] rounds = [] for i in range ( self . total_rounds ): rounds . append ( self . hashes [ rand % len ( self . hashes )]) rand = rand & gt ; & gt ; 2 return rounds def calculate_hash ( self , payload , hash_rounds ): interim_salt = payload [: 64 ] interim_hash = payload [ 64 :] for i in range ( len ( hash_rounds )): interim_salt = xor ( interim_salt , hash_rounds [ - 1 - i ]( interim_hash )) interim_hash = xor ( interim_hash , hash_rounds [ i ]( interim_salt )) ''' interim_hash = xor( interim_hash, hash_rounds[i]( xor(interim_salt, hash_rounds[-1-i](interim_hash)) ) ) ''' final_hash = interim_salt + interim_hash return final_hash def generate_delay ( self ): rand = struct . unpack ( \"I\" , os . urandom ( 4 ))[ 0 ] time . sleep ( rand / 1000000000.0 ) class ThreadedTCPServer ( socketserver . ThreadingMixIn , socketserver . TCPServer ): allow_reuse_address = True PORT = 1337 HOST = '0.0.0.0' flag = \"\" with open ( \"flag.txt\" ) as f : flag = f . read () def main (): server = ThreadedTCPServer (( HOST , PORT ), HashHandler ) server_thread = threading . Thread ( target = server . serve_forever ) server_thread . start () server_thread . join () if __name__ == \"__main__\" : main ()","title":"Original hash algorithm"},{"location":"crypto/ctf-wiki/hash/complex-zh/","text":"EN | ZH \u7efc\u5408\u9898\u76ee \u00b6 2017 34c3 Software_update \u00b6 \u53ef\u4ee5\u770b\u51fa\uff0c\u7a0b\u5e8f\u7684\u5927\u6982\u610f\u601d\u662f\u4e0a\u4f20\u4e00\u4e2a zip \u538b\u7f29\u5305\uff0c\u7136\u540e\u5bf9 signed_data \u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\u8fdb\u884c\u7b7e\u540d\u9a8c\u8bc1\u3002\u5176\u4e2d\uff0c\u6700\u540e\u9a8c\u8bc1\u7684\u624b\u6cd5\u662f\u5927\u6982\u662f\u5c06\u6bcf\u4e00\u4e2a\u6587\u4ef6\u8fdb\u884c sha256 \u54c8\u5e0c\uff0c\u7136\u540e \u5f02\u6216 \u8d77\u6765\u4f5c\u4e3a\u8f93\u5165\u4f20\u9012\u7ed9 rsa \u8fdb\u884c\u7b7e\u540d\u3002\u5982\u679c\u901a\u8fc7\u9a8c\u8bc1\u7684\u8bdd\uff0c\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684 pre-copy.py \u548c post-copy.py \u6587\u4ef6\u3002 \u5f88\u81ea\u7136\u7684\u60f3\u6cd5\u662f\u6211\u4eec\u4fee\u6539 pre-copy.py \u6216\u8005 post-copy.py \u6587\u4ef6\uff0c\u4f7f\u5176\u53ef\u4ee5\u8bfb\u53d6 flag\uff0c\u7136\u540e\u518d\u6b21\u7ed5\u8fc7\u7b7e\u540d\u5373\u53ef\u3002\u4e3b\u8981\u6709\u4e24\u79cd\u601d\u8def \u6839\u636e\u7ed9\u5b9a\u7684\u516c\u94a5\u6587\u4ef6\u83b7\u53d6\u5bf9\u5e94\u7684\u79c1\u94a5\uff0c\u8fdb\u800c\u518d\u4fee\u6539\u6587\u4ef6\u540e\u4f2a\u9020\u7b7e\u540d\uff0c\u7136\u540e\u5927\u6982\u770b\u4e86\u770b\u516c\u94a5\u6587\u4ef6\u51e0\u4e4e\u4e0d\u53ef\u7834\uff0c\u6240\u4ee5\u8fd9\u4e00\u70b9\uff0c\u57fa\u672c\u4e0a\u53ef\u4ee5\u653e\u5f03\u3002 \u4fee\u6539\u5bf9\u5e94\u6587\u4ef6\u540e\uff0c\u5229\u7528 \u5f02\u6216\u7684\u7279\u6027\u4f7f\u5f97\u5176\u54c8\u5e0c\u503c\u4ecd\u7136\u4e0e\u539f\u6765\u76f8\u540c \uff0c\u4ece\u800c\u7ed5\u8fc7\u7b7e\u540d\u68c0\u6d4b\u3002\u5373\u4f7f\u5f97 signed_data \u76ee\u5f55\u4e0b\u5305\u542b\u591a\u4e2a\u6587\u4ef6\uff0c\u4f7f\u5f97\u8fd9\u4e9b\u6587\u4ef6\u7684\u54c8\u5e0c\u503c\u6700\u540e\u5f02\u6216\u8d77\u6765\u53ef\u4ee5\u62b5\u6d88\u4fee\u6539 pre-copy.py \u6216\u8005 post-copy.py\u6587\u4ef6\u6240\u9020\u6210\u7684\u54c8\u5e0c\u503c\u7684\u4e0d\u540c\u3002 \u8fd9\u91cc\uff0c\u6211\u4eec\u9009\u62e9\u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff0c\u8fd9\u91cc\u6211\u4eec\u9009\u62e9\u4fee\u6539 pre-copy.py \u6587\u4ef6\uff0c\u5177\u4f53\u601d\u8def\u5982\u4e0b \u8ba1\u7b97 pre-copy.py \u7684\u539f hash \u503c\u3002 \u4fee\u6539 pre-copy.py \u6587\u4ef6\uff0c\u4f7f\u5176\u53ef\u4ee5\u8bfb\u53d6 flag\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u8ba1\u7b97\u65b0\u7684 hash \u503c\u3002\u5c06\u4e24\u8005\u5f02\u6216\uff0c\u6c42\u5f97\u5f02\u6216\u5dee\u503c delta\u3002 \u5bfb\u627e\u4e00\u7cfb\u5217\u7684\u6587\u4ef6\uff0c\u4f7f\u5176 hash \u503c\u5f02\u6216\u8d77\u6765\u6b63\u597d\u4e3a delta\u3002 \u5173\u952e\u7684\u6b65\u9aa4\u5728\u4e8e\u7b2c\u4e09\u6b65\uff0c\u800c\u5176\u5b9e\u8fd9\u4e2a\u6587\u4ef6\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2a\u7ebf\u6027\u7ec4\u5408\u7684\u95ee\u9898\uff0c\u5373\u5bfb\u627e\u82e5\u5e72\u4e2a 256 \u7ef401\u5411\u91cf\u4f7f\u5176\u5f02\u6216\u503c\u4e3a delta\u3002\u800c $$ (F={0,1},F^{256},\\oplus ,\\cdot) $$ \u662f\u4e00\u4e2a 256 \u7ef4\u7684\u5411\u91cf\u7a7a\u95f4\u3002\u5982\u679c\u6211\u4eec\u53ef\u4ee5\u6c42\u5f97\u8be5\u5411\u91cf\u7a7a\u95f4\u7684\u4e00\u4e2a\u57fa\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u6c42\u5f97\u8be5\u7a7a\u95f4\u4e2d\u4efb\u610f\u6307\u5b9a\u503c\u7684\u6240\u9700\u8981\u7684\u5411\u91cf\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 sage \u6765\u8f85\u52a9\u6211\u4eec\u6c42\uff0c\u5982\u4e0b # generage the base of <{0,1},F^256,xor,*> def gen_gf2_256_base (): v = VectorSpace ( GF ( 2 ), 256 ) tmphash = compute_file_hash ( \"0.py\" , \"\" ) tmphash_bin = hash2bin ( tmphash ) base = [ tmphash_bin ] filelist = [ '0.py' ] print base s = v . subspace ( base ) dim = s . dimension () cnt = 1 while dim != 256 : tmpfile = str ( cnt ) + \".py\" tmphash = compute_file_hash ( tmpfile , \"\" ) tmphash_bin = hash2bin ( tmphash ) old_dim = dim s = v . subspace ( base + [ tmphash_bin ]) dim = s . dimension () if dim > old_dim : base += [ tmphash_bin ] filelist . append ( tmpfile ) print ( \"dimension \" + str ( s . dimension ())) cnt += 1 print ( cnt ) m = matrix ( GF ( 2 ), 256 , 256 , base ) m = m . transpose () return m , filelist \u5173\u4e8e\u66f4\u52a0\u8be6\u7ec6\u7684\u89e3\u7b54\uff0c\u8bf7\u53c2\u8003 exp.py \u3002 \u8fd9\u91cc\u6211\u4fee\u6539 pre-copy \u591a\u8f93\u51fa !!!!come here!!!! \u5b57\u773c\uff0c\u5982\u4e0b \u279c software_update git: ( master ) python3 installer.py now.zip Preparing to copy data... !!!!come here!!!! Software update installed successfully. \u53c2\u8003\u6587\u732e https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py 2019 36c3 SaV-ls-l-aaS \u00b6 \u8fd9\u4e2a\u9898\u7684\u5206\u7c7b\u662f Crypto&Web\uff0c\u634b\u4e00\u4e0b\u6d41\u7a0b\uff1a 60601\u7aef\u53e3\u5f00\u7740\u4e00\u4e2aWeb\u670d\u52a1\uff0c\u9898\u76ee\u63cf\u8ff0\u7ed9\u4e86\u8fde\u63a5\u65b9\u6cd5\uff1a url = 'http://78.47.240.226:60601' && ip = $( curl -s \" $url /ip\" ) && sig = $( curl -s -d \"cmd=ls -l&ip= $ip \" \" $url /sign\" ) && curl --data-urlencode \"signature= $sig \" \" $url /exec\" \u53ef\u4ee5\u770b\u5230\uff0c\u5148\u662f\u8bbf\u95ee /ip \u5f97\u5230 ip\uff0c\u518d\u5411 /sign post \u8fc7\u53bb ip \u548c\u6211\u4eec\u8981\u6267\u884c\u7684\u547d\u4ee4\uff0c\u5f97\u5230\u7b7e\u540d\uff0c\u6700\u540e\u5411 /exec post signature \u6765\u6267\u884c\u547d\u4ee4\u3002\u6211\u4eec\u6267\u884c\u8fd9\u4e00\u884c\u53ef\u4ee5\u53d1\u73b0\u56de\u663e\u4e86 ls -l \u6267\u884c\u7684\u7ed3\u679c\uff0c\u53d1\u73b0\u6709\u4e2a flag.txt\u3002 \u770b\u6e90\u7801\uff0cWeb \u670d\u52a1\u662f\u7531 go \u8d77\u7684\uff1a package main import ( \"bytes\" \"crypto/sha1\" \"encoding/json\" \"fmt\" \"io\" \"io/ioutil\" \"log\" \"net\" \"net/http\" \"strings\" \"time\" ) func main () { m := http . NewServeMux () m . HandleFunc ( \"/ip\" , func ( w http . ResponseWriter , r * http . Request ) { ip , _ , err := net . SplitHostPort ( r . RemoteAddr ) if err != nil { return } fmt . Fprint ( w , ip ) }) m . HandleFunc ( \"/sign\" , func ( w http . ResponseWriter , r * http . Request ) { ip , _ , err := net . SplitHostPort ( r . RemoteAddr ) if err != nil { return } remoteAddr := net . ParseIP ( ip ) if remoteAddr == nil { return } ip = r . PostFormValue ( \"ip\" ) signIP := net . ParseIP ( ip ) if signIP == nil || ! signIP . Equal ( remoteAddr ) { fmt . Fprintln ( w , \"lol, not ip :>\" ) return } cmd := r . PostFormValue ( \"cmd\" ) if cmd != \"ls -l\" { fmt . Fprintln ( w , \"lol, nope :>\" ) return } msg := ip + \"|\" + cmd digest := sha1 . Sum ([] byte ( msg )) b := new ( bytes . Buffer ) err = json . NewEncoder ( b ). Encode ( string ( digest [:])) if err != nil { return } resp , err := http . Post ( \"http://127.0.0.1/index.php?action=sign\" , \"application/json; charset=utf-8\" , b ) if err != nil || resp . StatusCode != 200 { fmt . Fprintln ( w , \"oops, hsm is down\" ) return } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { fmt . Fprintln ( w , \"oops, hsm is bodyless?\" ) return } var signature string err = json . Unmarshal ( body , & signature ) if err != nil { fmt . Fprintln ( w , \"oops, hsm is jsonless?\" ) return } fmt . Fprint ( w , signature + msg ) }) m . HandleFunc ( \"/exec\" , func ( w http . ResponseWriter , r * http . Request ) { ip , _ , err := net . SplitHostPort ( r . RemoteAddr ) if err != nil { return } remoteAddr := net . ParseIP ( ip ) if remoteAddr == nil { return } signature := r . PostFormValue ( \"signature\" ) digest := sha1 . Sum ([] byte ( signature [ 172 :])) b := new ( bytes . Buffer ) err = json . NewEncoder ( b ). Encode ( signature [: 172 ] + string ( digest [:])) if err != nil { fmt . Fprintln ( w , \"oops, json encode\" ) return } resp , err := http . Post ( \"http://127.0.0.1/index.php?action=verify\" , \"application/json; charset=utf-8\" , b ) if err != nil || resp . StatusCode != 200 { fmt . Fprintln ( w , \"oops, hsm is down?\" ) return } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { fmt . Fprintln ( w , \"oops, hsm is bodyless?\" ) return } var valid bool err = json . Unmarshal ( body , & valid ) if err != nil { fmt . Fprintln ( w , \"oops, json unmarshal\" ) return } if valid { t := strings . Split ( signature [ 172 :], \"|\" ) if len ( t ) != 2 { fmt . Fprintln ( w , \"oops, split\" ) } signIP := net . ParseIP ( t [ 0 ]) if signIP == nil || ! signIP . Equal ( remoteAddr ) { fmt . Fprintln ( w , \"lol, not ip :>\" ) return } conn , err := net . DialTimeout ( \"tcp\" , \"127.0.0.1:1024\" , 1 * time . Second ) if err != nil { fmt . Fprintln ( w , \"oops, dial\" ) return } fmt . Fprintf ( conn , t [ 1 ] + \"\\n\" ) conn .( * net . TCPConn ). CloseWrite () io . Copy ( w , conn ) } }) s := & http . Server { Addr : \":60601\" , Handler : m , ReadTimeout : 5 * time . Second , WriteTimeout : 5 * time . Second , MaxHeaderBytes : 1 << 20 , } log . Fatal ( s . ListenAndServe ()) } \u4ee3\u7801\u5f88\u5bb9\u6613\u770b\uff0c\u9650\u5236\u4e86 cmd \u53ea\u80fd\u662f ls -l \uff0c\u5176\u4f59\u4e0d\u7ed9\u7b7e\u540d\uff0c\u770b\u6837\u5b50\u6211\u4eec\u662f\u8981\u4f2a\u9020\u5176\u4ed6\u547d\u4ee4\u7684\u7b7e\u540d\u6765\u8bfbflag\uff0c\u8fd9\u91cc\u6ce8\u610f\u5230\u7b7e\u540d\u548c\u9a8c\u7b7e\u7684\u8fc7\u7a0b\u662f\u4f20\u7ed9\u672c\u5730\u8d77\u7684\u4e00\u4e2a php \u6765\u5b8c\u6210\u7684\uff0c\u770b\u4e00\u4e0b\u8fd9\u90e8\u5206\u6e90\u7801\uff1a <?php define ( 'ALGO' , 'md5WithRSAEncryption' ); $d = json_decode ( file_get_contents ( 'php://input' ), JSON_THROW_ON_ERROR ); if ( $_GET [ 'action' ] === 'sign' ){ $pkeyid = openssl_pkey_get_private ( \"file:///var/www/private_key.pem\" ); openssl_sign ( $d , $signature , $pkeyid , ALGO ); echo json_encode ( base64_encode ( $signature )); openssl_free_key ( $pkeyid ); } elseif ( $_GET [ 'action' ] === 'verify' ) { $pkeyid = openssl_pkey_get_public ( \"file:///var/www/public_key.pem\" ); echo json_encode ( openssl_verify ( substr ( $d , 172 ), base64_decode ( substr ( $d , 0 , 172 )), $pkeyid , ALGO ) === 1 ); openssl_free_key ( $pkeyid ); } \u91c7\u7528\u7684\u662f md5WithRSAEncryption \u7684\u65b9\u5f0f\u7b7e\u540d\uff0c\u672c\u5730\u8bd5\u4e86\u4e00\u4e0b\uff0c\u662f\u628a\u6211\u4eec\u4f20\u5165\u7684 $d md5 \u540e\u8f6c\u4e3ahex\uff0c\u586b\u5145\u5230 0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff003020300c06082a864886f70d020505000410 \u540e\u9762\uff0c\u7ec4\u6210\u6570\u5b57\u7136\u540e\u7528RSA\u7b7e\u540d\u3002 \u770b\u6837\u5b50\u6574\u4e2a\u903b\u8f91\u627e\u4e0d\u5230\u4e00\u70b9\u95ee\u9898\uff0c\u7528\u7684\u90fd\u662f\u6807\u51c6\u5e93\uff0c\u57fa\u672c\u65e0\u6cd5\u653b\u51fb\u3002\u6709\u4e2a\u601d\u8def\u662f\u901a\u8fc7\u4ee3\u7406\u66f4\u6362 ip\uff0c\u53ef\u4ee5\u62ff\u5230\u4e24\u4e2a ip|ls -l \u7684\u7b7e\u540d\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u62e5\u6709\u4e86\u4e24\u7ec4 RSA \u7684 m \u548c c\uff0c\u56e0\u4e3a\u9898\u76ee\u7ed9\u4e86 dockerfile \u7ed9\u4e86\u751f\u6210\u516c\u79c1\u94a5\u7684\u65b9\u6cd5\uff0c\u4f7f\u7528 openssl \u9ed8\u8ba4\u751f\u6210\uff0ce\u4e3a65537\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6c42\u516c\u56e0\u6570\u7684\u65b9\u5f0f\u6765\u6c42\u51fa n\u3002 \u5728\u5f97\u5230\u4e24\u7ec4\u7b7e\u540d\u540e\uff0c\u6211\u4eec\u8981\u5f97\u5230 RSA \u7684m\uff0c\u5c31\u662f\u586b\u5145\u540e\u7684\u6570\uff0c\u6240\u4ee5\u6309\u7167\u4ee3\u7801\u903b\u8f91\uff0c\u5728 go \u91cc\u9762\u5148\u662f sha1: msg := ip + \"|\" + cmd digest := sha1 . Sum ([] byte ( msg )) b := new ( bytes . Buffer ) err = json . NewEncoder ( b ). Encode ( string ( digest [:])) \u518d php \u91cc\u7684 md5\uff0c\u5f97\u5230\u4e24\u7ec4 m \u548c c\uff0c\u4f46\u662f\u603b\u662f\u6c42\u4e0d\u51fa\u516c\u56e0\u6570 n\uff0c\u6000\u7591\u6c42\u7684 m \u4e0d\u5bf9\u3002\u770b\u4ee3\u7801\u53d1\u73b0 go \u91cc\u628a sha1\u7684\u7ed3\u679c\u7528 json \u7f16\u7801\uff0c\u7136\u540e\u4f20\u5230 php\u91cc json \u89e3\u7801\u3002\u8fd9\u90e8\u5206\u975e\u5e38\u53ef\u7591\uff0c\u4e3a\u4f55\u8981\u7528 json \u7f16\u7801\uff08\u7528 hex \u4f20\u8fc7\u53bb\u5b83\u4e0d\u9999\u4e48\uff09\uff0c\u672c\u5730\u642d\u4e00\u4e0b\u73af\u5883\u8ddf\u4e00\u4e0b\u3002\uff08\u9898\u76ee\u7ed9\u4e86dockerfile\uff09 \u8d77\u4e2adocker\uff0c\u6539\u4e00\u4e0b index.php\uff0c\u52a0\u4e00\u4e2a var_dump($d); \uff0c\u518d\u6539\u4e00\u4e0b go\uff0c\u8fd4\u56de\u4e00\u4e0b php \u7684\u7ed3\u679c\uff1a fmt . Fprintln ( w , string ( body )) \u73b0\u5728\u8ba9\u7a0b\u5e8f\u7b7e\u540d\uff0c\u8fd4\u56de\u7ed3\u679c\uff1a string(38) \"\u000e \u001d\ufffd\u0012\ufffd.\ufffd\ufffd\ufffd?-\ufffdKC\ufffd\u0005\ufffd@\ufffd\" \"K4FEmxz4yuTsjDAbRZQmHJ+MBiCSGaOnpZTLbThXpCkDYe3siAIPfihX6ppjN2Tz6XqOr4tF\\/u1\\/+ccfhj8NNLIL+2hknyDXbosmMBV8mEGYsMqQHAE0f+3OhDWlzN5RnteSMYNZbTipFErB8ZOWCiXmynWxsqJhyaN9J6\\/\\/h6I=\" oops, hsm is jsonless? $d \u7adf\u7136\u662f\u957f\u5ea6\u4e3a 38 \u7684\u5b57\u7b26\u4e32\uff0c\u770b\u6765\u679c\u7136\u662f\u8fd9\u91cc\u7f16\u7801\u6709\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u770b\u4e00\u4e0b\u6bcf\u4e2a\u6b65\u9aa4\u7684\u7ed3\u679c\uff0c\u5148\u770b\u4e00\u4e0b go \u91cc json\u7f16\u7801\u540e\u7684 sha1 \u7ed3\u679c\u662f\u4ec0\u4e48\uff1a package main import ( \"bytes\" \"crypto/sha1\" \"encoding/json\" \"fmt\" ) func main () { msg := \"172.17.0.1|ls -l\" digest := sha1 . Sum ([] byte ( msg )) b := new ( bytes . Buffer ) json . NewEncoder ( b ). Encode ( string ( digest [:])) fmt . Print ( string ( b . Bytes ())); } \u8fd0\u884c\u4e00\u4e0b\uff1a \"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\" \u548c\u6b63\u5e38\u7684sha1\u7684\u7ed3\u679c\u6765\u6bd4\u8f83\u4e00\u4e0b\uff1a Python 2 .7.16 ( default, Sep 2 2019 , 11 :59:44 ) [ GCC 4 .2.1 Compatible Apple LLVM 10 .0.1 ( clang-1001.0.46.4 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> \"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\" '\\\\u000e\\t\\\\u001d\\\\ufffd\\\\u0012\\\\ufffd.\\\\ufffd\\\\ufffd\\\\ufffd?-\\\\ufffdKC\\\\ufffd\\\\u0005\\\\ufffd@\\\\ufffd' >>> from hashlib import * >>> sha1 ( '172.17.0.1|ls -l' ) .digest () '\\x0e\\t\\x1d\\xbd\\x12\\x90.\\xca\\xf0\\xd9?-\\x98KC\\xeb\\x05\\xa1@\\xd1' \u7531\u4e8e go \u7684 json \u7f16\u7801\uff0c\u5f88\u591a\u4e0d\u53ef\u89c1\u5b57\u7b26\u90fd\u88ab\u8f6c\u4e3a\u4e86 U+fffd \uff0c\u4e22\u5931\u4e86\u5f88\u591a\u4fe1\u606f\u3002 \u518d\u7ecf\u8fc7 php \u63a5\u53e3\u7684\u63a5\u6536\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u7ed3\u679c\uff1a $d = json_decode(file_get_contents('php://input'), JSON_THROW_ON_ERROR); var_dump(file_get_contents('php://input')); var_dump($d); var_dump(bin2hex($d)); \u7ed3\u679c\uff1a string(89) \"\"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\" \" string(38) \"\u000e \u001d\ufffd\u0012\ufffd.\ufffd\ufffd\ufffd?-\ufffdKC\ufffd\u0005\ufffd@\ufffd\" string(76) \"0e091defbfbd12efbfbd2eefbfbdefbfbdefbfbd3f2defbfbd4b43efbfbd05efbfbd40efbfbd\" \"K4FEmxz4yuTsjDAbRZQmHJ+MBiCSGaOnpZTLbThXpCkDYe3siAIPfihX6ppjN2Tz6XqOr4tF\\/u1\\/+ccfhj8NNLIL+2hknyDXbosmMBV8mEGYsMqQHAE0f+3OhDWlzN5RnteSMYNZbTipFErB8ZOWCiXmynWxsqJhyaN9J6\\/\\/h6I=\" oops, hsm is jsonless? U+fffd \u53d8\u6210\u4e86 \\xef\\xbf\\xbd \u3002\u6240\u4ee5\u7531\u4e8e go \u7684 json \u7f16\u7801\u95ee\u9898\uff0c\u4e22\u5931\u4e86\u5f88\u591a\u4fe1\u606f\uff0c\u9020\u6210\u4e86 md5 \u524d\u7684\u6570\u636e\u6709\u5f88\u591a\u76f8\u540c\u5b57\u7b26\u3002\u5f53\u65f6\u505a\u9898\u65f6\u5f80\u4e0b\u5e76\u6ca1\u6709\u7ec6\u60f3\uff0c\u5f97\u5230 n \u540e\u603b\u662f\u60f3\u6784\u9020\u51fa\u4efb\u610f\u547d\u4ee4\u7684\u7b7e\u540d\uff0c\u4e5f\u5f88\u7591\u60d1\u5982\u679c\u6784\u9020\u51fa\u5c82\u4e0d\u662f\u8fd9\u79cd\u7b7e\u540d\u5c31\u4e0d\u5b89\u5168\u4e86\uff1f\u5176\u5b9e\u662f\u65e0\u6cd5\u5f97\u5230\u7684\u3002 \u6b63\u89e3\u662f go \u7684\u8fd9\u79cd\u95ee\u9898 \uff0c\u4e3a\u78b0\u649e\u521b\u9020\u4e86\u6761\u4ef6\u3002\u6211\u4eec\u53ef\u4ee5\u78b0\u649e\u51fa\u5728\u8fd9\u79cd\u7f16\u7801\u60c5\u51b5\u4e0b\u4e0e ls -l \u6709\u76f8\u540c\u7ed3\u679c\u7684 cat * \u6b64\u7c7b\u547d\u4ee4\u3002\u4f46\u662f\u95ee\u9898\u662f\u6211\u4eec\u9700\u8981\u975e\u5e38\u5927\u91cf ip \u6765\u63d0\u4f9b\u78b0\u649e\u7684\u6570\u636e\u3002 \u53ef\u4ee5\u53d1\u73b0\uff0cgo \u53d6 ip \u7684\u65f6\u5019\uff0c\u662f\u5148\u7528 net.ParseIP \u89e3\u6790\u4e86 ip\uff0c\u6211\u4eec\u5728 ip \u6bcf\u4e2a\u6570\u5b57\u524d\u9762\u52a0 0 \uff0c\u89e3\u6790\u540e\u8fd8\u662f\u539f\u6765\u7684 ip \u7ed3\u679c\uff0c\u6bcf\u4e2a\u6570\u5b57\u6700\u591a\u6dfb\u52a0 256 \u4e2a 0\uff0c\u56db\u4e2a\u6570\u5b57\u5c31\u5df2\u7ecf\u4ea7\u751f\u4e86 2^32 \u79cd\u4e0d\u540c\u7684\u7ec4\u5408\uff0c\u8db3\u4ee5\u78b0\u649e\u51fa ls -l \u4e0e cat * \u4e4b\u95f4\u7684\u51b2\u7a81\u3002 \u5b98\u65b9\u9898\u89e3\u7684 c++ \u78b0\u649e\u811a\u672c\u6211\u672c\u5730\u7f16\u8bd1\u7684\u6709\u70b9\u95ee\u9898\uff0c\u52a0\u4e86\u4e00\u4e9b\u5f15\u5165\u7684\u5934\u6587\u4ef6\uff1a // g++ -std=c++17 -march=native -O3 -lcrypto -lpthread gewalt.cpp -o gewalt #include <cassert> #include <iomanip> #include <string> #include <sstream> #include <iostream> #include <functional> #include <random> #include <unordered_map> #include <algorithm> #include <thread> #include <atomic> #include <mutex> #include <array> #include <openssl/sha.h> const unsigned num_threads = std :: thread :: hardware_concurrency (); static std :: string hash ( std :: string const & s ) { SHA_CTX ctx ; if ( ! SHA1_Init ( & ctx )) throw ; if ( ! SHA1_Update ( & ctx , s . data (), s . length ())) throw ; std :: string d ( SHA_DIGEST_LENGTH , 0 ); if ( ! SHA1_Final (( uint8_t * ) & d [ 0 ], & ctx )) throw ; return d ; } static std :: u32string kapot ( std :: string const & s ) { std :: u32string r ( s . size (), 0 ); size_t o = 0 ; for ( size_t i = 0 ; i < s . length (); ) { auto T = []( uint8_t c ) { return ( c < 0x80 ) ? 1 /* ASCII */ : ( c & 0xc0 ) == 0x80 ? 0 /* continuation */ : ( c & 0xe0 ) == 0xc0 ? 2 /* 2-byte chunk */ : ( c & 0xf0 ) == 0xe0 ? 3 /* 3-byte chunk */ : ( c & 0xf8 ) == 0xf0 ? 4 /* 4-byte chunk */ : - 1 ; }; uint32_t c = s [ i ++ ]; auto cont = [ & ]() { c = ( c << 6 ) | ( s [ i ++ ] & 0x3f ); }; switch ( T ( c )) { case - 1 : case 0 : invalid : c = 0xfffd ; /* fall through */ case 1 : valid : r [ o ++ ] = c ; break ; case 2 : if ( c &= 0x1f , i + 0 >= s . size () || T ( s [ i + 0 ])) goto invalid ; goto one ; case 3 : if ( c &= 0x1f , i + 1 >= s . size () || T ( s [ i + 0 ]) || T ( s [ i + 1 ])) goto invalid ; goto two ; case 4 : if ( c &= 0x1f , i + 2 >= s . size () || T ( s [ i + 0 ]) || T ( s [ i + 1 ]) || T ( s [ i + 2 ])) goto invalid ; cont (); two : cont (); one : cont (); goto valid ; } } r . resize ( o ); return r ; } std :: atomic < uint64_t > hcount = 0 , kcount = 0 ; typedef std :: unordered_map < std :: u32string , std :: string > tab_t ; tab_t tab0 , tab1 ; std :: mutex mtx ; std :: array < uint8_t , 4 > ip ; std :: string cmd0 , cmd1 ; class stuffer_t { private : std :: array < size_t , 4 > cnts ; size_t step ; std :: string cmd ; public : stuffer_t ( size_t t , size_t s , std :: string c ) : cnts { t }, step ( s ), cmd ( c ) {} std :: string operator ()() { //XXX this is by far not the most efficient way of doing this, but yeah if ( ++ cnts [ 3 ] >= cnts [ 0 ]) { cnts [ 3 ] = 0 ; if ( ++ cnts [ 2 ] >= cnts [ 0 ]) { cnts [ 2 ] = 0 ; if ( ++ cnts [ 1 ] >= cnts [ 0 ]) { cnts [ 1 ] = 0 ; cnts [ 0 ] += step ; } } } std :: stringstream o ; for ( size_t i = 0 ; i < 4 ; ++ i ) o << ( i ? \".\" : \"\" ) << std :: string ( cnts [ i ], '0' ) << ( unsigned ) ip [ i ]; o << \"|\" << cmd ; return o . str (); } }; void go ( size_t tid ) { //XXX tid stuff is a hack, but YOLO bool one = tid & 1 ; stuffer_t next ( tid >> 1 , ( num_threads + 1 ) >> 1 , one ? cmd1 : cmd0 ); tab_t & mytab = one ? tab1 : tab0 ; tab_t & thtab = one ? tab0 : tab1 ; uint64_t myhcount = 0 , mykcount = 0 ; while ( 1 ) { std :: string r = next (); { ++ myhcount ; auto h = hash ( r ); if (( h . size () + 3 ) / 4 < ( size_t ) std :: count_if ( h . begin (), h . end (), []( unsigned char c ) { return c < 0x80 ; })) continue ; ++ mykcount ; auto k = kapot ( h ); if ( k . size () > 3 + ( size_t ) std :: count ( k . begin (), k . end (), 0xfffd )) continue ; std :: lock_guard < std :: mutex > lck ( mtx ); hcount += myhcount , myhcount = 0 ; kcount += mykcount , mykcount = 0 ; if ( thtab . find ( k ) != thtab . end ()) { mytab [ k ] = r ; std :: cerr << \" \\r\\x1b [K\" << \" \\x1b [32m\" ; std :: cout << tab0 [ k ] << std :: endl << tab1 [ k ] << std :: endl ; std :: cerr << \" \\x1b [0m\" ; std :: cerr << std :: hex ; bool first = true ; for ( uint32_t c : k ) std :: cerr << ( first ? first = false , \"\" : \" \" ) << c ; std :: cerr << std :: endl ; std :: cerr << std :: dec << \"hash count: \\x1b [35m\" << hcount << \" \\x1b [0m\" ; { std :: stringstream s ; s << std :: fixed << std :: setprecision ( 2 ) << log ( hcount | 1 ) / log ( 2 ); std :: cerr << \" (2^ \\x1b [35m\" << std :: setw ( 5 ) << s . str () << \" \\x1b [0m\" << \")\" << std :: endl ; } std :: cerr << \"kapot count: \" << \" \\x1b [35m\" << kcount << \" \\x1b [0m\" ; { std :: stringstream s ; s << std :: fixed << std :: setprecision ( 2 ) << log ( kcount | 1 ) / log ( 2 ); std :: cerr << \" (2^ \\x1b [35m\" << std :: setw ( 5 ) << s . str () << \" \\x1b [0m)\" << std :: endl ; } std :: cerr << \"table sizes: \\x1b [35m\" << tab0 . size () << \" \\x1b [0m \\x1b [35m\" << tab1 . size () << \" \\x1b [0m\" << std :: endl ; exit ( 0 ); } if ( mytab . size () < ( 1 << 20 )) mytab [ k ] = r ; } hcount += myhcount ; kcount += mykcount ; } } void status () { while ( 1 ) { { std :: lock_guard < std :: mutex > lck ( mtx ); std :: cerr << \" \\r\\x1b [K\" ; std :: cerr << \"hash count: \\x1b [35m\" << std :: setw ( 12 ) << hcount << \" \\x1b [0m \" ; { std :: stringstream s ; s << std :: fixed << std :: setprecision ( 2 ) << log ( hcount | 1 ) / log ( 2 ); std :: cerr << \"(2^ \\x1b [35m\" << std :: setw ( 5 ) << s . str () << \" \\x1b [0m) | \" ; } std :: cerr << \"kapot count: \\x1b [35m\" << std :: setw ( 12 ) << kcount << \" \\x1b [0m \" ; { std :: stringstream s ; s << std :: fixed << std :: setprecision ( 2 ) << log ( kcount | 1 ) / log ( 2 ); std :: cerr << \"(2^ \\x1b [35m\" << std :: setw ( 5 ) << s . str () << \" \\x1b [0m) | \" ; } std :: cerr << \"tables: \\x1b [35m\" << std :: setw ( 9 ) << tab0 . size () << \" \" << std :: setw ( 9 ) << tab1 . size () << \" \\x1b [0m \" << std :: flush ; } std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } } int main ( int argc , char ** argv ) { if ( argc < 2 ) { std :: cerr << \" \\x1b [31mneed IPv4 in argv[1] \\x1b [0m\" << std :: endl ; exit ( 1 ); } { std :: stringstream ss ( argv [ 1 ]); for ( auto & v : ip ) { std :: string s ; std :: getline ( ss , s , '.' ); int n = std :: atoi ( s . c_str ()); if ( n < std :: numeric_limits < uint8_t >:: min () || n > std :: numeric_limits < uint8_t >:: max ()) goto bad_ip ; v = n ; } if ( ! ss ) { bad_ip : std :: cerr << \" \\x1b [31mbad IPv4 given? \\x1b [0m\" << std :: endl ; exit ( 2 ); } } if ( argc < 4 ) { std :: cerr << \" \\x1b [31mneed commands in argv[2] and argv[3] \\x1b [0m\" << std :: endl ; exit ( 2 ); } cmd0 = argv [ 2 ]; cmd1 = argv [ 3 ]; std :: thread status_thread ( status ); std :: vector < std :: thread > ts ; for ( unsigned i = 0 ; i < num_threads ; ++ i ) ts . push_back ( std :: thread ( go , i )); for ( auto & t : ts ) t . join (); } \u7f16\u8bd1\u53ef\u80fd\u4f1a\u627e\u4e0d\u5230 lcrypto \uff0c\u7f16\u8bd1\u547d\u4ee4\u52a0\u4e0a lcrypto \u8def\u5f84\uff08\u6211\u672c\u5730\u662f /usr/local/opt/openssl/lib\uff09 g++ -std = c++17 -march = native -O3 -lcrypto -lpthread gewalt.cpp -o gewalt -L/usr/local/opt/openssl/lib \u4e0e go \u4ea4\u4e92\u7684\u811a\u672c\uff1a #!/usr/bin/env python3 import sys , requests , subprocess benign_cmd = 'ls -l' exploit_cmd = 'cat *' ip , port = sys . argv [ 1 ], sys . argv [ 2 ] url = 'http:// {} : {} ' . format ( ip , port ) my_ip = requests . get ( url + '/ip' ) . text print ( '[+] IP: ' + my_ip ) o = subprocess . check_output ([ './gewalt' , my_ip , benign_cmd , exploit_cmd ]) print ( '[+] gewalt:' + o . decode ()) payload = {} for l in o . decode () . splitlines (): ip , cmd = l . split ( '|' ) payload [ 'benign' if cmd == benign_cmd else 'pwn' ] = ip , cmd print ( payload ) sig = requests . post ( url + '/sign' , data = { 'ip' : payload [ 'benign' ][ 0 ], 'cmd' : payload [ 'benign' ][ 1 ]}) . text print ( '[+] sig: ' + sig ) r = requests . post ( url + '/exec' , data = { 'signature' : sig [: 172 ] + payload [ 'pwn' ][ 0 ] + '|' + payload [ 'pwn' ][ 1 ]}) print ( r . text ) \u2699 \ue0b0 SaV-ls-l-aaS \ue0b0 python solve.py 127 .0.0.1 60601 [ + ] IP: 172 .17.0.1 fffd fffd fffd fffd fffd fffd 55 fffd fffd fffd fffd c fffd fffd fffd fffd fffd fffd fffd fffd hash count: 168104875 ( 2 ^27.32 ) kapot count: 3477222 ( 2 ^21.73 ) table sizes: 8745 8856 [ + ] gewalt:00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 | ls -l 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172 .17.000000000000000000000000.0000000000000000000000000000000000000001 | cat * { 'pwn' : ( u '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.17.000000000000000000000000.0000000000000000000000000000000000000001' , u 'cat *' ) , 'benign' : ( u '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001' , u 'ls -l' )} [ + ] sig: ODxSukwtu4rHICBpzT23WGD7DCJNawhA0DUN/tcyv1AgwNmS8OPUnO5FnBBDgiaVx5OTYd4OjH8LVbKiXUBUBuFx1OHDgKBKG5umkKMLt+350SlgMWY5qWny9tPIU3I+X0A9FcADCBCi6f0PkXfc0CSCZXuFu9rAKnVGsbmaUwY = 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172 .000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 | ls -l hxp { FLAG } \u53c2\u8003\uff1a https://ctftime.org/writeup/17966","title":"Complex zh"},{"location":"crypto/ctf-wiki/hash/complex-zh/#_1","text":"","title":"\u7efc\u5408\u9898\u76ee"},{"location":"crypto/ctf-wiki/hash/complex-zh/#2017-34c3-software_update","text":"\u53ef\u4ee5\u770b\u51fa\uff0c\u7a0b\u5e8f\u7684\u5927\u6982\u610f\u601d\u662f\u4e0a\u4f20\u4e00\u4e2a zip \u538b\u7f29\u5305\uff0c\u7136\u540e\u5bf9 signed_data \u76ee\u5f55\u4e0b\u7684\u6587\u4ef6\u8fdb\u884c\u7b7e\u540d\u9a8c\u8bc1\u3002\u5176\u4e2d\uff0c\u6700\u540e\u9a8c\u8bc1\u7684\u624b\u6cd5\u662f\u5927\u6982\u662f\u5c06\u6bcf\u4e00\u4e2a\u6587\u4ef6\u8fdb\u884c sha256 \u54c8\u5e0c\uff0c\u7136\u540e \u5f02\u6216 \u8d77\u6765\u4f5c\u4e3a\u8f93\u5165\u4f20\u9012\u7ed9 rsa \u8fdb\u884c\u7b7e\u540d\u3002\u5982\u679c\u901a\u8fc7\u9a8c\u8bc1\u7684\u8bdd\uff0c\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684 pre-copy.py \u548c post-copy.py \u6587\u4ef6\u3002 \u5f88\u81ea\u7136\u7684\u60f3\u6cd5\u662f\u6211\u4eec\u4fee\u6539 pre-copy.py \u6216\u8005 post-copy.py \u6587\u4ef6\uff0c\u4f7f\u5176\u53ef\u4ee5\u8bfb\u53d6 flag\uff0c\u7136\u540e\u518d\u6b21\u7ed5\u8fc7\u7b7e\u540d\u5373\u53ef\u3002\u4e3b\u8981\u6709\u4e24\u79cd\u601d\u8def \u6839\u636e\u7ed9\u5b9a\u7684\u516c\u94a5\u6587\u4ef6\u83b7\u53d6\u5bf9\u5e94\u7684\u79c1\u94a5\uff0c\u8fdb\u800c\u518d\u4fee\u6539\u6587\u4ef6\u540e\u4f2a\u9020\u7b7e\u540d\uff0c\u7136\u540e\u5927\u6982\u770b\u4e86\u770b\u516c\u94a5\u6587\u4ef6\u51e0\u4e4e\u4e0d\u53ef\u7834\uff0c\u6240\u4ee5\u8fd9\u4e00\u70b9\uff0c\u57fa\u672c\u4e0a\u53ef\u4ee5\u653e\u5f03\u3002 \u4fee\u6539\u5bf9\u5e94\u6587\u4ef6\u540e\uff0c\u5229\u7528 \u5f02\u6216\u7684\u7279\u6027\u4f7f\u5f97\u5176\u54c8\u5e0c\u503c\u4ecd\u7136\u4e0e\u539f\u6765\u76f8\u540c \uff0c\u4ece\u800c\u7ed5\u8fc7\u7b7e\u540d\u68c0\u6d4b\u3002\u5373\u4f7f\u5f97 signed_data \u76ee\u5f55\u4e0b\u5305\u542b\u591a\u4e2a\u6587\u4ef6\uff0c\u4f7f\u5f97\u8fd9\u4e9b\u6587\u4ef6\u7684\u54c8\u5e0c\u503c\u6700\u540e\u5f02\u6216\u8d77\u6765\u53ef\u4ee5\u62b5\u6d88\u4fee\u6539 pre-copy.py \u6216\u8005 post-copy.py\u6587\u4ef6\u6240\u9020\u6210\u7684\u54c8\u5e0c\u503c\u7684\u4e0d\u540c\u3002 \u8fd9\u91cc\uff0c\u6211\u4eec\u9009\u62e9\u7b2c\u4e8c\u79cd\u65b9\u6cd5\uff0c\u8fd9\u91cc\u6211\u4eec\u9009\u62e9\u4fee\u6539 pre-copy.py \u6587\u4ef6\uff0c\u5177\u4f53\u601d\u8def\u5982\u4e0b \u8ba1\u7b97 pre-copy.py \u7684\u539f hash \u503c\u3002 \u4fee\u6539 pre-copy.py \u6587\u4ef6\uff0c\u4f7f\u5176\u53ef\u4ee5\u8bfb\u53d6 flag\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u8ba1\u7b97\u65b0\u7684 hash \u503c\u3002\u5c06\u4e24\u8005\u5f02\u6216\uff0c\u6c42\u5f97\u5f02\u6216\u5dee\u503c delta\u3002 \u5bfb\u627e\u4e00\u7cfb\u5217\u7684\u6587\u4ef6\uff0c\u4f7f\u5176 hash \u503c\u5f02\u6216\u8d77\u6765\u6b63\u597d\u4e3a delta\u3002 \u5173\u952e\u7684\u6b65\u9aa4\u5728\u4e8e\u7b2c\u4e09\u6b65\uff0c\u800c\u5176\u5b9e\u8fd9\u4e2a\u6587\u4ef6\u53ef\u4ee5\u770b\u505a\u662f\u4e00\u4e2a\u7ebf\u6027\u7ec4\u5408\u7684\u95ee\u9898\uff0c\u5373\u5bfb\u627e\u82e5\u5e72\u4e2a 256 \u7ef401\u5411\u91cf\u4f7f\u5176\u5f02\u6216\u503c\u4e3a delta\u3002\u800c $$ (F={0,1},F^{256},\\oplus ,\\cdot) $$ \u662f\u4e00\u4e2a 256 \u7ef4\u7684\u5411\u91cf\u7a7a\u95f4\u3002\u5982\u679c\u6211\u4eec\u53ef\u4ee5\u6c42\u5f97\u8be5\u5411\u91cf\u7a7a\u95f4\u7684\u4e00\u4e2a\u57fa\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u6c42\u5f97\u8be5\u7a7a\u95f4\u4e2d\u4efb\u610f\u6307\u5b9a\u503c\u7684\u6240\u9700\u8981\u7684\u5411\u91cf\u3002 \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 sage \u6765\u8f85\u52a9\u6211\u4eec\u6c42\uff0c\u5982\u4e0b # generage the base of <{0,1},F^256,xor,*> def gen_gf2_256_base (): v = VectorSpace ( GF ( 2 ), 256 ) tmphash = compute_file_hash ( \"0.py\" , \"\" ) tmphash_bin = hash2bin ( tmphash ) base = [ tmphash_bin ] filelist = [ '0.py' ] print base s = v . subspace ( base ) dim = s . dimension () cnt = 1 while dim != 256 : tmpfile = str ( cnt ) + \".py\" tmphash = compute_file_hash ( tmpfile , \"\" ) tmphash_bin = hash2bin ( tmphash ) old_dim = dim s = v . subspace ( base + [ tmphash_bin ]) dim = s . dimension () if dim > old_dim : base += [ tmphash_bin ] filelist . append ( tmpfile ) print ( \"dimension \" + str ( s . dimension ())) cnt += 1 print ( cnt ) m = matrix ( GF ( 2 ), 256 , 256 , base ) m = m . transpose () return m , filelist \u5173\u4e8e\u66f4\u52a0\u8be6\u7ec6\u7684\u89e3\u7b54\uff0c\u8bf7\u53c2\u8003 exp.py \u3002 \u8fd9\u91cc\u6211\u4fee\u6539 pre-copy \u591a\u8f93\u51fa !!!!come here!!!! \u5b57\u773c\uff0c\u5982\u4e0b \u279c software_update git: ( master ) python3 installer.py now.zip Preparing to copy data... !!!!come here!!!! Software update installed successfully. \u53c2\u8003\u6587\u732e https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py","title":"2017 34c3 Software_update"},{"location":"crypto/ctf-wiki/hash/complex-zh/#2019-36c3-sav-ls-l-aas","text":"\u8fd9\u4e2a\u9898\u7684\u5206\u7c7b\u662f Crypto&Web\uff0c\u634b\u4e00\u4e0b\u6d41\u7a0b\uff1a 60601\u7aef\u53e3\u5f00\u7740\u4e00\u4e2aWeb\u670d\u52a1\uff0c\u9898\u76ee\u63cf\u8ff0\u7ed9\u4e86\u8fde\u63a5\u65b9\u6cd5\uff1a url = 'http://78.47.240.226:60601' && ip = $( curl -s \" $url /ip\" ) && sig = $( curl -s -d \"cmd=ls -l&ip= $ip \" \" $url /sign\" ) && curl --data-urlencode \"signature= $sig \" \" $url /exec\" \u53ef\u4ee5\u770b\u5230\uff0c\u5148\u662f\u8bbf\u95ee /ip \u5f97\u5230 ip\uff0c\u518d\u5411 /sign post \u8fc7\u53bb ip \u548c\u6211\u4eec\u8981\u6267\u884c\u7684\u547d\u4ee4\uff0c\u5f97\u5230\u7b7e\u540d\uff0c\u6700\u540e\u5411 /exec post signature \u6765\u6267\u884c\u547d\u4ee4\u3002\u6211\u4eec\u6267\u884c\u8fd9\u4e00\u884c\u53ef\u4ee5\u53d1\u73b0\u56de\u663e\u4e86 ls -l \u6267\u884c\u7684\u7ed3\u679c\uff0c\u53d1\u73b0\u6709\u4e2a flag.txt\u3002 \u770b\u6e90\u7801\uff0cWeb \u670d\u52a1\u662f\u7531 go \u8d77\u7684\uff1a package main import ( \"bytes\" \"crypto/sha1\" \"encoding/json\" \"fmt\" \"io\" \"io/ioutil\" \"log\" \"net\" \"net/http\" \"strings\" \"time\" ) func main () { m := http . NewServeMux () m . HandleFunc ( \"/ip\" , func ( w http . ResponseWriter , r * http . Request ) { ip , _ , err := net . SplitHostPort ( r . RemoteAddr ) if err != nil { return } fmt . Fprint ( w , ip ) }) m . HandleFunc ( \"/sign\" , func ( w http . ResponseWriter , r * http . Request ) { ip , _ , err := net . SplitHostPort ( r . RemoteAddr ) if err != nil { return } remoteAddr := net . ParseIP ( ip ) if remoteAddr == nil { return } ip = r . PostFormValue ( \"ip\" ) signIP := net . ParseIP ( ip ) if signIP == nil || ! signIP . Equal ( remoteAddr ) { fmt . Fprintln ( w , \"lol, not ip :>\" ) return } cmd := r . PostFormValue ( \"cmd\" ) if cmd != \"ls -l\" { fmt . Fprintln ( w , \"lol, nope :>\" ) return } msg := ip + \"|\" + cmd digest := sha1 . Sum ([] byte ( msg )) b := new ( bytes . Buffer ) err = json . NewEncoder ( b ). Encode ( string ( digest [:])) if err != nil { return } resp , err := http . Post ( \"http://127.0.0.1/index.php?action=sign\" , \"application/json; charset=utf-8\" , b ) if err != nil || resp . StatusCode != 200 { fmt . Fprintln ( w , \"oops, hsm is down\" ) return } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { fmt . Fprintln ( w , \"oops, hsm is bodyless?\" ) return } var signature string err = json . Unmarshal ( body , & signature ) if err != nil { fmt . Fprintln ( w , \"oops, hsm is jsonless?\" ) return } fmt . Fprint ( w , signature + msg ) }) m . HandleFunc ( \"/exec\" , func ( w http . ResponseWriter , r * http . Request ) { ip , _ , err := net . SplitHostPort ( r . RemoteAddr ) if err != nil { return } remoteAddr := net . ParseIP ( ip ) if remoteAddr == nil { return } signature := r . PostFormValue ( \"signature\" ) digest := sha1 . Sum ([] byte ( signature [ 172 :])) b := new ( bytes . Buffer ) err = json . NewEncoder ( b ). Encode ( signature [: 172 ] + string ( digest [:])) if err != nil { fmt . Fprintln ( w , \"oops, json encode\" ) return } resp , err := http . Post ( \"http://127.0.0.1/index.php?action=verify\" , \"application/json; charset=utf-8\" , b ) if err != nil || resp . StatusCode != 200 { fmt . Fprintln ( w , \"oops, hsm is down?\" ) return } body , err := ioutil . ReadAll ( resp . Body ) if err != nil { fmt . Fprintln ( w , \"oops, hsm is bodyless?\" ) return } var valid bool err = json . Unmarshal ( body , & valid ) if err != nil { fmt . Fprintln ( w , \"oops, json unmarshal\" ) return } if valid { t := strings . Split ( signature [ 172 :], \"|\" ) if len ( t ) != 2 { fmt . Fprintln ( w , \"oops, split\" ) } signIP := net . ParseIP ( t [ 0 ]) if signIP == nil || ! signIP . Equal ( remoteAddr ) { fmt . Fprintln ( w , \"lol, not ip :>\" ) return } conn , err := net . DialTimeout ( \"tcp\" , \"127.0.0.1:1024\" , 1 * time . Second ) if err != nil { fmt . Fprintln ( w , \"oops, dial\" ) return } fmt . Fprintf ( conn , t [ 1 ] + \"\\n\" ) conn .( * net . TCPConn ). CloseWrite () io . Copy ( w , conn ) } }) s := & http . Server { Addr : \":60601\" , Handler : m , ReadTimeout : 5 * time . Second , WriteTimeout : 5 * time . Second , MaxHeaderBytes : 1 << 20 , } log . Fatal ( s . ListenAndServe ()) } \u4ee3\u7801\u5f88\u5bb9\u6613\u770b\uff0c\u9650\u5236\u4e86 cmd \u53ea\u80fd\u662f ls -l \uff0c\u5176\u4f59\u4e0d\u7ed9\u7b7e\u540d\uff0c\u770b\u6837\u5b50\u6211\u4eec\u662f\u8981\u4f2a\u9020\u5176\u4ed6\u547d\u4ee4\u7684\u7b7e\u540d\u6765\u8bfbflag\uff0c\u8fd9\u91cc\u6ce8\u610f\u5230\u7b7e\u540d\u548c\u9a8c\u7b7e\u7684\u8fc7\u7a0b\u662f\u4f20\u7ed9\u672c\u5730\u8d77\u7684\u4e00\u4e2a php \u6765\u5b8c\u6210\u7684\uff0c\u770b\u4e00\u4e0b\u8fd9\u90e8\u5206\u6e90\u7801\uff1a <?php define ( 'ALGO' , 'md5WithRSAEncryption' ); $d = json_decode ( file_get_contents ( 'php://input' ), JSON_THROW_ON_ERROR ); if ( $_GET [ 'action' ] === 'sign' ){ $pkeyid = openssl_pkey_get_private ( \"file:///var/www/private_key.pem\" ); openssl_sign ( $d , $signature , $pkeyid , ALGO ); echo json_encode ( base64_encode ( $signature )); openssl_free_key ( $pkeyid ); } elseif ( $_GET [ 'action' ] === 'verify' ) { $pkeyid = openssl_pkey_get_public ( \"file:///var/www/public_key.pem\" ); echo json_encode ( openssl_verify ( substr ( $d , 172 ), base64_decode ( substr ( $d , 0 , 172 )), $pkeyid , ALGO ) === 1 ); openssl_free_key ( $pkeyid ); } \u91c7\u7528\u7684\u662f md5WithRSAEncryption \u7684\u65b9\u5f0f\u7b7e\u540d\uff0c\u672c\u5730\u8bd5\u4e86\u4e00\u4e0b\uff0c\u662f\u628a\u6211\u4eec\u4f20\u5165\u7684 $d md5 \u540e\u8f6c\u4e3ahex\uff0c\u586b\u5145\u5230 0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff003020300c06082a864886f70d020505000410 \u540e\u9762\uff0c\u7ec4\u6210\u6570\u5b57\u7136\u540e\u7528RSA\u7b7e\u540d\u3002 \u770b\u6837\u5b50\u6574\u4e2a\u903b\u8f91\u627e\u4e0d\u5230\u4e00\u70b9\u95ee\u9898\uff0c\u7528\u7684\u90fd\u662f\u6807\u51c6\u5e93\uff0c\u57fa\u672c\u65e0\u6cd5\u653b\u51fb\u3002\u6709\u4e2a\u601d\u8def\u662f\u901a\u8fc7\u4ee3\u7406\u66f4\u6362 ip\uff0c\u53ef\u4ee5\u62ff\u5230\u4e24\u4e2a ip|ls -l \u7684\u7b7e\u540d\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u62e5\u6709\u4e86\u4e24\u7ec4 RSA \u7684 m \u548c c\uff0c\u56e0\u4e3a\u9898\u76ee\u7ed9\u4e86 dockerfile \u7ed9\u4e86\u751f\u6210\u516c\u79c1\u94a5\u7684\u65b9\u6cd5\uff0c\u4f7f\u7528 openssl \u9ed8\u8ba4\u751f\u6210\uff0ce\u4e3a65537\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6c42\u516c\u56e0\u6570\u7684\u65b9\u5f0f\u6765\u6c42\u51fa n\u3002 \u5728\u5f97\u5230\u4e24\u7ec4\u7b7e\u540d\u540e\uff0c\u6211\u4eec\u8981\u5f97\u5230 RSA \u7684m\uff0c\u5c31\u662f\u586b\u5145\u540e\u7684\u6570\uff0c\u6240\u4ee5\u6309\u7167\u4ee3\u7801\u903b\u8f91\uff0c\u5728 go \u91cc\u9762\u5148\u662f sha1: msg := ip + \"|\" + cmd digest := sha1 . Sum ([] byte ( msg )) b := new ( bytes . Buffer ) err = json . NewEncoder ( b ). Encode ( string ( digest [:])) \u518d php \u91cc\u7684 md5\uff0c\u5f97\u5230\u4e24\u7ec4 m \u548c c\uff0c\u4f46\u662f\u603b\u662f\u6c42\u4e0d\u51fa\u516c\u56e0\u6570 n\uff0c\u6000\u7591\u6c42\u7684 m \u4e0d\u5bf9\u3002\u770b\u4ee3\u7801\u53d1\u73b0 go \u91cc\u628a sha1\u7684\u7ed3\u679c\u7528 json \u7f16\u7801\uff0c\u7136\u540e\u4f20\u5230 php\u91cc json \u89e3\u7801\u3002\u8fd9\u90e8\u5206\u975e\u5e38\u53ef\u7591\uff0c\u4e3a\u4f55\u8981\u7528 json \u7f16\u7801\uff08\u7528 hex \u4f20\u8fc7\u53bb\u5b83\u4e0d\u9999\u4e48\uff09\uff0c\u672c\u5730\u642d\u4e00\u4e0b\u73af\u5883\u8ddf\u4e00\u4e0b\u3002\uff08\u9898\u76ee\u7ed9\u4e86dockerfile\uff09 \u8d77\u4e2adocker\uff0c\u6539\u4e00\u4e0b index.php\uff0c\u52a0\u4e00\u4e2a var_dump($d); \uff0c\u518d\u6539\u4e00\u4e0b go\uff0c\u8fd4\u56de\u4e00\u4e0b php \u7684\u7ed3\u679c\uff1a fmt . Fprintln ( w , string ( body )) \u73b0\u5728\u8ba9\u7a0b\u5e8f\u7b7e\u540d\uff0c\u8fd4\u56de\u7ed3\u679c\uff1a string(38) \"\u000e \u001d\ufffd\u0012\ufffd.\ufffd\ufffd\ufffd?-\ufffdKC\ufffd\u0005\ufffd@\ufffd\" \"K4FEmxz4yuTsjDAbRZQmHJ+MBiCSGaOnpZTLbThXpCkDYe3siAIPfihX6ppjN2Tz6XqOr4tF\\/u1\\/+ccfhj8NNLIL+2hknyDXbosmMBV8mEGYsMqQHAE0f+3OhDWlzN5RnteSMYNZbTipFErB8ZOWCiXmynWxsqJhyaN9J6\\/\\/h6I=\" oops, hsm is jsonless? $d \u7adf\u7136\u662f\u957f\u5ea6\u4e3a 38 \u7684\u5b57\u7b26\u4e32\uff0c\u770b\u6765\u679c\u7136\u662f\u8fd9\u91cc\u7f16\u7801\u6709\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u770b\u4e00\u4e0b\u6bcf\u4e2a\u6b65\u9aa4\u7684\u7ed3\u679c\uff0c\u5148\u770b\u4e00\u4e0b go \u91cc json\u7f16\u7801\u540e\u7684 sha1 \u7ed3\u679c\u662f\u4ec0\u4e48\uff1a package main import ( \"bytes\" \"crypto/sha1\" \"encoding/json\" \"fmt\" ) func main () { msg := \"172.17.0.1|ls -l\" digest := sha1 . Sum ([] byte ( msg )) b := new ( bytes . Buffer ) json . NewEncoder ( b ). Encode ( string ( digest [:])) fmt . Print ( string ( b . Bytes ())); } \u8fd0\u884c\u4e00\u4e0b\uff1a \"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\" \u548c\u6b63\u5e38\u7684sha1\u7684\u7ed3\u679c\u6765\u6bd4\u8f83\u4e00\u4e0b\uff1a Python 2 .7.16 ( default, Sep 2 2019 , 11 :59:44 ) [ GCC 4 .2.1 Compatible Apple LLVM 10 .0.1 ( clang-1001.0.46.4 )] on darwin Type \"help\" , \"copyright\" , \"credits\" or \"license\" for more information. >>> \"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\" '\\\\u000e\\t\\\\u001d\\\\ufffd\\\\u0012\\\\ufffd.\\\\ufffd\\\\ufffd\\\\ufffd?-\\\\ufffdKC\\\\ufffd\\\\u0005\\\\ufffd@\\\\ufffd' >>> from hashlib import * >>> sha1 ( '172.17.0.1|ls -l' ) .digest () '\\x0e\\t\\x1d\\xbd\\x12\\x90.\\xca\\xf0\\xd9?-\\x98KC\\xeb\\x05\\xa1@\\xd1' \u7531\u4e8e go \u7684 json \u7f16\u7801\uff0c\u5f88\u591a\u4e0d\u53ef\u89c1\u5b57\u7b26\u90fd\u88ab\u8f6c\u4e3a\u4e86 U+fffd \uff0c\u4e22\u5931\u4e86\u5f88\u591a\u4fe1\u606f\u3002 \u518d\u7ecf\u8fc7 php \u63a5\u53e3\u7684\u63a5\u6536\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u7ed3\u679c\uff1a $d = json_decode(file_get_contents('php://input'), JSON_THROW_ON_ERROR); var_dump(file_get_contents('php://input')); var_dump($d); var_dump(bin2hex($d)); \u7ed3\u679c\uff1a string(89) \"\"\\u000e\\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd\" \" string(38) \"\u000e \u001d\ufffd\u0012\ufffd.\ufffd\ufffd\ufffd?-\ufffdKC\ufffd\u0005\ufffd@\ufffd\" string(76) \"0e091defbfbd12efbfbd2eefbfbdefbfbdefbfbd3f2defbfbd4b43efbfbd05efbfbd40efbfbd\" \"K4FEmxz4yuTsjDAbRZQmHJ+MBiCSGaOnpZTLbThXpCkDYe3siAIPfihX6ppjN2Tz6XqOr4tF\\/u1\\/+ccfhj8NNLIL+2hknyDXbosmMBV8mEGYsMqQHAE0f+3OhDWlzN5RnteSMYNZbTipFErB8ZOWCiXmynWxsqJhyaN9J6\\/\\/h6I=\" oops, hsm is jsonless? U+fffd \u53d8\u6210\u4e86 \\xef\\xbf\\xbd \u3002\u6240\u4ee5\u7531\u4e8e go \u7684 json \u7f16\u7801\u95ee\u9898\uff0c\u4e22\u5931\u4e86\u5f88\u591a\u4fe1\u606f\uff0c\u9020\u6210\u4e86 md5 \u524d\u7684\u6570\u636e\u6709\u5f88\u591a\u76f8\u540c\u5b57\u7b26\u3002\u5f53\u65f6\u505a\u9898\u65f6\u5f80\u4e0b\u5e76\u6ca1\u6709\u7ec6\u60f3\uff0c\u5f97\u5230 n \u540e\u603b\u662f\u60f3\u6784\u9020\u51fa\u4efb\u610f\u547d\u4ee4\u7684\u7b7e\u540d\uff0c\u4e5f\u5f88\u7591\u60d1\u5982\u679c\u6784\u9020\u51fa\u5c82\u4e0d\u662f\u8fd9\u79cd\u7b7e\u540d\u5c31\u4e0d\u5b89\u5168\u4e86\uff1f\u5176\u5b9e\u662f\u65e0\u6cd5\u5f97\u5230\u7684\u3002 \u6b63\u89e3\u662f go \u7684\u8fd9\u79cd\u95ee\u9898 \uff0c\u4e3a\u78b0\u649e\u521b\u9020\u4e86\u6761\u4ef6\u3002\u6211\u4eec\u53ef\u4ee5\u78b0\u649e\u51fa\u5728\u8fd9\u79cd\u7f16\u7801\u60c5\u51b5\u4e0b\u4e0e ls -l \u6709\u76f8\u540c\u7ed3\u679c\u7684 cat * \u6b64\u7c7b\u547d\u4ee4\u3002\u4f46\u662f\u95ee\u9898\u662f\u6211\u4eec\u9700\u8981\u975e\u5e38\u5927\u91cf ip \u6765\u63d0\u4f9b\u78b0\u649e\u7684\u6570\u636e\u3002 \u53ef\u4ee5\u53d1\u73b0\uff0cgo \u53d6 ip \u7684\u65f6\u5019\uff0c\u662f\u5148\u7528 net.ParseIP \u89e3\u6790\u4e86 ip\uff0c\u6211\u4eec\u5728 ip \u6bcf\u4e2a\u6570\u5b57\u524d\u9762\u52a0 0 \uff0c\u89e3\u6790\u540e\u8fd8\u662f\u539f\u6765\u7684 ip \u7ed3\u679c\uff0c\u6bcf\u4e2a\u6570\u5b57\u6700\u591a\u6dfb\u52a0 256 \u4e2a 0\uff0c\u56db\u4e2a\u6570\u5b57\u5c31\u5df2\u7ecf\u4ea7\u751f\u4e86 2^32 \u79cd\u4e0d\u540c\u7684\u7ec4\u5408\uff0c\u8db3\u4ee5\u78b0\u649e\u51fa ls -l \u4e0e cat * \u4e4b\u95f4\u7684\u51b2\u7a81\u3002 \u5b98\u65b9\u9898\u89e3\u7684 c++ \u78b0\u649e\u811a\u672c\u6211\u672c\u5730\u7f16\u8bd1\u7684\u6709\u70b9\u95ee\u9898\uff0c\u52a0\u4e86\u4e00\u4e9b\u5f15\u5165\u7684\u5934\u6587\u4ef6\uff1a // g++ -std=c++17 -march=native -O3 -lcrypto -lpthread gewalt.cpp -o gewalt #include <cassert> #include <iomanip> #include <string> #include <sstream> #include <iostream> #include <functional> #include <random> #include <unordered_map> #include <algorithm> #include <thread> #include <atomic> #include <mutex> #include <array> #include <openssl/sha.h> const unsigned num_threads = std :: thread :: hardware_concurrency (); static std :: string hash ( std :: string const & s ) { SHA_CTX ctx ; if ( ! SHA1_Init ( & ctx )) throw ; if ( ! SHA1_Update ( & ctx , s . data (), s . length ())) throw ; std :: string d ( SHA_DIGEST_LENGTH , 0 ); if ( ! SHA1_Final (( uint8_t * ) & d [ 0 ], & ctx )) throw ; return d ; } static std :: u32string kapot ( std :: string const & s ) { std :: u32string r ( s . size (), 0 ); size_t o = 0 ; for ( size_t i = 0 ; i < s . length (); ) { auto T = []( uint8_t c ) { return ( c < 0x80 ) ? 1 /* ASCII */ : ( c & 0xc0 ) == 0x80 ? 0 /* continuation */ : ( c & 0xe0 ) == 0xc0 ? 2 /* 2-byte chunk */ : ( c & 0xf0 ) == 0xe0 ? 3 /* 3-byte chunk */ : ( c & 0xf8 ) == 0xf0 ? 4 /* 4-byte chunk */ : - 1 ; }; uint32_t c = s [ i ++ ]; auto cont = [ & ]() { c = ( c << 6 ) | ( s [ i ++ ] & 0x3f ); }; switch ( T ( c )) { case - 1 : case 0 : invalid : c = 0xfffd ; /* fall through */ case 1 : valid : r [ o ++ ] = c ; break ; case 2 : if ( c &= 0x1f , i + 0 >= s . size () || T ( s [ i + 0 ])) goto invalid ; goto one ; case 3 : if ( c &= 0x1f , i + 1 >= s . size () || T ( s [ i + 0 ]) || T ( s [ i + 1 ])) goto invalid ; goto two ; case 4 : if ( c &= 0x1f , i + 2 >= s . size () || T ( s [ i + 0 ]) || T ( s [ i + 1 ]) || T ( s [ i + 2 ])) goto invalid ; cont (); two : cont (); one : cont (); goto valid ; } } r . resize ( o ); return r ; } std :: atomic < uint64_t > hcount = 0 , kcount = 0 ; typedef std :: unordered_map < std :: u32string , std :: string > tab_t ; tab_t tab0 , tab1 ; std :: mutex mtx ; std :: array < uint8_t , 4 > ip ; std :: string cmd0 , cmd1 ; class stuffer_t { private : std :: array < size_t , 4 > cnts ; size_t step ; std :: string cmd ; public : stuffer_t ( size_t t , size_t s , std :: string c ) : cnts { t }, step ( s ), cmd ( c ) {} std :: string operator ()() { //XXX this is by far not the most efficient way of doing this, but yeah if ( ++ cnts [ 3 ] >= cnts [ 0 ]) { cnts [ 3 ] = 0 ; if ( ++ cnts [ 2 ] >= cnts [ 0 ]) { cnts [ 2 ] = 0 ; if ( ++ cnts [ 1 ] >= cnts [ 0 ]) { cnts [ 1 ] = 0 ; cnts [ 0 ] += step ; } } } std :: stringstream o ; for ( size_t i = 0 ; i < 4 ; ++ i ) o << ( i ? \".\" : \"\" ) << std :: string ( cnts [ i ], '0' ) << ( unsigned ) ip [ i ]; o << \"|\" << cmd ; return o . str (); } }; void go ( size_t tid ) { //XXX tid stuff is a hack, but YOLO bool one = tid & 1 ; stuffer_t next ( tid >> 1 , ( num_threads + 1 ) >> 1 , one ? cmd1 : cmd0 ); tab_t & mytab = one ? tab1 : tab0 ; tab_t & thtab = one ? tab0 : tab1 ; uint64_t myhcount = 0 , mykcount = 0 ; while ( 1 ) { std :: string r = next (); { ++ myhcount ; auto h = hash ( r ); if (( h . size () + 3 ) / 4 < ( size_t ) std :: count_if ( h . begin (), h . end (), []( unsigned char c ) { return c < 0x80 ; })) continue ; ++ mykcount ; auto k = kapot ( h ); if ( k . size () > 3 + ( size_t ) std :: count ( k . begin (), k . end (), 0xfffd )) continue ; std :: lock_guard < std :: mutex > lck ( mtx ); hcount += myhcount , myhcount = 0 ; kcount += mykcount , mykcount = 0 ; if ( thtab . find ( k ) != thtab . end ()) { mytab [ k ] = r ; std :: cerr << \" \\r\\x1b [K\" << \" \\x1b [32m\" ; std :: cout << tab0 [ k ] << std :: endl << tab1 [ k ] << std :: endl ; std :: cerr << \" \\x1b [0m\" ; std :: cerr << std :: hex ; bool first = true ; for ( uint32_t c : k ) std :: cerr << ( first ? first = false , \"\" : \" \" ) << c ; std :: cerr << std :: endl ; std :: cerr << std :: dec << \"hash count: \\x1b [35m\" << hcount << \" \\x1b [0m\" ; { std :: stringstream s ; s << std :: fixed << std :: setprecision ( 2 ) << log ( hcount | 1 ) / log ( 2 ); std :: cerr << \" (2^ \\x1b [35m\" << std :: setw ( 5 ) << s . str () << \" \\x1b [0m\" << \")\" << std :: endl ; } std :: cerr << \"kapot count: \" << \" \\x1b [35m\" << kcount << \" \\x1b [0m\" ; { std :: stringstream s ; s << std :: fixed << std :: setprecision ( 2 ) << log ( kcount | 1 ) / log ( 2 ); std :: cerr << \" (2^ \\x1b [35m\" << std :: setw ( 5 ) << s . str () << \" \\x1b [0m)\" << std :: endl ; } std :: cerr << \"table sizes: \\x1b [35m\" << tab0 . size () << \" \\x1b [0m \\x1b [35m\" << tab1 . size () << \" \\x1b [0m\" << std :: endl ; exit ( 0 ); } if ( mytab . size () < ( 1 << 20 )) mytab [ k ] = r ; } hcount += myhcount ; kcount += mykcount ; } } void status () { while ( 1 ) { { std :: lock_guard < std :: mutex > lck ( mtx ); std :: cerr << \" \\r\\x1b [K\" ; std :: cerr << \"hash count: \\x1b [35m\" << std :: setw ( 12 ) << hcount << \" \\x1b [0m \" ; { std :: stringstream s ; s << std :: fixed << std :: setprecision ( 2 ) << log ( hcount | 1 ) / log ( 2 ); std :: cerr << \"(2^ \\x1b [35m\" << std :: setw ( 5 ) << s . str () << \" \\x1b [0m) | \" ; } std :: cerr << \"kapot count: \\x1b [35m\" << std :: setw ( 12 ) << kcount << \" \\x1b [0m \" ; { std :: stringstream s ; s << std :: fixed << std :: setprecision ( 2 ) << log ( kcount | 1 ) / log ( 2 ); std :: cerr << \"(2^ \\x1b [35m\" << std :: setw ( 5 ) << s . str () << \" \\x1b [0m) | \" ; } std :: cerr << \"tables: \\x1b [35m\" << std :: setw ( 9 ) << tab0 . size () << \" \" << std :: setw ( 9 ) << tab1 . size () << \" \\x1b [0m \" << std :: flush ; } std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } } int main ( int argc , char ** argv ) { if ( argc < 2 ) { std :: cerr << \" \\x1b [31mneed IPv4 in argv[1] \\x1b [0m\" << std :: endl ; exit ( 1 ); } { std :: stringstream ss ( argv [ 1 ]); for ( auto & v : ip ) { std :: string s ; std :: getline ( ss , s , '.' ); int n = std :: atoi ( s . c_str ()); if ( n < std :: numeric_limits < uint8_t >:: min () || n > std :: numeric_limits < uint8_t >:: max ()) goto bad_ip ; v = n ; } if ( ! ss ) { bad_ip : std :: cerr << \" \\x1b [31mbad IPv4 given? \\x1b [0m\" << std :: endl ; exit ( 2 ); } } if ( argc < 4 ) { std :: cerr << \" \\x1b [31mneed commands in argv[2] and argv[3] \\x1b [0m\" << std :: endl ; exit ( 2 ); } cmd0 = argv [ 2 ]; cmd1 = argv [ 3 ]; std :: thread status_thread ( status ); std :: vector < std :: thread > ts ; for ( unsigned i = 0 ; i < num_threads ; ++ i ) ts . push_back ( std :: thread ( go , i )); for ( auto & t : ts ) t . join (); } \u7f16\u8bd1\u53ef\u80fd\u4f1a\u627e\u4e0d\u5230 lcrypto \uff0c\u7f16\u8bd1\u547d\u4ee4\u52a0\u4e0a lcrypto \u8def\u5f84\uff08\u6211\u672c\u5730\u662f /usr/local/opt/openssl/lib\uff09 g++ -std = c++17 -march = native -O3 -lcrypto -lpthread gewalt.cpp -o gewalt -L/usr/local/opt/openssl/lib \u4e0e go \u4ea4\u4e92\u7684\u811a\u672c\uff1a #!/usr/bin/env python3 import sys , requests , subprocess benign_cmd = 'ls -l' exploit_cmd = 'cat *' ip , port = sys . argv [ 1 ], sys . argv [ 2 ] url = 'http:// {} : {} ' . format ( ip , port ) my_ip = requests . get ( url + '/ip' ) . text print ( '[+] IP: ' + my_ip ) o = subprocess . check_output ([ './gewalt' , my_ip , benign_cmd , exploit_cmd ]) print ( '[+] gewalt:' + o . decode ()) payload = {} for l in o . decode () . splitlines (): ip , cmd = l . split ( '|' ) payload [ 'benign' if cmd == benign_cmd else 'pwn' ] = ip , cmd print ( payload ) sig = requests . post ( url + '/sign' , data = { 'ip' : payload [ 'benign' ][ 0 ], 'cmd' : payload [ 'benign' ][ 1 ]}) . text print ( '[+] sig: ' + sig ) r = requests . post ( url + '/exec' , data = { 'signature' : sig [: 172 ] + payload [ 'pwn' ][ 0 ] + '|' + payload [ 'pwn' ][ 1 ]}) print ( r . text ) \u2699 \ue0b0 SaV-ls-l-aaS \ue0b0 python solve.py 127 .0.0.1 60601 [ + ] IP: 172 .17.0.1 fffd fffd fffd fffd fffd fffd 55 fffd fffd fffd fffd c fffd fffd fffd fffd fffd fffd fffd fffd hash count: 168104875 ( 2 ^27.32 ) kapot count: 3477222 ( 2 ^21.73 ) table sizes: 8745 8856 [ + ] gewalt:00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 | ls -l 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172 .17.000000000000000000000000.0000000000000000000000000000000000000001 | cat * { 'pwn' : ( u '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.17.000000000000000000000000.0000000000000000000000000000000000000001' , u 'cat *' ) , 'benign' : ( u '00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001' , u 'ls -l' )} [ + ] sig: ODxSukwtu4rHICBpzT23WGD7DCJNawhA0DUN/tcyv1AgwNmS8OPUnO5FnBBDgiaVx5OTYd4OjH8LVbKiXUBUBuFx1OHDgKBKG5umkKMLt+350SlgMWY5qWny9tPIU3I+X0A9FcADCBCi6f0PkXfc0CSCZXuFu9rAKnVGsbmaUwY = 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172 .000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 | ls -l hxp { FLAG } \u53c2\u8003\uff1a https://ctftime.org/writeup/17966","title":"2019 36c3 SaV-ls-l-aaS"},{"location":"crypto/ctf-wiki/hash/complex/","text":"EN | ZH \u7efc\u5408 \u00b6 2017 34c3 Software_update \u00b6 As you can see, the general meaning of the program is to upload a zip archive and then verify the signature of the files in the signed_data directory. Among them, the final verification method is to perform a sha256 hash on each file, and then XOR X is sent as input to rsa for signature. If verified, the corresponding pre-copy.py and post-copy.py files will be executed. The natural idea is that we modify the pre-copy.py or post-copy.py file so that it can read the flag and then bypass the signature again. There are two main ideas According to the given public key file to obtain the corresponding private key, and then modify the file to forge the signature, and then look at the public key file is almost unbreakable, so this can basically give up. After modifying the corresponding file, use the XOR feature to make its hash value the same as the original **, thus bypassing the signature detection. That is, the signed_data directory contains multiple files, so that the hash values of these files are finally XORed to offset the difference in hash values caused by modifying the pre-copy.py or post-copy.py files. Here, we choose the second method, here we choose to modify the pre-copy.py file, the specific ideas are as follows Calculate the original hash value of pre-copy.py. Modify the pre-copy.py file so that it can read the flag. At the same time, calculate the new hash value. XOR the two and find the difference or delta. Look for a series of files whose X-values are XORed exactly as delta. The key step is the third step, but in fact this file can be seen as a linear combination problem, that is, looking for several 256-dimensional 01 vectors to make the XOR value delta. and $$ (F={0,1},F^{256},\\oplus ,\\cdot) $$ Is a 256-dimensional vector space. If we can find a basis for the vector space, then we can find the required vector for any given value in the space. We can use sage to assist us, as follows # generage the base of <{0,1},F^256,xor,*> def gen_gf2_256_base (): v = VectorSpace ( GF ( 2 ), 256 ) tmphash = compute_file_hash ( \"0.py\" , \"\" ) tmphash_bin = hash2bin ( tmphash ) base = [ tmphash_bin ] filelist = [ '0.py' ] print base s = v . subspace ( base ) dim = s . dimension () cnt = 1 while dim != 256 : tmpfile = str ( cnt ) + \".py\" tmphash = compute_file_hash ( tmpfile , \"\" ) tmphash_bin = hash2bin ( tmphash ) old_dim = dim s = v . subspace ( base + [ tmphash_bin ]) dim = s . dimension () if dim > old_dim : base += [ tmphash_bin ] filelist . append ( tmpfile ) print ( \"dimension \" + str ( s . dimension ())) cnt += 1 print ( cnt ) m = matrix ( GF ( 2 ), 256 , 256 , base ) m = m . transpose () return m , filelist For more detailed answers, please refer to exp.py . Here I am modifying the pre-copy multi-output !!!!come here!!!! word, as follows \u279c software_update git: ( master ) python3 installer.py now.zip Preparing to copy data... !!!!come here!!!! Software update installed successfully. references \u00b6 https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py","title":"\u7efc\u5408"},{"location":"crypto/ctf-wiki/hash/complex/#_1","text":"","title":"\u7efc\u5408"},{"location":"crypto/ctf-wiki/hash/complex/#2017-34c3-software_update","text":"As you can see, the general meaning of the program is to upload a zip archive and then verify the signature of the files in the signed_data directory. Among them, the final verification method is to perform a sha256 hash on each file, and then XOR X is sent as input to rsa for signature. If verified, the corresponding pre-copy.py and post-copy.py files will be executed. The natural idea is that we modify the pre-copy.py or post-copy.py file so that it can read the flag and then bypass the signature again. There are two main ideas According to the given public key file to obtain the corresponding private key, and then modify the file to forge the signature, and then look at the public key file is almost unbreakable, so this can basically give up. After modifying the corresponding file, use the XOR feature to make its hash value the same as the original **, thus bypassing the signature detection. That is, the signed_data directory contains multiple files, so that the hash values of these files are finally XORed to offset the difference in hash values caused by modifying the pre-copy.py or post-copy.py files. Here, we choose the second method, here we choose to modify the pre-copy.py file, the specific ideas are as follows Calculate the original hash value of pre-copy.py. Modify the pre-copy.py file so that it can read the flag. At the same time, calculate the new hash value. XOR the two and find the difference or delta. Look for a series of files whose X-values are XORed exactly as delta. The key step is the third step, but in fact this file can be seen as a linear combination problem, that is, looking for several 256-dimensional 01 vectors to make the XOR value delta. and $$ (F={0,1},F^{256},\\oplus ,\\cdot) $$ Is a 256-dimensional vector space. If we can find a basis for the vector space, then we can find the required vector for any given value in the space. We can use sage to assist us, as follows # generage the base of <{0,1},F^256,xor,*> def gen_gf2_256_base (): v = VectorSpace ( GF ( 2 ), 256 ) tmphash = compute_file_hash ( \"0.py\" , \"\" ) tmphash_bin = hash2bin ( tmphash ) base = [ tmphash_bin ] filelist = [ '0.py' ] print base s = v . subspace ( base ) dim = s . dimension () cnt = 1 while dim != 256 : tmpfile = str ( cnt ) + \".py\" tmphash = compute_file_hash ( tmpfile , \"\" ) tmphash_bin = hash2bin ( tmphash ) old_dim = dim s = v . subspace ( base + [ tmphash_bin ]) dim = s . dimension () if dim > old_dim : base += [ tmphash_bin ] filelist . append ( tmpfile ) print ( \"dimension \" + str ( s . dimension ())) cnt += 1 print ( cnt ) m = matrix ( GF ( 2 ), 256 , 256 , base ) m = m . transpose () return m , filelist For more detailed answers, please refer to exp.py . Here I am modifying the pre-copy multi-output !!!!come here!!!! word, as follows \u279c software_update git: ( master ) python3 installer.py now.zip Preparing to copy data... !!!!come here!!!! Software update installed successfully.","title":"2017 34c3 Software_update"},{"location":"crypto/ctf-wiki/hash/complex/#references","text":"https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py","title":"references"},{"location":"crypto/ctf-wiki/hash/fnv-zh/","text":"EN | ZH Fowler\u2013Noll\u2013Vo hash function \u00b6 \u5177\u4f53\u8bf7\u53c2\u89c1 https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function \u3002 2018 \u7f51\u9f0e\u676f hashcoll \u00b6 \u5176\u5b9e\u8fd9\u9053\u9898\u662f\u4ece NSU Crypto \u6284\u8fc7\u6765\u7684\uff0c https://nsucrypto.nsu.ru/archive/2017/problems_solution \uff0c\u5177\u4f53\u7684 wp \u4e4b\u524d hellman \u4e5f\u5199\u4e86\uff0c https://gist.github.com/hellman/9bf8376cd04e7a8dd2ec7be1947261e9 \u3002 \u7b80\u5355\u770b\u4e00\u4e0b\u9898\u76ee h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 # 2**168 + 355 g = 374144419156711147060143317175368453031918731002211 L def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 \u9898\u76ee\u5e0c\u671b\u6211\u4eec\u7ed9\u51fa\u4e24\u4e2a\u6d88\u606f\uff0c\u5176\u54c8\u5e0c\u503c\u76f8\u540c\u3002\u5982\u679c\u6211\u4eec\u5c06\u8be5\u51fd\u6570\u5c55\u5f00\u7684\u8bdd\uff0c\u90a3\u4e48 hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} \u5047\u8bbe\u4e24\u4e2a\u6d88\u606f\u7684 hash \u503c\u76f8\u540c\u90a3\u4e48 h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\equiv h_0g^n+y_1g^n+y_2g_{n-1}+...+y_ng\\bmod 2^{256} h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\equiv h_0g^n+y_1g^n+y_2g_{n-1}+...+y_ng\\bmod 2^{256} \u8fdb\u800c (x_1-y_1)g^{n-1}+(x_2-y_2)g^{n-2}+...+(x_n-y_n)g^0 \\equiv 0 \\bmod 2^{256} (x_1-y_1)g^{n-1}+(x_2-y_2)g^{n-2}+...+(x_n-y_n)g^0 \\equiv 0 \\bmod 2^{256} \u5373\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230\u4e00\u4e2a n \u7ef4\u5411\u91cf z_i=x_i-y_i z_i=x_i-y_i \uff0c\u6ee1\u8db3\u4e0a\u8ff0\u7b49\u5f0f\u5373\u53ef\uff0c\u6211\u4eec\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5c06\u5176\u5316\u4e3a z_1g^{n-1}+z_2g^{n-2}+...+z_ng^0-k*2^{256}=0 z_1g^{n-1}+z_2g^{n-2}+...+z_ng^0-k*2^{256}=0 \u5373\u627e\u5230\u4e00\u7ec4\u5411\u91cf\u6ee1\u8db3\u4e0a\u8ff0\u8fd9\u4e2a\u5f0f\u5b50\u3002\u8fd9\u53ef\u4ee5\u8ba4\u4e3a\u662f LLL Paper \u4e2d\u7b2c\u4e8c\u4e2a\u4f8b\u5b50\u7684\u7b80\u5355\u60c5\u51b5\uff08\u53c2\u89c1\u683c\u95ee\u9898\u90e8\u5206\uff09\u3002 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5feb\u901f\u6784\u9020\u77e9\u9635\uff0c\u5982\u4e0b A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] \u4e4b\u540e\u6211\u4eec\u4f7f\u7528LLL \u7b97\u6cd5\u5373\u53ef\u83b7\u5f97\u4e24\u4e2a\u4e00\u6837\u7684\u54c8\u5e0c\u503c from sage.all import * mod = 2 ** 256 h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 g = 2 ** 168 + 355 def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 K = 2 ** 200 N = 50 base_str = 'a' * N base = map ( ord , base_str ) m = Matrix ( ZZ , N + 1 , N + 2 ) for i in xrange ( N + 1 ): ge = ZZ ( pow ( g , N - i , mod )) m [ i , i ] = 1 m [ i , N + 1 ] = ZZ ( ge * K ) m [ i , N + 1 ] = ZZ ( K * mod ) ml = m . LLL () ttt = ml . rows ()[ 0 ] print \"result:\" , ttt if ttt [ - 1 ] != 0 : print \"Zero not reached, increase K\" exit () else : msg = [] for i in xrange ( N ): msg . append ( base [ i ] + ttt [ i ]) if not ( 0 <= msg [ i ] <= 255 ): print \"Need more bytes!\" quit () print msg other = '' . join ( map ( chr , msg )) print shitty_hash ( base_str ) print shitty_hash ( other ) \u6ce8\u610f\u4e0d\u80fd\u76f4\u63a5\u4ec5\u4ec5\u4f7f\u7528 pow(g, N - i, mod)\uff0c\u4e0d\u7136\u751f\u6210\u7684\u6570\u4f1a\u5728 mod \u5bf9\u5e94\u7684\u57df\u4e2d\uff0c\u8fd9\u771f\u662f\u4e2a\u5927\u5751\u3002 \u5982\u4e0b \u279c hashcoll sage exp.sage result: ( 15 , -14, 17 , 14 , 6 , 0 , 12 , 21 , 8 , 29 , 6 , -4, -9, 10 , -2, -12, -6, 0 , -12, 13 , -28, -28, -24, -3, 6 , -5, -16, 15 , 17 , -14, 3 , -2, -16, -25, 3 , -21, -27, -9, 16 , 5 , -1, 0 , -3, -4, -4, -19, 6 , 8 , 0 , 0 , 0 , 0 ) [ 112 , 83 , 114 , 111 , 103 , 97 , 109 , 118 , 105 , 126 , 103 , 93 , 88 , 107 , 95 , 85 , 91 , 97 , 85 , 110 , 69 , 69 , 73 , 94 , 103 , 92 , 81 , 112 , 114 , 83 , 100 , 95 , 81 , 72 , 100 , 76 , 70 , 88 , 113 , 102 , 96 , 97 , 94 , 93 , 93 , 78 , 103 , 105 , 97 , 97 ] 106025341237231370726407656306665079105509255639964756437758376184556498283725 106025341237231370726407656306665079105509255639964756437758376184556498283725 \u5373\u6210\u529f\u3002","title":"Fnv zh"},{"location":"crypto/ctf-wiki/hash/fnv-zh/#fowlernollvo-hash-function","text":"\u5177\u4f53\u8bf7\u53c2\u89c1 https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function \u3002","title":"Fowler\u2013Noll\u2013Vo hash function"},{"location":"crypto/ctf-wiki/hash/fnv-zh/#2018-hashcoll","text":"\u5176\u5b9e\u8fd9\u9053\u9898\u662f\u4ece NSU Crypto \u6284\u8fc7\u6765\u7684\uff0c https://nsucrypto.nsu.ru/archive/2017/problems_solution \uff0c\u5177\u4f53\u7684 wp \u4e4b\u524d hellman \u4e5f\u5199\u4e86\uff0c https://gist.github.com/hellman/9bf8376cd04e7a8dd2ec7be1947261e9 \u3002 \u7b80\u5355\u770b\u4e00\u4e0b\u9898\u76ee h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 # 2**168 + 355 g = 374144419156711147060143317175368453031918731002211 L def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 \u9898\u76ee\u5e0c\u671b\u6211\u4eec\u7ed9\u51fa\u4e24\u4e2a\u6d88\u606f\uff0c\u5176\u54c8\u5e0c\u503c\u76f8\u540c\u3002\u5982\u679c\u6211\u4eec\u5c06\u8be5\u51fd\u6570\u5c55\u5f00\u7684\u8bdd\uff0c\u90a3\u4e48 hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} \u5047\u8bbe\u4e24\u4e2a\u6d88\u606f\u7684 hash \u503c\u76f8\u540c\u90a3\u4e48 h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\equiv h_0g^n+y_1g^n+y_2g_{n-1}+...+y_ng\\bmod 2^{256} h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\equiv h_0g^n+y_1g^n+y_2g_{n-1}+...+y_ng\\bmod 2^{256} \u8fdb\u800c (x_1-y_1)g^{n-1}+(x_2-y_2)g^{n-2}+...+(x_n-y_n)g^0 \\equiv 0 \\bmod 2^{256} (x_1-y_1)g^{n-1}+(x_2-y_2)g^{n-2}+...+(x_n-y_n)g^0 \\equiv 0 \\bmod 2^{256} \u5373\u6211\u4eec\u53ea\u9700\u8981\u627e\u5230\u4e00\u4e2a n \u7ef4\u5411\u91cf z_i=x_i-y_i z_i=x_i-y_i \uff0c\u6ee1\u8db3\u4e0a\u8ff0\u7b49\u5f0f\u5373\u53ef\uff0c\u6211\u4eec\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5c06\u5176\u5316\u4e3a z_1g^{n-1}+z_2g^{n-2}+...+z_ng^0-k*2^{256}=0 z_1g^{n-1}+z_2g^{n-2}+...+z_ng^0-k*2^{256}=0 \u5373\u627e\u5230\u4e00\u7ec4\u5411\u91cf\u6ee1\u8db3\u4e0a\u8ff0\u8fd9\u4e2a\u5f0f\u5b50\u3002\u8fd9\u53ef\u4ee5\u8ba4\u4e3a\u662f LLL Paper \u4e2d\u7b2c\u4e8c\u4e2a\u4f8b\u5b50\u7684\u7b80\u5355\u60c5\u51b5\uff08\u53c2\u89c1\u683c\u95ee\u9898\u90e8\u5206\uff09\u3002 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5feb\u901f\u6784\u9020\u77e9\u9635\uff0c\u5982\u4e0b A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] \u4e4b\u540e\u6211\u4eec\u4f7f\u7528LLL \u7b97\u6cd5\u5373\u53ef\u83b7\u5f97\u4e24\u4e2a\u4e00\u6837\u7684\u54c8\u5e0c\u503c from sage.all import * mod = 2 ** 256 h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 g = 2 ** 168 + 355 def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 K = 2 ** 200 N = 50 base_str = 'a' * N base = map ( ord , base_str ) m = Matrix ( ZZ , N + 1 , N + 2 ) for i in xrange ( N + 1 ): ge = ZZ ( pow ( g , N - i , mod )) m [ i , i ] = 1 m [ i , N + 1 ] = ZZ ( ge * K ) m [ i , N + 1 ] = ZZ ( K * mod ) ml = m . LLL () ttt = ml . rows ()[ 0 ] print \"result:\" , ttt if ttt [ - 1 ] != 0 : print \"Zero not reached, increase K\" exit () else : msg = [] for i in xrange ( N ): msg . append ( base [ i ] + ttt [ i ]) if not ( 0 <= msg [ i ] <= 255 ): print \"Need more bytes!\" quit () print msg other = '' . join ( map ( chr , msg )) print shitty_hash ( base_str ) print shitty_hash ( other ) \u6ce8\u610f\u4e0d\u80fd\u76f4\u63a5\u4ec5\u4ec5\u4f7f\u7528 pow(g, N - i, mod)\uff0c\u4e0d\u7136\u751f\u6210\u7684\u6570\u4f1a\u5728 mod \u5bf9\u5e94\u7684\u57df\u4e2d\uff0c\u8fd9\u771f\u662f\u4e2a\u5927\u5751\u3002 \u5982\u4e0b \u279c hashcoll sage exp.sage result: ( 15 , -14, 17 , 14 , 6 , 0 , 12 , 21 , 8 , 29 , 6 , -4, -9, 10 , -2, -12, -6, 0 , -12, 13 , -28, -28, -24, -3, 6 , -5, -16, 15 , 17 , -14, 3 , -2, -16, -25, 3 , -21, -27, -9, 16 , 5 , -1, 0 , -3, -4, -4, -19, 6 , 8 , 0 , 0 , 0 , 0 ) [ 112 , 83 , 114 , 111 , 103 , 97 , 109 , 118 , 105 , 126 , 103 , 93 , 88 , 107 , 95 , 85 , 91 , 97 , 85 , 110 , 69 , 69 , 73 , 94 , 103 , 92 , 81 , 112 , 114 , 83 , 100 , 95 , 81 , 72 , 100 , 76 , 70 , 88 , 113 , 102 , 96 , 97 , 94 , 93 , 93 , 78 , 103 , 105 , 97 , 97 ] 106025341237231370726407656306665079105509255639964756437758376184556498283725 106025341237231370726407656306665079105509255639964756437758376184556498283725 \u5373\u6210\u529f\u3002","title":"2018 \u7f51\u9f0e\u676f hashcoll"},{"location":"crypto/ctf-wiki/hash/fnv/","text":"EN | ZH Fowler\u2013Noll\u2013Vo hash function \u00b6 See https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function for details. 2018 \u7f51\u9f0e\u676fashcoll \u00b6 In fact, this question was copied from NSU Crypto, https://nsucrypto.nsu.ru/archive/2017/problems_solution , the specific wp before hellman also wrote, https://gist.github.com/hellman/9bf8376cd04e7a8dd2ec7be1947261e9 . Simply look at the topic h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 # 2**168 + 355 g = 374144419156711147060143317175368453031918731002211 L def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & amp ; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 The topic hopes that we give two messages with the same hash value. If we expand the function, then hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} Suppose the hash values of the two messages are the same. $ h_0g ^ n + x_1g ^ n + x_2g_ {n-1} + ... + x_ng equiv h_0g ^ n + y_1g ^ n + y_2g_ {n-1} + ... + y_ng bmod 2 ^ {256} $ and then $ (x_1-y_1) g ^ {n-1} + (x_2-y_2) g ^ {n-2} + ... + (x_n-y_n) g ^ 0 equiv 0 bmod 2 ^ {256} $ That is, we only need to find an n-dimensional vector z_i=x_i-y_i z_i=x_i-y_i , which satisfies the above equation, we can further convert it into $ z_1g ^ {n-1} + z_2g ^ {n-2} + ... + z_ng ^ 0-k * 2 ^ {256} = 0 $ That is, a set of vectors is found to satisfy the above formula. This can be thought of as a simple case of the second example in LLL Paper (see the Lattice Question section). Then we can quickly construct the matrix as follows A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] Then we can get two identical hashes using the LLL algorithm. from sage.all import * mod = 2 ** 256 h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 g = 2 ** 168 + 355 def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & amp ; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 K = 2 ** 200 N = 50 base_str = 'a' * N base = map ( word , base_str ) m = Matrix ( ZZ , N + 1 , N + 2 ) for i in xrange ( N + 1 ): ge = ZZ ( pow ( g , N - i , mod )) m [ i , i ] = 1 m [ i , N + 1 ] = ZZ ( ge * K ) m [ i , N + 1 ] = ZZ ( K * mod ) ml = m . LLL () ttt = ml . rows ()[ 0 ] print \"result:\" , ttt if ttt [ - 1 ] != 0 : print \"Zero not reached, increase K\" exit () else : msg = [] for i in xrange ( N ): msg . append ( base [ i ] + ttt [ i ]) if not ( 0 <= msg [ i ] <= 255 ): print \"Need more bytes!\" quit () print msg other = '' . join ( map ( chr , msg )) print shitty_hash ( base_str ) print shitty_hash ( other ) Note that you can't just use pow(g, N - i, mod) directly, otherwise the generated number will be in the domain corresponding to mod, which is really a big pit. as follows \u279c hashcoll sage exp.sage result: ( 15 , -14, 17 , 14 , 6 , 0 , 12 , 21 , 8 , 29 , 6 , -4, -9, 10 , -2, -12, -6, 0 , -12, 13 , -28, -28, -24, -3, 6 , -5, -16, 15 , 17 , -14, 3 , -2, -16, -25, 3 , -21, -27, -9, 16 , 5 , -1, 0 , -3, -4, -4, -19, 6 , 8 , 0 , 0 , 0 , 0 ) [ 112 , 83 , 114 , 111 , 103 , 97 , 109 , 118 , 105 , 126 , 103 , 93 , 88 , 107 , 95 , 85 , 91 , 97 , 85 , 110 , 69 , 69 , 73 , 94 , 103 , 92 , 81 , 112 , 114 , 83 , 100 , 95 , 81 , 72 , 100 , 76 , 70 , 88 , 113 , 102 , 96 , 97 , 94 , 93 , 93 , 78 , 103 , 105 , 97 , 97 ] 106025341237231370726407656306665079105509255639964756437758376184556498283725 106025341237231370726407656306665079105509255639964756437758376184556498283725 That is success.","title":"FNV"},{"location":"crypto/ctf-wiki/hash/fnv/#fowlernollvo-hash-function","text":"See https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function for details.","title":"Fowler\u2013Noll\u2013Vo hash function"},{"location":"crypto/ctf-wiki/hash/fnv/#2018-ashcoll","text":"In fact, this question was copied from NSU Crypto, https://nsucrypto.nsu.ru/archive/2017/problems_solution , the specific wp before hellman also wrote, https://gist.github.com/hellman/9bf8376cd04e7a8dd2ec7be1947261e9 . Simply look at the topic h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 # 2**168 + 355 g = 374144419156711147060143317175368453031918731002211 L def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & amp ; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 The topic hopes that we give two messages with the same hash value. If we expand the function, then hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} hash(m)=h_0g^n+x_1g^n+x_2g_{n-1}+...+x_ng \\bmod 2^{256} Suppose the hash values of the two messages are the same. $ h_0g ^ n + x_1g ^ n + x_2g_ {n-1} + ... + x_ng equiv h_0g ^ n + y_1g ^ n + y_2g_ {n-1} + ... + y_ng bmod 2 ^ {256} $ and then $ (x_1-y_1) g ^ {n-1} + (x_2-y_2) g ^ {n-2} + ... + (x_n-y_n) g ^ 0 equiv 0 bmod 2 ^ {256} $ That is, we only need to find an n-dimensional vector z_i=x_i-y_i z_i=x_i-y_i , which satisfies the above equation, we can further convert it into $ z_1g ^ {n-1} + z_2g ^ {n-2} + ... + z_ng ^ 0-k * 2 ^ {256} = 0 $ That is, a set of vectors is found to satisfy the above formula. This can be thought of as a simple case of the second example in LLL Paper (see the Lattice Question section). Then we can quickly construct the matrix as follows A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] A = \\left[ \\begin{matrix} 1 & 0 & 0 & \\cdots & 0 & Kg^{n-1} \\\\ 0 & 1 & 0 & \\cdots & 0 & Kg^{n-2} \\\\ 0 & 0 & 1 & \\cdots & 0 & Kg^{n-3} \\\\\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 &0 & \\cdots & 1 & K*mod \\\\ \\end{matrix} \\right] Then we can get two identical hashes using the LLL algorithm. from sage.all import * mod = 2 ** 256 h0 = 45740974929179720441799381904411404011270459520712533273451053262137196814399 g = 2 ** 168 + 355 def shitty_hash ( msg ): h = h0 msg = map ( ord , msg ) for i in msg : h = ( h + i ) * g # This line is just to screw you up :)) h = h & amp ; 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff return h - 0xe6168647f636 K = 2 ** 200 N = 50 base_str = 'a' * N base = map ( word , base_str ) m = Matrix ( ZZ , N + 1 , N + 2 ) for i in xrange ( N + 1 ): ge = ZZ ( pow ( g , N - i , mod )) m [ i , i ] = 1 m [ i , N + 1 ] = ZZ ( ge * K ) m [ i , N + 1 ] = ZZ ( K * mod ) ml = m . LLL () ttt = ml . rows ()[ 0 ] print \"result:\" , ttt if ttt [ - 1 ] != 0 : print \"Zero not reached, increase K\" exit () else : msg = [] for i in xrange ( N ): msg . append ( base [ i ] + ttt [ i ]) if not ( 0 <= msg [ i ] <= 255 ): print \"Need more bytes!\" quit () print msg other = '' . join ( map ( chr , msg )) print shitty_hash ( base_str ) print shitty_hash ( other ) Note that you can't just use pow(g, N - i, mod) directly, otherwise the generated number will be in the domain corresponding to mod, which is really a big pit. as follows \u279c hashcoll sage exp.sage result: ( 15 , -14, 17 , 14 , 6 , 0 , 12 , 21 , 8 , 29 , 6 , -4, -9, 10 , -2, -12, -6, 0 , -12, 13 , -28, -28, -24, -3, 6 , -5, -16, 15 , 17 , -14, 3 , -2, -16, -25, 3 , -21, -27, -9, 16 , 5 , -1, 0 , -3, -4, -4, -19, 6 , 8 , 0 , 0 , 0 , 0 ) [ 112 , 83 , 114 , 111 , 103 , 97 , 109 , 118 , 105 , 126 , 103 , 93 , 88 , 107 , 95 , 85 , 91 , 97 , 85 , 110 , 69 , 69 , 73 , 94 , 103 , 92 , 81 , 112 , 114 , 83 , 100 , 95 , 81 , 72 , 100 , 76 , 70 , 88 , 113 , 102 , 96 , 97 , 94 , 93 , 93 , 78 , 103 , 105 , 97 , 97 ] 106025341237231370726407656306665079105509255639964756437758376184556498283725 106025341237231370726407656306665079105509255639964756437758376184556498283725 That is success.","title":"2018 \u7f51\u9f0e\u676fashcoll"},{"location":"crypto/ctf-wiki/hash/introduction-zh/","text":"EN | ZH \u54c8\u5e0c\u51fd\u6570 \u00b6 \u54c8\u5e0c\u51fd\u6570\uff08Hash Function\uff09\u628a\u6d88\u606f\u6216\u6570\u636e\u538b\u7f29\u6210\u6458\u8981\uff0c\u4f7f\u5f97\u6570\u636e\u91cf\u53d8\u5c0f\u3002\u5176\u4e00\u822c\u6a21\u578b\u5982\u4e0b \u663e\u7136\u5bf9\u4e8e\u4efb\u4f55\u4e00\u4e2ahash\u503c\uff0c\u7406\u8bba\u4e0a\u5b58\u5728\u82e5\u5e72\u4e2a\u6d88\u606f\u4e0e\u4e4b\u5bf9\u5e94\uff0c\u5373\u78b0\u649e\u3002 \u54c8\u5e0c\u51fd\u6570\u7684\u57fa\u672c\u9700\u6c42\u5982\u4e0b \u9700\u6c42 \u63cf\u8ff0 \u8f93\u5165\u957f\u5ea6\u53ef\u53d8 hash\u51fd\u6570\u53ef\u4ee5\u5e94\u7528\u4e8e\u4efb\u610f\u957f\u5ea6\u7684\u6570\u636e \u8f93\u51fa\u957f\u5ea6\u56fa\u5b9a hash\u51fd\u6570\u7684\u8f93\u51fa\u957f\u5ea6\u56fa\u5b9a \u6548\u7387 \u5bf9\u4e8e\u4efb\u610f\u6d88\u606f x x \uff0c\u8ba1\u7b97 H(x) H(x) \u5f88\u5bb9\u6613 \u5355\u5411\u6027 \u5bf9\u4e8e\u4efb\u610f\u54c8\u5e0c\u503ch\uff0c\u60f3\u8981\u627e\u5230\u6ee1\u8db3 H(x)=h H(x)=h \u7684x\u5728\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u3002 \u6297\u5f31\u78b0\u649e\u6027 \u5bf9\u4e8e\u4efb\u610f\u6d88\u606fx\uff0c\u627e\u5230\u6ee1\u8db3\u53e6\u4e00\u6d88\u606fy\uff0c\u6ee1\u8db3 H(x)=H(y) H(x)=H(y) \uff0c\u5728\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u3002 \u6297\u5f3a\u78b0\u649e\u6027 \u627e\u5230\u4efb\u610f\u4e00\u5bf9\u6ee1\u8db3 H(x)=H(y) H(x)=H(y) \u7684\u6d88\u606fx\u548cy\u5728\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u3002 \u4f2a\u968f\u673a\u6027 \u54c8\u5e0c\u51fd\u6570\u7684\u8f93\u51fa\u6ee1\u8db3\u4f2a\u968f\u673a\u6027\u6d4b\u8bd5\u6807\u51c6\u3002 \u6563\u5217\u503c\u7684\u76ee\u7684\u5982\u4e0b \u786e\u4fdd\u6d88\u606f\u7684\u5b8c\u6574\u6027\uff0c\u5373\u786e\u4fdd\u6536\u5230\u7684\u6570\u636e\u786e\u5b9e\u548c\u53d1\u9001\u65f6\u7684\u4e00\u6837\uff08\u5373\u6ca1\u6709\u4fee\u6539\u3001\u63d2\u5165\u3001\u5220\u9664\u6216\u91cd\u653e\uff09\uff0c\u9632\u6b62\u4e2d\u95f4\u4eba\u7be1\u6539\u3002 \u5197\u4f59\u6821\u9a8c \u5355\u5411\u53e3\u4ee4\u6587\u4ef6\uff0c\u6bd4\u5982linux\u7cfb\u7edf\u7684\u5bc6\u7801 \u5165\u4fb5\u68c0\u6d4b\u548c\u75c5\u6bd2\u68c0\u6d4b\u4e2d\u7684\u7279\u5f81\u7801\u68c0\u6d4b \u76ee\u524d\u7684Hash\u51fd\u6570\u4e3b\u8981\u6709MD5\uff0cSHA1\uff0cSHA256\uff0cSHA512\u3002\u76ee\u524d\u7684\u5927\u591a\u6570hash\u51fd\u6570\u90fd\u662f\u8fed\u4ee3\u6027\u7684\uff0c\u5373\u4f7f\u7528\u540c\u4e00\u4e2ahash\u51fd\u6570\uff0c\u4e0d\u540c\u7684\u53c2\u6570\u8fdb\u884c\u591a\u6b21\u8fed\u4ee3\u8fd0\u7b97\u3002 \u7b97\u6cd5\u7c7b\u578b \u8f93\u51fa Hash \u503c\u957f\u5ea6 MD5 128 bit / 256 bit SHA1 160 bit SHA256 256 bit SHA512 512 bit","title":"Introduction zh"},{"location":"crypto/ctf-wiki/hash/introduction-zh/#_1","text":"\u54c8\u5e0c\u51fd\u6570\uff08Hash Function\uff09\u628a\u6d88\u606f\u6216\u6570\u636e\u538b\u7f29\u6210\u6458\u8981\uff0c\u4f7f\u5f97\u6570\u636e\u91cf\u53d8\u5c0f\u3002\u5176\u4e00\u822c\u6a21\u578b\u5982\u4e0b \u663e\u7136\u5bf9\u4e8e\u4efb\u4f55\u4e00\u4e2ahash\u503c\uff0c\u7406\u8bba\u4e0a\u5b58\u5728\u82e5\u5e72\u4e2a\u6d88\u606f\u4e0e\u4e4b\u5bf9\u5e94\uff0c\u5373\u78b0\u649e\u3002 \u54c8\u5e0c\u51fd\u6570\u7684\u57fa\u672c\u9700\u6c42\u5982\u4e0b \u9700\u6c42 \u63cf\u8ff0 \u8f93\u5165\u957f\u5ea6\u53ef\u53d8 hash\u51fd\u6570\u53ef\u4ee5\u5e94\u7528\u4e8e\u4efb\u610f\u957f\u5ea6\u7684\u6570\u636e \u8f93\u51fa\u957f\u5ea6\u56fa\u5b9a hash\u51fd\u6570\u7684\u8f93\u51fa\u957f\u5ea6\u56fa\u5b9a \u6548\u7387 \u5bf9\u4e8e\u4efb\u610f\u6d88\u606f x x \uff0c\u8ba1\u7b97 H(x) H(x) \u5f88\u5bb9\u6613 \u5355\u5411\u6027 \u5bf9\u4e8e\u4efb\u610f\u54c8\u5e0c\u503ch\uff0c\u60f3\u8981\u627e\u5230\u6ee1\u8db3 H(x)=h H(x)=h \u7684x\u5728\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u3002 \u6297\u5f31\u78b0\u649e\u6027 \u5bf9\u4e8e\u4efb\u610f\u6d88\u606fx\uff0c\u627e\u5230\u6ee1\u8db3\u53e6\u4e00\u6d88\u606fy\uff0c\u6ee1\u8db3 H(x)=H(y) H(x)=H(y) \uff0c\u5728\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u3002 \u6297\u5f3a\u78b0\u649e\u6027 \u627e\u5230\u4efb\u610f\u4e00\u5bf9\u6ee1\u8db3 H(x)=H(y) H(x)=H(y) \u7684\u6d88\u606fx\u548cy\u5728\u8ba1\u7b97\u4e0a\u4e0d\u53ef\u884c\u3002 \u4f2a\u968f\u673a\u6027 \u54c8\u5e0c\u51fd\u6570\u7684\u8f93\u51fa\u6ee1\u8db3\u4f2a\u968f\u673a\u6027\u6d4b\u8bd5\u6807\u51c6\u3002 \u6563\u5217\u503c\u7684\u76ee\u7684\u5982\u4e0b \u786e\u4fdd\u6d88\u606f\u7684\u5b8c\u6574\u6027\uff0c\u5373\u786e\u4fdd\u6536\u5230\u7684\u6570\u636e\u786e\u5b9e\u548c\u53d1\u9001\u65f6\u7684\u4e00\u6837\uff08\u5373\u6ca1\u6709\u4fee\u6539\u3001\u63d2\u5165\u3001\u5220\u9664\u6216\u91cd\u653e\uff09\uff0c\u9632\u6b62\u4e2d\u95f4\u4eba\u7be1\u6539\u3002 \u5197\u4f59\u6821\u9a8c \u5355\u5411\u53e3\u4ee4\u6587\u4ef6\uff0c\u6bd4\u5982linux\u7cfb\u7edf\u7684\u5bc6\u7801 \u5165\u4fb5\u68c0\u6d4b\u548c\u75c5\u6bd2\u68c0\u6d4b\u4e2d\u7684\u7279\u5f81\u7801\u68c0\u6d4b \u76ee\u524d\u7684Hash\u51fd\u6570\u4e3b\u8981\u6709MD5\uff0cSHA1\uff0cSHA256\uff0cSHA512\u3002\u76ee\u524d\u7684\u5927\u591a\u6570hash\u51fd\u6570\u90fd\u662f\u8fed\u4ee3\u6027\u7684\uff0c\u5373\u4f7f\u7528\u540c\u4e00\u4e2ahash\u51fd\u6570\uff0c\u4e0d\u540c\u7684\u53c2\u6570\u8fdb\u884c\u591a\u6b21\u8fed\u4ee3\u8fd0\u7b97\u3002 \u7b97\u6cd5\u7c7b\u578b \u8f93\u51fa Hash \u503c\u957f\u5ea6 MD5 128 bit / 256 bit SHA1 160 bit SHA256 256 bit SHA512 512 bit","title":"\u54c8\u5e0c\u51fd\u6570"},{"location":"crypto/ctf-wiki/hash/introduction/","text":"EN | ZH hash function \u00b6 A hash function compresses a message or data into a digest, making the amount of data smaller. Its general model is as follows Obviously for any hash value, there are theoretically several messages corresponding to it, namely collisions. The basic requirements of the hash function are as follows Requirements Description | Input length variable | hash function can be applied to data of any length | | Output length fixed | The output length of the hash function is fixed | | Efficiency | For any message x x , calculating H(x) H(x) is easy | | Unidirectional | For any hash value h, it is computationally infeasible to find x that satisfies H(x)=h H(x)=h . | | Weak Collision Resistance | For any message x, finding another message y that satisfies H(x)=H(y) H(x)=H(y) is not computationally feasible. | | Strong Collision Resistance | Finding any pair of messages x and y that satisfy H(x)=H(y) H(x)=H(y) is not computationally feasible. | | Pseudo-randomness | The output of the hash function satisfies the pseudo-randomness test criteria. | The purpose of the hash value is as follows Ensuring the integrity of the message, ie ensuring that the data received is exactly the same as it was sent (ie no modification, insertion, deletion or replay) to prevent tampering by the intermediary. Redundancy check One-way password file, such as the password of the Linux system Signature detection in intrusion detection and virus detection The current Hash functions mainly include MD5, SHA1, SHA256, and SHA512. Most of the current hash functions are iterative, that is, using the same hash function and performing multiple iterations with different parameters. Algorithm Type Output Hash Value Length | MD5 | 128 bit / 256 bit | | SHA1 | 160 bit | | SHA256 | 256 bit | | SHA512 | 512 bit |","title":"\u54c8\u5e0c\u51fd\u6570\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/hash/introduction/#hash-function","text":"A hash function compresses a message or data into a digest, making the amount of data smaller. Its general model is as follows Obviously for any hash value, there are theoretically several messages corresponding to it, namely collisions. The basic requirements of the hash function are as follows Requirements Description | Input length variable | hash function can be applied to data of any length | | Output length fixed | The output length of the hash function is fixed | | Efficiency | For any message x x , calculating H(x) H(x) is easy | | Unidirectional | For any hash value h, it is computationally infeasible to find x that satisfies H(x)=h H(x)=h . | | Weak Collision Resistance | For any message x, finding another message y that satisfies H(x)=H(y) H(x)=H(y) is not computationally feasible. | | Strong Collision Resistance | Finding any pair of messages x and y that satisfy H(x)=H(y) H(x)=H(y) is not computationally feasible. | | Pseudo-randomness | The output of the hash function satisfies the pseudo-randomness test criteria. | The purpose of the hash value is as follows Ensuring the integrity of the message, ie ensuring that the data received is exactly the same as it was sent (ie no modification, insertion, deletion or replay) to prevent tampering by the intermediary. Redundancy check One-way password file, such as the password of the Linux system Signature detection in intrusion detection and virus detection The current Hash functions mainly include MD5, SHA1, SHA256, and SHA512. Most of the current hash functions are iterative, that is, using the same hash function and performing multiple iterations with different parameters. Algorithm Type Output Hash Value Length | MD5 | 128 bit / 256 bit | | SHA1 | 160 bit | | SHA256 | 256 bit | | SHA512 | 512 bit |","title":"hash function"},{"location":"crypto/ctf-wiki/hash/md5-zh/","text":"EN | ZH MD5 \u00b6 \u57fa\u672c\u63cf\u8ff0 \u00b6 MD5\u7684\u8f93\u5165\u8f93\u51fa\u5982\u4e0b \u8f93\u5165\uff1a\u4efb\u610f\u957f\u7684\u6d88\u606f\uff0c512\u6bd4\u7279\u957f\u7684\u5206\u7ec4\u3002 \u8f93\u51fa\uff1a128\u6bd4\u7279\u7684\u6d88\u606f\u6458\u8981\u3002 \u5173\u4e8e\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff0c\u8bf7\u81ea\u884c\u641c\u7d22\u3002 \u6b64\u5916\uff0c\u6709\u65f6\u5019\u6211\u4eec\u83b7\u5f97\u5230\u7684md5\u662f16\u4f4d\u7684\uff0c\u5176\u5b9e\u90a316\u4f4d\u662f32\u4f4dmd5\u7684\u957f\u5ea6\uff0c\u662f\u4ece32\u4f4dmd5\u503c\u6765\u7684\u3002\u662f\u5c0632\u4f4dmd5\u53bb\u6389\u524d\u516b\u4f4d\uff0c\u53bb\u6389\u540e\u516b\u4f4d\u5f97\u5230\u7684\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570\u7684\u521d\u59cb\u5316\u6765\u5224\u65ad\u662f\u4e0d\u662fMD5\u51fd\u6570\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u6709\u5982\u4e0b\u56db\u4e2a\u521d\u59cb\u5316\u7684\u53d8\u91cf\uff0c\u53ef\u4ee5\u731c\u6d4b\u8be5\u51fd\u6570\u4e3aMD5\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u662fMD5\u51fd\u6570\u7684\u521d\u59cb\u5316IV\u3002 0x67452301\uff0c0xEFCDAB89\uff0c0x98BADCFE\uff0c0x10325476 \u7834\u89e3 \u00b6 \u76ee\u524d\u53ef\u4ee5\u8bf4md5\u5df2\u7ecf\u57fa\u672c\u88ab\u653b\u7834\u4e86\uff0c\u4e00\u822c\u7684MD5\u7684\u78b0\u649e\u90fd\u53ef\u4ee5\u5728\u5982\u4e0b\u7f51\u4e0a\u83b7\u53d6\u5230 http://www.cmd5.com/ http://www.ttmd5.com/ http://pmd5.com/ https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (\u751f\u6210\u6307\u5b9a\u524d\u7f00\u7684md5\u78b0\u649e) \u9898\u76ee \u00b6 CFF 2016 \u597d\u591a\u76d0 JarvisOJ \u597d\u591a\u76d0","title":"Md5 zh"},{"location":"crypto/ctf-wiki/hash/md5-zh/#md5","text":"","title":"MD5"},{"location":"crypto/ctf-wiki/hash/md5-zh/#_1","text":"MD5\u7684\u8f93\u5165\u8f93\u51fa\u5982\u4e0b \u8f93\u5165\uff1a\u4efb\u610f\u957f\u7684\u6d88\u606f\uff0c512\u6bd4\u7279\u957f\u7684\u5206\u7ec4\u3002 \u8f93\u51fa\uff1a128\u6bd4\u7279\u7684\u6d88\u606f\u6458\u8981\u3002 \u5173\u4e8e\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff0c\u8bf7\u81ea\u884c\u641c\u7d22\u3002 \u6b64\u5916\uff0c\u6709\u65f6\u5019\u6211\u4eec\u83b7\u5f97\u5230\u7684md5\u662f16\u4f4d\u7684\uff0c\u5176\u5b9e\u90a316\u4f4d\u662f32\u4f4dmd5\u7684\u957f\u5ea6\uff0c\u662f\u4ece32\u4f4dmd5\u503c\u6765\u7684\u3002\u662f\u5c0632\u4f4dmd5\u53bb\u6389\u524d\u516b\u4f4d\uff0c\u53bb\u6389\u540e\u516b\u4f4d\u5f97\u5230\u7684\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570\u7684\u521d\u59cb\u5316\u6765\u5224\u65ad\u662f\u4e0d\u662fMD5\u51fd\u6570\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u6709\u5982\u4e0b\u56db\u4e2a\u521d\u59cb\u5316\u7684\u53d8\u91cf\uff0c\u53ef\u4ee5\u731c\u6d4b\u8be5\u51fd\u6570\u4e3aMD5\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u662fMD5\u51fd\u6570\u7684\u521d\u59cb\u5316IV\u3002 0x67452301\uff0c0xEFCDAB89\uff0c0x98BADCFE\uff0c0x10325476","title":"\u57fa\u672c\u63cf\u8ff0"},{"location":"crypto/ctf-wiki/hash/md5-zh/#_2","text":"\u76ee\u524d\u53ef\u4ee5\u8bf4md5\u5df2\u7ecf\u57fa\u672c\u88ab\u653b\u7834\u4e86\uff0c\u4e00\u822c\u7684MD5\u7684\u78b0\u649e\u90fd\u53ef\u4ee5\u5728\u5982\u4e0b\u7f51\u4e0a\u83b7\u53d6\u5230 http://www.cmd5.com/ http://www.ttmd5.com/ http://pmd5.com/ https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (\u751f\u6210\u6307\u5b9a\u524d\u7f00\u7684md5\u78b0\u649e)","title":"\u7834\u89e3"},{"location":"crypto/ctf-wiki/hash/md5-zh/#_3","text":"CFF 2016 \u597d\u591a\u76d0 JarvisOJ \u597d\u591a\u76d0","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/hash/md5/","text":"EN | ZH MD5 \u00b6 Basic description \u00b6 The input and output of MD5 are as follows Input: Any long message, 512-bit long packet. Output: 128-bit message digest. For a detailed introduction, please search for yourself. In addition, sometimes the md5 we get is 16-bit. In fact, the 16-bit is the length of the 32-bit md5, which is derived from the 32-bit md5 value. It is to remove the first eight bits of 32-bit md5 and get the last eight bits. In general, we can determine whether it is an MD5 function by initializing the function. In general, if a function has the following four initialized variables, you can guess that the function is an MD5 function, because this is the initialization IV of the MD5 function. 0x67452301\uff0c0xEFCDAB89\uff0c0x98BADCFE\uff0c0x10325476 Crack \u00b6 At present, it can be said that md5 has been basically broken. The general MD5 collision can be obtained on the following online. http://www.cmd5.com/ http://www.ttmd5.com/ http://pmd5.com/ https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (generate md5 collision with the specified prefix) topic \u00b6 CFF 2016 a lot of salt JarvisOJ a lot of salt","title":"MD5"},{"location":"crypto/ctf-wiki/hash/md5/#md5","text":"","title":"MD5"},{"location":"crypto/ctf-wiki/hash/md5/#basic-description","text":"The input and output of MD5 are as follows Input: Any long message, 512-bit long packet. Output: 128-bit message digest. For a detailed introduction, please search for yourself. In addition, sometimes the md5 we get is 16-bit. In fact, the 16-bit is the length of the 32-bit md5, which is derived from the 32-bit md5 value. It is to remove the first eight bits of 32-bit md5 and get the last eight bits. In general, we can determine whether it is an MD5 function by initializing the function. In general, if a function has the following four initialized variables, you can guess that the function is an MD5 function, because this is the initialization IV of the MD5 function. 0x67452301\uff0c0xEFCDAB89\uff0c0x98BADCFE\uff0c0x10325476","title":"Basic description"},{"location":"crypto/ctf-wiki/hash/md5/#crack","text":"At present, it can be said that md5 has been basically broken. The general MD5 collision can be obtained on the following online. http://www.cmd5.com/ http://www.ttmd5.com/ http://pmd5.com/ https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (generate md5 collision with the specified prefix)","title":"Crack"},{"location":"crypto/ctf-wiki/hash/md5/#topic","text":"CFF 2016 a lot of salt JarvisOJ a lot of salt","title":"topic"},{"location":"crypto/ctf-wiki/hash/sha1-zh/","text":"EN | ZH SHA1 \u00b6 \u57fa\u672c\u63cf\u8ff0 \u00b6 SHA1\u7684\u8f93\u5165\u8f93\u51fa\u5982\u4e0b \u8f93\u5165\uff1a\u4efb\u610f\u957f\u7684\u6d88\u606f\uff0c\u5206\u4e3a 512 \u6bd4\u7279 \u957f\u7684\u5206\u7ec4\u3002\u9996\u5148\u5728\u6d88\u606f\u53f3\u4fa7\u8865\u6bd4\u7279 1\uff0c\u7136\u540e\u518d\u8865\u82e5\u5e72\u4e2a\u6bd4\u7279 0\uff0c\u76f4\u5230\u6d88\u606f\u7684\u6bd4\u7279\u957f\u5ea6\u6ee1\u8db3\u5bf9 512 \u53d6\u6a21\u540e\u4f59\u6570\u662f 448\uff0c\u4f7f\u5176\u4e0e 448 \u6a21 512 \u540c\u4f59\u3002 \u8f93\u51fa\uff1a160 \u6bd4\u7279\u7684\u6d88\u606f\u6458\u8981\u3002 \u5173\u4e8e\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff0c\u8bf7\u81ea\u884c\u641c\u7d22\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570\u7684\u521d\u59cb\u5316\u6765\u5224\u65ad\u662f\u4e0d\u662f SHA1 \u51fd\u6570\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u6709\u5982\u4e0b\u4e94\u4e2a\u521d\u59cb\u5316\u7684\u53d8\u91cf\uff0c\u53ef\u4ee5\u731c\u6d4b\u8be5\u51fd\u6570\u4e3a SHA1 \u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u662f SHA1 \u51fd\u6570\u7684\u521d\u59cb\u5316IV\u3002 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476 0xC3D2E1F0 \u524d\u9762\u56db\u4e2a\u4e0e MD5 \u7c7b\u4f3c\uff0c\u540e\u9762\u7684\u662f\u65b0\u52a0\u7684\u3002 \u7834\u89e3 \u00b6 \u5c31\u76ee\u524d\u800c\u8a00\uff0cSHA1 \u5df2\u7ecf\u4e0d\u518d\u5b89\u5168\u4e86\uff0c\u56e0\u4e3a\u4e4b\u524d\u8c37\u6b4c\u516c\u5e03\u4e86\u6c42\u5f97\u4e24\u4e2a sha1 \u503c\u4e00\u6837\u7684 pdf\uff0c\u5177\u4f53\u8bf7\u53c2\u8003 shattered \u3002 \u8fd9\u91cc\u8fd8\u6709\u4e00\u4e2a\u6bd4\u8f83\u6709\u610f\u601d\u7684\u7f51\u7ad9\uff1a https://alf.nu/SHA1 \u3002 2017 SECCON SHA1 is dead \u00b6 \u9898\u76ee\u63cf\u8ff0\u5982\u4e0b file1 != file2 SHA1(file1) == SHA1(file2) SHA256(file1) <> SHA256(file2) 2017KiB < sizeof(file1) < 2018KiB 2017KiB < sizeof(file2) < 2018KiB \u5176\u4e2d 1KiB = 1024 bytes \u5373\u6211\u4eec\u9700\u8981\u627e\u5230\u4e24\u4e2a\u6587\u4ef6\u6ee1\u8db3\u4e0a\u8ff0\u7684\u7ea6\u675f\u3002 \u8fd9\u91cc\u7acb\u9a6c\u5c31\u60f3\u5230\u8c37\u6b4c\u4e4b\u524d\u516c\u5e03\u7684\u6587\u6863\uff0c\u800c\u4e14\uff0c\u975e\u5e38\u91cd\u8981\u7684\u662f\uff0c\u53ea\u8981\u4f7f\u7528\u7ed9\u5b9a\u7684\u524d 320 \u5b57\u8282\uff0c\u540e\u9762\u4efb\u610f\u6dfb\u52a0\u4e00\u6837\u7684\u5b57\u8282\u83b7\u53d6\u7684\u54c8\u5e0c\u4ecd\u7136\u4e00\u6837\uff0c\u8fd9\u91cc\u6211\u4eec\u6d4b\u8bd5\u5982\u4e0b \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-1.pdf | sha1sum \u8bb0\u5f55\u4e86320+0 \u7684\u8bfb\u5165 \u8bb0\u5f55\u4e86320+0 \u7684\u5199\u51fa 320 bytes copied, 0 .00796817 s, 40 .2 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-2.pdf | sha1sum \u8bb0\u5f55\u4e86320+0 \u7684\u8bfb\u5165 \u8bb0\u5f55\u4e86320+0 \u7684\u5199\u51fa 320 bytes copied, 0 .00397215 s, 80 .6 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - \u8fdb\u800c\u6211\u4eec\u76f4\u63a5\u5199\u7a0b\u5e8f\u5373\u53ef\uff0c\u5982\u4e0b from hashlib import sha1 from hashlib import sha256 pdf1 = open ( './shattered-1.pdf' ) . read ( 320 ) pdf2 = open ( './shattered-2.pdf' ) . read ( 320 ) pdf1 = pdf1 . ljust ( 2017 * 1024 + 1 - 320 , \" \\00 \" ) #padding pdf to 2017Kib + 1 pdf2 = pdf2 . ljust ( 2017 * 1024 + 1 - 320 , \" \\00 \" ) open ( \"upload1\" , \"w\" ) . write ( pdf1 ) open ( \"upload2\" , \"w\" ) . write ( pdf2 ) print sha1 ( pdf1 ) . hexdigest () print sha1 ( pdf2 ) . hexdigest () print sha256 ( pdf1 ) . hexdigest () print sha256 ( pdf2 ) . hexdigest () \u53c2\u8003\u6587\u732e \u00b6 https://www.slideshare.net/herumi/googlesha1","title":"Sha1 zh"},{"location":"crypto/ctf-wiki/hash/sha1-zh/#sha1","text":"","title":"SHA1"},{"location":"crypto/ctf-wiki/hash/sha1-zh/#_1","text":"SHA1\u7684\u8f93\u5165\u8f93\u51fa\u5982\u4e0b \u8f93\u5165\uff1a\u4efb\u610f\u957f\u7684\u6d88\u606f\uff0c\u5206\u4e3a 512 \u6bd4\u7279 \u957f\u7684\u5206\u7ec4\u3002\u9996\u5148\u5728\u6d88\u606f\u53f3\u4fa7\u8865\u6bd4\u7279 1\uff0c\u7136\u540e\u518d\u8865\u82e5\u5e72\u4e2a\u6bd4\u7279 0\uff0c\u76f4\u5230\u6d88\u606f\u7684\u6bd4\u7279\u957f\u5ea6\u6ee1\u8db3\u5bf9 512 \u53d6\u6a21\u540e\u4f59\u6570\u662f 448\uff0c\u4f7f\u5176\u4e0e 448 \u6a21 512 \u540c\u4f59\u3002 \u8f93\u51fa\uff1a160 \u6bd4\u7279\u7684\u6d88\u606f\u6458\u8981\u3002 \u5173\u4e8e\u8be6\u7ec6\u7684\u4ecb\u7ecd\uff0c\u8bf7\u81ea\u884c\u641c\u7d22\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u51fd\u6570\u7684\u521d\u59cb\u5316\u6765\u5224\u65ad\u662f\u4e0d\u662f SHA1 \u51fd\u6570\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5982\u679c\u4e00\u4e2a\u51fd\u6570\u6709\u5982\u4e0b\u4e94\u4e2a\u521d\u59cb\u5316\u7684\u53d8\u91cf\uff0c\u53ef\u4ee5\u731c\u6d4b\u8be5\u51fd\u6570\u4e3a SHA1 \u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u662f SHA1 \u51fd\u6570\u7684\u521d\u59cb\u5316IV\u3002 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476 0xC3D2E1F0 \u524d\u9762\u56db\u4e2a\u4e0e MD5 \u7c7b\u4f3c\uff0c\u540e\u9762\u7684\u662f\u65b0\u52a0\u7684\u3002","title":"\u57fa\u672c\u63cf\u8ff0"},{"location":"crypto/ctf-wiki/hash/sha1-zh/#_2","text":"\u5c31\u76ee\u524d\u800c\u8a00\uff0cSHA1 \u5df2\u7ecf\u4e0d\u518d\u5b89\u5168\u4e86\uff0c\u56e0\u4e3a\u4e4b\u524d\u8c37\u6b4c\u516c\u5e03\u4e86\u6c42\u5f97\u4e24\u4e2a sha1 \u503c\u4e00\u6837\u7684 pdf\uff0c\u5177\u4f53\u8bf7\u53c2\u8003 shattered \u3002 \u8fd9\u91cc\u8fd8\u6709\u4e00\u4e2a\u6bd4\u8f83\u6709\u610f\u601d\u7684\u7f51\u7ad9\uff1a https://alf.nu/SHA1 \u3002","title":"\u7834\u89e3"},{"location":"crypto/ctf-wiki/hash/sha1-zh/#2017-seccon-sha1-is-dead","text":"\u9898\u76ee\u63cf\u8ff0\u5982\u4e0b file1 != file2 SHA1(file1) == SHA1(file2) SHA256(file1) <> SHA256(file2) 2017KiB < sizeof(file1) < 2018KiB 2017KiB < sizeof(file2) < 2018KiB \u5176\u4e2d 1KiB = 1024 bytes \u5373\u6211\u4eec\u9700\u8981\u627e\u5230\u4e24\u4e2a\u6587\u4ef6\u6ee1\u8db3\u4e0a\u8ff0\u7684\u7ea6\u675f\u3002 \u8fd9\u91cc\u7acb\u9a6c\u5c31\u60f3\u5230\u8c37\u6b4c\u4e4b\u524d\u516c\u5e03\u7684\u6587\u6863\uff0c\u800c\u4e14\uff0c\u975e\u5e38\u91cd\u8981\u7684\u662f\uff0c\u53ea\u8981\u4f7f\u7528\u7ed9\u5b9a\u7684\u524d 320 \u5b57\u8282\uff0c\u540e\u9762\u4efb\u610f\u6dfb\u52a0\u4e00\u6837\u7684\u5b57\u8282\u83b7\u53d6\u7684\u54c8\u5e0c\u4ecd\u7136\u4e00\u6837\uff0c\u8fd9\u91cc\u6211\u4eec\u6d4b\u8bd5\u5982\u4e0b \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-1.pdf | sha1sum \u8bb0\u5f55\u4e86320+0 \u7684\u8bfb\u5165 \u8bb0\u5f55\u4e86320+0 \u7684\u5199\u51fa 320 bytes copied, 0 .00796817 s, 40 .2 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-2.pdf | sha1sum \u8bb0\u5f55\u4e86320+0 \u7684\u8bfb\u5165 \u8bb0\u5f55\u4e86320+0 \u7684\u5199\u51fa 320 bytes copied, 0 .00397215 s, 80 .6 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - \u8fdb\u800c\u6211\u4eec\u76f4\u63a5\u5199\u7a0b\u5e8f\u5373\u53ef\uff0c\u5982\u4e0b from hashlib import sha1 from hashlib import sha256 pdf1 = open ( './shattered-1.pdf' ) . read ( 320 ) pdf2 = open ( './shattered-2.pdf' ) . read ( 320 ) pdf1 = pdf1 . ljust ( 2017 * 1024 + 1 - 320 , \" \\00 \" ) #padding pdf to 2017Kib + 1 pdf2 = pdf2 . ljust ( 2017 * 1024 + 1 - 320 , \" \\00 \" ) open ( \"upload1\" , \"w\" ) . write ( pdf1 ) open ( \"upload2\" , \"w\" ) . write ( pdf2 ) print sha1 ( pdf1 ) . hexdigest () print sha1 ( pdf2 ) . hexdigest () print sha256 ( pdf1 ) . hexdigest () print sha256 ( pdf2 ) . hexdigest ()","title":"2017 SECCON SHA1 is dead"},{"location":"crypto/ctf-wiki/hash/sha1-zh/#_3","text":"https://www.slideshare.net/herumi/googlesha1","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/hash/sha1/","text":"EN | ZH SHA1 \u00b6 Basic description \u00b6 The input and output of SHA1 are as follows Input: Any long message divided into 512 bits long packets. First, bit 1 is added to the right side of the message, and then a number of bits 0 are added until the bit length of the message satisfies the modulo remainder of 512, which is 448, which is congruent with 448 modulo 512. Output: 160-bit message digest. For a detailed introduction, please search for yourself. In general, we can determine whether the SHA1 function is through the initialization of the function. In general, if a function has the following five initialized variables, you can guess that the function is a SHA1 function, because this is the initialization IV of the SHA1 function. 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476 0xC3D2E1F0 The first four are similar to the MD5, and the latter are new. Crack \u00b6 For now, SHA1 is no longer safe, because Google has previously published two pdfs with the same sha1 value, please refer to [shattered] ( https://shattered.io/ ). There is also a more interesting website here: https://alf.nu/SHA1 . 2017 SECCON SHA1 is dead \u00b6 The title is described below file1 != file2 SHA1(file1) == SHA1(file2) SHA256(file1) <> SHA256(file2) 2017KiB < sizeof(file1) < 2018KiB 2017KiB < sizeof(file2) < 2018KiB 1KiB = 1024 bytes That is, we need to find two files that satisfy the above constraints. Here is the idea of Google's previously published documents, and, very importantly, as long as the given first 320 bytes, the hash added after adding the same byte is still the same, here we test the following \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-1.pdf | sha1sum Recorded the reading of 320 +0 Recorded the write of 320 +0 320 bytes copied, 0 .00796817 s, 40 .2 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-2.pdf | sha1sum Recorded the reading of 320 +0 Recorded the write of 320 +0 320 bytes copied, 0 .00397215 s, 80 .6 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - Then we can write the program directly, as follows from hashlib import sha1 from hashlib import sha256 pdf1 = open ( './shattered-1.pdf' ) . read ( 320 ) pdf2 = open ( './shattered-2.pdf' ) . read ( 320 ) pdf1 = pdf1 . ljust ( 2017 * 1024 + 1 - 320 , & quot ; 00 & quot ;) #padding pdf to 2017Kib + 1 pdf2 = pdf2 . light ( 2017 * 1024 + 1 - 320 , & quot ; 00 & quot ;) open ( \"upload1\" , \"w\" ) . write ( pdf1 ) open ( \"upload2\" , \"w\" ) . write ( pdf2 ) print sha1 ( pdf1 ) . hexdigest () print sha1 ( pdf2 ) . hexdigest () print sha256 ( pdf1 ) . hexdigest () print sha256 ( pdf2 ) . hexdigest () references \u00b6 https://www.slideshare.net/herumi/googlesha1","title":"SHA1"},{"location":"crypto/ctf-wiki/hash/sha1/#sha1","text":"","title":"SHA1"},{"location":"crypto/ctf-wiki/hash/sha1/#basic-description","text":"The input and output of SHA1 are as follows Input: Any long message divided into 512 bits long packets. First, bit 1 is added to the right side of the message, and then a number of bits 0 are added until the bit length of the message satisfies the modulo remainder of 512, which is 448, which is congruent with 448 modulo 512. Output: 160-bit message digest. For a detailed introduction, please search for yourself. In general, we can determine whether the SHA1 function is through the initialization of the function. In general, if a function has the following five initialized variables, you can guess that the function is a SHA1 function, because this is the initialization IV of the SHA1 function. 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476 0xC3D2E1F0 The first four are similar to the MD5, and the latter are new.","title":"Basic description"},{"location":"crypto/ctf-wiki/hash/sha1/#crack","text":"For now, SHA1 is no longer safe, because Google has previously published two pdfs with the same sha1 value, please refer to [shattered] ( https://shattered.io/ ). There is also a more interesting website here: https://alf.nu/SHA1 .","title":"Crack"},{"location":"crypto/ctf-wiki/hash/sha1/#2017-seccon-sha1-is-dead","text":"The title is described below file1 != file2 SHA1(file1) == SHA1(file2) SHA256(file1) <> SHA256(file2) 2017KiB < sizeof(file1) < 2018KiB 2017KiB < sizeof(file2) < 2018KiB 1KiB = 1024 bytes That is, we need to find two files that satisfy the above constraints. Here is the idea of Google's previously published documents, and, very importantly, as long as the given first 320 bytes, the hash added after adding the same byte is still the same, here we test the following \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-1.pdf | sha1sum Recorded the reading of 320 +0 Recorded the write of 320 +0 320 bytes copied, 0 .00796817 s, 40 .2 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - \u279c 2017_seccon_sha1_is_dead git: ( master ) dd bs = 1 count = 320 <shattered-2.pdf | sha1sum Recorded the reading of 320 +0 Recorded the write of 320 +0 320 bytes copied, 0 .00397215 s, 80 .6 kB/s f92d74e3874587aaf443d1db961d4e26dde13e9c - Then we can write the program directly, as follows from hashlib import sha1 from hashlib import sha256 pdf1 = open ( './shattered-1.pdf' ) . read ( 320 ) pdf2 = open ( './shattered-2.pdf' ) . read ( 320 ) pdf1 = pdf1 . ljust ( 2017 * 1024 + 1 - 320 , & quot ; 00 & quot ;) #padding pdf to 2017Kib + 1 pdf2 = pdf2 . light ( 2017 * 1024 + 1 - 320 , & quot ; 00 & quot ;) open ( \"upload1\" , \"w\" ) . write ( pdf1 ) open ( \"upload2\" , \"w\" ) . write ( pdf2 ) print sha1 ( pdf1 ) . hexdigest () print sha1 ( pdf2 ) . hexdigest () print sha256 ( pdf1 ) . hexdigest () print sha256 ( pdf2 ) . hexdigest ()","title":"2017 SECCON SHA1 is dead"},{"location":"crypto/ctf-wiki/hash/sha1/#references","text":"https://www.slideshare.net/herumi/googlesha1","title":"references"},{"location":"crypto/ctf-wiki/signature/dsa-zh/","text":"EN | ZH DSA \u00b6 \u4e0a\u9762\u6240\u63cf\u8ff0\u7684ElGamal\u7b7e\u540d\u7b97\u6cd5\u5728\u5b9e\u9645\u4e2d\u5e76\u4e0d\u5e38\u7528\uff0c\u66f4\u5e38\u7528\u7684\u662f\u5176\u53d8\u4f53DSA\u3002 \u57fa\u672c\u539f\u7406 \u00b6 \u5bc6\u94a5\u751f\u6210 \u00b6 \u9009\u62e9\u4e00\u4e2a\u5408\u9002\u7684\u54c8\u5e0c\u51fd\u6570\uff0c\u76ee\u524d\u4e00\u822c\u9009\u62e9SHA1\uff0c\u5f53\u524d\u4e5f\u53ef\u4ee5\u9009\u62e9\u5f3a\u5ea6\u66f4\u9ad8\u7684\u54c8\u5e0c\u51fd\u6570H\u3002 \u9009\u62e9\u5bc6\u94a5\u7684\u957f\u5ea6L\u548cN\uff0c\u8fd9\u4e24\u4e2a\u503c\u51b3\u5b9a\u4e86\u7b7e\u540d\u7684\u5b89\u5168\u7a0b\u5ea6\u3002\u5728\u6700\u521d\u7684DSS\uff08 Digital Signature Standard \uff09\u4e2d\u5efa\u8baeL\u5fc5\u987b\u4e3a64\u7684\u500d\u6570\uff0c\u5e76\u4e14 512 \\leq L \\leq 1024 512 \\leq L \\leq 1024 \uff0c\u5f53\u7136\uff0c\u4e5f\u53ef\u4ee5\u66f4\u5927\u3002N\u5fc5\u987b\u5927\u5c0f\u5fc5\u987b\u4e0d\u5927\u4e8e\u54c8\u5e0c\u51fd\u6570H\u8f93\u51fa\u7684\u957f\u5ea6\u3002FIPS 186-3\u7ed9\u51fa\u4e86\u4e00\u4e9b\u5efa\u8bae\u7684L\u548cN\u7684\u53d6\u503c\u4f8b\u5b50\uff1a(1024, 160)\uff0c (2048, 224)\uff0c (2048, 256)\uff0c\u4ee5\u53ca (3,072, 256)\u3002 \u9009\u62e9N\u6bd4\u7279\u7684\u7d20\u6570q\u3002 \u9009\u62e9L\u6bd4\u7279\u7684\u7d20\u6570p\uff0c\u4f7f\u5f97p-1\u662fq\u7684\u500d\u6570\u3002 \u9009\u62e9\u6ee1\u8db3 g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p \u7684\u6700\u5c0f\u6b63\u6574\u6570k\u4e3aq\u7684g\uff0c\u5373\u5728\u6a21p\u7684\u80cc\u666f\u4e0b\uff0cord(g)=q\u7684g\u3002\u5373g\u5728\u6a21p\u7684\u610f\u4e49\u4e0b\uff0c\u5176\u6307\u6570\u6b21\u5e42\u53ef\u4ee5\u751f\u6210\u5177\u6709q\u4e2a\u5143\u7d20\u7684\u5b50\u7fa4\u3002\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8ba1\u7b97 g=h^{\\frac{p-1}{q}} \\bmod p g=h^{\\frac{p-1}{q}} \\bmod p \u6765\u5f97\u5230g\uff0c\u5176\u4e2d 1< h < p-1 1< h < p-1 \u3002 \u9009\u62e9\u79c1\u94a5x\uff0c 0<x<q 0<x<q \uff0c\u8ba1\u7b97 y \\equiv g^x \\bmod p y \\equiv g^x \\bmod p \u3002 \u516c\u94a5\u4e3a(p,q,g,y)\uff0c\u79c1\u94a5\u4e3a(x)\u3002 \u7b7e\u540d \u00b6 \u7b7e\u540d\u6b65\u9aa4\u5982\u4e0b \u9009\u62e9\u968f\u673a\u6574\u6570\u6570k\u4f5c\u4e3a\u4e34\u65f6\u5bc6\u94a5\uff0c 0<k<q 0<k<q \u3002 \u8ba1\u7b97 r\\equiv (g^k \\bmod p) \\bmod q r\\equiv (g^k \\bmod p) \\bmod q \u8ba1\u7b97 s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q \u7b7e\u540d\u7ed3\u679c\u4e3a(r,s)\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u91cc\u4e0eElgamal\u5f88\u91cd\u8981\u7684\u4e0d\u540c\u662f\u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u51fd\u6570\u5bf9\u6d88\u606f\u8fdb\u884c\u4e86\u54c8\u5e0c\u5904\u7406\u3002 \u9a8c\u8bc1 \u00b6 \u9a8c\u8bc1\u8fc7\u7a0b\u5982\u4e0b \u8ba1\u7b97\u8f85\u52a9\u503c\uff0c w=s^{-1} \\bmod q w=s^{-1} \\bmod q \u8ba1\u7b97\u8f85\u52a9\u503c\uff0c u_1=H(m)w \\bmod q u_1=H(m)w \\bmod q \u8ba1\u7b97\u8f85\u52a9\u503c\uff0c u_2=rw \\bmod q u_2=rw \\bmod q \u8ba1\u7b97 v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q \u5982\u679cv\u4e0er\u76f8\u7b49\uff0c\u5219\u6821\u9a8c\u6210\u529f\u3002 \u6b63\u786e\u6027\u63a8\u5bfc \u00b6 \u9996\u5148\uff0cg \u6ee1\u8db3 g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p \u7684\u6700\u5c0f\u6b63\u6574\u6570k\u4e3aq\u3002\u6240\u4ee5 g^q \\equiv 1 \\bmod p g^q \\equiv 1 \\bmod p \u3002\u6240\u4ee5 g^x \\equiv g^{x \\bmod q} \\bmod p g^x \\equiv g^{x \\bmod q} \\bmod p \u3002\u8fdb\u800c v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} \u53c8 s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q \u4e14 w=s^{-1} \\bmod q w=s^{-1} \\bmod q \u6240\u4ee5 k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q \u6240\u4ee5 v \\equiv g^k v \\equiv g^k \u3002\u6b63\u786e\u6027\u5f97\u8bc1\u3002 \u5b89\u5168\u6027 \u00b6 \u5df2\u77e5k \u00b6 \u539f\u7406 \u00b6 \u5982\u679c\u77e5\u9053\u4e86\u968f\u673a\u5bc6\u94a5k\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u6839\u636e s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q \u8ba1\u7b97\u79c1\u94a5d\uff0c\u51e0\u4e4e\u653b\u7834\u4e86DSA\u3002 \u8fd9\u91cc\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u6d88\u606f\u7684hash\u503c\u90fd\u4f1a\u7ed9\u51fa\u3002 x \\equiv r^{-1}(ks-H(m)) \\bmod q x \\equiv r^{-1}(ks-H(m)) \\bmod q k\u5171\u4eab \u00b6 \u539f\u7406 \u00b6 \u5982\u679c\u5728\u4e24\u6b21\u7b7e\u540d\u7684\u8fc7\u7a0b\u4e2d\u5171\u4eab\u4e86k\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u8fdb\u884c\u653b\u51fb\u3002 \u5047\u8bbe\u7b7e\u540d\u7684\u6d88\u606f\u4e3am1,m2\uff0c\u663e\u7136\uff0c\u4e24\u8005\u7684r\u7684\u503c\u4e00\u6837\uff0c\u6b64\u5916 s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q \u8fd9\u91cc\u6211\u4eec\u9664\u4e86x\u548ck\u4e0d\u77e5\u9053\u5269\u4e0b\u7684\u5747\u77e5\u9053\uff0c\u90a3\u4e48 s_1k \\equiv H(m_1)+xr s_1k \\equiv H(m_1)+xr s_2k \\equiv H(m_2)+xr s_2k \\equiv H(m_2)+xr \u4e24\u5f0f\u76f8\u51cf k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q \u6b64\u65f6 \u5373\u53ef\u89e3\u51fak\uff0c\u8fdb\u4e00\u6b65\u6211\u4eec\u53ef\u4ee5\u89e3\u51fax\u3002 \u4f8b\u5b50 \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5\u6e56\u6e58\u676f\u7684DSA\u4e3a\u4f8b\uff0c\u4f46\u662f\u4e0d\u80fd\u76f4\u63a5\u53bb\u505a\uff0c\uff0c\uff0c\u56e0\u4e3a\u53d1\u73b0\u5728\u9a8c\u8bc1message4\u7684\u65f6\u5019\u7b7e\u540d\u4e0d\u901a\u8fc7\u3002\u6e90\u9898\u76ee\u6211\u6ca1\u6709\u4e86\uff0c\u3002\uff0c\uff0c\u8fd9\u91cc\u6211\u4ee5Jarvis OJ\u4e2d\u7ecf\u8fc7\u4fee\u6539\u7684\u9898\u76eeDSA\u4e3a\u4f8b \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet1/sign1.bin packet1/message1 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message1 packet2/message1: No such file or directory \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message2 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet3/sign3.bin packet3/message3 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet4/sign4.bin packet4/message4 Verified OK \u53ef\u4ee5\u770b\u51fa\u56db\u5219\u6d88\u606f\u5168\u90e8\u6821\u9a8c\u901a\u8fc7\u3002\u8fd9\u91cc\u4e4b\u6240\u4ee5\u4f1a\u8054\u60f3\u5230\u5171\u4eabk\u662f\u56e0\u4e3a\u9898\u76ee\u4e2d\u63d0\u793a\u4e86PS3\u7684\u7834\u89e3\u66fe\u7528\u5230\u8fd9\u4e2a\u65b9\u6cd5\uff0c\u4ece\u7f51\u4e0a\u641c\u7d22\u53ef\u77e5\u8be5\u653b\u51fb\u3002 \u4e0b\u9762\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u7b7e\u540d\u540e\u7684\u503c\uff0c\u8fd9\u91cc\u4f7f\u7528\u7684\u547d\u4ee4\u5982\u4e0b \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet4/sign4.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 :d = 1 hl = 2 l = 20 prim: INTEGER :5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 :d = 1 hl = 2 l = 20 prim: INTEGER :5E10DED084203CCBCEC3356A2CA02FF318FD4123 \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet3/sign3.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 :d = 1 hl = 2 l = 20 prim: INTEGER :5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 :d = 1 hl = 2 l = 20 prim: INTEGER :30EB88E6A4BFB1B16728A974210AE4E41B42677D \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet2/sign2.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 :d = 1 hl = 2 l = 20 prim: INTEGER :60B9F2A5BA689B802942D667ED5D1EED066C5A7F 24 :d = 1 hl = 2 l = 20 prim: INTEGER :3DC8921BA26B514F4D991A85482750E0225A15B5 \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet1/sign1.bin 0 :d = 0 hl = 2 l = 45 cons: SEQUENCE 2 :d = 1 hl = 2 l = 21 prim: INTEGER :8158B477C5AA033D650596E93653C730D26BA409 25 :d = 1 hl = 2 l = 20 prim: INTEGER :165B9DD1C93230C31111E5A4E6EB5181F990F702 \u5176\u4e2d\uff0c\u83b7\u53d6\u7684\u7b2c\u4e00\u4e2a\u503c\u662fr\uff0c\u7b2c\u4e8c\u4e2a\u503c\u662fs\u3002\u53ef\u4ee5\u770b\u5230\u7b2c4\u4e2apacket\u548c\u7b2c3\u4e2apacket\u5171\u4eab\u4e86k\uff0c\u56e0\u4e3a\u4ed6\u4eec\u7684r\u4e00\u81f4\u3002 \u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528openssl\u770b\u4e0b\u516c\u94a5 \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl dsa -in dsa_public.pem -text -noout -pubin read DSA key pub: 45 :bb:18:f6:0e:b0:51:f9:d4:82:18:df:8c:d9:56: 33 :0a:4f:f3:0a:f5:34:4f:6c:95:40:06:1d:53:83: 29 :2d:95:c4:df:c8:ac:26:ca:45:2e:17:0d:c7:9b: e1:5c:c6:15:9e:03:7b:cc:f5:64:ef:36:1c:18:c9: 9e:8a:eb:0b:c1:ac:f9:c0:c3:5d:62:0d:60:bb:73: 11 :f1:cf:08:cf:bc:34:cc:aa:79:ef:1d:ad:8a:7a: 6f:ac:ce:86:65:90:06:d4:fa:f0:57:71:68:57:ec: 7c:a6:04:ad:e2:c3:d7:31:d6:d0:2f:93:31:98:d3: 90 :c3:ef:c3:f3:ff:04:6f P: 00 :c0:59:6c:3b:5e:93:3d:33:78:be:36:26:be:31: 5e:e7:0c:a6:b5:b1:1a:51:9b:55:23:d4:0e:5b:a7: 45 :66:e2:2c:c8:8b:fe:c5:6a:ad:66:91:8b:9b:30: ad:28:13:88:f0:bb:c6:b8:02:6b:7c:80:26:e9:11: 84 :be:e0:c8:ad:10:cc:f2:96:be:cf:e5:05:05:38: 3c:b4:a9:54:b3:7c:b5:88:67:2f:7c:09:57:b6:fd: f2:fa:05:38:fd:ad:83:93:4a:45:e4:f9:9d:38:de: 57 :c0:8a:24:d0:0d:1c:c5:d5:fb:db:73:29:1c:d1: 0c:e7:57:68:90:b6:ba:08:9b Q: 00 :86:8f:78:b8:c8:50:0b:eb:f6:7a:58:e3:3c:1f: 53 :9d:35:70:d1:bd G: 4c:d5:e6:b6:6a:6e:b7:e9:27:94:e3:61:1f:41:53: cb:11:af:5a:08:d9:d4:f8:a3:f2:50:03:72:91:ba: 5f:ff:3c:29:a8:c3:7b:c4:ee:5f:98:ec:17:f4:18: bc:71:61:01:6c:94:c8:49:02:e4:00:3a:79:87:f0: d8:cf:6a:61:c1:3a:fd:56:73:ca:a5:fb:41:15:08: cd:b3:50:1b:df:f7:3e:74:79:25:f7:65:86:f4:07: 9f:ea:12:09:8b:34:50:84:4a:2a:9e:5d:0a:99:bd: 86 :5e:05:70:d5:19:7d:f4:a1:c9:b8:01:8f:b9:9c: dc:e9:15:7b:98:50:01:79 \u4e0b\u9762\uff0c\u6211\u4eec\u76f4\u63a5\u5229\u7528\u4e0a\u9762\u7684\u539f\u7406\u7f16\u5199\u7a0b\u5e8f\u5373\u53ef\uff0c\u7a0b\u5e8f\u5982\u4e0b #coding=utf8 from Crypto.PublicKey import DSA from hashlib import sha1 import gmpy2 with open ( './dsa_public.pem' ) as f : key = DSA . importKey ( f ) y = key . y g = key . g p = key . p q = key . q f3 = open ( r \"packet3/message3\" , 'r' ) f4 = open ( r \"packet4/message4\" , 'r' ) data3 = f3 . read () data4 = f4 . read () sha = sha1 () sha . update ( data3 ) m3 = int ( sha . hexdigest (), 16 ) sha = sha1 () sha . update ( data4 ) m4 = int ( sha . hexdigest (), 16 ) print m3 , m4 s3 = 0x30EB88E6A4BFB1B16728A974210AE4E41B42677D s4 = 0x5E10DED084203CCBCEC3356A2CA02FF318FD4123 r = 0x5090DA81FEDE048D706D80E0AC47701E5A9EF1CC ds = s4 - s3 dm = m4 - m3 k = gmpy2 . mul ( dm , gmpy2 . invert ( ds , q )) k = gmpy2 . f_mod ( k , q ) tmp = gmpy2 . mul ( k , s3 ) - m3 x = tmp * gmpy2 . invert ( r , q ) x = gmpy2 . f_mod ( x , q ) print int ( x ) \u6211\u53d1\u73b0pip\u5b89\u88c5\u7684pycrypto\u7adf\u7136\u6ca1\u6709DSA\u7684importKey\u51fd\u6570\u3002\u3002\u3002\u53ea\u597d\u4ecegithub\u4e0a\u4e0b\u8f7d\u5b89\u88c5\u4e86pycrypto\u3002\u3002\u3002 \u7ed3\u679c\u5982\u4e0b \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 python exp.py 1104884177962524221174509726811256177146235961550 943735132044536149000710760545778628181961840230 520793588153805320783422521615148687785086070744","title":"Dsa zh"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#dsa","text":"\u4e0a\u9762\u6240\u63cf\u8ff0\u7684ElGamal\u7b7e\u540d\u7b97\u6cd5\u5728\u5b9e\u9645\u4e2d\u5e76\u4e0d\u5e38\u7528\uff0c\u66f4\u5e38\u7528\u7684\u662f\u5176\u53d8\u4f53DSA\u3002","title":"DSA"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_1","text":"","title":"\u57fa\u672c\u539f\u7406"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_2","text":"\u9009\u62e9\u4e00\u4e2a\u5408\u9002\u7684\u54c8\u5e0c\u51fd\u6570\uff0c\u76ee\u524d\u4e00\u822c\u9009\u62e9SHA1\uff0c\u5f53\u524d\u4e5f\u53ef\u4ee5\u9009\u62e9\u5f3a\u5ea6\u66f4\u9ad8\u7684\u54c8\u5e0c\u51fd\u6570H\u3002 \u9009\u62e9\u5bc6\u94a5\u7684\u957f\u5ea6L\u548cN\uff0c\u8fd9\u4e24\u4e2a\u503c\u51b3\u5b9a\u4e86\u7b7e\u540d\u7684\u5b89\u5168\u7a0b\u5ea6\u3002\u5728\u6700\u521d\u7684DSS\uff08 Digital Signature Standard \uff09\u4e2d\u5efa\u8baeL\u5fc5\u987b\u4e3a64\u7684\u500d\u6570\uff0c\u5e76\u4e14 512 \\leq L \\leq 1024 512 \\leq L \\leq 1024 \uff0c\u5f53\u7136\uff0c\u4e5f\u53ef\u4ee5\u66f4\u5927\u3002N\u5fc5\u987b\u5927\u5c0f\u5fc5\u987b\u4e0d\u5927\u4e8e\u54c8\u5e0c\u51fd\u6570H\u8f93\u51fa\u7684\u957f\u5ea6\u3002FIPS 186-3\u7ed9\u51fa\u4e86\u4e00\u4e9b\u5efa\u8bae\u7684L\u548cN\u7684\u53d6\u503c\u4f8b\u5b50\uff1a(1024, 160)\uff0c (2048, 224)\uff0c (2048, 256)\uff0c\u4ee5\u53ca (3,072, 256)\u3002 \u9009\u62e9N\u6bd4\u7279\u7684\u7d20\u6570q\u3002 \u9009\u62e9L\u6bd4\u7279\u7684\u7d20\u6570p\uff0c\u4f7f\u5f97p-1\u662fq\u7684\u500d\u6570\u3002 \u9009\u62e9\u6ee1\u8db3 g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p \u7684\u6700\u5c0f\u6b63\u6574\u6570k\u4e3aq\u7684g\uff0c\u5373\u5728\u6a21p\u7684\u80cc\u666f\u4e0b\uff0cord(g)=q\u7684g\u3002\u5373g\u5728\u6a21p\u7684\u610f\u4e49\u4e0b\uff0c\u5176\u6307\u6570\u6b21\u5e42\u53ef\u4ee5\u751f\u6210\u5177\u6709q\u4e2a\u5143\u7d20\u7684\u5b50\u7fa4\u3002\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8ba1\u7b97 g=h^{\\frac{p-1}{q}} \\bmod p g=h^{\\frac{p-1}{q}} \\bmod p \u6765\u5f97\u5230g\uff0c\u5176\u4e2d 1< h < p-1 1< h < p-1 \u3002 \u9009\u62e9\u79c1\u94a5x\uff0c 0<x<q 0<x<q \uff0c\u8ba1\u7b97 y \\equiv g^x \\bmod p y \\equiv g^x \\bmod p \u3002 \u516c\u94a5\u4e3a(p,q,g,y)\uff0c\u79c1\u94a5\u4e3a(x)\u3002","title":"\u5bc6\u94a5\u751f\u6210"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_3","text":"\u7b7e\u540d\u6b65\u9aa4\u5982\u4e0b \u9009\u62e9\u968f\u673a\u6574\u6570\u6570k\u4f5c\u4e3a\u4e34\u65f6\u5bc6\u94a5\uff0c 0<k<q 0<k<q \u3002 \u8ba1\u7b97 r\\equiv (g^k \\bmod p) \\bmod q r\\equiv (g^k \\bmod p) \\bmod q \u8ba1\u7b97 s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q \u7b7e\u540d\u7ed3\u679c\u4e3a(r,s)\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u91cc\u4e0eElgamal\u5f88\u91cd\u8981\u7684\u4e0d\u540c\u662f\u8fd9\u91cc\u4f7f\u7528\u4e86\u54c8\u5e0c\u51fd\u6570\u5bf9\u6d88\u606f\u8fdb\u884c\u4e86\u54c8\u5e0c\u5904\u7406\u3002","title":"\u7b7e\u540d"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_4","text":"\u9a8c\u8bc1\u8fc7\u7a0b\u5982\u4e0b \u8ba1\u7b97\u8f85\u52a9\u503c\uff0c w=s^{-1} \\bmod q w=s^{-1} \\bmod q \u8ba1\u7b97\u8f85\u52a9\u503c\uff0c u_1=H(m)w \\bmod q u_1=H(m)w \\bmod q \u8ba1\u7b97\u8f85\u52a9\u503c\uff0c u_2=rw \\bmod q u_2=rw \\bmod q \u8ba1\u7b97 v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q \u5982\u679cv\u4e0er\u76f8\u7b49\uff0c\u5219\u6821\u9a8c\u6210\u529f\u3002","title":"\u9a8c\u8bc1"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_5","text":"\u9996\u5148\uff0cg \u6ee1\u8db3 g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p \u7684\u6700\u5c0f\u6b63\u6574\u6570k\u4e3aq\u3002\u6240\u4ee5 g^q \\equiv 1 \\bmod p g^q \\equiv 1 \\bmod p \u3002\u6240\u4ee5 g^x \\equiv g^{x \\bmod q} \\bmod p g^x \\equiv g^{x \\bmod q} \\bmod p \u3002\u8fdb\u800c v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} \u53c8 s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q \u4e14 w=s^{-1} \\bmod q w=s^{-1} \\bmod q \u6240\u4ee5 k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q \u6240\u4ee5 v \\equiv g^k v \\equiv g^k \u3002\u6b63\u786e\u6027\u5f97\u8bc1\u3002","title":"\u6b63\u786e\u6027\u63a8\u5bfc"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_6","text":"","title":"\u5b89\u5168\u6027"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#k","text":"","title":"\u5df2\u77e5k"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_7","text":"\u5982\u679c\u77e5\u9053\u4e86\u968f\u673a\u5bc6\u94a5k\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u6839\u636e s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q \u8ba1\u7b97\u79c1\u94a5d\uff0c\u51e0\u4e4e\u653b\u7834\u4e86DSA\u3002 \u8fd9\u91cc\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u6d88\u606f\u7684hash\u503c\u90fd\u4f1a\u7ed9\u51fa\u3002 x \\equiv r^{-1}(ks-H(m)) \\bmod q x \\equiv r^{-1}(ks-H(m)) \\bmod q","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#k_1","text":"","title":"k\u5171\u4eab"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_8","text":"\u5982\u679c\u5728\u4e24\u6b21\u7b7e\u540d\u7684\u8fc7\u7a0b\u4e2d\u5171\u4eab\u4e86k\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u8fdb\u884c\u653b\u51fb\u3002 \u5047\u8bbe\u7b7e\u540d\u7684\u6d88\u606f\u4e3am1,m2\uff0c\u663e\u7136\uff0c\u4e24\u8005\u7684r\u7684\u503c\u4e00\u6837\uff0c\u6b64\u5916 s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q \u8fd9\u91cc\u6211\u4eec\u9664\u4e86x\u548ck\u4e0d\u77e5\u9053\u5269\u4e0b\u7684\u5747\u77e5\u9053\uff0c\u90a3\u4e48 s_1k \\equiv H(m_1)+xr s_1k \\equiv H(m_1)+xr s_2k \\equiv H(m_2)+xr s_2k \\equiv H(m_2)+xr \u4e24\u5f0f\u76f8\u51cf k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q \u6b64\u65f6 \u5373\u53ef\u89e3\u51fak\uff0c\u8fdb\u4e00\u6b65\u6211\u4eec\u53ef\u4ee5\u89e3\u51fax\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/signature/dsa-zh/#_9","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5\u6e56\u6e58\u676f\u7684DSA\u4e3a\u4f8b\uff0c\u4f46\u662f\u4e0d\u80fd\u76f4\u63a5\u53bb\u505a\uff0c\uff0c\uff0c\u56e0\u4e3a\u53d1\u73b0\u5728\u9a8c\u8bc1message4\u7684\u65f6\u5019\u7b7e\u540d\u4e0d\u901a\u8fc7\u3002\u6e90\u9898\u76ee\u6211\u6ca1\u6709\u4e86\uff0c\u3002\uff0c\uff0c\u8fd9\u91cc\u6211\u4ee5Jarvis OJ\u4e2d\u7ecf\u8fc7\u4fee\u6539\u7684\u9898\u76eeDSA\u4e3a\u4f8b \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet1/sign1.bin packet1/message1 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message1 packet2/message1: No such file or directory \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message2 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet3/sign3.bin packet3/message3 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet4/sign4.bin packet4/message4 Verified OK \u53ef\u4ee5\u770b\u51fa\u56db\u5219\u6d88\u606f\u5168\u90e8\u6821\u9a8c\u901a\u8fc7\u3002\u8fd9\u91cc\u4e4b\u6240\u4ee5\u4f1a\u8054\u60f3\u5230\u5171\u4eabk\u662f\u56e0\u4e3a\u9898\u76ee\u4e2d\u63d0\u793a\u4e86PS3\u7684\u7834\u89e3\u66fe\u7528\u5230\u8fd9\u4e2a\u65b9\u6cd5\uff0c\u4ece\u7f51\u4e0a\u641c\u7d22\u53ef\u77e5\u8be5\u653b\u51fb\u3002 \u4e0b\u9762\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u7b7e\u540d\u540e\u7684\u503c\uff0c\u8fd9\u91cc\u4f7f\u7528\u7684\u547d\u4ee4\u5982\u4e0b \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet4/sign4.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 :d = 1 hl = 2 l = 20 prim: INTEGER :5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 :d = 1 hl = 2 l = 20 prim: INTEGER :5E10DED084203CCBCEC3356A2CA02FF318FD4123 \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet3/sign3.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 :d = 1 hl = 2 l = 20 prim: INTEGER :5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 :d = 1 hl = 2 l = 20 prim: INTEGER :30EB88E6A4BFB1B16728A974210AE4E41B42677D \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet2/sign2.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 :d = 1 hl = 2 l = 20 prim: INTEGER :60B9F2A5BA689B802942D667ED5D1EED066C5A7F 24 :d = 1 hl = 2 l = 20 prim: INTEGER :3DC8921BA26B514F4D991A85482750E0225A15B5 \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet1/sign1.bin 0 :d = 0 hl = 2 l = 45 cons: SEQUENCE 2 :d = 1 hl = 2 l = 21 prim: INTEGER :8158B477C5AA033D650596E93653C730D26BA409 25 :d = 1 hl = 2 l = 20 prim: INTEGER :165B9DD1C93230C31111E5A4E6EB5181F990F702 \u5176\u4e2d\uff0c\u83b7\u53d6\u7684\u7b2c\u4e00\u4e2a\u503c\u662fr\uff0c\u7b2c\u4e8c\u4e2a\u503c\u662fs\u3002\u53ef\u4ee5\u770b\u5230\u7b2c4\u4e2apacket\u548c\u7b2c3\u4e2apacket\u5171\u4eab\u4e86k\uff0c\u56e0\u4e3a\u4ed6\u4eec\u7684r\u4e00\u81f4\u3002 \u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528openssl\u770b\u4e0b\u516c\u94a5 \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl dsa -in dsa_public.pem -text -noout -pubin read DSA key pub: 45 :bb:18:f6:0e:b0:51:f9:d4:82:18:df:8c:d9:56: 33 :0a:4f:f3:0a:f5:34:4f:6c:95:40:06:1d:53:83: 29 :2d:95:c4:df:c8:ac:26:ca:45:2e:17:0d:c7:9b: e1:5c:c6:15:9e:03:7b:cc:f5:64:ef:36:1c:18:c9: 9e:8a:eb:0b:c1:ac:f9:c0:c3:5d:62:0d:60:bb:73: 11 :f1:cf:08:cf:bc:34:cc:aa:79:ef:1d:ad:8a:7a: 6f:ac:ce:86:65:90:06:d4:fa:f0:57:71:68:57:ec: 7c:a6:04:ad:e2:c3:d7:31:d6:d0:2f:93:31:98:d3: 90 :c3:ef:c3:f3:ff:04:6f P: 00 :c0:59:6c:3b:5e:93:3d:33:78:be:36:26:be:31: 5e:e7:0c:a6:b5:b1:1a:51:9b:55:23:d4:0e:5b:a7: 45 :66:e2:2c:c8:8b:fe:c5:6a:ad:66:91:8b:9b:30: ad:28:13:88:f0:bb:c6:b8:02:6b:7c:80:26:e9:11: 84 :be:e0:c8:ad:10:cc:f2:96:be:cf:e5:05:05:38: 3c:b4:a9:54:b3:7c:b5:88:67:2f:7c:09:57:b6:fd: f2:fa:05:38:fd:ad:83:93:4a:45:e4:f9:9d:38:de: 57 :c0:8a:24:d0:0d:1c:c5:d5:fb:db:73:29:1c:d1: 0c:e7:57:68:90:b6:ba:08:9b Q: 00 :86:8f:78:b8:c8:50:0b:eb:f6:7a:58:e3:3c:1f: 53 :9d:35:70:d1:bd G: 4c:d5:e6:b6:6a:6e:b7:e9:27:94:e3:61:1f:41:53: cb:11:af:5a:08:d9:d4:f8:a3:f2:50:03:72:91:ba: 5f:ff:3c:29:a8:c3:7b:c4:ee:5f:98:ec:17:f4:18: bc:71:61:01:6c:94:c8:49:02:e4:00:3a:79:87:f0: d8:cf:6a:61:c1:3a:fd:56:73:ca:a5:fb:41:15:08: cd:b3:50:1b:df:f7:3e:74:79:25:f7:65:86:f4:07: 9f:ea:12:09:8b:34:50:84:4a:2a:9e:5d:0a:99:bd: 86 :5e:05:70:d5:19:7d:f4:a1:c9:b8:01:8f:b9:9c: dc:e9:15:7b:98:50:01:79 \u4e0b\u9762\uff0c\u6211\u4eec\u76f4\u63a5\u5229\u7528\u4e0a\u9762\u7684\u539f\u7406\u7f16\u5199\u7a0b\u5e8f\u5373\u53ef\uff0c\u7a0b\u5e8f\u5982\u4e0b #coding=utf8 from Crypto.PublicKey import DSA from hashlib import sha1 import gmpy2 with open ( './dsa_public.pem' ) as f : key = DSA . importKey ( f ) y = key . y g = key . g p = key . p q = key . q f3 = open ( r \"packet3/message3\" , 'r' ) f4 = open ( r \"packet4/message4\" , 'r' ) data3 = f3 . read () data4 = f4 . read () sha = sha1 () sha . update ( data3 ) m3 = int ( sha . hexdigest (), 16 ) sha = sha1 () sha . update ( data4 ) m4 = int ( sha . hexdigest (), 16 ) print m3 , m4 s3 = 0x30EB88E6A4BFB1B16728A974210AE4E41B42677D s4 = 0x5E10DED084203CCBCEC3356A2CA02FF318FD4123 r = 0x5090DA81FEDE048D706D80E0AC47701E5A9EF1CC ds = s4 - s3 dm = m4 - m3 k = gmpy2 . mul ( dm , gmpy2 . invert ( ds , q )) k = gmpy2 . f_mod ( k , q ) tmp = gmpy2 . mul ( k , s3 ) - m3 x = tmp * gmpy2 . invert ( r , q ) x = gmpy2 . f_mod ( x , q ) print int ( x ) \u6211\u53d1\u73b0pip\u5b89\u88c5\u7684pycrypto\u7adf\u7136\u6ca1\u6709DSA\u7684importKey\u51fd\u6570\u3002\u3002\u3002\u53ea\u597d\u4ecegithub\u4e0a\u4e0b\u8f7d\u5b89\u88c5\u4e86pycrypto\u3002\u3002\u3002 \u7ed3\u679c\u5982\u4e0b \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 python exp.py 1104884177962524221174509726811256177146235961550 943735132044536149000710760545778628181961840230 520793588153805320783422521615148687785086070744","title":"\u4f8b\u5b50"},{"location":"crypto/ctf-wiki/signature/dsa/","text":"EN | ZH DSA \u00b6 The ElGamal signature algorithm described above is not commonly used in practice, and its variant DSA is more commonly used. Fundamental \u00b6 Key Generation \u00b6 Select a suitable hash function. Currently, SHA1 is generally selected. Currently, a stronger hash function H can be selected. Select the length L and N of the key, which determine the security of the signature. In the original DSS ( Digital Signature Standard ) it was suggested that L must be a multiple of 64, and 512 \\leq L \\leq 1024 512 \\leq L \\leq 1024 , of course, can be larger. The N must be no larger than the length of the hash function H output. FIPS 186-3 gives some suggested examples of L and N values: (1024, 160), (2048, 224), (2048, 256), and (3, 072, 256). Select the prime number q of N bits. Select the prime number p of L bits such that p-1 is a multiple of q. Select the g that satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p as q, ie g in the background of modulo p, ord(g)=q. That is, in the sense of modulo p, its exponential power can generate subgroups with q elements. Here, we can get g by calculating g=h^{\\frac{p-1}{q}} \\bmod p g=h^{\\frac{p-1}{q}} \\bmod p , where 1< h < p-1 1&lt; h &lt; p-1 . Select private key x, 0 <x<q 0 <x<q \uff0c\u8ba1\u7b97 y \\equiv g^x \\bmod p y \\equiv g^x \\bmod p \u3002 The public key is (p, q, g, y) and the private key is (x). Signature \u00b6 The signature steps are as follows Select the random integer number k as the temporary key, 0 <k<q 0 <k<q \u3002 Calculate r\\equiv (g^k \\bmod p) \\bmod q r\\equiv (g^k \\bmod p) \\bmod q Calculate s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q The result of the signature is (r, s). It should be noted that the important difference here with Elgamal is that the hash function is used to hash the message. Verification \u00b6 The verification process is as follows Calculate the auxiliary value, w=s^{-1} \\bmod q w=s^{-1} \\bmod q Calculate the auxiliary value, u_1=H(m)w \\bmod q u_1=H(m)w \\bmod q Calculate the auxiliary value, u_2=rw \\bmod q u_2=rw \\bmod q \u8ba1\u7b97 $ v = (g ^ y ^ {} {u_1 u_2} way p) $ q way If v is equal to r, the verification is successful. Correctness derivation \u00b6 First, g satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p as q. So g^q \\equiv 1 \\bmod p g^q \\equiv 1 \\bmod p . So g^x \\equiv g^{x \\bmod q} \\bmod p g^x \\equiv g^{x \\bmod q} \\bmod p . and then v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} Also s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q and w=s^{-1} \\bmod q w=s^{-1} \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q So v \\equiv g^k v \\equiv g^k . Correctness is proven. safety \u00b6 Known k \u00b6 Principle \u00b6 If we know the random key k, then we can calculate the private key d based on s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q , which almost breaks the DSA. In general, the hash value of the message will be given. x \\equiv r^{-1}(ks-H(m)) \\bmod q x \\equiv r^{-1}(ks-H(m)) \\bmod q k\u5206\u4eab \u00b6 Principle \u00b6 If k is shared during the two signatures, we can attack. Suppose the signed message is m1, m2, obviously, the values of r are the same, in addition s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q Here we don't know the rest except x and k, then s_1k \\equiv H(m_1)+xr s_1k \\equiv H(m_1)+xr s_2k \\equiv H(m_2)+xr s_2k \\equiv H(m_2)+xr Two-type subtraction k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q At this point, we can solve for k, and further we can solve x. Example \u00b6 Here we take the DSA of the Huxiang Cup as an example, but we can't do it directly, because we found that the signature did not pass when verifying message4. I have no source questions. , here I take the modified topic DSA in Jarvis OJ as an example. \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet1/sign1.bin packet1/message1 Verified OK \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message1 packet2/message1: No such file or directory \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message2 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet3/sign3.bin packet3/message3 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet4/sign4.bin packet4/message4 Verified OK It can be seen that all four messages are verified. The reason why I think of sharing k here is because the title of the PS3 has been used to crack this method, from the online search can know the attack. Below, let's take a look at the signed value, the command used here is as follows \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet4/sign4.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 :d = 1 hl = 2 l = 20 prim: INTEGER :5E10DED084203CCBCEC3356A2CA02FF318FD4123 \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet3/sign3.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 : d = 1 hl = 2 l = 20 prim: INTEGER: 30EB88E6A4BFB1B16728A974210AE4E41B42677D \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet2/sign2.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 l = 20 prim: INTEGER: 60B9F2A5BA689B802942D667ED5D1EED066C5A7F 24 : d = 1 hl = 2 l = 20 prim: INTEGER: 3DC8921BA26B514F4D991A85482750E0225A15B5 \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet1/sign1.bin 0 :d = 0 hl = 2 l = 45 cons: SEQUENCE 2 : d = 1 hl = 2 l = 21 prim: INTEGER: 8158B477C5AA033D650596E93653C730D26BA409 25 : d = 1 hl = 2 l = 20 prim: INTEGER: 165B9DD1C93230C31111E5A4E6EB5181F990F702 Among them, the first value obtained is r, and the second value is s. You can see that the 4 th packet and the 3 rd packet share k because their r is the same. Here we can use openssl to see the public key \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl dsa -in dsa_public.pem -text -noout -pubin read DSA key pub: 45 : bb: 18 : f6: 0e: b0: 51 : f9: d4: 8c: d9: 56 : 33 :0a:4f:f3:0a:f5:34:4f:6c:95:40:06:1d:53:83: 29 : 2d: 95 : c4: df: c8: ac: 26 : c: 45 : 2e: 17 : e: 5c: c6: 15 : 9e: 03 : 7b: cc: f5: 64 : ef: 36 : 1c: 18 : c9: : 9 : 8 : 1 : 2 : 1 : 2 : 1 : 6 : 1 : 1 : 6 : 1 : 1 : 60 : bb: 73 : 0d: 60 : bb: 73 : 0 : 60 : 1 : 2 11 :f1:cf:08:cf:bc:34:cc:aa:79:ef:1d:ad:8a:7a: 6f: ac: it: 86 : 65 : 90 : 06 : d4: fa: f0: 57 : 71 : 68 : 57 : ec: 7c: a6: 04 : ad: e2: c3: d7: 31 : d6: d0: 2f: 93 : 31 : 98 : d3: 90 : c3: ef: c3: f3: ff: 04 : 6f P: 00 :c0:59:6c:3b:5e:93:3d:33:78:be:36:26:be:31: 5e: e7: 0c: a6: b5: b1: 1a: 51 : 9b: 55 : 23 : d4: 45 : 66 : e2: 2c: c8: 8b: f: c5: 6a: ad: 66 : ad:28:13:88:f0:bb:c6:b8:02:6b:7c:80:26:e9:11: 84 :be:e0:c8:ad:10:cc:f2:96:be:cf:e5:05:05:38: 3c: b4: a9: 54 : b3: 7c: b5: 88 : 67 : 2f: 7c: f2: fa: 05 : 38 : fd: ad: 83 : 93 : 4a: 45 : e4: f9: 9d: 38 : from: 57 :c0:8a:24:d0:0d:1c:c5:d5:fb:db:73:29:1c:d1: 0c: e7: 57 : 68 : 90 : b6: ba: 08 : 9b Q: 00 : 86 : 8f: 78 : b8: c8: 50 : 0b: eb: f6: 7a: 58 : e3: 53 : 9d: 35 : 70 : d1: bd G: 4c: d5: e6: b6: 6a: 6e: b7: e9: 27 : 94 : cb: 11 : af: 5a: 08 : d9: d4: f8: a3: f2: 50 : 03 : 72 : 91 : ba: 5f: ff: 3c: 29 : a8: c3: 7b: c4: ee: 5f: 98 : ec: 17 : f4: 18 : bc: 71 : 61 : 01 : 6c: 94 : c8: 49 : 02 : e4: 00 : d8:cf:6a:61:c1:3a:fd:56:73:ca:a5:fb:41:15:08: cd:b3:50:1b:df:f7:3e:74:79:25:f7:65:86:f4:07: 9f: it: 12 : 09 : 8b: 34 : 50 : 84 : 4 : 2 : 9e: 5d: 0A: 99 : bd: 86 : 5 : 05 : 70 : d5: 19 : 7d: f4: a1: c9: b8: 01 : 8f: b9: 9c: dc: e9: 15 : 7b: 98 : 50 : 01 : 79 Below, we can directly use the above principle to write a program, the program is as follows #coding=utf8 from Crypto.PublicKey import DSA from hashlib import sha1 import gmpy2 with open ( './dsa_public.pem' ) as f : key = DSA . importKey ( f ) y = key . y g = key . g p = key . p q = key . q f3 = open ( r \"packet3/message3\" , 'r' ) f4 = open ( r \"packet4/message4\" , 'r' ) data3 = f3 . read () data4 = f4 . read () Sha = sha1 () sha . update ( data3 ) m3 = int ( sha . hexdigest (), 16 ) Sha = sha1 () sha . update ( data4 ) m4 = int ( sha . hexdigest (), 16 ) print m3 , m4 s3 = 0x30EB88E6A4BFB1B16728A974210AE4E41B42677D s4 = 0x5E10DED084203CCBCEC3356A2CA02FF318FD4123 r = 0x5090DA81FEDE048D706D80E0AC47701E5A9EF1CC ds = s4 - s3 dm = m4 - m3 k = gmpy2 . mul ( dm , gmpy2 . invert ( ds , q )) k = gmpy2 . f_mod ( k , q ) tmp = gmpy2 . mul ( k , s3 ) - m3 x = tmp * gmpy2 . invert ( r , q ) x = gmpy2 . f_mod ( x , q ) print int ( x ) I found that pycrypto installed by pip does not have the importKey function of DSA. . . I had to download and install pycrypto from github. . . Results are as follows \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 python exp.py 1104884177962524221174509726811256177146235961550 943735132044536149000710760545778628181961840230 520793588153805320783422521615148687785086070744","title":"DSA \u6570\u5b57\u7b7e\u540d"},{"location":"crypto/ctf-wiki/signature/dsa/#dsa","text":"The ElGamal signature algorithm described above is not commonly used in practice, and its variant DSA is more commonly used.","title":"DSA"},{"location":"crypto/ctf-wiki/signature/dsa/#fundamental","text":"","title":"Fundamental"},{"location":"crypto/ctf-wiki/signature/dsa/#key-generation","text":"Select a suitable hash function. Currently, SHA1 is generally selected. Currently, a stronger hash function H can be selected. Select the length L and N of the key, which determine the security of the signature. In the original DSS ( Digital Signature Standard ) it was suggested that L must be a multiple of 64, and 512 \\leq L \\leq 1024 512 \\leq L \\leq 1024 , of course, can be larger. The N must be no larger than the length of the hash function H output. FIPS 186-3 gives some suggested examples of L and N values: (1024, 160), (2048, 224), (2048, 256), and (3, 072, 256). Select the prime number q of N bits. Select the prime number p of L bits such that p-1 is a multiple of q. Select the g that satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p as q, ie g in the background of modulo p, ord(g)=q. That is, in the sense of modulo p, its exponential power can generate subgroups with q elements. Here, we can get g by calculating g=h^{\\frac{p-1}{q}} \\bmod p g=h^{\\frac{p-1}{q}} \\bmod p , where 1< h < p-1 1&lt; h &lt; p-1 . Select private key x, 0 <x<q 0 <x<q \uff0c\u8ba1\u7b97 y \\equiv g^x \\bmod p y \\equiv g^x \\bmod p \u3002 The public key is (p, q, g, y) and the private key is (x).","title":"Key Generation"},{"location":"crypto/ctf-wiki/signature/dsa/#signature","text":"The signature steps are as follows Select the random integer number k as the temporary key, 0 <k<q 0 <k<q \u3002 Calculate r\\equiv (g^k \\bmod p) \\bmod q r\\equiv (g^k \\bmod p) \\bmod q Calculate s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q The result of the signature is (r, s). It should be noted that the important difference here with Elgamal is that the hash function is used to hash the message.","title":"Signature"},{"location":"crypto/ctf-wiki/signature/dsa/#verification","text":"The verification process is as follows Calculate the auxiliary value, w=s^{-1} \\bmod q w=s^{-1} \\bmod q Calculate the auxiliary value, u_1=H(m)w \\bmod q u_1=H(m)w \\bmod q Calculate the auxiliary value, u_2=rw \\bmod q u_2=rw \\bmod q \u8ba1\u7b97 $ v = (g ^ y ^ {} {u_1 u_2} way p) $ q way If v is equal to r, the verification is successful.","title":"Verification"},{"location":"crypto/ctf-wiki/signature/dsa/#correctness-derivation","text":"First, g satisfies the minimum positive integer k of g^k \\equiv 1 \\bmod p g^k \\equiv 1 \\bmod p as q. So g^q \\equiv 1 \\bmod p g^q \\equiv 1 \\bmod p . So g^x \\equiv g^{x \\bmod q} \\bmod p g^x \\equiv g^{x \\bmod q} \\bmod p . and then v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} v=(g^{u_1}y^{u_2} \\bmod p) \\bmod q=g^{u_1}g^{xu_2} \\equiv g^{H(m)w}g^{xrw} \\equiv g^{H(m)w+xrw} Also s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q and w=s^{-1} \\bmod q w=s^{-1} \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q k \\equiv s^{-1}(H(m)+xr) \\equiv H(m)w+xrw \\bmod q So v \\equiv g^k v \\equiv g^k . Correctness is proven.","title":"Correctness derivation"},{"location":"crypto/ctf-wiki/signature/dsa/#safety","text":"","title":"safety"},{"location":"crypto/ctf-wiki/signature/dsa/#known-k","text":"","title":"Known k"},{"location":"crypto/ctf-wiki/signature/dsa/#principle","text":"If we know the random key k, then we can calculate the private key d based on s\\equiv (H(m)+xr)k^{-1} \\bmod q s\\equiv (H(m)+xr)k^{-1} \\bmod q , which almost breaks the DSA. In general, the hash value of the message will be given. x \\equiv r^{-1}(ks-H(m)) \\bmod q x \\equiv r^{-1}(ks-H(m)) \\bmod q","title":"Principle"},{"location":"crypto/ctf-wiki/signature/dsa/#k","text":"","title":"k\u5206\u4eab"},{"location":"crypto/ctf-wiki/signature/dsa/#principle_1","text":"If k is shared during the two signatures, we can attack. Suppose the signed message is m1, m2, obviously, the values of r are the same, in addition s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_1\\equiv (H(m_1)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q s_2\\equiv (H(m_2)+xr)k^{-1} \\bmod q Here we don't know the rest except x and k, then s_1k \\equiv H(m_1)+xr s_1k \\equiv H(m_1)+xr s_2k \\equiv H(m_2)+xr s_2k \\equiv H(m_2)+xr Two-type subtraction k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q k(s_1-s_2) \\equiv H(m_1)-H(m_2) \\bmod q At this point, we can solve for k, and further we can solve x.","title":"Principle"},{"location":"crypto/ctf-wiki/signature/dsa/#example","text":"Here we take the DSA of the Huxiang Cup as an example, but we can't do it directly, because we found that the signature did not pass when verifying message4. I have no source questions. , here I take the modified topic DSA in Jarvis OJ as an example. \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet1/sign1.bin packet1/message1 Verified OK \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message1 packet2/message1: No such file or directory \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet2/sign2.bin packet2/message2 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet3/sign3.bin packet3/message3 Verified OK \u279c 2016\u6e56\u6e58\u676fDSA git: ( master ) \u2717 openssl sha1 -verify dsa_public.pem -signature packet4/sign4.bin packet4/message4 Verified OK It can be seen that all four messages are verified. The reason why I think of sharing k here is because the title of the PS3 has been used to crack this method, from the online search can know the attack. Below, let's take a look at the signed value, the command used here is as follows \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet4/sign4.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 :d = 1 hl = 2 l = 20 prim: INTEGER :5E10DED084203CCBCEC3356A2CA02FF318FD4123 \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet3/sign3.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 = 20 prime: INTEGER: 5090DA81FEDE048D706D80E0AC47701E5A9EF1CC 24 : d = 1 hl = 2 l = 20 prim: INTEGER: 30EB88E6A4BFB1B16728A974210AE4E41B42677D \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet2/sign2.bin 0 :d = 0 hl = 2 l = 44 cons: SEQUENCE 2 : d = 1 hl = 2 l = 20 prim: INTEGER: 60B9F2A5BA689B802942D667ED5D1EED066C5A7F 24 : d = 1 hl = 2 l = 20 prim: INTEGER: 3DC8921BA26B514F4D991A85482750E0225A15B5 \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl asn1parse -inform der -in packet1/sign1.bin 0 :d = 0 hl = 2 l = 45 cons: SEQUENCE 2 : d = 1 hl = 2 l = 21 prim: INTEGER: 8158B477C5AA033D650596E93653C730D26BA409 25 : d = 1 hl = 2 l = 20 prim: INTEGER: 165B9DD1C93230C31111E5A4E6EB5181F990F702 Among them, the first value obtained is r, and the second value is s. You can see that the 4 th packet and the 3 rd packet share k because their r is the same. Here we can use openssl to see the public key \u279c 2016 Hunan Cup DSA git: ( master ) \u2717 openssl dsa -in dsa_public.pem -text -noout -pubin read DSA key pub: 45 : bb: 18 : f6: 0e: b0: 51 : f9: d4: 8c: d9: 56 : 33 :0a:4f:f3:0a:f5:34:4f:6c:95:40:06:1d:53:83: 29 : 2d: 95 : c4: df: c8: ac: 26 : c: 45 : 2e: 17 : e: 5c: c6: 15 : 9e: 03 : 7b: cc: f5: 64 : ef: 36 : 1c: 18 : c9: : 9 : 8 : 1 : 2 : 1 : 2 : 1 : 6 : 1 : 1 : 6 : 1 : 1 : 60 : bb: 73 : 0d: 60 : bb: 73 : 0 : 60 : 1 : 2 11 :f1:cf:08:cf:bc:34:cc:aa:79:ef:1d:ad:8a:7a: 6f: ac: it: 86 : 65 : 90 : 06 : d4: fa: f0: 57 : 71 : 68 : 57 : ec: 7c: a6: 04 : ad: e2: c3: d7: 31 : d6: d0: 2f: 93 : 31 : 98 : d3: 90 : c3: ef: c3: f3: ff: 04 : 6f P: 00 :c0:59:6c:3b:5e:93:3d:33:78:be:36:26:be:31: 5e: e7: 0c: a6: b5: b1: 1a: 51 : 9b: 55 : 23 : d4: 45 : 66 : e2: 2c: c8: 8b: f: c5: 6a: ad: 66 : ad:28:13:88:f0:bb:c6:b8:02:6b:7c:80:26:e9:11: 84 :be:e0:c8:ad:10:cc:f2:96:be:cf:e5:05:05:38: 3c: b4: a9: 54 : b3: 7c: b5: 88 : 67 : 2f: 7c: f2: fa: 05 : 38 : fd: ad: 83 : 93 : 4a: 45 : e4: f9: 9d: 38 : from: 57 :c0:8a:24:d0:0d:1c:c5:d5:fb:db:73:29:1c:d1: 0c: e7: 57 : 68 : 90 : b6: ba: 08 : 9b Q: 00 : 86 : 8f: 78 : b8: c8: 50 : 0b: eb: f6: 7a: 58 : e3: 53 : 9d: 35 : 70 : d1: bd G: 4c: d5: e6: b6: 6a: 6e: b7: e9: 27 : 94 : cb: 11 : af: 5a: 08 : d9: d4: f8: a3: f2: 50 : 03 : 72 : 91 : ba: 5f: ff: 3c: 29 : a8: c3: 7b: c4: ee: 5f: 98 : ec: 17 : f4: 18 : bc: 71 : 61 : 01 : 6c: 94 : c8: 49 : 02 : e4: 00 : d8:cf:6a:61:c1:3a:fd:56:73:ca:a5:fb:41:15:08: cd:b3:50:1b:df:f7:3e:74:79:25:f7:65:86:f4:07: 9f: it: 12 : 09 : 8b: 34 : 50 : 84 : 4 : 2 : 9e: 5d: 0A: 99 : bd: 86 : 5 : 05 : 70 : d5: 19 : 7d: f4: a1: c9: b8: 01 : 8f: b9: 9c: dc: e9: 15 : 7b: 98 : 50 : 01 : 79 Below, we can directly use the above principle to write a program, the program is as follows #coding=utf8 from Crypto.PublicKey import DSA from hashlib import sha1 import gmpy2 with open ( './dsa_public.pem' ) as f : key = DSA . importKey ( f ) y = key . y g = key . g p = key . p q = key . q f3 = open ( r \"packet3/message3\" , 'r' ) f4 = open ( r \"packet4/message4\" , 'r' ) data3 = f3 . read () data4 = f4 . read () Sha = sha1 () sha . update ( data3 ) m3 = int ( sha . hexdigest (), 16 ) Sha = sha1 () sha . update ( data4 ) m4 = int ( sha . hexdigest (), 16 ) print m3 , m4 s3 = 0x30EB88E6A4BFB1B16728A974210AE4E41B42677D s4 = 0x5E10DED084203CCBCEC3356A2CA02FF318FD4123 r = 0x5090DA81FEDE048D706D80E0AC47701E5A9EF1CC ds = s4 - s3 dm = m4 - m3 k = gmpy2 . mul ( dm , gmpy2 . invert ( ds , q )) k = gmpy2 . f_mod ( k , q ) tmp = gmpy2 . mul ( k , s3 ) - m3 x = tmp * gmpy2 . invert ( r , q ) x = gmpy2 . f_mod ( x , q ) print int ( x ) I found that pycrypto installed by pip does not have the importKey function of DSA. . . I had to download and install pycrypto from github. . . Results are as follows \u279c 2016 Huxiang Cup DSA git: ( master ) \u2717 python exp.py 1104884177962524221174509726811256177146235961550 943735132044536149000710760545778628181961840230 520793588153805320783422521615148687785086070744","title":"Example"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/","text":"EN | ZH ElGamal \u00b6 RSA\u7684\u6570\u5b57\u7b7e\u540d\u65b9\u6848\u51e0\u4e4e\u4e0e\u5176\u52a0\u5bc6\u65b9\u6848\u5b8c\u5168\u4e00\u81f4\uff0c\u53ea\u662f\u5229\u7528\u79c1\u94a5\u8fdb\u884c\u4e86\u7b7e\u540d\u3002\u4f46\u662f\uff0c\u5bf9\u4e8eElGamal\u6765\u8bf4\uff0c\u5176\u7b7e\u540d\u65b9\u6848\u4e0e\u76f8\u5e94\u7684\u52a0\u5bc6\u65b9\u6848\u5177\u6709\u5f88\u5927\u533a\u522b\u3002 \u57fa\u672c\u539f\u7406 \u00b6 \u5bc6\u94a5\u751f\u6210 \u00b6 \u57fa\u672c\u6b65\u9aa4\u5982\u4e0b \u9009\u53d6\u4e00\u4e2a\u8db3\u591f\u5927\u7684\u7d20\u6570p\uff08\u5341\u8fdb\u5236\u4f4d\u6570\u4e0d\u4f4e\u4e8e160\uff09\uff0c\u4ee5\u4fbf\u4e8e\u5728 Z_p Z_p \u4e0a\u6c42\u89e3\u79bb\u6563\u5bf9\u6570\u95ee\u9898\u662f\u56f0\u96be\u7684\u3002 \u9009\u53d6 Z_p^* Z_p^* \u7684\u751f\u6210\u5143g\u3002 \u968f\u673a\u9009\u53d6\u6574\u6570d, 0\\leq d \\leq p-2 0\\leq d \\leq p-2 \uff0c\u5e76\u8ba1\u7b97 g^d \\equiv y \\bmod p g^d \\equiv y \\bmod p \u3002 \u5176\u4e2d\u79c1\u94a5\u4e3a{d}\uff0c\u516c\u94a5\u4e3a{p,g,y} \u3002 \u7b7e\u540d \u00b6 A\u9009\u53d6\u968f\u673a\u6570 k \\in Z_{p-1} k \\in Z_{p-1} \uff0c\u5e76\u4e14 gcd(k,p-1)=1 gcd(k,p-1)=1 \uff0c\u5bf9\u6d88\u606f\u8fdb\u884c\u7b7e\u540d sig_d(m,k)=(r,s) sig_d(m,k)=(r,s) \u5176\u4e2d r \\equiv g^k \\bmod p r \\equiv g^k \\bmod p \uff0c s \\equiv (m-dr)k^{-1} \\bmod p-1 s \\equiv (m-dr)k^{-1} \\bmod p-1 \u3002 \u9a8c\u8bc1 \u00b6 \u5982\u679c g^m \\equiv y^rr^s \\bmod p g^m \\equiv y^rr^s \\bmod p \uff0c\u90a3\u4e48\u9a8c\u8bc1\u6210\u529f\uff0c\u5426\u5219\u9a8c\u8bc1\u5931\u8d25\u3002\u8fd9\u91cc\u9a8c\u8bc1\u6210\u529f\u7684\u539f\u7406\u5982\u4e0b\uff0c\u9996\u5148\u6211\u4eec\u6709 y^rr^s \\equiv g^{dr}g^{ks} \\equiv g^{dr+ks} y^rr^s \\equiv g^{dr}g^{ks} \\equiv g^{dr+ks} \u53c8\u56e0\u4e3a s \\equiv (m-dr)k^{-1} \\bmod p-1 s \\equiv (m-dr)k^{-1} \\bmod p-1 \u6240\u4ee5 ks \\equiv m-dr \\bmod p-1 ks \\equiv m-dr \\bmod p-1 \u8fdb\u800c ks+dr=a*(p-1)+m ks+dr=a*(p-1)+m \u6240\u4ee5 g^{ks+dr}=g^{a*(p-1)+m}=(g^{p-1})^a*g^m g^{ks+dr}=g^{a*(p-1)+m}=(g^{p-1})^a*g^m \u6240\u4ee5\u6839\u636e\u8d39\u9a6c\u5b9a\u7406\uff0c\u53ef\u5f97 g^{ks+dr} \\equiv g^m \\bmod p g^{ks+dr} \\equiv g^m \\bmod p \u5e38\u89c1\u653b\u51fb \u00b6 \u5b8c\u5168\u7834\u8bd1\u653b\u51fb \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 p\u592a\u5c0f\u6216\u65e0\u5927\u7d20\u56e0\u5b50 \u5982\u679c p p \u592a\u5c0f\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7528\u5927\u90e8\u5c0f\u6b65\u7b97\u6cd5\u5206\u89e3, \u6216\u8005\u5982\u679c\u5176\u65e0\u5927\u7684\u7d20\u56e0\u5b50, \u6211\u4eec\u53ef\u4ee5\u91c7\u7528 Pohling\\: Hellman Pohling\\: Hellman \u7b97\u6cd5\u8ba1\u7b97\u79bb\u6563\u5bf9\u6570\u5373\u53ef\u8fdb\u800c\u6c42\u51fa\u79c1\u94a5\u3002 \u968f\u673a\u6570k\u590d\u7528 \u5982\u679c\u7b7e\u540d\u8005\u590d\u7528\u4e86\u968f\u673a\u6570k\uff0c\u90a3\u4e48\u653b\u51fb\u8005\u5c31\u53ef\u4ee5\u8f7b\u800c\u6613\u4e3e\u5730\u8ba1\u7b97\u51fa\u79c1\u94a5\u3002\u5177\u4f53\u7684\u539f\u7406\u5982\u4e0b\uff1a \u5047\u8bbe\u76ee\u524d\u6709\u4e24\u4e2a\u7b7e\u540d\u90fd\u662f\u4f7f\u7528\u540c\u4e00\u4e2a\u968f\u673a\u6570\u8fdb\u884c\u7b7e\u540d\u7684\u3002\u90a3\u4e48\u6211\u4eec\u6709 r \\equiv g^k \\bmod p \\\\\\\\ s _1\\equiv (m_1-dr)k^{-1} \\bmod p-1\\\\\\\\ r \\equiv g^k \\bmod p \\\\\\\\ s_2 \\equiv (m_2-dr)k^{-1} \\bmod p-1 r \\equiv g^k \\bmod p \\\\\\\\ s _1\\equiv (m_1-dr)k^{-1} \\bmod p-1\\\\\\\\ r \\equiv g^k \\bmod p \\\\\\\\ s_2 \\equiv (m_2-dr)k^{-1} \\bmod p-1 \u8fdb\u800c\u6709 s_1k \\equiv m_1-dr \\bmod p-1 \\\\\\\\ s_2k \\equiv m_2-dr \\bmod p-1 s_1k \\equiv m_1-dr \\bmod p-1 \\\\\\\\ s_2k \\equiv m_2-dr \\bmod p-1 \u4e24\u5f0f\u76f8\u51cf k(s_1-s_2) \\equiv m_1-m_2 \\bmod p-1 k(s_1-s_2) \\equiv m_1-m_2 \\bmod p-1 \u8fd9\u91cc\uff0c s_1,s_2,m_1,m_2,p-1 s_1,s_2,m_1,m_2,p-1 \u5747\u5df2\u77e5\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u7b97\u51fak\u3002\u5f53\u7136\uff0c\u5982\u679c gcd(s_1-s_2,p-1)!=1 gcd(s_1-s_2,p-1)!=1 \u7684\u8bdd\uff0c\u53ef\u80fd\u4f1a\u5b58\u5728\u591a\u4e2a\u89e3\uff0c\u8fd9\u65f6\u6211\u4eec\u53ea\u9700\u8981\u591a\u8bd5\u4e00\u8bd5\u3002\u8fdb\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636es\u7684\u8ba1\u7b97\u65b9\u6cd5\u5f97\u5230\u79c1\u94a5d\uff0c\u5982\u4e0b d \\equiv \\frac{m-ks}{r} d \\equiv \\frac{m-ks}{r} \u9898\u76ee \u00b6 2016 LCTF Crypto 450 \u901a\u7528\u4f2a\u9020\u7b7e\u540d \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5982\u679c\u6d88\u606f m m \u6ca1\u6709\u53d6\u54c8\u5e0c\uff0c\u6216\u8005\u6d88\u606f m m \u6ca1\u6709\u6307\u5b9a\u6d88\u606f\u683c\u5f0f\u7684\u60c5\u51b5\u4e0b\u653b\u51fb\u6210\u7acb\u3002 \u539f\u7406 \u00b6 \u5728\u653b\u51fb\u8005\u77e5\u9053\u4e86\u67d0\u4e2a\u4ebaAlice\u7684\u516c\u94a5\u4e4b\u540e\uff0c\u4ed6\u53ef\u4ee5\u4f2a\u9020Alice\u7684\u7b7e\u540d\u4fe1\u606f\u3002\u5177\u4f53\u539f\u7406\u5982\u4e0b: \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\uff0cAlice\u7684\u516c\u94a5\u4e3a{p,g,y}\u3002\u653b\u51fb\u8005\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u5f0f\u4f2a\u9020 \u9009\u62e9\u6574\u6570 i i \uff0c j j \uff0c\u5176\u4e2d gcd(j,p-1)=1 gcd(j,p-1)=1 \u8ba1\u7b97\u7b7e\u540d\uff0c r \\equiv g^iy^j \\bmod p r \\equiv g^iy^j \\bmod p \uff0c s\\equiv -rj^{-1} \\bmod p-1 s\\equiv -rj^{-1} \\bmod p-1 \u8ba1\u7b97\u6d88\u606f\uff0c m\\equiv si \\bmod p-1 m\\equiv si \\bmod p-1 \u90a3\u4e48\u6b64\u65f6\u751f\u6210\u7684\u7b7e\u540d\u4e0e\u6d88\u606f\u5c31\u662f\u53ef\u4ee5\u88ab\u6b63\u5e38\u901a\u8fc7\u9a8c\u8bc1\uff0c\u5177\u4f53\u63a8\u5bfc\u5982\u4e0b: y^rr^s \\equiv g^{dr}g^{is}y^{js} \\equiv g^{dr}g^{djs}g^{is} \\equiv g^{dr+s(i+dj)} \\equiv g^{dr} g^{-rj^{-1}(i+dj)} \\equiv g^{dr-dr-rij^{-1}} \\equiv g^{si} \\bmod p y^rr^s \\equiv g^{dr}g^{is}y^{js} \\equiv g^{dr}g^{djs}g^{is} \\equiv g^{dr+s(i+dj)} \\equiv g^{dr} g^{-rj^{-1}(i+dj)} \\equiv g^{dr-dr-rij^{-1}} \\equiv g^{si} \\bmod p \u53c8\u7531\u4e8e\u6d88\u606fm\u7684\u6784\u9020\u65b9\u5f0f\uff0c\u6240\u4ee5 g^{si} \\equiv g^m \\bmod p-1 g^{si} \\equiv g^m \\bmod p-1 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u4f2a\u9020\u901a\u8fc7\u7b7e\u540d\u9a8c\u8bc1\u7684\u6d88\u606f\uff0c\u4f46\u662f\u4ed6\u5374\u65e0\u6cd5\u4f2a\u9020\u6307\u5b9a\u683c\u5f0f\u7684\u6d88\u606f\u3002\u800c\u4e14\uff0c\u4e00\u65e6\u6d88\u606f\u8fdb\u884c\u4e86\u54c8\u5e0c\u64cd\u4f5c\uff0c\u8fd9\u4e00\u653b\u51fb\u5c31\u4e0d\u518d\u53ef\u884c\u3002 \u5df2\u77e5\u7b7e\u540d\u4f2a\u9020 \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5047\u8bbe\u653b\u51fb\u8005\u77e5\u9053 (r, s) (r, s) \u662f\u6d88\u606f M M \u7684\u7b7e\u540d\uff0c\u5219\u653b\u51fb\u8005\u53ef\u5229\u7528\u5b83\u6765\u4f2a\u9020\u5176\u5b83\u6d88\u606f\u7684\u7b7e\u540d\u3002 \u539f\u7406 \u00b6 \u9009\u62e9\u6574\u6570 h, i, j \\in[0, p-2] h, i, j \\in[0, p-2] \u4e14\u6ee1\u8db3 \\operatorname{gcd}(h r-j s, \\varphi(p))=1 \\operatorname{gcd}(h r-j s, \\varphi(p))=1 \u8ba1\u7b97\u4e0b\u5f0f \\begin{array}{l} r^{\\prime}=r^{h} \\alpha^{i} y_{A}^{j} \\bmod p \\\\ s^{\\prime}=\\operatorname{sr}(h r-j s)^{-1} \\bmod \\varphi(p) \\\\ m^{\\prime}=r^{\\prime}(h m+i s)(h r-j s)^{-1} \\bmod \\varphi(p) \\end{array} \\begin{array}{l} r^{\\prime}=r^{h} \\alpha^{i} y_{A}^{j} \\bmod p \\\\ s^{\\prime}=\\operatorname{sr}(h r-j s)^{-1} \\bmod \\varphi(p) \\\\ m^{\\prime}=r^{\\prime}(h m+i s)(h r-j s)^{-1} \\bmod \\varphi(p) \\end{array} \u53ef\u5f97\u5230 (r',s') (r',s') \u662f m' m' \u7684\u6709\u6548\u7b7e\u540d \u8bc1\u660e\u5982\u4e0b: \u5df2\u77e5Alice\u5bf9\u6d88\u606f x x \u7684\u7b7e\u540d (\\gamma,\\delta) (\\gamma,\\delta) \u6ee1\u8db3 \\beta^{\\gamma} \\gamma^{\\delta} \\equiv \\alpha^{x}(\\bmod p) \\beta^{\\gamma} \\gamma^{\\delta} \\equiv \\alpha^{x}(\\bmod p) \uff0c\u6240\u4ee5\u6211\u4eec\u76ee\u7684\u4e3a\u6784\u9020\u51fa \\left(x^{\\prime}, \\lambda, \\mu\\right) \\left(x^{\\prime}, \\lambda, \\mu\\right) \u6ee1\u8db3 \\beta^{\\lambda} \\lambda^{\\mu} \\equiv \\alpha^{x'}(\\bmod p) \\beta^{\\lambda} \\lambda^{\\mu} \\equiv \\alpha^{x'}(\\bmod p) \u90a3\u4e48\uff0c\u9996\u5148\u6211\u4eec\u628a \\lambda \\lambda \u8868\u793a\u4e3a\u4e09\u4e2a\u5df2\u77e5\u5e95 \\alpha, \\beta, \\gamma \\alpha, \\beta, \\gamma \u7684\u5f62\u5f0f: \\lambda=\\alpha^{i} \\beta^{j} \\gamma^{h} \\bmod p \\lambda=\\alpha^{i} \\beta^{j} \\gamma^{h} \\bmod p ,\u7531\u6761\u4ef6\u53ef\u5f97 \\beta^{\\gamma} \\gamma^{\\delta} \\equiv \\alpha^{x}(\\bmod p) \\Leftrightarrow \\gamma=\\left(\\beta^{-\\gamma} \\alpha^{x}\\right)^{\\delta-1} \\bmod p \\beta^{\\gamma} \\gamma^{\\delta} \\equiv \\alpha^{x}(\\bmod p) \\Leftrightarrow \\gamma=\\left(\\beta^{-\\gamma} \\alpha^{x}\\right)^{\\delta-1} \\bmod p \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 \\lambda=\\alpha^{i+x \\delta^{-1} h} \\beta^{j-\\gamma \\delta^{-1} h} \\bmod p \\lambda=\\alpha^{i+x \\delta^{-1} h} \\beta^{j-\\gamma \\delta^{-1} h} \\bmod p \u6211\u4eec\u628a \\lambda \\lambda \u7684\u8868\u8fbe\u5f0f\u4ee3\u5165\u4e00\u5f0f\u4e2d \\begin{aligned}& \\beta^{\\lambda}\\left(\\alpha^{i+x \\delta^{-1} h} \\beta^{j-\\gamma \\delta^{-1} h}\\right)^{\\mu} \\equiv \\alpha^{x^{\\prime}}(\\bmod p) \\\\\\Leftrightarrow & \\beta^{\\lambda+\\left(j-\\gamma \\delta^{-1} h\\right) \\mu} \\equiv \\alpha^{x^{\\prime}-\\left(i+x \\delta^{-1} h\\right) \\mu}(\\bmod p)\\end{aligned} \\begin{aligned}& \\beta^{\\lambda}\\left(\\alpha^{i+x \\delta^{-1} h} \\beta^{j-\\gamma \\delta^{-1} h}\\right)^{\\mu} \\equiv \\alpha^{x^{\\prime}}(\\bmod p) \\\\\\Leftrightarrow & \\beta^{\\lambda+\\left(j-\\gamma \\delta^{-1} h\\right) \\mu} \\equiv \\alpha^{x^{\\prime}-\\left(i+x \\delta^{-1} h\\right) \\mu}(\\bmod p)\\end{aligned} \u6211\u4eec\u4ee4\u4e24\u8fb9\u6307\u6570\u4e3a 0 0 , \u5373 \\left\\{\\begin{matrix}\\lambda+\\left(j-\\gamma \\delta^{-1} h\\right) \\mu \\equiv 0 \\bmod p-1 \\\\ x^{\\prime}-\\left(i+x \\delta^{-1} h\\right) \\mu \\equiv 0 \\bmod p-1 \\end{matrix}\\right. \\left\\{\\begin{matrix}\\lambda+\\left(j-\\gamma \\delta^{-1} h\\right) \\mu \\equiv 0 \\bmod p-1 \\\\ x^{\\prime}-\\left(i+x \\delta^{-1} h\\right) \\mu \\equiv 0 \\bmod p-1 \\end{matrix}\\right. \u53ef\u4ee5\u5f97\u5230 \\mu=\\delta \\lambda(h \\gamma-j \\delta)^{-1} \\quad(\\bmod p-1) \\\\ x^{\\prime}=\\lambda(h x+i \\delta)(h \\gamma-j \\delta)^{-1}(\\bmod p-1) \\mu=\\delta \\lambda(h \\gamma-j \\delta)^{-1} \\quad(\\bmod p-1) \\\\ x^{\\prime}=\\lambda(h x+i \\delta)(h \\gamma-j \\delta)^{-1}(\\bmod p-1) \u5176\u4e2d \\lambda=\\alpha^{i} \\beta^{j} \\gamma^{h} \\bmod p \\lambda=\\alpha^{i} \\beta^{j} \\gamma^{h} \\bmod p \u6240\u4ee5\u6211\u4eec\u5f97\u5230 (\\lambda, \\mu) (\\lambda, \\mu) \u662f x' x' \u7684\u6709\u6548\u7b7e\u540d\u3002 \u6b64\u5916,\u6211\u4eec\u8fd8\u53ef\u4ee5\u501f\u52a9CRT\u6784\u9020 m' m' , \u539f\u7406\u5982\u4e0b: u=m^{\\prime} m^{-1} \\bmod \\varphi(p), \\quad s^{\\prime}=s u \\bmod \\varphi(p) u=m^{\\prime} m^{-1} \\bmod \\varphi(p), \\quad s^{\\prime}=s u \\bmod \\varphi(p) \u518d\u8ba1\u7b97 r^{\\prime}, \\quad r^{\\prime} \\equiv r u \\bmod \\varphi(p), r^{\\prime} \\equiv r \\bmod p r^{\\prime}, \\quad r^{\\prime} \\equiv r u \\bmod \\varphi(p), r^{\\prime} \\equiv r \\bmod p \u663e\u7136\u53ef\u4ee5\u4f7f\u7528CRT\u6c42\u89e3 r' r' , \u6ce8\u610f\u5230 y_{A}^{r'} r'^{s^{\\prime}}=y_{A}^{ru} r^{s u}=\\left(y_{A}^{r} r^{s}\\right)^{u}=\\alpha^{m u} \\equiv \\alpha^{m} \\bmod p y_{A}^{r'} r'^{s^{\\prime}}=y_{A}^{ru} r^{s u}=\\left(y_{A}^{r} r^{s}\\right)^{u}=\\alpha^{m u} \\equiv \\alpha^{m} \\bmod p \u6240\u4ee5 (r',s') (r',s') \u662f\u6d88\u606f m' m' \u7684\u6709\u6548\u7b7e\u540d\u3002 \u62b5\u6297\u63aa\u65bd:\u5728\u9a8c\u8bc1\u7b7e\u540d\u65f6, \u68c0\u67e5 r < p r < p \u3002 \u9009\u62e9\u7b7e\u540d\u4f2a\u9020 \u00b6 \u653b\u51fb\u6761\u4ef6 \u00b6 \u5982\u679c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u6211\u4eec\u6d88\u606f\u8fdb\u884c\u7b7e\u540d\uff0c\u5e76\u4e14\u53ef\u4ee5\u5f97\u5230\u7b7e\u540d\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e00\u4e2a\u65b0\u7684\u4f46\u662f\u6211\u4eec\u4e0d\u80fd\u591f\u9009\u62e9\u7b7e\u540d\u7684\u6d88\u606f\u4f2a\u9020\u7b7e\u540d\u3002 \u539f\u7406 \u00b6 \u6211\u4eec\u77e5\u9053\uff0c\u6700\u540e\u9a8c\u8bc1\u7684\u8fc7\u7a0b\u5982\u4e0b g^m \\equiv y^rr^s \\bmod p g^m \\equiv y^rr^s \\bmod p \u90a3\u4e48\u53ea\u8981\u6211\u4eec\u9009\u62e9\u4e00\u4e2a\u6d88\u606fm\u4f7f\u5176\u548c\u6211\u4eec\u6240\u8981\u4f2a\u9020\u7684\u6d88\u606f m' m' \u6a21p-1\u540c\u4f59\uff0c\u7136\u540e\u540c\u65f6\u4f7f\u7528\u6d88\u606fm\u7684\u7b7e\u540d\u5373\u53ef\u7ed5\u8fc7\u3002 \u9898\u76ee \u00b6 \u8fd9\u91cc\u4ee52017\u5e74\u56fd\u8d5bmailbox\u4e3a\u4f8b\uff0c i\u6625\u79cb\u6709\u590d\u73b0 \u3002 \u9996\u5148\uff0c\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u7a0b\u5e8f\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u8fdb\u884cproof of work proof = b64 . b64encode ( os . urandom ( 12 )) req . sendall ( \"Please provide your proof of work, a sha1 sum ending in 16 bit's set to 0, it must be of length %d bytes, starting with %s \\n \" % ( len ( proof ) + 5 , proof )) test = req . recv ( 21 ) ha = hashlib . sha1 () ha . update ( test ) if ( test [ 0 : 16 ] != proof or ord ( ha . digest ()[ - 1 ]) != 0 or ord ( ha . digest ()[ - 2 ]) != 0 ): # or ord(ha.digest()[-3]) != 0 or ord(ha.digest()[-4]) != 0): req . sendall ( \"Check failed\" ) req . close () return \u6211\u4eec\u9700\u8981\u751f\u6210\u4e00\u4e2a\u4ee5proof\u5f00\u5934\u7684\u957f\u5ea6\u4e3aproof\u957f\u5ea6\u52a05\u7684\u5b57\u7b26\u4e32\uff0c\u5e76\u4e14\u5176sha1\u7684\u503c\u4ee516\u6bd4\u7279\u76840\u7ed3\u675f\u3002 \u8fd9\u91cc\u6211\u4eec\u76f4\u63a5\u4f7f\u7528\u5982\u4e0b\u7684\u65b9\u5f0f\u6765\u7ed5\u8fc7\u3002 def f ( x ): return sha1 ( prefix + x ) . digest ()[ - 2 :] == ' \\0\\0 ' sh = remote ( '106.75.66.195' , 40001 ) # bypass proof sh . recvuntil ( 'starting with ' ) prefix = sh . recvuntil ( ' \\n ' , drop = True ) print string . ascii_letters s = util . iters . mbruteforce ( f , string . ascii_letters + string . digits , 5 , 'fixed' ) test = prefix + s sh . sendline ( test ) \u8fd9\u91cc\u4f7f\u7528\u4e86pwntools\u4e2d\u7684util.iters.mbruteforce\uff0c\u8fd9\u662f\u4e00\u4e2a\u5229\u7528\u7ed9\u5b9a\u5b57\u7b26\u96c6\u5408\u4ee5\u53ca\u6307\u5b9a\u957f\u5ea6\u8fdb\u884c\u591a\u7ebf\u7a0b\u7206\u7834\u7684\u51fd\u6570\u3002\u5176\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u4e3a\u7206\u7834\u51fd\u6570\uff0c\u8fd9\u91cc\u662fsha1\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u5b57\u7b26\u96c6\uff0c\u7b2c\u4e09\u4e2a\u53c2\u6570\u662f\u5b57\u8282\u6570\uff0c\u7b2c\u56db\u4e2a\u53c2\u6570\u6307\u7684\u662f\u6211\u4eec\u53ea\u5c1d\u8bd5\u5b57\u8282\u6570\u4e3a\u7b2c\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u5b57\u8282\u6570\u7684\u6392\u5217\uff0c\u5373\u957f\u5ea6\u662f\u56fa\u5b9a\u7684\u3002\u66f4\u52a0\u5177\u4f53\u7684\u4fe1\u606f\u8bf7\u53c2\u8003pwntools\u3002 \u7ed5\u8fc7\u4e4b\u540e\uff0c\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u7a0b\u5e8f\uff0c\u7b80\u5355\u770b\u4e0bgenerate_keys\u51fd\u6570\uff0c\u53ef\u4ee5\u77e5\u9053\u8be5\u51fd\u6570\u662fElGamal\u751f\u6210\u516c\u94a5\u7684\u8fc7\u7a0b\uff0c\u7136\u540e\u770b\u4e86\u770bverify\u51fd\u6570\uff0c\u5c31\u662f\u9a8c\u8bc1\u7b7e\u540d\u7684\u8fc7\u7a0b\u3002 \u7ee7\u7eed\u5206\u6790 if len ( msg ) > MSGLENGTH : req . sendall ( \"what r u do'in?\" ) req . close () return if msg [: 4 ] == \"test\" : r , s = sign ( digitalize ( msg ), sk , pk , p , g ) req . sendall ( \"Your signature is\" + repr (( hex ( r ), hex ( s ))) + \" \\n \" ) else : if msg == \"Th3_bery_un1que1i_ChArmIng_G3nji\" + test : req . sendall ( \"Signature:\" ) sig = self . rfile . readline () . strip () if len ( sig ) > MSGLENGTH : req . sendall ( \"what r u do'in?\" ) req . close () return sig_rs = sig . split ( \",\" ) if len ( sig_rs ) < 2 : req . sendall ( \"yo what?\" ) req . close () return # print \"Got sig\", sig_rs if verify ( digitalize ( msg ), int ( sig_rs [ 0 ]), int ( sig_rs [ 1 ]), pk , p , g ): req . sendall ( \"Login Success. \\n Dr. Ziegler has a message for you: \" + FLAG ) print \"shipped flag\" req . close () return else : req . sendall ( \"You are not the Genji I knew! \\n \" ) \u6839\u636e\u8fd9\u4e09\u4e2aif\u6761\u4ef6\u53ef\u4ee5\u77e5\u9053 \u6211\u4eec\u7684\u6d88\u606f\u957f\u5ea6\u4e0d\u80fd\u8d85\u8fc7MSGLENGTH\uff0c40000\u3002 \u6211\u4eec\u53ef\u4ee5\u5bf9\u6d88\u606f\u5f00\u5934\u4e3atest\u7684\u6d88\u606f\u8fdb\u884c\u7b7e\u540d\u3002 \u6211\u4eec\u9700\u8981\u4f7f\u5f97\u4ee5Th3_bery_un1que1i_ChArmIng_G3nji\u5f00\u5934\uff0c\u4ee5\u6211\u4eec\u7ed5\u8fc7proof\u7684test\u4e3a\u7ed3\u5c3e\u7684\u6d88\u606f\u901a\u8fc7\u7b7e\u540d\u9a8c\u8bc1\uff0c\u5176\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u81ea\u5df1\u63d0\u4f9b\u7b7e\u540d\u7684\u503c\u3002 \u5206\u6790\u5230\u8fd9\u91cc\uff0c\u5176\u5b9e\u5c31\u77e5\u9053\u4e86\uff0c\u6211\u4eec\u5c31\u662f\u5728\u9009\u62e9\u6307\u5b9a\u7b7e\u540d\u8fdb\u884c\u4f2a\u9020\uff0c\u8fd9\u91cc\u6211\u4eec\u81ea\u7136\u8981\u5145\u5206\u5229\u7528\u7b2c\u4e8c\u4e2aif\u6761\u4ef6\uff0c\u53ea\u8981\u6211\u4eec\u786e\u4fdd\u6211\u4eec\u8f93\u5165\u7684\u6d88\u606f\u7684\u5f00\u5934\u4e3a\u2018test\u2019\uff0c\u5e76\u4e14\u8be5\u6d88\u606f\u4e0e\u4ee5Th3_bery_un1que1i_ChArmIng_G3nji\u5f00\u5934\u7684\u56fa\u5b9a\u6d88\u606f\u6a21p-1\u540c\u4f59\uff0c\u6211\u4eec\u5373\u53ef\u4ee5\u901a\u8fc7\u9a8c\u8bc1\u3002 \u90a3\u6211\u4eec\u5982\u4f55\u6784\u9020\u5462\uff1f\u65e2\u7136\u6d88\u606f\u7684\u957f\u5ea6\u53ef\u4ee5\u8db3\u591f\u957f\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06'test'\u5bf9\u5e94\u768416\u8fdb\u5236\u5148\u5de6\u79fb\u5f97\u5230\u6bd4p-1\u5927\u7684\u6570\u5b57a\uff0c\u7136\u540e\u7528a\u5bf9p-1\u53d6\u6a21\uff0c\u7528a\u518d\u51cf\u53bb\u4f59\u6570\uff0c\u6b64\u65f6a\u6a21p-1\u4f590\u4e86\u3002\u8fd9\u65f6\u518d\u52a0\u4e0a\u4ee5Th3_bery_un1que1i_ChArmIng_G3nji\u5f00\u5934\u7684\u56fa\u5b9a\u6d88\u606f\u7684\u503c\uff0c\u5373\u5b9e\u73b0\u4e86\u6a21p-1\u540c\u4f59\u3002 \u5177\u4f53\u5982\u4e0b # construct the message begins with 'test' target = \"Th3_bery_un1que1i_ChArmIng_G3nji\" + test part1 = ( digitalize ( 'test' + os . urandom ( 51 )) << 512 ) // ( p - 1 ) * ( p - 1 ) victim = part1 + digitalize ( target ) while 1 : tmp = hex ( victim )[ 2 :] . decode ( 'hex' ) if tmp . startswith ( 'test' ) and ' \\n ' not in tmp : break else : part1 = ( digitalize ( 'test' + os . urandom ( 51 )) << 512 ) // ( p - 1 ) * ( p - 1 ) victim = part1 + digitalize ( target ) \u6700\u540e\u7684\u811a\u672c\u5982\u4e0b from pwn import * from hashlib import sha1 import string import ast import os import binascii context . log_level = 'debug' def f ( x ): return sha1 ( prefix + x ) . digest ()[ - 2 :] == ' \\0\\0 ' def digitalize ( m ): return int ( m . encode ( 'hex' ), 16 ) sh = remote ( '106.75.66.195' , 40001 ) # bypass proof sh . recvuntil ( 'starting with ' ) prefix = sh . recvuntil ( ' \\n ' , drop = True ) print string . ascii_letters s = util . iters . mbruteforce ( f , string . ascii_letters + string . digits , 5 , 'fixed' ) test = prefix + s sh . sendline ( test ) sh . recvuntil ( 'Current PK we are using: ' ) pubkey = ast . literal_eval ( sh . recvuntil ( ' \\n ' , drop = True )) p = pubkey [ 0 ] g = pubkey [ 1 ] pk = pubkey [ 2 ] # construct the message begins with 'test' target = \"Th3_bery_un1que1i_ChArmIng_G3nji\" + test part1 = ( digitalize ( 'test' + os . urandom ( 51 )) << 512 ) // ( p - 1 ) * ( p - 1 ) victim = part1 + digitalize ( target ) while 1 : tmp = hex ( victim )[ 2 :] . decode ( 'hex' ) if tmp . startswith ( 'test' ) and ' \\n ' not in tmp : break else : part1 = ( digitalize ( 'test' + os . urandom ( 51 )) << 512 ) // ( p - 1 ) * ( p - 1 ) victim = part1 + digitalize ( target ) assert ( victim % ( p - 1 ) == digitalize ( target ) % ( p - 1 )) # get victim signature sh . sendline ( hex ( victim )[ 2 :] . decode ( 'hex' )) sh . recvuntil ( 'Your signature is' ) sig = ast . literal_eval ( sh . recvuntil ( ' \\n ' , drop = True )) sig = [ int ( sig [ 0 ], 0 ), int ( sig [ 1 ], 0 )] # get flag sh . sendline ( target ) sh . sendline ( str ( sig [ 0 ]) + \",\" + str ( sig [ 1 ])) sh . interactive () \u8fd9\u91cc\u8fd8\u8981\u8bf4\u51e0\u4e2a\u6709\u610f\u601d\u7684\u70b9\u5c31\u662f int(x,0)\u53ea\u7684\u662f\u5c06x\u6309\u7167\u5176\u5b57\u9762\u5bf9\u5e94\u7684\u8fdb\u5236\u8f6c\u6362\u4e3a\u5bf9\u5e94\u7684\u6570\u5b57\uff0c\u6bd4\u5982\u8bf4int('0x12',0)=18\uff0c\u8fd9\u91cc\u76f8\u5e94\u7684\u5b57\u9762\u5fc5\u987b\u6709\u5bf9\u5e94\u6807\u5fd7\u5f00\u5934\uff0c\u6bd4\u5982\u8bf4\u5341\u516d\u8fdb\u5236\u662f0x,8\u8fdb\u5236\u662f0\uff0c\u4e8c\u8fdb\u5236\u662f0b\u3002\u56e0\u4e3a\u5982\u679c\u6ca1\u6709\u7684\u8bdd\uff0c\u5c31\u4e0d\u77e5\u9053\u8be5\u5982\u4f55\u8bc6\u522b\u4e86\u3002 python(python2) \u91cc\u9762\u5230\u5e95\u591a\u5927\u7684\u6570\uff0c\u8ba1\u7b97\u51fa\u6765\u6700\u540e\u624d\u4f1a\u5e26\u6709L\u5462\uff1f\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u5927\u4e8eint\u90fd\u4f1a\u6709L\u3002\u4f46\u662f\u8fd9\u4e2a\u91cc\u9762\u7684victim\u786e\u5b9e\u662f\u6ca1\u6709\u7684\uff0c\uff0c \u4e00\u4e2a\u95ee\u9898\uff0c\u5f85\u89e3\u51b3\u3002\u3002","title":"Elgamal zh"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#elgamal","text":"RSA\u7684\u6570\u5b57\u7b7e\u540d\u65b9\u6848\u51e0\u4e4e\u4e0e\u5176\u52a0\u5bc6\u65b9\u6848\u5b8c\u5168\u4e00\u81f4\uff0c\u53ea\u662f\u5229\u7528\u79c1\u94a5\u8fdb\u884c\u4e86\u7b7e\u540d\u3002\u4f46\u662f\uff0c\u5bf9\u4e8eElGamal\u6765\u8bf4\uff0c\u5176\u7b7e\u540d\u65b9\u6848\u4e0e\u76f8\u5e94\u7684\u52a0\u5bc6\u65b9\u6848\u5177\u6709\u5f88\u5927\u533a\u522b\u3002","title":"ElGamal"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_1","text":"","title":"\u57fa\u672c\u539f\u7406"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_2","text":"\u57fa\u672c\u6b65\u9aa4\u5982\u4e0b \u9009\u53d6\u4e00\u4e2a\u8db3\u591f\u5927\u7684\u7d20\u6570p\uff08\u5341\u8fdb\u5236\u4f4d\u6570\u4e0d\u4f4e\u4e8e160\uff09\uff0c\u4ee5\u4fbf\u4e8e\u5728 Z_p Z_p \u4e0a\u6c42\u89e3\u79bb\u6563\u5bf9\u6570\u95ee\u9898\u662f\u56f0\u96be\u7684\u3002 \u9009\u53d6 Z_p^* Z_p^* \u7684\u751f\u6210\u5143g\u3002 \u968f\u673a\u9009\u53d6\u6574\u6570d, 0\\leq d \\leq p-2 0\\leq d \\leq p-2 \uff0c\u5e76\u8ba1\u7b97 g^d \\equiv y \\bmod p g^d \\equiv y \\bmod p \u3002 \u5176\u4e2d\u79c1\u94a5\u4e3a{d}\uff0c\u516c\u94a5\u4e3a{p,g,y} \u3002","title":"\u5bc6\u94a5\u751f\u6210"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_3","text":"A\u9009\u53d6\u968f\u673a\u6570 k \\in Z_{p-1} k \\in Z_{p-1} \uff0c\u5e76\u4e14 gcd(k,p-1)=1 gcd(k,p-1)=1 \uff0c\u5bf9\u6d88\u606f\u8fdb\u884c\u7b7e\u540d sig_d(m,k)=(r,s) sig_d(m,k)=(r,s) \u5176\u4e2d r \\equiv g^k \\bmod p r \\equiv g^k \\bmod p \uff0c s \\equiv (m-dr)k^{-1} \\bmod p-1 s \\equiv (m-dr)k^{-1} \\bmod p-1 \u3002","title":"\u7b7e\u540d"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_4","text":"\u5982\u679c g^m \\equiv y^rr^s \\bmod p g^m \\equiv y^rr^s \\bmod p \uff0c\u90a3\u4e48\u9a8c\u8bc1\u6210\u529f\uff0c\u5426\u5219\u9a8c\u8bc1\u5931\u8d25\u3002\u8fd9\u91cc\u9a8c\u8bc1\u6210\u529f\u7684\u539f\u7406\u5982\u4e0b\uff0c\u9996\u5148\u6211\u4eec\u6709 y^rr^s \\equiv g^{dr}g^{ks} \\equiv g^{dr+ks} y^rr^s \\equiv g^{dr}g^{ks} \\equiv g^{dr+ks} \u53c8\u56e0\u4e3a s \\equiv (m-dr)k^{-1} \\bmod p-1 s \\equiv (m-dr)k^{-1} \\bmod p-1 \u6240\u4ee5 ks \\equiv m-dr \\bmod p-1 ks \\equiv m-dr \\bmod p-1 \u8fdb\u800c ks+dr=a*(p-1)+m ks+dr=a*(p-1)+m \u6240\u4ee5 g^{ks+dr}=g^{a*(p-1)+m}=(g^{p-1})^a*g^m g^{ks+dr}=g^{a*(p-1)+m}=(g^{p-1})^a*g^m \u6240\u4ee5\u6839\u636e\u8d39\u9a6c\u5b9a\u7406\uff0c\u53ef\u5f97 g^{ks+dr} \\equiv g^m \\bmod p g^{ks+dr} \\equiv g^m \\bmod p","title":"\u9a8c\u8bc1"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_5","text":"","title":"\u5e38\u89c1\u653b\u51fb"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_6","text":"","title":"\u5b8c\u5168\u7834\u8bd1\u653b\u51fb"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_7","text":"p\u592a\u5c0f\u6216\u65e0\u5927\u7d20\u56e0\u5b50 \u5982\u679c p p \u592a\u5c0f\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7528\u5927\u90e8\u5c0f\u6b65\u7b97\u6cd5\u5206\u89e3, \u6216\u8005\u5982\u679c\u5176\u65e0\u5927\u7684\u7d20\u56e0\u5b50, \u6211\u4eec\u53ef\u4ee5\u91c7\u7528 Pohling\\: Hellman Pohling\\: Hellman \u7b97\u6cd5\u8ba1\u7b97\u79bb\u6563\u5bf9\u6570\u5373\u53ef\u8fdb\u800c\u6c42\u51fa\u79c1\u94a5\u3002 \u968f\u673a\u6570k\u590d\u7528 \u5982\u679c\u7b7e\u540d\u8005\u590d\u7528\u4e86\u968f\u673a\u6570k\uff0c\u90a3\u4e48\u653b\u51fb\u8005\u5c31\u53ef\u4ee5\u8f7b\u800c\u6613\u4e3e\u5730\u8ba1\u7b97\u51fa\u79c1\u94a5\u3002\u5177\u4f53\u7684\u539f\u7406\u5982\u4e0b\uff1a \u5047\u8bbe\u76ee\u524d\u6709\u4e24\u4e2a\u7b7e\u540d\u90fd\u662f\u4f7f\u7528\u540c\u4e00\u4e2a\u968f\u673a\u6570\u8fdb\u884c\u7b7e\u540d\u7684\u3002\u90a3\u4e48\u6211\u4eec\u6709 r \\equiv g^k \\bmod p \\\\\\\\ s _1\\equiv (m_1-dr)k^{-1} \\bmod p-1\\\\\\\\ r \\equiv g^k \\bmod p \\\\\\\\ s_2 \\equiv (m_2-dr)k^{-1} \\bmod p-1 r \\equiv g^k \\bmod p \\\\\\\\ s _1\\equiv (m_1-dr)k^{-1} \\bmod p-1\\\\\\\\ r \\equiv g^k \\bmod p \\\\\\\\ s_2 \\equiv (m_2-dr)k^{-1} \\bmod p-1 \u8fdb\u800c\u6709 s_1k \\equiv m_1-dr \\bmod p-1 \\\\\\\\ s_2k \\equiv m_2-dr \\bmod p-1 s_1k \\equiv m_1-dr \\bmod p-1 \\\\\\\\ s_2k \\equiv m_2-dr \\bmod p-1 \u4e24\u5f0f\u76f8\u51cf k(s_1-s_2) \\equiv m_1-m_2 \\bmod p-1 k(s_1-s_2) \\equiv m_1-m_2 \\bmod p-1 \u8fd9\u91cc\uff0c s_1,s_2,m_1,m_2,p-1 s_1,s_2,m_1,m_2,p-1 \u5747\u5df2\u77e5\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u7b97\u51fak\u3002\u5f53\u7136\uff0c\u5982\u679c gcd(s_1-s_2,p-1)!=1 gcd(s_1-s_2,p-1)!=1 \u7684\u8bdd\uff0c\u53ef\u80fd\u4f1a\u5b58\u5728\u591a\u4e2a\u89e3\uff0c\u8fd9\u65f6\u6211\u4eec\u53ea\u9700\u8981\u591a\u8bd5\u4e00\u8bd5\u3002\u8fdb\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636es\u7684\u8ba1\u7b97\u65b9\u6cd5\u5f97\u5230\u79c1\u94a5d\uff0c\u5982\u4e0b d \\equiv \\frac{m-ks}{r} d \\equiv \\frac{m-ks}{r}","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_8","text":"2016 LCTF Crypto 450","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_9","text":"","title":"\u901a\u7528\u4f2a\u9020\u7b7e\u540d"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_10","text":"\u5982\u679c\u6d88\u606f m m \u6ca1\u6709\u53d6\u54c8\u5e0c\uff0c\u6216\u8005\u6d88\u606f m m \u6ca1\u6709\u6307\u5b9a\u6d88\u606f\u683c\u5f0f\u7684\u60c5\u51b5\u4e0b\u653b\u51fb\u6210\u7acb\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_11","text":"\u5728\u653b\u51fb\u8005\u77e5\u9053\u4e86\u67d0\u4e2a\u4ebaAlice\u7684\u516c\u94a5\u4e4b\u540e\uff0c\u4ed6\u53ef\u4ee5\u4f2a\u9020Alice\u7684\u7b7e\u540d\u4fe1\u606f\u3002\u5177\u4f53\u539f\u7406\u5982\u4e0b: \u8fd9\u91cc\u6211\u4eec\u5047\u8bbe\uff0cAlice\u7684\u516c\u94a5\u4e3a{p,g,y}\u3002\u653b\u51fb\u8005\u53ef\u4ee5\u6309\u7167\u5982\u4e0b\u65b9\u5f0f\u4f2a\u9020 \u9009\u62e9\u6574\u6570 i i \uff0c j j \uff0c\u5176\u4e2d gcd(j,p-1)=1 gcd(j,p-1)=1 \u8ba1\u7b97\u7b7e\u540d\uff0c r \\equiv g^iy^j \\bmod p r \\equiv g^iy^j \\bmod p \uff0c s\\equiv -rj^{-1} \\bmod p-1 s\\equiv -rj^{-1} \\bmod p-1 \u8ba1\u7b97\u6d88\u606f\uff0c m\\equiv si \\bmod p-1 m\\equiv si \\bmod p-1 \u90a3\u4e48\u6b64\u65f6\u751f\u6210\u7684\u7b7e\u540d\u4e0e\u6d88\u606f\u5c31\u662f\u53ef\u4ee5\u88ab\u6b63\u5e38\u901a\u8fc7\u9a8c\u8bc1\uff0c\u5177\u4f53\u63a8\u5bfc\u5982\u4e0b: y^rr^s \\equiv g^{dr}g^{is}y^{js} \\equiv g^{dr}g^{djs}g^{is} \\equiv g^{dr+s(i+dj)} \\equiv g^{dr} g^{-rj^{-1}(i+dj)} \\equiv g^{dr-dr-rij^{-1}} \\equiv g^{si} \\bmod p y^rr^s \\equiv g^{dr}g^{is}y^{js} \\equiv g^{dr}g^{djs}g^{is} \\equiv g^{dr+s(i+dj)} \\equiv g^{dr} g^{-rj^{-1}(i+dj)} \\equiv g^{dr-dr-rij^{-1}} \\equiv g^{si} \\bmod p \u53c8\u7531\u4e8e\u6d88\u606fm\u7684\u6784\u9020\u65b9\u5f0f\uff0c\u6240\u4ee5 g^{si} \\equiv g^m \\bmod p-1 g^{si} \\equiv g^m \\bmod p-1 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u653b\u51fb\u8005\u53ef\u4ee5\u4f2a\u9020\u901a\u8fc7\u7b7e\u540d\u9a8c\u8bc1\u7684\u6d88\u606f\uff0c\u4f46\u662f\u4ed6\u5374\u65e0\u6cd5\u4f2a\u9020\u6307\u5b9a\u683c\u5f0f\u7684\u6d88\u606f\u3002\u800c\u4e14\uff0c\u4e00\u65e6\u6d88\u606f\u8fdb\u884c\u4e86\u54c8\u5e0c\u64cd\u4f5c\uff0c\u8fd9\u4e00\u653b\u51fb\u5c31\u4e0d\u518d\u53ef\u884c\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_12","text":"","title":"\u5df2\u77e5\u7b7e\u540d\u4f2a\u9020"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_13","text":"\u5047\u8bbe\u653b\u51fb\u8005\u77e5\u9053 (r, s) (r, s) \u662f\u6d88\u606f M M \u7684\u7b7e\u540d\uff0c\u5219\u653b\u51fb\u8005\u53ef\u5229\u7528\u5b83\u6765\u4f2a\u9020\u5176\u5b83\u6d88\u606f\u7684\u7b7e\u540d\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_14","text":"\u9009\u62e9\u6574\u6570 h, i, j \\in[0, p-2] h, i, j \\in[0, p-2] \u4e14\u6ee1\u8db3 \\operatorname{gcd}(h r-j s, \\varphi(p))=1 \\operatorname{gcd}(h r-j s, \\varphi(p))=1 \u8ba1\u7b97\u4e0b\u5f0f \\begin{array}{l} r^{\\prime}=r^{h} \\alpha^{i} y_{A}^{j} \\bmod p \\\\ s^{\\prime}=\\operatorname{sr}(h r-j s)^{-1} \\bmod \\varphi(p) \\\\ m^{\\prime}=r^{\\prime}(h m+i s)(h r-j s)^{-1} \\bmod \\varphi(p) \\end{array} \\begin{array}{l} r^{\\prime}=r^{h} \\alpha^{i} y_{A}^{j} \\bmod p \\\\ s^{\\prime}=\\operatorname{sr}(h r-j s)^{-1} \\bmod \\varphi(p) \\\\ m^{\\prime}=r^{\\prime}(h m+i s)(h r-j s)^{-1} \\bmod \\varphi(p) \\end{array} \u53ef\u5f97\u5230 (r',s') (r',s') \u662f m' m' \u7684\u6709\u6548\u7b7e\u540d \u8bc1\u660e\u5982\u4e0b: \u5df2\u77e5Alice\u5bf9\u6d88\u606f x x \u7684\u7b7e\u540d (\\gamma,\\delta) (\\gamma,\\delta) \u6ee1\u8db3 \\beta^{\\gamma} \\gamma^{\\delta} \\equiv \\alpha^{x}(\\bmod p) \\beta^{\\gamma} \\gamma^{\\delta} \\equiv \\alpha^{x}(\\bmod p) \uff0c\u6240\u4ee5\u6211\u4eec\u76ee\u7684\u4e3a\u6784\u9020\u51fa \\left(x^{\\prime}, \\lambda, \\mu\\right) \\left(x^{\\prime}, \\lambda, \\mu\\right) \u6ee1\u8db3 \\beta^{\\lambda} \\lambda^{\\mu} \\equiv \\alpha^{x'}(\\bmod p) \\beta^{\\lambda} \\lambda^{\\mu} \\equiv \\alpha^{x'}(\\bmod p) \u90a3\u4e48\uff0c\u9996\u5148\u6211\u4eec\u628a \\lambda \\lambda \u8868\u793a\u4e3a\u4e09\u4e2a\u5df2\u77e5\u5e95 \\alpha, \\beta, \\gamma \\alpha, \\beta, \\gamma \u7684\u5f62\u5f0f: \\lambda=\\alpha^{i} \\beta^{j} \\gamma^{h} \\bmod p \\lambda=\\alpha^{i} \\beta^{j} \\gamma^{h} \\bmod p ,\u7531\u6761\u4ef6\u53ef\u5f97 \\beta^{\\gamma} \\gamma^{\\delta} \\equiv \\alpha^{x}(\\bmod p) \\Leftrightarrow \\gamma=\\left(\\beta^{-\\gamma} \\alpha^{x}\\right)^{\\delta-1} \\bmod p \\beta^{\\gamma} \\gamma^{\\delta} \\equiv \\alpha^{x}(\\bmod p) \\Leftrightarrow \\gamma=\\left(\\beta^{-\\gamma} \\alpha^{x}\\right)^{\\delta-1} \\bmod p \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5f97\u5230 \\lambda=\\alpha^{i+x \\delta^{-1} h} \\beta^{j-\\gamma \\delta^{-1} h} \\bmod p \\lambda=\\alpha^{i+x \\delta^{-1} h} \\beta^{j-\\gamma \\delta^{-1} h} \\bmod p \u6211\u4eec\u628a \\lambda \\lambda \u7684\u8868\u8fbe\u5f0f\u4ee3\u5165\u4e00\u5f0f\u4e2d \\begin{aligned}& \\beta^{\\lambda}\\left(\\alpha^{i+x \\delta^{-1} h} \\beta^{j-\\gamma \\delta^{-1} h}\\right)^{\\mu} \\equiv \\alpha^{x^{\\prime}}(\\bmod p) \\\\\\Leftrightarrow & \\beta^{\\lambda+\\left(j-\\gamma \\delta^{-1} h\\right) \\mu} \\equiv \\alpha^{x^{\\prime}-\\left(i+x \\delta^{-1} h\\right) \\mu}(\\bmod p)\\end{aligned} \\begin{aligned}& \\beta^{\\lambda}\\left(\\alpha^{i+x \\delta^{-1} h} \\beta^{j-\\gamma \\delta^{-1} h}\\right)^{\\mu} \\equiv \\alpha^{x^{\\prime}}(\\bmod p) \\\\\\Leftrightarrow & \\beta^{\\lambda+\\left(j-\\gamma \\delta^{-1} h\\right) \\mu} \\equiv \\alpha^{x^{\\prime}-\\left(i+x \\delta^{-1} h\\right) \\mu}(\\bmod p)\\end{aligned} \u6211\u4eec\u4ee4\u4e24\u8fb9\u6307\u6570\u4e3a 0 0 , \u5373 \\left\\{\\begin{matrix}\\lambda+\\left(j-\\gamma \\delta^{-1} h\\right) \\mu \\equiv 0 \\bmod p-1 \\\\ x^{\\prime}-\\left(i+x \\delta^{-1} h\\right) \\mu \\equiv 0 \\bmod p-1 \\end{matrix}\\right. \\left\\{\\begin{matrix}\\lambda+\\left(j-\\gamma \\delta^{-1} h\\right) \\mu \\equiv 0 \\bmod p-1 \\\\ x^{\\prime}-\\left(i+x \\delta^{-1} h\\right) \\mu \\equiv 0 \\bmod p-1 \\end{matrix}\\right. \u53ef\u4ee5\u5f97\u5230 \\mu=\\delta \\lambda(h \\gamma-j \\delta)^{-1} \\quad(\\bmod p-1) \\\\ x^{\\prime}=\\lambda(h x+i \\delta)(h \\gamma-j \\delta)^{-1}(\\bmod p-1) \\mu=\\delta \\lambda(h \\gamma-j \\delta)^{-1} \\quad(\\bmod p-1) \\\\ x^{\\prime}=\\lambda(h x+i \\delta)(h \\gamma-j \\delta)^{-1}(\\bmod p-1) \u5176\u4e2d \\lambda=\\alpha^{i} \\beta^{j} \\gamma^{h} \\bmod p \\lambda=\\alpha^{i} \\beta^{j} \\gamma^{h} \\bmod p \u6240\u4ee5\u6211\u4eec\u5f97\u5230 (\\lambda, \\mu) (\\lambda, \\mu) \u662f x' x' \u7684\u6709\u6548\u7b7e\u540d\u3002 \u6b64\u5916,\u6211\u4eec\u8fd8\u53ef\u4ee5\u501f\u52a9CRT\u6784\u9020 m' m' , \u539f\u7406\u5982\u4e0b: u=m^{\\prime} m^{-1} \\bmod \\varphi(p), \\quad s^{\\prime}=s u \\bmod \\varphi(p) u=m^{\\prime} m^{-1} \\bmod \\varphi(p), \\quad s^{\\prime}=s u \\bmod \\varphi(p) \u518d\u8ba1\u7b97 r^{\\prime}, \\quad r^{\\prime} \\equiv r u \\bmod \\varphi(p), r^{\\prime} \\equiv r \\bmod p r^{\\prime}, \\quad r^{\\prime} \\equiv r u \\bmod \\varphi(p), r^{\\prime} \\equiv r \\bmod p \u663e\u7136\u53ef\u4ee5\u4f7f\u7528CRT\u6c42\u89e3 r' r' , \u6ce8\u610f\u5230 y_{A}^{r'} r'^{s^{\\prime}}=y_{A}^{ru} r^{s u}=\\left(y_{A}^{r} r^{s}\\right)^{u}=\\alpha^{m u} \\equiv \\alpha^{m} \\bmod p y_{A}^{r'} r'^{s^{\\prime}}=y_{A}^{ru} r^{s u}=\\left(y_{A}^{r} r^{s}\\right)^{u}=\\alpha^{m u} \\equiv \\alpha^{m} \\bmod p \u6240\u4ee5 (r',s') (r',s') \u662f\u6d88\u606f m' m' \u7684\u6709\u6548\u7b7e\u540d\u3002 \u62b5\u6297\u63aa\u65bd:\u5728\u9a8c\u8bc1\u7b7e\u540d\u65f6, \u68c0\u67e5 r < p r < p \u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_15","text":"","title":"\u9009\u62e9\u7b7e\u540d\u4f2a\u9020"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_16","text":"\u5982\u679c\u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u6211\u4eec\u6d88\u606f\u8fdb\u884c\u7b7e\u540d\uff0c\u5e76\u4e14\u53ef\u4ee5\u5f97\u5230\u7b7e\u540d\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e00\u4e2a\u65b0\u7684\u4f46\u662f\u6211\u4eec\u4e0d\u80fd\u591f\u9009\u62e9\u7b7e\u540d\u7684\u6d88\u606f\u4f2a\u9020\u7b7e\u540d\u3002","title":"\u653b\u51fb\u6761\u4ef6"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_17","text":"\u6211\u4eec\u77e5\u9053\uff0c\u6700\u540e\u9a8c\u8bc1\u7684\u8fc7\u7a0b\u5982\u4e0b g^m \\equiv y^rr^s \\bmod p g^m \\equiv y^rr^s \\bmod p \u90a3\u4e48\u53ea\u8981\u6211\u4eec\u9009\u62e9\u4e00\u4e2a\u6d88\u606fm\u4f7f\u5176\u548c\u6211\u4eec\u6240\u8981\u4f2a\u9020\u7684\u6d88\u606f m' m' \u6a21p-1\u540c\u4f59\uff0c\u7136\u540e\u540c\u65f6\u4f7f\u7528\u6d88\u606fm\u7684\u7b7e\u540d\u5373\u53ef\u7ed5\u8fc7\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/signature/elgamal-zh/#_18","text":"\u8fd9\u91cc\u4ee52017\u5e74\u56fd\u8d5bmailbox\u4e3a\u4f8b\uff0c i\u6625\u79cb\u6709\u590d\u73b0 \u3002 \u9996\u5148\uff0c\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u7a0b\u5e8f\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u8fdb\u884cproof of work proof = b64 . b64encode ( os . urandom ( 12 )) req . sendall ( \"Please provide your proof of work, a sha1 sum ending in 16 bit's set to 0, it must be of length %d bytes, starting with %s \\n \" % ( len ( proof ) + 5 , proof )) test = req . recv ( 21 ) ha = hashlib . sha1 () ha . update ( test ) if ( test [ 0 : 16 ] != proof or ord ( ha . digest ()[ - 1 ]) != 0 or ord ( ha . digest ()[ - 2 ]) != 0 ): # or ord(ha.digest()[-3]) != 0 or ord(ha.digest()[-4]) != 0): req . sendall ( \"Check failed\" ) req . close () return \u6211\u4eec\u9700\u8981\u751f\u6210\u4e00\u4e2a\u4ee5proof\u5f00\u5934\u7684\u957f\u5ea6\u4e3aproof\u957f\u5ea6\u52a05\u7684\u5b57\u7b26\u4e32\uff0c\u5e76\u4e14\u5176sha1\u7684\u503c\u4ee516\u6bd4\u7279\u76840\u7ed3\u675f\u3002 \u8fd9\u91cc\u6211\u4eec\u76f4\u63a5\u4f7f\u7528\u5982\u4e0b\u7684\u65b9\u5f0f\u6765\u7ed5\u8fc7\u3002 def f ( x ): return sha1 ( prefix + x ) . digest ()[ - 2 :] == ' \\0\\0 ' sh = remote ( '106.75.66.195' , 40001 ) # bypass proof sh . recvuntil ( 'starting with ' ) prefix = sh . recvuntil ( ' \\n ' , drop = True ) print string . ascii_letters s = util . iters . mbruteforce ( f , string . ascii_letters + string . digits , 5 , 'fixed' ) test = prefix + s sh . sendline ( test ) \u8fd9\u91cc\u4f7f\u7528\u4e86pwntools\u4e2d\u7684util.iters.mbruteforce\uff0c\u8fd9\u662f\u4e00\u4e2a\u5229\u7528\u7ed9\u5b9a\u5b57\u7b26\u96c6\u5408\u4ee5\u53ca\u6307\u5b9a\u957f\u5ea6\u8fdb\u884c\u591a\u7ebf\u7a0b\u7206\u7834\u7684\u51fd\u6570\u3002\u5176\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u4e3a\u7206\u7834\u51fd\u6570\uff0c\u8fd9\u91cc\u662fsha1\uff0c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u662f\u5b57\u7b26\u96c6\uff0c\u7b2c\u4e09\u4e2a\u53c2\u6570\u662f\u5b57\u8282\u6570\uff0c\u7b2c\u56db\u4e2a\u53c2\u6570\u6307\u7684\u662f\u6211\u4eec\u53ea\u5c1d\u8bd5\u5b57\u8282\u6570\u4e3a\u7b2c\u4e09\u4e2a\u53c2\u6570\u6307\u5b9a\u5b57\u8282\u6570\u7684\u6392\u5217\uff0c\u5373\u957f\u5ea6\u662f\u56fa\u5b9a\u7684\u3002\u66f4\u52a0\u5177\u4f53\u7684\u4fe1\u606f\u8bf7\u53c2\u8003pwntools\u3002 \u7ed5\u8fc7\u4e4b\u540e\uff0c\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u7a0b\u5e8f\uff0c\u7b80\u5355\u770b\u4e0bgenerate_keys\u51fd\u6570\uff0c\u53ef\u4ee5\u77e5\u9053\u8be5\u51fd\u6570\u662fElGamal\u751f\u6210\u516c\u94a5\u7684\u8fc7\u7a0b\uff0c\u7136\u540e\u770b\u4e86\u770bverify\u51fd\u6570\uff0c\u5c31\u662f\u9a8c\u8bc1\u7b7e\u540d\u7684\u8fc7\u7a0b\u3002 \u7ee7\u7eed\u5206\u6790 if len ( msg ) > MSGLENGTH : req . sendall ( \"what r u do'in?\" ) req . close () return if msg [: 4 ] == \"test\" : r , s = sign ( digitalize ( msg ), sk , pk , p , g ) req . sendall ( \"Your signature is\" + repr (( hex ( r ), hex ( s ))) + \" \\n \" ) else : if msg == \"Th3_bery_un1que1i_ChArmIng_G3nji\" + test : req . sendall ( \"Signature:\" ) sig = self . rfile . readline () . strip () if len ( sig ) > MSGLENGTH : req . sendall ( \"what r u do'in?\" ) req . close () return sig_rs = sig . split ( \",\" ) if len ( sig_rs ) < 2 : req . sendall ( \"yo what?\" ) req . close () return # print \"Got sig\", sig_rs if verify ( digitalize ( msg ), int ( sig_rs [ 0 ]), int ( sig_rs [ 1 ]), pk , p , g ): req . sendall ( \"Login Success. \\n Dr. Ziegler has a message for you: \" + FLAG ) print \"shipped flag\" req . close () return else : req . sendall ( \"You are not the Genji I knew! \\n \" ) \u6839\u636e\u8fd9\u4e09\u4e2aif\u6761\u4ef6\u53ef\u4ee5\u77e5\u9053 \u6211\u4eec\u7684\u6d88\u606f\u957f\u5ea6\u4e0d\u80fd\u8d85\u8fc7MSGLENGTH\uff0c40000\u3002 \u6211\u4eec\u53ef\u4ee5\u5bf9\u6d88\u606f\u5f00\u5934\u4e3atest\u7684\u6d88\u606f\u8fdb\u884c\u7b7e\u540d\u3002 \u6211\u4eec\u9700\u8981\u4f7f\u5f97\u4ee5Th3_bery_un1que1i_ChArmIng_G3nji\u5f00\u5934\uff0c\u4ee5\u6211\u4eec\u7ed5\u8fc7proof\u7684test\u4e3a\u7ed3\u5c3e\u7684\u6d88\u606f\u901a\u8fc7\u7b7e\u540d\u9a8c\u8bc1\uff0c\u5176\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u81ea\u5df1\u63d0\u4f9b\u7b7e\u540d\u7684\u503c\u3002 \u5206\u6790\u5230\u8fd9\u91cc\uff0c\u5176\u5b9e\u5c31\u77e5\u9053\u4e86\uff0c\u6211\u4eec\u5c31\u662f\u5728\u9009\u62e9\u6307\u5b9a\u7b7e\u540d\u8fdb\u884c\u4f2a\u9020\uff0c\u8fd9\u91cc\u6211\u4eec\u81ea\u7136\u8981\u5145\u5206\u5229\u7528\u7b2c\u4e8c\u4e2aif\u6761\u4ef6\uff0c\u53ea\u8981\u6211\u4eec\u786e\u4fdd\u6211\u4eec\u8f93\u5165\u7684\u6d88\u606f\u7684\u5f00\u5934\u4e3a\u2018test\u2019\uff0c\u5e76\u4e14\u8be5\u6d88\u606f\u4e0e\u4ee5Th3_bery_un1que1i_ChArmIng_G3nji\u5f00\u5934\u7684\u56fa\u5b9a\u6d88\u606f\u6a21p-1\u540c\u4f59\uff0c\u6211\u4eec\u5373\u53ef\u4ee5\u901a\u8fc7\u9a8c\u8bc1\u3002 \u90a3\u6211\u4eec\u5982\u4f55\u6784\u9020\u5462\uff1f\u65e2\u7136\u6d88\u606f\u7684\u957f\u5ea6\u53ef\u4ee5\u8db3\u591f\u957f\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06'test'\u5bf9\u5e94\u768416\u8fdb\u5236\u5148\u5de6\u79fb\u5f97\u5230\u6bd4p-1\u5927\u7684\u6570\u5b57a\uff0c\u7136\u540e\u7528a\u5bf9p-1\u53d6\u6a21\uff0c\u7528a\u518d\u51cf\u53bb\u4f59\u6570\uff0c\u6b64\u65f6a\u6a21p-1\u4f590\u4e86\u3002\u8fd9\u65f6\u518d\u52a0\u4e0a\u4ee5Th3_bery_un1que1i_ChArmIng_G3nji\u5f00\u5934\u7684\u56fa\u5b9a\u6d88\u606f\u7684\u503c\uff0c\u5373\u5b9e\u73b0\u4e86\u6a21p-1\u540c\u4f59\u3002 \u5177\u4f53\u5982\u4e0b # construct the message begins with 'test' target = \"Th3_bery_un1que1i_ChArmIng_G3nji\" + test part1 = ( digitalize ( 'test' + os . urandom ( 51 )) << 512 ) // ( p - 1 ) * ( p - 1 ) victim = part1 + digitalize ( target ) while 1 : tmp = hex ( victim )[ 2 :] . decode ( 'hex' ) if tmp . startswith ( 'test' ) and ' \\n ' not in tmp : break else : part1 = ( digitalize ( 'test' + os . urandom ( 51 )) << 512 ) // ( p - 1 ) * ( p - 1 ) victim = part1 + digitalize ( target ) \u6700\u540e\u7684\u811a\u672c\u5982\u4e0b from pwn import * from hashlib import sha1 import string import ast import os import binascii context . log_level = 'debug' def f ( x ): return sha1 ( prefix + x ) . digest ()[ - 2 :] == ' \\0\\0 ' def digitalize ( m ): return int ( m . encode ( 'hex' ), 16 ) sh = remote ( '106.75.66.195' , 40001 ) # bypass proof sh . recvuntil ( 'starting with ' ) prefix = sh . recvuntil ( ' \\n ' , drop = True ) print string . ascii_letters s = util . iters . mbruteforce ( f , string . ascii_letters + string . digits , 5 , 'fixed' ) test = prefix + s sh . sendline ( test ) sh . recvuntil ( 'Current PK we are using: ' ) pubkey = ast . literal_eval ( sh . recvuntil ( ' \\n ' , drop = True )) p = pubkey [ 0 ] g = pubkey [ 1 ] pk = pubkey [ 2 ] # construct the message begins with 'test' target = \"Th3_bery_un1que1i_ChArmIng_G3nji\" + test part1 = ( digitalize ( 'test' + os . urandom ( 51 )) << 512 ) // ( p - 1 ) * ( p - 1 ) victim = part1 + digitalize ( target ) while 1 : tmp = hex ( victim )[ 2 :] . decode ( 'hex' ) if tmp . startswith ( 'test' ) and ' \\n ' not in tmp : break else : part1 = ( digitalize ( 'test' + os . urandom ( 51 )) << 512 ) // ( p - 1 ) * ( p - 1 ) victim = part1 + digitalize ( target ) assert ( victim % ( p - 1 ) == digitalize ( target ) % ( p - 1 )) # get victim signature sh . sendline ( hex ( victim )[ 2 :] . decode ( 'hex' )) sh . recvuntil ( 'Your signature is' ) sig = ast . literal_eval ( sh . recvuntil ( ' \\n ' , drop = True )) sig = [ int ( sig [ 0 ], 0 ), int ( sig [ 1 ], 0 )] # get flag sh . sendline ( target ) sh . sendline ( str ( sig [ 0 ]) + \",\" + str ( sig [ 1 ])) sh . interactive () \u8fd9\u91cc\u8fd8\u8981\u8bf4\u51e0\u4e2a\u6709\u610f\u601d\u7684\u70b9\u5c31\u662f int(x,0)\u53ea\u7684\u662f\u5c06x\u6309\u7167\u5176\u5b57\u9762\u5bf9\u5e94\u7684\u8fdb\u5236\u8f6c\u6362\u4e3a\u5bf9\u5e94\u7684\u6570\u5b57\uff0c\u6bd4\u5982\u8bf4int('0x12',0)=18\uff0c\u8fd9\u91cc\u76f8\u5e94\u7684\u5b57\u9762\u5fc5\u987b\u6709\u5bf9\u5e94\u6807\u5fd7\u5f00\u5934\uff0c\u6bd4\u5982\u8bf4\u5341\u516d\u8fdb\u5236\u662f0x,8\u8fdb\u5236\u662f0\uff0c\u4e8c\u8fdb\u5236\u662f0b\u3002\u56e0\u4e3a\u5982\u679c\u6ca1\u6709\u7684\u8bdd\uff0c\u5c31\u4e0d\u77e5\u9053\u8be5\u5982\u4f55\u8bc6\u522b\u4e86\u3002 python(python2) \u91cc\u9762\u5230\u5e95\u591a\u5927\u7684\u6570\uff0c\u8ba1\u7b97\u51fa\u6765\u6700\u540e\u624d\u4f1a\u5e26\u6709L\u5462\uff1f\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u5927\u4e8eint\u90fd\u4f1a\u6709L\u3002\u4f46\u662f\u8fd9\u4e2a\u91cc\u9762\u7684victim\u786e\u5b9e\u662f\u6ca1\u6709\u7684\uff0c\uff0c \u4e00\u4e2a\u95ee\u9898\uff0c\u5f85\u89e3\u51b3\u3002\u3002","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/signature/introduction-zh/","text":"EN | ZH \u6570\u5b57\u7b7e\u540d \u00b6 \u5728\u65e5\u5e38\u751f\u6d3b\u4e2d\uff0c\u6211\u4eec\u5728\u53c2\u52a0\u67d0\u4e2a\u6d3b\u52a8\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u4f1a\u9700\u8981\u7b7e\u540d\uff0c\u4ee5\u4fbf\u4e8e\u8bc1\u660e\u6211\u4eec\u786e\u5b9e\u5230\u573a\u4e86\uff0c\uff0c\uff0c\u9632\u6b62\u5bfc\u5458\u5565\u7684\uff0c\u4f60\u61c2\u5f97\u3002\u3002\u3002\u4f46\u5176\u5b9e\u5427\uff0c\u8fd9\u79cd\u7b7e\u540d\u5f88\u5bb9\u6613\u88ab\u4f2a\u9020\uff0c\u968f\u4fbf\u627e\u4e00\u4e2a\u4eba\u4ee3\u7b7e\u4e00\u4e0b\uff0c\u6216\u8005\u8bf4\u627e\u4e00\u4e2a\u4f1a\u6a21\u4eff\u522b\u4eba\u5b57\u8ff9\u7684\u4eba\u5e2e\u5fd9\u7b7e\u4e00\u4e0b\u3002\u5728\u8ba1\u7b97\u673a\u4e16\u754c\u4e2d\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u9700\u8981\u7535\u5b50\u7b7e\u540d\uff0c\u56e0\u4e3a\u6211\u4eec\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f1a\u4f7f\u7528\u7535\u5b50\u6587\u4ef6\uff0c\u90a3\u8fd9\u65f6\u5019\u600e\u4e48\u529e\u5462\uff1f\u5f53\u7136\uff0c\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u81ea\u5df1\u7684\u540d\u5b57\u3002\u4f46\u5176\u5b9e\u8fd8\u6709\u53e6\u5916\u4e00\u79cd\u65b9\u5f0f\uff0c\u90a3\u5c31\u662f\u91c7\u7528\u6570\u5b57\u7b7e\u540d\uff0c\u8fd9\u79cd\u7b7e\u540d\u66f4\u52a0\u96be\u4ee5\u4f2a\u9020\uff0c\u53ef\u4fe1\u7a0b\u5ea6\u66f4\u9ad8\u3002\u6570\u5b57\u7b7e\u540d\u7684\u4e3b\u8981\u7528\u5904\u662f\u786e\u4fdd\u6d88\u606f\u786e\u5b9e\u6765\u81ea\u4e8e\u58f0\u79f0\u4ea7\u751f\u8be5\u6d88\u606f\u7684\u4eba\u3002 \u6570\u5b57\u7b7e\u540d\uff08digital signature\uff09\u4e3b\u8981\u7528\u4e8e\u5bf9\u6570\u5b57\u6d88\u606f\uff08digital message\uff09\u8fdb\u884c\u7b7e\u540d\uff0c\u4ee5\u9632\u6d88\u606f\u7684\u5192\u540d\u4f2a\u9020\u6216\u7be1\u6539\uff0c\u4ea6\u53ef\u4ee5\u7528\u4e8e\u901a\u4fe1\u53cc\u65b9\u7684\u8eab\u4efd\u9274\u522b\u3002 \u6570\u5b57\u7b7e\u540d\u4f9d\u8d56\u4e8e\u975e\u5bf9\u79f0\u5bc6\u7801\uff0c\u56e0\u4e3a\u6211\u4eec\u5fc5\u987b\u786e\u4fdd\u4e00\u65b9\u80fd\u591f\u505a\u7684\u4e8b\u60c5\uff0c\u800c\u53e6\u4e00\u65b9\u4e0d\u80fd\u591f\u505a\u51fa\u8fd9\u6837\u7684\u4e8b\u60c5\u3002\u5176\u57fa\u672c\u539f\u7406\u5982\u4e0b \u6570\u5b57\u7b7e\u540d\u5e94\u5f53\u5177\u6709\u4ee5\u4e0b\u51e0\u4e2a\u7279\u6027\uff1a (1) \u7b7e\u540d\u662f\u53ef\u4fe1\u7684\uff1a\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u9a8c\u8bc1\u7b7e\u540d\u7684\u6709\u6548\u6027\u3002 (2) \u7b7e\u540d\u662f\u4e0d\u53ef\u4f2a\u9020\u7684\uff1a\u9664\u4e86\u5408\u6cd5\u7684\u7b7e\u540d\u8005\u4e4b\u5916\uff0c\u4efb\u4f55\u5176\u4ed6\u4eba\u4f2a\u9020\u5176\u7b7e\u540d\u662f\u56f0\u96be\u7684\u3002 (3) \u7b7e\u540d\u662f\u4e0d\u53ef\u590d\u5236\u7684\uff1a\u5bf9\u4e00\u4e2a\u6d88\u606f\u7684\u7b7e\u540d\u4e0d\u80fd\u901a\u8fc7\u590d\u5236\u53d8\u4e3a\u53e6\u4e00\u4e2a\u6d88\u606f\u7684\u7b7e\u540d\u3002\u5982\u679c\u5bf9\u4e00\u4e2a\u6d88\u606f\u7684\u7b7e\u540d\u662f\u4ece\u522b\u5904\u590d\u5236\u5f97\u5230\u7684\uff0c\u5219\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u53d1\u73b0\u6d88\u606f\u4e0e\u7b7e\u540d\u4e4b\u95f4\u7684\u4e0d\u4e00\u81f4\u6027\uff0c\u4ece\u800c\u53ef\u4ee5\u62d2\u7edd\u7b7e\u540d\u7684\u6d88\u606f\u3002 (4) \u7b7e\u540d\u7684\u6d88\u606f\u662f\u4e0d\u53ef\u6539\u53d8\u7684\uff1a\u7ecf\u7b7e\u540d\u7684\u6d88\u606f\u4e0d\u80fd\u88ab\u7be1\u6539\u3002\u4e00\u65e6\u7b7e\u540d\u7684\u6d88\u606f\u88ab\u7be1\u6539\uff0c\u5219\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u53d1\u73b0\u6d88\u606f\u4e0e\u7b7e\u540d\u4e4b\u95f4\u7684\u4e0d\u4e00\u81f4\u6027\u3002 (5) \u7b7e\u540d\u662f\u4e0d\u53ef\u62b5\u8d56\u7684\uff1a\u7b7e\u540d\u8005\u4e8b\u540e\u4e0d\u80fd\u5426\u8ba4\u81ea\u5df1\u7684\u7b7e\u540d\u3002","title":"Introduction zh"},{"location":"crypto/ctf-wiki/signature/introduction-zh/#_1","text":"\u5728\u65e5\u5e38\u751f\u6d3b\u4e2d\uff0c\u6211\u4eec\u5728\u53c2\u52a0\u67d0\u4e2a\u6d3b\u52a8\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u4f1a\u9700\u8981\u7b7e\u540d\uff0c\u4ee5\u4fbf\u4e8e\u8bc1\u660e\u6211\u4eec\u786e\u5b9e\u5230\u573a\u4e86\uff0c\uff0c\uff0c\u9632\u6b62\u5bfc\u5458\u5565\u7684\uff0c\u4f60\u61c2\u5f97\u3002\u3002\u3002\u4f46\u5176\u5b9e\u5427\uff0c\u8fd9\u79cd\u7b7e\u540d\u5f88\u5bb9\u6613\u88ab\u4f2a\u9020\uff0c\u968f\u4fbf\u627e\u4e00\u4e2a\u4eba\u4ee3\u7b7e\u4e00\u4e0b\uff0c\u6216\u8005\u8bf4\u627e\u4e00\u4e2a\u4f1a\u6a21\u4eff\u522b\u4eba\u5b57\u8ff9\u7684\u4eba\u5e2e\u5fd9\u7b7e\u4e00\u4e0b\u3002\u5728\u8ba1\u7b97\u673a\u4e16\u754c\u4e2d\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u9700\u8981\u7535\u5b50\u7b7e\u540d\uff0c\u56e0\u4e3a\u6211\u4eec\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4f1a\u4f7f\u7528\u7535\u5b50\u6587\u4ef6\uff0c\u90a3\u8fd9\u65f6\u5019\u600e\u4e48\u529e\u5462\uff1f\u5f53\u7136\uff0c\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5\u9009\u62e9\u4f7f\u7528\u81ea\u5df1\u7684\u540d\u5b57\u3002\u4f46\u5176\u5b9e\u8fd8\u6709\u53e6\u5916\u4e00\u79cd\u65b9\u5f0f\uff0c\u90a3\u5c31\u662f\u91c7\u7528\u6570\u5b57\u7b7e\u540d\uff0c\u8fd9\u79cd\u7b7e\u540d\u66f4\u52a0\u96be\u4ee5\u4f2a\u9020\uff0c\u53ef\u4fe1\u7a0b\u5ea6\u66f4\u9ad8\u3002\u6570\u5b57\u7b7e\u540d\u7684\u4e3b\u8981\u7528\u5904\u662f\u786e\u4fdd\u6d88\u606f\u786e\u5b9e\u6765\u81ea\u4e8e\u58f0\u79f0\u4ea7\u751f\u8be5\u6d88\u606f\u7684\u4eba\u3002 \u6570\u5b57\u7b7e\u540d\uff08digital signature\uff09\u4e3b\u8981\u7528\u4e8e\u5bf9\u6570\u5b57\u6d88\u606f\uff08digital message\uff09\u8fdb\u884c\u7b7e\u540d\uff0c\u4ee5\u9632\u6d88\u606f\u7684\u5192\u540d\u4f2a\u9020\u6216\u7be1\u6539\uff0c\u4ea6\u53ef\u4ee5\u7528\u4e8e\u901a\u4fe1\u53cc\u65b9\u7684\u8eab\u4efd\u9274\u522b\u3002 \u6570\u5b57\u7b7e\u540d\u4f9d\u8d56\u4e8e\u975e\u5bf9\u79f0\u5bc6\u7801\uff0c\u56e0\u4e3a\u6211\u4eec\u5fc5\u987b\u786e\u4fdd\u4e00\u65b9\u80fd\u591f\u505a\u7684\u4e8b\u60c5\uff0c\u800c\u53e6\u4e00\u65b9\u4e0d\u80fd\u591f\u505a\u51fa\u8fd9\u6837\u7684\u4e8b\u60c5\u3002\u5176\u57fa\u672c\u539f\u7406\u5982\u4e0b \u6570\u5b57\u7b7e\u540d\u5e94\u5f53\u5177\u6709\u4ee5\u4e0b\u51e0\u4e2a\u7279\u6027\uff1a (1) \u7b7e\u540d\u662f\u53ef\u4fe1\u7684\uff1a\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u9a8c\u8bc1\u7b7e\u540d\u7684\u6709\u6548\u6027\u3002 (2) \u7b7e\u540d\u662f\u4e0d\u53ef\u4f2a\u9020\u7684\uff1a\u9664\u4e86\u5408\u6cd5\u7684\u7b7e\u540d\u8005\u4e4b\u5916\uff0c\u4efb\u4f55\u5176\u4ed6\u4eba\u4f2a\u9020\u5176\u7b7e\u540d\u662f\u56f0\u96be\u7684\u3002 (3) \u7b7e\u540d\u662f\u4e0d\u53ef\u590d\u5236\u7684\uff1a\u5bf9\u4e00\u4e2a\u6d88\u606f\u7684\u7b7e\u540d\u4e0d\u80fd\u901a\u8fc7\u590d\u5236\u53d8\u4e3a\u53e6\u4e00\u4e2a\u6d88\u606f\u7684\u7b7e\u540d\u3002\u5982\u679c\u5bf9\u4e00\u4e2a\u6d88\u606f\u7684\u7b7e\u540d\u662f\u4ece\u522b\u5904\u590d\u5236\u5f97\u5230\u7684\uff0c\u5219\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u53d1\u73b0\u6d88\u606f\u4e0e\u7b7e\u540d\u4e4b\u95f4\u7684\u4e0d\u4e00\u81f4\u6027\uff0c\u4ece\u800c\u53ef\u4ee5\u62d2\u7edd\u7b7e\u540d\u7684\u6d88\u606f\u3002 (4) \u7b7e\u540d\u7684\u6d88\u606f\u662f\u4e0d\u53ef\u6539\u53d8\u7684\uff1a\u7ecf\u7b7e\u540d\u7684\u6d88\u606f\u4e0d\u80fd\u88ab\u7be1\u6539\u3002\u4e00\u65e6\u7b7e\u540d\u7684\u6d88\u606f\u88ab\u7be1\u6539\uff0c\u5219\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u53d1\u73b0\u6d88\u606f\u4e0e\u7b7e\u540d\u4e4b\u95f4\u7684\u4e0d\u4e00\u81f4\u6027\u3002 (5) \u7b7e\u540d\u662f\u4e0d\u53ef\u62b5\u8d56\u7684\uff1a\u7b7e\u540d\u8005\u4e8b\u540e\u4e0d\u80fd\u5426\u8ba4\u81ea\u5df1\u7684\u7b7e\u540d\u3002","title":"\u6570\u5b57\u7b7e\u540d"},{"location":"crypto/ctf-wiki/signature/introduction/","text":"EN | ZH digital signature \u00b6 In daily life, when we participate in an event, we may need to sign in order to prove that we are indeed present, and to prevent the leader from knowing, you know. . . But in fact, this signature is easy to be forged, just ask someone to sign it, or find someone who will imitate someone else's handwriting to help sign it. In the computer world, we may need an electronic signature, because most of the time we use electronic files, what should we do at this time? Of course, we can still choose to use our own name. But there is another way, that is, using digital signatures, which are more difficult to forge and more trustworthy. The primary use of digital signatures is to ensure that the message does come from the person who claims to have generated the message. Digital signatures are mainly used to sign digital messages in case of impersonation or falsification of messages, and can also be used for identity authentication of both parties. Digital signatures rely on asymmetric cryptography because we have to make sure that one party can do something while the other party cannot do something like this. The basic principle is as follows Digital signatures should have the following characteristics: (1) The signature is credible: anyone can verify the validity of the signature. (2) Signatures are unforgeable: it is difficult for anyone else to falsify their signatures except for legitimate signers. (3) Signatures are not reproducible: the signature of one message cannot be changed to the signature of another message by copying. If the signature of a message is copied from elsewhere, anyone can discover the inconsistency between the message and the signature, so that the signed message can be rejected. (4) The signed message is immutable: the signed message cannot be tampered with. Once the signed message has been tampered with, anyone can discover the inconsistency between the message and the signature. (5) The signature is non-repudiation: the signer cannot deny his signature afterwards.","title":"\u6570\u5b57\u7b7e\u540d\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/signature/introduction/#digital-signature","text":"In daily life, when we participate in an event, we may need to sign in order to prove that we are indeed present, and to prevent the leader from knowing, you know. . . But in fact, this signature is easy to be forged, just ask someone to sign it, or find someone who will imitate someone else's handwriting to help sign it. In the computer world, we may need an electronic signature, because most of the time we use electronic files, what should we do at this time? Of course, we can still choose to use our own name. But there is another way, that is, using digital signatures, which are more difficult to forge and more trustworthy. The primary use of digital signatures is to ensure that the message does come from the person who claims to have generated the message. Digital signatures are mainly used to sign digital messages in case of impersonation or falsification of messages, and can also be used for identity authentication of both parties. Digital signatures rely on asymmetric cryptography because we have to make sure that one party can do something while the other party cannot do something like this. The basic principle is as follows Digital signatures should have the following characteristics: (1) The signature is credible: anyone can verify the validity of the signature. (2) Signatures are unforgeable: it is difficult for anyone else to falsify their signatures except for legitimate signers. (3) Signatures are not reproducible: the signature of one message cannot be changed to the signature of another message by copying. If the signature of a message is copied from elsewhere, anyone can discover the inconsistency between the message and the signature, so that the signed message can be rejected. (4) The signed message is immutable: the signed message cannot be tampered with. Once the signed message has been tampered with, anyone can discover the inconsistency between the message and the signature. (5) The signature is non-repudiation: the signer cannot deny his signature afterwards.","title":"digital signature"},{"location":"crypto/ctf-wiki/signature/rsa-zh/","text":"EN | ZH RSA \u6570\u5b57\u7b7e\u540d \u00b6 \u539f\u7406 \u00b6 \u539f\u7406\u7c7b\u4f3c\u4e8e RSA \u52a0\u5bc6\uff0c\u53ea\u662f\u8fd9\u91cc\u4f7f\u7528\u79c1\u94a5\u8fdb\u884c\u52a0\u5bc6\uff0c\u5c06\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u4f5c\u4e3a\u7b7e\u540d\u3002 2018 Backdoor Awesome mix1 \u00b6 \u9996\u5148\uff0c\u53ef\u4ee5\u7b80\u5355\u5206\u6790\u6e90\u7801\uff0c\u8fd9\u91cc\u7a0b\u5e8f\u4f7f\u7528 PKCS1_V1.5 \u8fdb\u884c\u4e86 RSA \u7b7e\u540d\uff0c\u8fd9\u4f1a\u5bf9\u660e\u6587\u6d88\u606f\u8fdb\u884c\u6269\u5c55\uff0c\u5177\u4f53\u6269\u5c55\u89c4\u5219\u8bf7\u53c2\u8003 https://www.emc.com/collateral/white-papers/h11300-pkcs-1v2-2-rsa-cryptography-standard-wp.pdf \u3002\u8fd9\u91cc\u7ed9\u51fa\u5bf9\u5e94\u6269\u5c55\u811a\u672c\uff0c\u5bf9\u5e94\u4e8e\u9898\u76ee\u4e2d\u7684 from Util import PKCS1_pad as pad def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( '00' + '01' + 'ff' * ( 1024 / 8 - n / 2 - 3 ) + '00' + ans ), 16 ) \u7a0b\u5e8f\u5e0c\u671b\u6211\u4eec\u7ed9\u51fa n,e \u4f7f\u5f97\u7a0b\u5e8f\u6ee1\u8db3 h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) \u8fd9\u91cc\u6211\u4eec\u5df2\u7ecf\u77e5\u9053 h(m)\uff0cpad(m) \u3002\u663e\u7136\u5982\u679c\u6211\u4eec\u63a7\u5236 e=1 \u7684\u8bdd\uff0c\u90a3\u4e48 h(m)-pad(m)=kn h(m)-pad(m)=kn \u90a3\u4e48\u5982\u679c\u6211\u4eec\u53ef\u4ee5\u8bbe\u7f6e k=1\uff0c\u65e2\u53ef\u4ee5\u5f97\u5230 n\u3002 \u672c\u5730\u90e8\u7f72 socat TCP4-LISTEN:12345,fork EXEC:./mix1.py \u3002 exp \u5982\u4e0b from Crypto.Hash import SHA from pwn import * from Util import PKCS1_pad #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) e = 1 n = int ( signature , 16 ) - m p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () \u6548\u679c\u5982\u4e0b \u279c 2018 -BackdoorCTF-Awesome-mix1 git: ( master ) python exp.py [ + ] Opening connection to 127 .0.0.1 on port 12345 : Done [ * ] message: super important information for admin only [ * ] signature: 721af5bd401b5f2aff8e86bf811b827cdb5877ef12202f24fa914a26f235523f80c45fdbf0d3c9fa77278828ddd8ca0551a941bd57c97dd38654692568d1357a49e7a2a284d296508602ead24c91e5aa7f517b9e48422575f0dd373d00f267a206ba164ab104c488268b5f95daf490a048407773d4b1016de8ef508bf1aa678f [ * ] Switching to interactive mode CTF { cryp70_5ur3_15_w13rd } [ * ] Got EOF while reading in interactive 2018 Backdoor Awesome mix2 \u00b6 \u672c\u5730\u90e8\u7f72 socat TCP4-LISTEN:12345,fork EXEC:./service.py \u3002 \u9898\u76ee\u7c7b\u4f3c\u4e8e\u4e0a\u9762\u7684\u9898\u76ee\uff0c\u552f\u4e00\u7684\u533a\u522b\u5728\u4e8e\u5bf9\u4e8e e \u6709\u7ea6\u675f\uff0c\u5fc5\u987b\u5927\u4e8e 3\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528 1 \u4e86\u3002 h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) \u8fd9\u91cc\u6211\u4eec\u5df2\u7ecf\u77e5\u9053 h(m)\uff0cpad(m) \u3002\u6211\u4eec\u53ea\u9700\u8981\u6784\u9020\u5269\u4e0b\u7684\u6570\u5373\u53ef\uff0c\u8fd9\u91cc\u6211\u4eec\u6784\u9020 n \u4e3a\u7d20\u6570\uff0c\u4f7f\u5f97 n-1\u662f\u4e00\u4e2a\u5149\u6ed1\u6570\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4f7f\u7528 pohlig_hellman \u7b97\u6cd5\u4e86\u3002 from Crypto.Hash import SHA from pwn import * import gmpy2 from gmpy2 import is_prime import random def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( '00' + '01' + 'ff' * ( 1024 / 8 - n / 2 - 3 ) + '00' + ans ), 16 ) #context.log_level = 'debug' def gen_smooth_num ( plist , minnum = pow ( 2 , 1020 )): lenp = len ( plist ) while True : n = 1 factors = dict () while n + 1 < minnum : tmp = random . randint ( 0 , lenp - 1 ) n *= plist [ tmp ] if plist [ tmp ] in factors : factors [ plist [ tmp ]] += 1 else : factors [ plist [ tmp ]] = 1 if n . bit_length () > 1024 : continue if is_prime ( n + 1 ): return n + 1 , factors # http://pythonexample.com/snippet/pohligpy_neuratron_python # solve g^x=h mod m def log_prime_power ( g , h , pf , pe , M ): powers = [ pf ** k for k in range ( pe )] gamma = gmpy2 . powmod ( g , powers [ - 1 ], M ) xk = gmpy2 . mpz ( 0 ) for k in range ( pe ): if k == 0 : hk = gmpy2 . powmod ( h , powers [ pe - k - 1 ], M ) else : gk = gmpy2 . powmod ( g , xk * ( M - 2 ), M ) hk = gmpy2 . powmod ( gk * h , powers [ pe - k - 1 ], M ) k_log_found = False for dk in range ( pf ): yk = gmpy2 . powmod ( gamma , dk , M ) if yk == hk : k_log_found = True break if not k_log_found : raise Exception ( \"can not solve\" ) xk += gmpy2 . mul ( powers [ k ], dk ) return xk def pohlig_hellman ( g , h , M , factors ): M1 = M - 1 xs = [] for f in factors : pf = f pe = factors [ f ] subgroup_exponent = gmpy2 . div ( M1 , gmpy2 . powmod ( pf , pe , M )) gi = gmpy2 . powmod ( g , subgroup_exponent , M ) hi = gmpy2 . powmod ( h , subgroup_exponent , M ) xi = log_prime_power ( gi , hi , pf , pe , M ) xs . append ( xi ) crt_coeffs = [] for f in factors : pf = f pe = factors [ f ] mi = pf ** pe bi = gmpy2 . div ( M , mi ) bi_inv = gmpy2 . invert ( bi , mi ) crt_coeffs . append ( gmpy2 . mul ( bi , bi_inv )) x = 0 for i in range ( len ( crt_coeffs )): x = gmpy2 . t_mod ( x + gmpy2 . t_mod ( xs [ i ] * crt_coeffs [ i ], M1 ), M1 ) return x #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) signature = int ( signature , 16 ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) print m , signature plist = [] for i in range ( 2 , 1000 ): if is_prime ( i ): plist . append ( i ) while True : try : n , factors = gen_smooth_num ( plist , signature ) e = pohlig_hellman ( signature , m , n , factors ) except Exception as e : continue else : break print n , e print m print gmpy2 . powmod ( signature , e , n ) p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () \u6709\u4e24\u70b9\u9700\u8981\u6ce8\u610f \u7531\u4e8e g^x=y g^x=y \u4e2d\u7684 g \u548c y \u90fd\u662f\u7ed9\u5b9a\u7684\uff0c\u6211\u4eec\u65b0\u627e\u5230\u7684 n\uff0c\u4e0d\u4e00\u5b9a g \u7684\u5e42\u6b21\u6784\u6210\u7684\u7fa4\u4f1a\u5305\u542b y\uff0c\u6240\u4ee5\u53ef\u80fd\u6c42\u89e3\u5931\u8d25\uff0c\u6240\u4ee5\u9700\u8981\u591a\u6b21\u6c42\u89e3\u3002 \u6e90\u4ee3\u7801\u4e2d\u867d\u7136 n.bit_length() <= 1025 \uff0c\u4f46\u662f\u5176\u5b9e n \u5728\u6ee1\u8db3\u4e0d\u5c0f\u4e8e signature \u7684\u6761\u4ef6\u65f6\uff0c\u5fc5\u987b\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6\uff08pycrypto \u6e90\u7801\uff09 modBits = Crypto . Util . number . size ( self . _key . n ) k = ceil_div ( modBits , 8 ) # Convert from bits to bytes # Step 1 if len ( S ) != k : return 0 \u6240\u4ee5\u6211\u4eec\u6700\u597d\u8bbe\u7f6e n \u4e3a1024 \u6bd4\u7279\u4f4d\u3002","title":"Rsa zh"},{"location":"crypto/ctf-wiki/signature/rsa-zh/#rsa","text":"","title":"RSA \u6570\u5b57\u7b7e\u540d"},{"location":"crypto/ctf-wiki/signature/rsa-zh/#_1","text":"\u539f\u7406\u7c7b\u4f3c\u4e8e RSA \u52a0\u5bc6\uff0c\u53ea\u662f\u8fd9\u91cc\u4f7f\u7528\u79c1\u94a5\u8fdb\u884c\u52a0\u5bc6\uff0c\u5c06\u52a0\u5bc6\u540e\u7684\u7ed3\u679c\u4f5c\u4e3a\u7b7e\u540d\u3002","title":"\u539f\u7406"},{"location":"crypto/ctf-wiki/signature/rsa-zh/#2018-backdoor-awesome-mix1","text":"\u9996\u5148\uff0c\u53ef\u4ee5\u7b80\u5355\u5206\u6790\u6e90\u7801\uff0c\u8fd9\u91cc\u7a0b\u5e8f\u4f7f\u7528 PKCS1_V1.5 \u8fdb\u884c\u4e86 RSA \u7b7e\u540d\uff0c\u8fd9\u4f1a\u5bf9\u660e\u6587\u6d88\u606f\u8fdb\u884c\u6269\u5c55\uff0c\u5177\u4f53\u6269\u5c55\u89c4\u5219\u8bf7\u53c2\u8003 https://www.emc.com/collateral/white-papers/h11300-pkcs-1v2-2-rsa-cryptography-standard-wp.pdf \u3002\u8fd9\u91cc\u7ed9\u51fa\u5bf9\u5e94\u6269\u5c55\u811a\u672c\uff0c\u5bf9\u5e94\u4e8e\u9898\u76ee\u4e2d\u7684 from Util import PKCS1_pad as pad def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( '00' + '01' + 'ff' * ( 1024 / 8 - n / 2 - 3 ) + '00' + ans ), 16 ) \u7a0b\u5e8f\u5e0c\u671b\u6211\u4eec\u7ed9\u51fa n,e \u4f7f\u5f97\u7a0b\u5e8f\u6ee1\u8db3 h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) \u8fd9\u91cc\u6211\u4eec\u5df2\u7ecf\u77e5\u9053 h(m)\uff0cpad(m) \u3002\u663e\u7136\u5982\u679c\u6211\u4eec\u63a7\u5236 e=1 \u7684\u8bdd\uff0c\u90a3\u4e48 h(m)-pad(m)=kn h(m)-pad(m)=kn \u90a3\u4e48\u5982\u679c\u6211\u4eec\u53ef\u4ee5\u8bbe\u7f6e k=1\uff0c\u65e2\u53ef\u4ee5\u5f97\u5230 n\u3002 \u672c\u5730\u90e8\u7f72 socat TCP4-LISTEN:12345,fork EXEC:./mix1.py \u3002 exp \u5982\u4e0b from Crypto.Hash import SHA from pwn import * from Util import PKCS1_pad #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) e = 1 n = int ( signature , 16 ) - m p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () \u6548\u679c\u5982\u4e0b \u279c 2018 -BackdoorCTF-Awesome-mix1 git: ( master ) python exp.py [ + ] Opening connection to 127 .0.0.1 on port 12345 : Done [ * ] message: super important information for admin only [ * ] signature: 721af5bd401b5f2aff8e86bf811b827cdb5877ef12202f24fa914a26f235523f80c45fdbf0d3c9fa77278828ddd8ca0551a941bd57c97dd38654692568d1357a49e7a2a284d296508602ead24c91e5aa7f517b9e48422575f0dd373d00f267a206ba164ab104c488268b5f95daf490a048407773d4b1016de8ef508bf1aa678f [ * ] Switching to interactive mode CTF { cryp70_5ur3_15_w13rd } [ * ] Got EOF while reading in interactive","title":"2018 Backdoor Awesome mix1"},{"location":"crypto/ctf-wiki/signature/rsa-zh/#2018-backdoor-awesome-mix2","text":"\u672c\u5730\u90e8\u7f72 socat TCP4-LISTEN:12345,fork EXEC:./service.py \u3002 \u9898\u76ee\u7c7b\u4f3c\u4e8e\u4e0a\u9762\u7684\u9898\u76ee\uff0c\u552f\u4e00\u7684\u533a\u522b\u5728\u4e8e\u5bf9\u4e8e e \u6709\u7ea6\u675f\uff0c\u5fc5\u987b\u5927\u4e8e 3\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528 1 \u4e86\u3002 h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) \u8fd9\u91cc\u6211\u4eec\u5df2\u7ecf\u77e5\u9053 h(m)\uff0cpad(m) \u3002\u6211\u4eec\u53ea\u9700\u8981\u6784\u9020\u5269\u4e0b\u7684\u6570\u5373\u53ef\uff0c\u8fd9\u91cc\u6211\u4eec\u6784\u9020 n \u4e3a\u7d20\u6570\uff0c\u4f7f\u5f97 n-1\u662f\u4e00\u4e2a\u5149\u6ed1\u6570\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4f7f\u7528 pohlig_hellman \u7b97\u6cd5\u4e86\u3002 from Crypto.Hash import SHA from pwn import * import gmpy2 from gmpy2 import is_prime import random def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( '00' + '01' + 'ff' * ( 1024 / 8 - n / 2 - 3 ) + '00' + ans ), 16 ) #context.log_level = 'debug' def gen_smooth_num ( plist , minnum = pow ( 2 , 1020 )): lenp = len ( plist ) while True : n = 1 factors = dict () while n + 1 < minnum : tmp = random . randint ( 0 , lenp - 1 ) n *= plist [ tmp ] if plist [ tmp ] in factors : factors [ plist [ tmp ]] += 1 else : factors [ plist [ tmp ]] = 1 if n . bit_length () > 1024 : continue if is_prime ( n + 1 ): return n + 1 , factors # http://pythonexample.com/snippet/pohligpy_neuratron_python # solve g^x=h mod m def log_prime_power ( g , h , pf , pe , M ): powers = [ pf ** k for k in range ( pe )] gamma = gmpy2 . powmod ( g , powers [ - 1 ], M ) xk = gmpy2 . mpz ( 0 ) for k in range ( pe ): if k == 0 : hk = gmpy2 . powmod ( h , powers [ pe - k - 1 ], M ) else : gk = gmpy2 . powmod ( g , xk * ( M - 2 ), M ) hk = gmpy2 . powmod ( gk * h , powers [ pe - k - 1 ], M ) k_log_found = False for dk in range ( pf ): yk = gmpy2 . powmod ( gamma , dk , M ) if yk == hk : k_log_found = True break if not k_log_found : raise Exception ( \"can not solve\" ) xk += gmpy2 . mul ( powers [ k ], dk ) return xk def pohlig_hellman ( g , h , M , factors ): M1 = M - 1 xs = [] for f in factors : pf = f pe = factors [ f ] subgroup_exponent = gmpy2 . div ( M1 , gmpy2 . powmod ( pf , pe , M )) gi = gmpy2 . powmod ( g , subgroup_exponent , M ) hi = gmpy2 . powmod ( h , subgroup_exponent , M ) xi = log_prime_power ( gi , hi , pf , pe , M ) xs . append ( xi ) crt_coeffs = [] for f in factors : pf = f pe = factors [ f ] mi = pf ** pe bi = gmpy2 . div ( M , mi ) bi_inv = gmpy2 . invert ( bi , mi ) crt_coeffs . append ( gmpy2 . mul ( bi , bi_inv )) x = 0 for i in range ( len ( crt_coeffs )): x = gmpy2 . t_mod ( x + gmpy2 . t_mod ( xs [ i ] * crt_coeffs [ i ], M1 ), M1 ) return x #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) signature = int ( signature , 16 ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) print m , signature plist = [] for i in range ( 2 , 1000 ): if is_prime ( i ): plist . append ( i ) while True : try : n , factors = gen_smooth_num ( plist , signature ) e = pohlig_hellman ( signature , m , n , factors ) except Exception as e : continue else : break print n , e print m print gmpy2 . powmod ( signature , e , n ) p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () \u6709\u4e24\u70b9\u9700\u8981\u6ce8\u610f \u7531\u4e8e g^x=y g^x=y \u4e2d\u7684 g \u548c y \u90fd\u662f\u7ed9\u5b9a\u7684\uff0c\u6211\u4eec\u65b0\u627e\u5230\u7684 n\uff0c\u4e0d\u4e00\u5b9a g \u7684\u5e42\u6b21\u6784\u6210\u7684\u7fa4\u4f1a\u5305\u542b y\uff0c\u6240\u4ee5\u53ef\u80fd\u6c42\u89e3\u5931\u8d25\uff0c\u6240\u4ee5\u9700\u8981\u591a\u6b21\u6c42\u89e3\u3002 \u6e90\u4ee3\u7801\u4e2d\u867d\u7136 n.bit_length() <= 1025 \uff0c\u4f46\u662f\u5176\u5b9e n \u5728\u6ee1\u8db3\u4e0d\u5c0f\u4e8e signature \u7684\u6761\u4ef6\u65f6\uff0c\u5fc5\u987b\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6\uff08pycrypto \u6e90\u7801\uff09 modBits = Crypto . Util . number . size ( self . _key . n ) k = ceil_div ( modBits , 8 ) # Convert from bits to bytes # Step 1 if len ( S ) != k : return 0 \u6240\u4ee5\u6211\u4eec\u6700\u597d\u8bbe\u7f6e n \u4e3a1024 \u6bd4\u7279\u4f4d\u3002","title":"2018 Backdoor Awesome mix2"},{"location":"crypto/ctf-wiki/signature/rsa/","text":"EN | ZH RSA Digital Signature \u00b6 Principle \u00b6 The principle is similar to RSA encryption, except that the private key is used for encryption, and the encrypted result is used as a signature. 2018 Backdoor Awesome mix1 \u00b6 First, you can easily analyze the source code. Here, the program uses RSK signature with PKCS1_V1.5, which will extend the plaintext message. For specific extension rules, please refer to https://www.emc.com/collateral/white-papers/h11300-pkcs -1v2-2-rsa-cryptography-standard-wp.pdf. Here is the corresponding extension script, corresponding to the from Util import PKCS1_pad as pad in the title. def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( & #39;00&#39; + &#39;01&#39; + &#39;ff&#39; * (1024/8 - n / 2 - 3) + &#39;00&#39; + years), 16) The program wants us to give n,e to make the program satisfy h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) Here we already know h(m), pad(m) . Obviously if we control e=1 , then h(m)-pad(m)=kn h(m)-pad(m)=kn Then if we can set k=1, we can get n. Local deployment socat TCP4-LISTEN: 12345, fork EXEC:./mix1.py . Exp is as follows from Crypto.Hash import SHA from pwn import * from Util import PKCS1_pad #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) e = 1 n = int ( signature , 16 ) - m p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () The effect is as follows \u279c 2018 -BackdoorCTF-Awesome-mix1 git: ( master ) python exp.py [ + ] Opening connection to 127 .0.0.1 on port 12345 : Done [ * ] message: super important information for admin only [ * ] signature: 721af5bd401b5f2aff8e86bf811b827cdb5877ef12202f24fa914a26f235523f80c45fdbf0d3c9fa77278828ddd8ca0551a941bd57c97dd38654692568d1357a49e7a2a284d296508602ead24c91e5aa7f517b9e48422575f0dd373d00f267a206ba164ab104c488268b5f95daf490a048407773d4b1016de8ef508bf1aa678f [ * ] Switching to interactive mode CTF { cryp70_5ur3_15_w13rd } [ * ] Got EOF while reading in interactive 2018 Backdoor Awesome mix2 \u00b6 Local deployment socat TCP4-LISTEN: 12345, fork EXEC:./service.py . The topic is similar to the above question. The only difference is that there is a constraint on e, which must be greater than 3, so we can't use 1. h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) Here we already know h(m), pad(m) . We only need to construct the remaining numbers. Here we construct n as a prime number, so that n-1 is a smooth number, so we can use the pohlig_hellman algorithm. from Crypto.Hash import SHA from pwn import * import gmpy2 from gmpy2 import is_prime import random def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( & #39;00&#39; + &#39;01&#39; + &#39;ff&#39; * (1024/8 - n / 2 - 3) + &#39;00&#39; + years), 16) #context.log_level = 'debug' def gen_smooth_num ( plist , minnum = pow ( 2 , 1020 )): lenp = len ( plist ) while True : n = 1 factors = dict () while n + 1 & lt ; remember : tmp = random . randint ( 0 , lenp - 1 ) n *= plist [ tmp ] if plist [ tmp ] in factors : factors [ plist [ tmp ]] += 1 else : factors [ plist [ tmp ]] = 1 if n . bit_length () > 1024 : continue if is_prime ( n + 1 ): return n + 1 , factors # http://pythonexample.com/snippet/pohligpy_neuratron_python # solve g^x=h mod m define log_prime_power ( g , h , pf , pe , M ): powers = [ pf ** k for k in range ( pe )] gamma = gmpy2 . powmod ( g , powers [ - 1 ], M ) xk = gmpy2 . mpz ( 0 ) for k in range ( pe ): if k == 0 : hk = gmpy2 . powmod ( h , powers [ pe - k - 1 ], m ) else : gk = gmpy2 . powmod ( g , xk * ( M - 2 ), M ) hk = gmpy2 . powmod ( gk * h , powers [ pe - k - 1 ], m ) k_log_found = False for dk in range ( pf ): yk = gmpy2 . powmod ( gamma , dk , M ) if yk == hk : k_log_found = True break if not k_log_found : raise Exception ( \"can not solve\" ) xk += gmpy2 . mul ( powers [ k ], dk ) return xk def pohlig_hellman ( g , h , M , factors ): M1 = M - 1 xs = [] for f in factors : pf = f pe = factors [ f ] subgroup_exponent = gmpy2 . div ( M1 , gmpy2 . powmod ( pf , pe , M )) gi = gmpy2 . powmod ( g , subgroup_exponent , M ) hi = gmpy2 . powmod ( h , subgroup_exponent , M ) xi = log_prime_power ( gi , hi , pf , pe , M ) xs . append ( xi ) crt_coeffs = [] for f in factors : pf = f pe = factors [ f ] mi = pf ** on bi = gmpy2 . div ( M , mi ) bi_inv = gmpy2 . invert ( bi , mi ) crt_coeffs . append ( gmpy2 . mul ( bi , bi_inv )) x = 0 for i in range ( len ( crt_coeffs )): x = gmpy2 . t_mod ( x + gmpy2 . t_mod ( xs [ i ] * crt_coeffs [ i ], M1 ), M1 ) return x #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) signature = int ( signature , 16 ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) print m , signature plist = [] for i in range ( 2 , 1000 ): if is_prime ( i ): plist . append ( i ) while True : try : n , factors = gen_smooth_num ( plist , signature ) e = pohlig_hellman ( signature , m , n , factors ) except Exception as e : continue else : break print n , e print m print gmpy2 . powmod ( signature , e , n ) p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () There are two points to note Since both g and y in g^x=y g^x=y are given, the newly found n, not necessarily the power of g, will contain y, so the solution may fail, so it needs to be solved multiple times. . Although n.bit_length() &lt;= 1025 in the source code, in fact, when n satisfies the condition of not less than signature, the following conditions must be met (pycrypto source code) modBits = Crypto . Util . number . size ( self . _key . n ) k = ceil_div ( modBits , 8 ) # Convert from bits to bytes # Step 1 if len ( S ) ! = k : return 0 So we'd better set n to 1024 bits.","title":"RSA \u6570\u5b57\u7b7e\u540d"},{"location":"crypto/ctf-wiki/signature/rsa/#rsa-digital-signature","text":"","title":"RSA Digital Signature"},{"location":"crypto/ctf-wiki/signature/rsa/#principle","text":"The principle is similar to RSA encryption, except that the private key is used for encryption, and the encrypted result is used as a signature.","title":"Principle"},{"location":"crypto/ctf-wiki/signature/rsa/#2018-backdoor-awesome-mix1","text":"First, you can easily analyze the source code. Here, the program uses RSK signature with PKCS1_V1.5, which will extend the plaintext message. For specific extension rules, please refer to https://www.emc.com/collateral/white-papers/h11300-pkcs -1v2-2-rsa-cryptography-standard-wp.pdf. Here is the corresponding extension script, corresponding to the from Util import PKCS1_pad as pad in the title. def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( & #39;00&#39; + &#39;01&#39; + &#39;ff&#39; * (1024/8 - n / 2 - 3) + &#39;00&#39; + years), 16) The program wants us to give n,e to make the program satisfy h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) Here we already know h(m), pad(m) . Obviously if we control e=1 , then h(m)-pad(m)=kn h(m)-pad(m)=kn Then if we can set k=1, we can get n. Local deployment socat TCP4-LISTEN: 12345, fork EXEC:./mix1.py . Exp is as follows from Crypto.Hash import SHA from pwn import * from Util import PKCS1_pad #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) e = 1 n = int ( signature , 16 ) - m p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () The effect is as follows \u279c 2018 -BackdoorCTF-Awesome-mix1 git: ( master ) python exp.py [ + ] Opening connection to 127 .0.0.1 on port 12345 : Done [ * ] message: super important information for admin only [ * ] signature: 721af5bd401b5f2aff8e86bf811b827cdb5877ef12202f24fa914a26f235523f80c45fdbf0d3c9fa77278828ddd8ca0551a941bd57c97dd38654692568d1357a49e7a2a284d296508602ead24c91e5aa7f517b9e48422575f0dd373d00f267a206ba164ab104c488268b5f95daf490a048407773d4b1016de8ef508bf1aa678f [ * ] Switching to interactive mode CTF { cryp70_5ur3_15_w13rd } [ * ] Got EOF while reading in interactive","title":"2018 Backdoor Awesome mix1"},{"location":"crypto/ctf-wiki/signature/rsa/#2018-backdoor-awesome-mix2","text":"Local deployment socat TCP4-LISTEN: 12345, fork EXEC:./service.py . The topic is similar to the above question. The only difference is that there is a constraint on e, which must be greater than 3, so we can't use 1. h(m)^e mod \\ n=pad(m) h(m)^e mod \\ n=pad(m) Here we already know h(m), pad(m) . We only need to construct the remaining numbers. Here we construct n as a prime number, so that n-1 is a smooth number, so we can use the pohlig_hellman algorithm. from Crypto.Hash import SHA from pwn import * import gmpy2 from gmpy2 import is_prime import random def PKCS1_pad ( data ): asn1 = \"3021300906052b0e03021a05000414\" ans = asn1 + data n = len ( ans ) return int (( & #39;00&#39; + &#39;01&#39; + &#39;ff&#39; * (1024/8 - n / 2 - 3) + &#39;00&#39; + years), 16) #context.log_level = 'debug' def gen_smooth_num ( plist , minnum = pow ( 2 , 1020 )): lenp = len ( plist ) while True : n = 1 factors = dict () while n + 1 & lt ; remember : tmp = random . randint ( 0 , lenp - 1 ) n *= plist [ tmp ] if plist [ tmp ] in factors : factors [ plist [ tmp ]] += 1 else : factors [ plist [ tmp ]] = 1 if n . bit_length () > 1024 : continue if is_prime ( n + 1 ): return n + 1 , factors # http://pythonexample.com/snippet/pohligpy_neuratron_python # solve g^x=h mod m define log_prime_power ( g , h , pf , pe , M ): powers = [ pf ** k for k in range ( pe )] gamma = gmpy2 . powmod ( g , powers [ - 1 ], M ) xk = gmpy2 . mpz ( 0 ) for k in range ( pe ): if k == 0 : hk = gmpy2 . powmod ( h , powers [ pe - k - 1 ], m ) else : gk = gmpy2 . powmod ( g , xk * ( M - 2 ), M ) hk = gmpy2 . powmod ( gk * h , powers [ pe - k - 1 ], m ) k_log_found = False for dk in range ( pf ): yk = gmpy2 . powmod ( gamma , dk , M ) if yk == hk : k_log_found = True break if not k_log_found : raise Exception ( \"can not solve\" ) xk += gmpy2 . mul ( powers [ k ], dk ) return xk def pohlig_hellman ( g , h , M , factors ): M1 = M - 1 xs = [] for f in factors : pf = f pe = factors [ f ] subgroup_exponent = gmpy2 . div ( M1 , gmpy2 . powmod ( pf , pe , M )) gi = gmpy2 . powmod ( g , subgroup_exponent , M ) hi = gmpy2 . powmod ( h , subgroup_exponent , M ) xi = log_prime_power ( gi , hi , pf , pe , M ) xs . append ( xi ) crt_coeffs = [] for f in factors : pf = f pe = factors [ f ] mi = pf ** on bi = gmpy2 . div ( M , mi ) bi_inv = gmpy2 . invert ( bi , mi ) crt_coeffs . append ( gmpy2 . mul ( bi , bi_inv )) x = 0 for i in range ( len ( crt_coeffs )): x = gmpy2 . t_mod ( x + gmpy2 . t_mod ( xs [ i ] * crt_coeffs [ i ], M1 ), M1 ) return x #context.log_level = 'debug' def main (): port = 12345 host = \"127.0.0.1\" p = remote ( host , port ) p . recvuntil ( 'Message -> ' ) message = p . recvuntil ( ' \\n\\n Signature -> ' , drop = True ) log . info ( 'message: ' + message ) signature = p . recvuntil ( ' \\n ' , drop = True ) log . info ( 'signature: ' + signature ) signature = int ( signature , 16 ) h = SHA . new ( message ) m = PKCS1_pad ( h . hexdigest ()) print m , signature plist = [] for i in range ( 2 , 1000 ): if is_prime ( i ): plist . append ( i ) while True : try : n , factors = gen_smooth_num ( plist , signature ) e = pohlig_hellman ( signature , m , n , factors ) except Exception as e : continue else : break print n , e print m print gmpy2 . powmod ( signature , e , n ) p . sendlineafter ( 'Enter n:' , str ( n )) p . sendlineafter ( 'Enter e:' , str ( e )) p . interactive () main () There are two points to note Since both g and y in g^x=y g^x=y are given, the newly found n, not necessarily the power of g, will contain y, so the solution may fail, so it needs to be solved multiple times. . Although n.bit_length() &lt;= 1025 in the source code, in fact, when n satisfies the condition of not less than signature, the following conditions must be met (pycrypto source code) modBits = Crypto . Util . number . size ( self . _key . n ) k = ceil_div ( modBits , 8 ) # Convert from bits to bytes # Step 1 if len ( S ) ! = k : return 0 So we'd better set n to 1024 bits.","title":"2018 Backdoor Awesome mix2"},{"location":"crypto/ctf-wiki/streamcipher/intro-zh/","text":"EN | ZH \u6d41\u5bc6\u7801 \u00b6 \u6d41\u5bc6\u7801\u4e00\u822c\u9010\u5b57\u8282\u6216\u8005\u9010\u6bd4\u7279\u5904\u7406\u4fe1\u606f\u3002\u4e00\u822c\u6765\u8bf4 \u6d41\u5bc6\u7801\u7684\u5bc6\u94a5\u957f\u5ea6\u4f1a\u4e0e\u660e\u6587\u7684\u957f\u5ea6\u76f8\u540c\u3002 \u6d41\u5bc6\u7801\u7684\u5bc6\u94a5\u6d3e\u751f\u81ea\u4e00\u4e2a\u8f83\u77ed\u7684\u5bc6\u94a5\uff0c\u6d3e\u751f\u7b97\u6cd5\u901a\u5e38\u4e3a\u4e00\u4e2a\u4f2a\u968f\u673a\u6570\u751f\u6210\u7b97\u6cd5\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6d41\u52a0\u5bc6\u76ee\u524d\u6765\u8bf4\u90fd\u662f\u5bf9\u79f0\u52a0\u5bc6\u3002 \u4f2a\u968f\u673a\u6570\u751f\u6210\u7b97\u6cd5\u751f\u6210\u7684\u5e8f\u5217\u7684\u968f\u673a\u6027\u8d8a\u5f3a\uff0c\u660e\u6587\u4e2d\u7684\u7edf\u8ba1\u7279\u5f81\u88ab\u8986\u76d6\u7684\u66f4\u597d\u3002 \u6d41\u5bc6\u7801\u52a0\u89e3\u5bc6\u975e\u5e38\u7b80\u5355\uff0c\u5728\u5df2\u77e5\u660e\u6587\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u975e\u5e38\u5bb9\u6613\u5730\u83b7\u53d6\u5bc6\u94a5\u6d41\u3002 \u6d41\u5bc6\u7801\u7684\u5173\u952e\u5728\u4e8e\u8bbe\u8ba1\u597d\u7684\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u7684\u57fa\u672c\u6784\u9020\u6a21\u5757\u4e3a\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u3002\u5f53\u7136\uff0c\u4e5f\u6709\u4e00\u4e9b\u7279\u6b8a\u8bbe\u8ba1\u7684\u6d41\u5bc6\u7801\uff0c\u6bd4\u5982 RC4\u3002","title":"Intro zh"},{"location":"crypto/ctf-wiki/streamcipher/intro-zh/#_1","text":"\u6d41\u5bc6\u7801\u4e00\u822c\u9010\u5b57\u8282\u6216\u8005\u9010\u6bd4\u7279\u5904\u7406\u4fe1\u606f\u3002\u4e00\u822c\u6765\u8bf4 \u6d41\u5bc6\u7801\u7684\u5bc6\u94a5\u957f\u5ea6\u4f1a\u4e0e\u660e\u6587\u7684\u957f\u5ea6\u76f8\u540c\u3002 \u6d41\u5bc6\u7801\u7684\u5bc6\u94a5\u6d3e\u751f\u81ea\u4e00\u4e2a\u8f83\u77ed\u7684\u5bc6\u94a5\uff0c\u6d3e\u751f\u7b97\u6cd5\u901a\u5e38\u4e3a\u4e00\u4e2a\u4f2a\u968f\u673a\u6570\u751f\u6210\u7b97\u6cd5\u3002 \u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6d41\u52a0\u5bc6\u76ee\u524d\u6765\u8bf4\u90fd\u662f\u5bf9\u79f0\u52a0\u5bc6\u3002 \u4f2a\u968f\u673a\u6570\u751f\u6210\u7b97\u6cd5\u751f\u6210\u7684\u5e8f\u5217\u7684\u968f\u673a\u6027\u8d8a\u5f3a\uff0c\u660e\u6587\u4e2d\u7684\u7edf\u8ba1\u7279\u5f81\u88ab\u8986\u76d6\u7684\u66f4\u597d\u3002 \u6d41\u5bc6\u7801\u52a0\u89e3\u5bc6\u975e\u5e38\u7b80\u5355\uff0c\u5728\u5df2\u77e5\u660e\u6587\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u975e\u5e38\u5bb9\u6613\u5730\u83b7\u53d6\u5bc6\u94a5\u6d41\u3002 \u6d41\u5bc6\u7801\u7684\u5173\u952e\u5728\u4e8e\u8bbe\u8ba1\u597d\u7684\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u7684\u57fa\u672c\u6784\u9020\u6a21\u5757\u4e3a\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u3002\u5f53\u7136\uff0c\u4e5f\u6709\u4e00\u4e9b\u7279\u6b8a\u8bbe\u8ba1\u7684\u6d41\u5bc6\u7801\uff0c\u6bd4\u5982 RC4\u3002","title":"\u6d41\u5bc6\u7801"},{"location":"crypto/ctf-wiki/streamcipher/intro/","text":"EN | ZH \u6d41\u5bc6\u7801 \u00b6 Stream ciphers typically process information byte by byte or bit by bit. Generally speaking The key length of the stream cipher will be the same as the length of the plaintext. The key of the stream cipher is derived from a shorter key, and the derived algorithm is usually a pseudo-random number generation algorithm. It should be noted that stream encryption is currently symmetric encryption. The more random the sequence generated by the pseudo-random number generation algorithm, the better the statistical features in the plaintext are covered. Stream cipher encryption and decryption is very simple, and in the case of known plaintext, the key stream can be obtained very easily. The key to stream ciphers is the well-designed pseudo-random number generator. In general, the basic building block of a pseudo-random number generator is a feedback shift register. Of course, there are also some specially designed stream ciphers, such as RC4.","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/streamcipher/intro/#_1","text":"Stream ciphers typically process information byte by byte or bit by bit. Generally speaking The key length of the stream cipher will be the same as the length of the plaintext. The key of the stream cipher is derived from a shorter key, and the derived algorithm is usually a pseudo-random number generation algorithm. It should be noted that stream encryption is currently symmetric encryption. The more random the sequence generated by the pseudo-random number generation algorithm, the better the statistical features in the plaintext are covered. Stream cipher encryption and decryption is very simple, and in the case of known plaintext, the key stream can be obtained very easily. The key to stream ciphers is the well-designed pseudo-random number generator. In general, the basic building block of a pseudo-random number generator is a feedback shift register. Of course, there are also some specially designed stream ciphers, such as RC4.","title":"\u6d41\u5bc6\u7801"},{"location":"crypto/ctf-wiki/streamcipher/fsr/intro-zh/","text":"EN | ZH \u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668 \u00b6 \u4e00\u822c\u7684\uff0c\u4e00\u4e2a n \u7ea7\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u5982\u4e0b\u56fe\u6240\u793a \u5176\u4e2d a_0 a_0 \uff0c a_1 a_1 \uff0c\u2026\uff0c a_{n-1} a_{n-1} \uff0c\u4e3a\u521d\u6001\u3002 F \u4e3a\u53cd\u9988\u51fd\u6570\u6216\u8005\u53cd\u9988\u903b\u8f91\u3002\u5982\u679c F \u4e3a\u7ebf\u6027\u51fd\u6570\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u5176\u4e3a\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff08LFSR\uff09\uff0c\u5426\u5219\u6211\u4eec\u79f0\u5176\u4e3a\u975e\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff08NFSR\uff09\u3002 a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) \u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u90fd\u4f1a\u5b9a\u4e49\u5728\u67d0\u4e2a\u6709\u9650\u57df\u4e0a\uff0c\u4ece\u800c\u907f\u514d\u6570\u5b57\u592a\u5927\u548c\u592a\u5c0f\u7684\u95ee\u9898\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u89c6\u4e3a\u540c\u4e00\u4e2a\u7a7a\u95f4\u4e2d\u7684\u53d8\u6362\uff0c\u5373 (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) . \u5bf9\u4e8e\u4e00\u4e2a\u5e8f\u5217\u6765\u8bf4\uff0c\u6211\u4eec\u4e00\u822c\u5b9a\u4e49\u5176\u751f\u6210\u51fd\u6570\u4e3a\u5176\u5e8f\u5217\u5bf9\u5e94\u7684\u5e42\u7ea7\u6570\u7684\u548c\u3002","title":"Intro zh"},{"location":"crypto/ctf-wiki/streamcipher/fsr/intro-zh/#_1","text":"\u4e00\u822c\u7684\uff0c\u4e00\u4e2a n \u7ea7\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u5982\u4e0b\u56fe\u6240\u793a \u5176\u4e2d a_0 a_0 \uff0c a_1 a_1 \uff0c\u2026\uff0c a_{n-1} a_{n-1} \uff0c\u4e3a\u521d\u6001\u3002 F \u4e3a\u53cd\u9988\u51fd\u6570\u6216\u8005\u53cd\u9988\u903b\u8f91\u3002\u5982\u679c F \u4e3a\u7ebf\u6027\u51fd\u6570\uff0c\u90a3\u4e48\u6211\u4eec\u79f0\u5176\u4e3a\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff08LFSR\uff09\uff0c\u5426\u5219\u6211\u4eec\u79f0\u5176\u4e3a\u975e\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff08NFSR\uff09\u3002 a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) \u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u90fd\u4f1a\u5b9a\u4e49\u5728\u67d0\u4e2a\u6709\u9650\u57df\u4e0a\uff0c\u4ece\u800c\u907f\u514d\u6570\u5b57\u592a\u5927\u548c\u592a\u5c0f\u7684\u95ee\u9898\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u89c6\u4e3a\u540c\u4e00\u4e2a\u7a7a\u95f4\u4e2d\u7684\u53d8\u6362\uff0c\u5373 (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) . \u5bf9\u4e8e\u4e00\u4e2a\u5e8f\u5217\u6765\u8bf4\uff0c\u6211\u4eec\u4e00\u822c\u5b9a\u4e49\u5176\u751f\u6210\u51fd\u6570\u4e3a\u5176\u5e8f\u5217\u5bf9\u5e94\u7684\u5e42\u7ea7\u6570\u7684\u548c\u3002","title":"\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668"},{"location":"crypto/ctf-wiki/streamcipher/fsr/intro/","text":"EN | ZH Feedback shift register \u00b6 In general, an n-level feedback shift register is shown below among them a_0 a_0 , a_1 a_1 ,..., a_{n-1} a_{n-1} , as initial. F is the feedback function or feedback logic. If F is a linear function, then we call it a linear feedback shift register (LFSR), otherwise we call it a nonlinear feedback shift register (NFSR). a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) \u3002 In general, the feedback shift register is defined on a finite field to avoid the problem of too large and too small numbers. So we can think of it as a transformation in the same space, ie (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) . For a sequence, we generally define the sum of the power series whose generator function corresponds to its sequence.","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/streamcipher/fsr/intro/#feedback-shift-register","text":"In general, an n-level feedback shift register is shown below among them a_0 a_0 , a_1 a_1 ,..., a_{n-1} a_{n-1} , as initial. F is the feedback function or feedback logic. If F is a linear function, then we call it a linear feedback shift register (LFSR), otherwise we call it a nonlinear feedback shift register (NFSR). a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) a_{i+n}=F(a_i,a_{i+1},...,a_{i+n-1}) \u3002 In general, the feedback shift register is defined on a finite field to avoid the problem of too large and too small numbers. So we can think of it as a transformation in the same space, ie (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) (a_i,a_{i+1},...,a_{i+n-1}) \\rightarrow (a_{i+1},...,a_{i+n-1},a_{i+n}) . For a sequence, we generally define the sum of the power series whose generator function corresponds to its sequence.","title":"Feedback shift register"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/","text":"EN | ZH \u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668 - LFSR \u00b6 \u4ecb\u7ecd \u00b6 \u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u7684\u53cd\u9988\u51fd\u6570\u4e00\u822c\u5982\u4e0b a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} \u5176\u4e2d\uff0c c_j c_j \u5747\u5728\u67d0\u4e2a\u6709\u9650\u57df F_q F_q \u4e2d\u3002 \u65e2\u7136\u7ebf\u6027\u7a7a\u95f4\u662f\u4e00\u4e2a\u7ebf\u6027\u53d8\u6362\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5\u8fd9\u4e2a\u7ebf\u6027\u53d8\u6362\u4e3a \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] \u8fdb\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u6c42\u5f97\u5176\u7279\u5f81\u591a\u9879\u5f0f\u4e3a f(x)=x^n-\\sum\\limits_{i=1}^{n}c_ix^{n-i} f(x)=x^n-\\sum\\limits_{i=1}^{n}c_ix^{n-i} \u540c\u65f6\uff0c\u6211\u4eec\u5b9a\u4e49\u5176\u4e92\u53cd\u591a\u9879\u5f0f\u4e3a \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} \u6211\u4eec\u4e5f\u79f0\u4e92\u53cd\u591a\u9879\u5f0f\u4e3a\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u7684\u8054\u7ed3\u591a\u9879\u5f0f\u3002 \u8fd9\u91cc\u6709\u4e00\u4e9b\u5b9a\u7406\u9700\u8981\u6211\u4eec\u8bb0\u4e00\u4e0b\uff0c\u611f\u5174\u8da3\u7684\u53ef\u4ee5\u81ea\u884c\u63a8\u5bfc\u3002 \u7279\u5f81\u591a\u9879\u5f0f\u4e0e\u751f\u6210\u51fd\u6570 \u00b6 \u5df2\u77e5\u67d0\u4e2a n \u7ea7\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u7684\u7279\u5f81\u591a\u9879\u5f0f\uff0c\u90a3\u4e48\u8be5\u5e8f\u5217\u5bf9\u5e94\u7684\u751f\u6210\u51fd\u6570\u4e3a A(x)=\\frac{p(x)}{\\overline f(x)} A(x)=\\frac{p(x)}{\\overline f(x)} \u5176\u4e2d\uff0c p(x)=\\sum\\limits_{i=1}^{n}(c_{n-i}x^{n-i}\\sum\\limits_{j=1}^{i}a_jx^{j-1}) p(x)=\\sum\\limits_{i=1}^{n}(c_{n-i}x^{n-i}\\sum\\limits_{j=1}^{i}a_jx^{j-1}) \u3002\u53ef\u4ee5\u770b\u51fa p(x) \u5b8c\u5168\u7531\u521d\u59cb\u72b6\u6001\u548c\u53cd\u9988\u51fd\u6570\u7684\u7cfb\u6570\u51b3\u5b9a\u3002 \u5e8f\u5217\u5468\u671f\u4e0e\u751f\u6210\u51fd\u6570 \u00b6 \u5e8f\u5217\u7684\u7684\u5468\u671f\u4e3a\u5176\u751f\u6210\u51fd\u6570\u7684\u65e2\u7ea6\u771f\u5206\u5f0f\u7684\u5206\u6bcd\u7684\u5468\u671f\u3002 \u5bf9\u4e8e n \u7ea7\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff0c\u6700\u957f\u5468\u671f\u4e3a 2^{n}-1 2^{n}-1 \uff08\u6392\u9664\u5168\u96f6\uff09\u3002\u8fbe\u5230\u6700\u957f\u5468\u671f\u7684\u5e8f\u5217\u4e00\u822c\u79f0\u4e3a m \u5e8f\u5217\u3002 \u7279\u6b8a\u6027\u8d28 \u00b6 \u5c06\u4e24\u4e2a\u5e8f\u5217\u7d2f\u52a0\u5f97\u5230\u65b0\u7684\u5e8f\u5217\u7684\u5468\u671f\u4e3a\u8fd9\u4e24\u4e2a\u5e8f\u5217\u7684\u5468\u671f\u7684\u548c\u3002 \u5e8f\u5217\u662f n \u7ea7 m \u5e8f\u5217\uff0c\u5f53\u4e14\u4ec5\u5f53\u5e8f\u5217\u7684\u6781\u5c0f\u591a\u9879\u5f0f\u662f n \u6b21\u672c\u539f\u591a\u9879\u5f0f\u3002 B-M \u7b97\u6cd5 \u00b6 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u4e24\u79cd\u89d2\u5ea6\u6765\u8003\u8651 LFSR \u5bc6\u94a5\u751f\u6210\u89d2\u5ea6\uff0c\u4e00\u822c\u6211\u4eec\u5e0c\u671b\u4f7f\u7528\u7ea7\u6570\u5c3d\u53ef\u80fd\u4f4e\u7684 LFSR \u6765\u751f\u6210\u5468\u671f\u5927\uff0c\u968f\u673a\u6027\u597d\u7684\u5e8f\u5217\u3002 \u5bc6\u7801\u5206\u6790\u89d2\u5ea6\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u5e8f\u5217 a\uff0c\u5982\u4f55\u6784\u9020\u4e00\u4e2a\u7ea7\u6570\u5c3d\u53ef\u80fd\u5c0f\u7684 LFSR \u6765\u751f\u6210\u5b83\u3002\u5176\u5b9e\u8fd9\u5c31\u662f B-M \u7b97\u6cd5\u7684\u6765\u6e90\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u5e8f\u5217\u7684\u7ebf\u6027\u590d\u6742\u5ea6\u5982\u4e0b \u82e5 s \u4e3a\u4e00\u4e2a\u5168\u96f6\u5e8f\u5217\uff0c\u5219\u7ebf\u6027\u590d\u6742\u5ea6\u4e3a0\u3002 \u82e5\u6ca1\u6709 LFSR \u80fd\u751f\u6210 s\uff0c\u5219\u7ebf\u6027\u590d\u6742\u5ea6\u4e3a\u65e0\u7a77\u3002 \u5426\u5219\uff0cs \u7684\u7ebf\u6027\u590d\u6742\u5ea6\u4e3a\u751f\u6210 L(s) \u7684\u6700\u5c0f\u7ea7\u7684 LFSR\u3002 BM \u7b97\u6cd5\u7684\u8981\u6c42\u6211\u4eec\u9700\u8981\u77e5\u9053\u957f\u5ea6\u4e3a 2n \u7684\u5e8f\u5217\u3002\u5176\u590d\u6742\u5ea6 \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2) \u6b21\u6bd4\u7279\u64cd\u4f5c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n) \u6bd4\u7279\u3002 \u5173\u4e8e BM \u7b97\u6cd5\u7684\u7ec6\u8282\uff0c\u540e\u7eed\u6dfb\u52a0\uff0c\u76ee\u524d\u5904\u4e8e\u5b66\u4e60\u8fc7\u7a0b\u4e2d\u3002 \u4f46\u662f\u5176\u5b9e\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86\u957f\u5ea6\u4e3a 2n \u7684\u5e8f\u5217\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e00\u79cd\u6bd4\u8f83\u7b28\u7684\u65b9\u6cd5\u6765\u83b7\u53d6\u539f\u5148\u7684\u5e8f\u5217\u3002\u4e0d\u59a8\u5047\u8bbe\u5df2\u77e5\u7684\u5e8f\u5217\u4e3a a_1,...,a_{2n} a_1,...,a_{2n} \uff0c\u6211\u4eec\u53ef\u4ee5\u4ee4 S_1=(a_1,...,a_n) S_1=(a_1,...,a_n) S_2=(a_2,...,a_{n+1}) S_2=(a_2,...,a_{n+1}) .... S_{n+1}=(a_{n+1},...,a_{2n}) S_{n+1}=(a_{n+1},...,a_{2n}) \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6784\u9020\u77e9\u9635 X=(S_1,...,S_n) X=(S_1,...,S_n) \uff0c\u90a3\u4e48 S_{n+1}=(c_n,...,c_1)X S_{n+1}=(c_n,...,c_1)X \u6240\u4ee5 (c_n,...,c_1)=S_{n+1}X^{-1} (c_n,...,c_1)=S_{n+1}X^{-1} \u8fdb\u800c\u6211\u4eec\u4e5f\u5c31\u77e5\u9053\u4e86 LFSR \u7684\u53cd\u9988\u8868\u8fbe\u5f0f\uff0c\u8fdb\u800c\u6211\u4eec\u5c31\u53ef\u4ee5\u63a8\u51fa\u521d\u59cb\u5316\u79cd\u5b50\u3002 2018 \u5f3a\u7f51\u676f streamgame1 \u00b6 \u7b80\u5355\u770b\u4e00\u4e0b\u9898\u76ee from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 25 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) R = int ( flag [ 5 : - 1 ], 2 ) mask = 0b1010011000100011100 f = open ( \"key\" , \"ab\" ) for i in range ( 12 ): tmp = 0 for j in range ( 8 ): ( R , out ) = lfsr ( R , mask ) tmp = ( tmp << 1 ) ^ out f . write ( chr ( tmp )) f . close () \u53ef\u4ee5\u53d1\u73b0\uff0cflag \u7684\u957f\u5ea6\u4e3a25-5-1=19\uff0c\u6240\u4ee5\u53ef\u4ee5\u66b4\u529b\u679a\u4e3e\u3002\u7ed3\u679c \u279c 2018 -\u5f3a\u7f51\u676f-streamgame1 git: ( master ) \u2717 python exp.py 12 0b1110101100001101011 \u56e0\u6b64 flag \u4e3a flag{1110101100001101011}\u3002 2018 CISCN \u521d\u8d5b oldstreamgame \u00b6 \u7b80\u5355\u770b\u4e00\u4e0b\u9898\u76ee flag = \"flag{xxxxxxxxxxxxxxxx}\" assert flag.startswith ( \"flag{\" ) assert flag.endswith ( \"}\" ) assert len ( flag )== 14 def lfsr ( R,mask ) : output = ( R << 1) & 0xffffffff i=(R&mask)&0xffffffff lastbit=0 while i!=0: lastbit^=(i&1 ) i = i>>1 output^ = lastbit return ( output,lastbit ) R = int ( flag [ 5 :-1 ] ,16 ) mask = 0b10100100000010000000100010010100 f = open ( \"key\" , \"w\" ) for i in range ( 100 ) : tmp = 0 for j in range ( 8 ) : ( R,out )= lfsr ( R,mask ) tmp =( tmp << 1 ) ^out f.write ( chr ( tmp )) f.close () \u7a0b\u5e8f\u5f88\u7b80\u5355\uff0c\u4ecd\u7136\u662f\u4e00\u4e2a LFSR\uff0c\u4f46\u662f\u521d\u6001\u662f 32 \u6bd4\u7279\u4f4d\uff0c\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u9009\u62e9\u7206\u7834\uff0c\u4f46\u662f\u8fd9\u91cc\u4e0d\u9009\u62e9\u7206\u7834\u3002 \u8fd9\u91cc\u7ed9\u51fa\u4e24\u79cd\u505a\u6cd5\u3002 \u7b2c\u4e00\u79cd\u505a\u6cd5\uff0c\u7a0b\u5e8f\u8f93\u51fa\u7684\u7b2c 32 \u4e2a\u6bd4\u7279\u662f\u7531\u7a0b\u5e8f\u8f93\u51fa\u7684\u524d 31 \u4e2a\u6bd4\u7279\u548c\u521d\u59cb\u79cd\u5b50\u7684\u7b2c 1 \u4e2a\u6bd4\u7279\u6765\u51b3\u5b9a\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\u521d\u59cb\u79cd\u5b50\u7684\u7b2c\u4e00\u4e2a\u6bd4\u7279\uff0c\u8fdb\u800c\u53ef\u4ee5\u77e5\u9053\u521d\u59cb\u79cd\u5b50\u7684\u7b2c 2 \u4e2a\u6bd4\u7279\uff0c\u4f9d\u6b21\u7c7b\u63a8\u3002\u4ee3\u7801\u5982\u4e0b mask = 0b10100100000010000000100010010100 b = '' N = 32 with open ( 'key' , 'rb' ) as f : b = f . read () key = '' for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): key += str ( t >> j & 1 ) idx = 0 ans = \"\" key = key [ 31 ] + key [: 32 ] while idx < 32 : tmp = 0 for i in range ( 32 ): if mask >> i & 1 : tmp ^= int ( key [ 31 - i ]) ans = str ( tmp ) + ans idx += 1 key = key [ 31 ] + str ( tmp ) + key [ 1 : 31 ] num = int ( ans , 2 ) print hex ( num ) \u8fd0\u884c \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 python exp1.py 0x926201d7 \u7b2c\u4e8c\u79cd\u505a\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4e00\u4e0b\u77e9\u9635\u8f6c\u6362\u7684\u8fc7\u7a0b\uff0c\u5982\u679c\u8fdb\u884c\u4e86 32 \u6b21\u7ebf\u6027\u53d8\u6362\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5f97\u5230\u8f93\u51fa\u6d41\u524d 32 \u4e2a\u6bd4\u7279\u3002\u800c\u5176\u5b9e\uff0c\u6211\u4eec\u53ea\u9700\u8981\u524d 32 \u4e2a\u6bd4\u7279\u5c31\u53ef\u4ee5\u6062\u590d\u521d\u59cb\u72b6\u6001\u4e86\u3002 mask = 0b10100100000010000000100010010100 N = 32 F = GF ( 2 ) b = '' with open ( 'key' , 'rb' ) as f : b = f . read () R = [ vector ( F , N ) for i in range ( N )] for i in range ( N ): R [ i ][ N - 1 ] = mask >> ( 31 - i ) & 1 for i in range ( N - 1 ): R [ i + 1 ][ i ] = 1 M = Matrix ( F , R ) M = M ^ N vec = vector ( F , N ) row = 0 for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): vec [ row ] = t >> j & 1 row += 1 print rank ( M ) num = int ( '' . join ( map ( str , list ( M . solve_left ( vec )))), 2 ) print hex ( num ) \u8fd0\u884c\u811a\u672c \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 sage exp.sage 32 0x926201d7 \u4ece\u800c flag \u4e3a flag{926201d7}\u3002 \u8fd8\u6709\u4e00\u79cd\u505a\u6cd5\u662f TokyoWesterns \u7684\uff0c\u53ef\u4ee5\u53c2\u8003\u5bf9\u5e94\u7684\u6587\u4ef6\u5939\u7684\u6587\u4ef6\u3002 \u9898\u76ee \u00b6 \u53c2\u8003\u6587\u732e \u00b6 \u5bc6\u7801\u5b66\u8bb2\u4e49\uff0c\u674e\u8d85\uff0c\u5c48\u9f99\u6c5f\u7f16\u8457","title":"Lfsr zh"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#-lfsr","text":"","title":"\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668 - LFSR"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#_1","text":"\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u7684\u53cd\u9988\u51fd\u6570\u4e00\u822c\u5982\u4e0b a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} \u5176\u4e2d\uff0c c_j c_j \u5747\u5728\u67d0\u4e2a\u6709\u9650\u57df F_q F_q \u4e2d\u3002 \u65e2\u7136\u7ebf\u6027\u7a7a\u95f4\u662f\u4e00\u4e2a\u7ebf\u6027\u53d8\u6362\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5\u8fd9\u4e2a\u7ebf\u6027\u53d8\u6362\u4e3a \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] \u8fdb\u800c\uff0c\u6211\u4eec\u53ef\u4ee5\u6c42\u5f97\u5176\u7279\u5f81\u591a\u9879\u5f0f\u4e3a f(x)=x^n-\\sum\\limits_{i=1}^{n}c_ix^{n-i} f(x)=x^n-\\sum\\limits_{i=1}^{n}c_ix^{n-i} \u540c\u65f6\uff0c\u6211\u4eec\u5b9a\u4e49\u5176\u4e92\u53cd\u591a\u9879\u5f0f\u4e3a \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} \u6211\u4eec\u4e5f\u79f0\u4e92\u53cd\u591a\u9879\u5f0f\u4e3a\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u7684\u8054\u7ed3\u591a\u9879\u5f0f\u3002 \u8fd9\u91cc\u6709\u4e00\u4e9b\u5b9a\u7406\u9700\u8981\u6211\u4eec\u8bb0\u4e00\u4e0b\uff0c\u611f\u5174\u8da3\u7684\u53ef\u4ee5\u81ea\u884c\u63a8\u5bfc\u3002","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#_2","text":"\u5df2\u77e5\u67d0\u4e2a n \u7ea7\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\u7684\u7279\u5f81\u591a\u9879\u5f0f\uff0c\u90a3\u4e48\u8be5\u5e8f\u5217\u5bf9\u5e94\u7684\u751f\u6210\u51fd\u6570\u4e3a A(x)=\\frac{p(x)}{\\overline f(x)} A(x)=\\frac{p(x)}{\\overline f(x)} \u5176\u4e2d\uff0c p(x)=\\sum\\limits_{i=1}^{n}(c_{n-i}x^{n-i}\\sum\\limits_{j=1}^{i}a_jx^{j-1}) p(x)=\\sum\\limits_{i=1}^{n}(c_{n-i}x^{n-i}\\sum\\limits_{j=1}^{i}a_jx^{j-1}) \u3002\u53ef\u4ee5\u770b\u51fa p(x) \u5b8c\u5168\u7531\u521d\u59cb\u72b6\u6001\u548c\u53cd\u9988\u51fd\u6570\u7684\u7cfb\u6570\u51b3\u5b9a\u3002","title":"\u7279\u5f81\u591a\u9879\u5f0f\u4e0e\u751f\u6210\u51fd\u6570"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#_3","text":"\u5e8f\u5217\u7684\u7684\u5468\u671f\u4e3a\u5176\u751f\u6210\u51fd\u6570\u7684\u65e2\u7ea6\u771f\u5206\u5f0f\u7684\u5206\u6bcd\u7684\u5468\u671f\u3002 \u5bf9\u4e8e n \u7ea7\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff0c\u6700\u957f\u5468\u671f\u4e3a 2^{n}-1 2^{n}-1 \uff08\u6392\u9664\u5168\u96f6\uff09\u3002\u8fbe\u5230\u6700\u957f\u5468\u671f\u7684\u5e8f\u5217\u4e00\u822c\u79f0\u4e3a m \u5e8f\u5217\u3002","title":"\u5e8f\u5217\u5468\u671f\u4e0e\u751f\u6210\u51fd\u6570"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#_4","text":"\u5c06\u4e24\u4e2a\u5e8f\u5217\u7d2f\u52a0\u5f97\u5230\u65b0\u7684\u5e8f\u5217\u7684\u5468\u671f\u4e3a\u8fd9\u4e24\u4e2a\u5e8f\u5217\u7684\u5468\u671f\u7684\u548c\u3002 \u5e8f\u5217\u662f n \u7ea7 m \u5e8f\u5217\uff0c\u5f53\u4e14\u4ec5\u5f53\u5e8f\u5217\u7684\u6781\u5c0f\u591a\u9879\u5f0f\u662f n \u6b21\u672c\u539f\u591a\u9879\u5f0f\u3002","title":"\u7279\u6b8a\u6027\u8d28"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#b-m","text":"\u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u4ece\u4e24\u79cd\u89d2\u5ea6\u6765\u8003\u8651 LFSR \u5bc6\u94a5\u751f\u6210\u89d2\u5ea6\uff0c\u4e00\u822c\u6211\u4eec\u5e0c\u671b\u4f7f\u7528\u7ea7\u6570\u5c3d\u53ef\u80fd\u4f4e\u7684 LFSR \u6765\u751f\u6210\u5468\u671f\u5927\uff0c\u968f\u673a\u6027\u597d\u7684\u5e8f\u5217\u3002 \u5bc6\u7801\u5206\u6790\u89d2\u5ea6\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3a n \u7684\u5e8f\u5217 a\uff0c\u5982\u4f55\u6784\u9020\u4e00\u4e2a\u7ea7\u6570\u5c3d\u53ef\u80fd\u5c0f\u7684 LFSR \u6765\u751f\u6210\u5b83\u3002\u5176\u5b9e\u8fd9\u5c31\u662f B-M \u7b97\u6cd5\u7684\u6765\u6e90\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u5e8f\u5217\u7684\u7ebf\u6027\u590d\u6742\u5ea6\u5982\u4e0b \u82e5 s \u4e3a\u4e00\u4e2a\u5168\u96f6\u5e8f\u5217\uff0c\u5219\u7ebf\u6027\u590d\u6742\u5ea6\u4e3a0\u3002 \u82e5\u6ca1\u6709 LFSR \u80fd\u751f\u6210 s\uff0c\u5219\u7ebf\u6027\u590d\u6742\u5ea6\u4e3a\u65e0\u7a77\u3002 \u5426\u5219\uff0cs \u7684\u7ebf\u6027\u590d\u6742\u5ea6\u4e3a\u751f\u6210 L(s) \u7684\u6700\u5c0f\u7ea7\u7684 LFSR\u3002 BM \u7b97\u6cd5\u7684\u8981\u6c42\u6211\u4eec\u9700\u8981\u77e5\u9053\u957f\u5ea6\u4e3a 2n \u7684\u5e8f\u5217\u3002\u5176\u590d\u6742\u5ea6 \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^2) \u6b21\u6bd4\u7279\u64cd\u4f5c \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n) \u6bd4\u7279\u3002 \u5173\u4e8e BM \u7b97\u6cd5\u7684\u7ec6\u8282\uff0c\u540e\u7eed\u6dfb\u52a0\uff0c\u76ee\u524d\u5904\u4e8e\u5b66\u4e60\u8fc7\u7a0b\u4e2d\u3002 \u4f46\u662f\u5176\u5b9e\u5982\u679c\u6211\u4eec\u77e5\u9053\u4e86\u957f\u5ea6\u4e3a 2n \u7684\u5e8f\u5217\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e00\u79cd\u6bd4\u8f83\u7b28\u7684\u65b9\u6cd5\u6765\u83b7\u53d6\u539f\u5148\u7684\u5e8f\u5217\u3002\u4e0d\u59a8\u5047\u8bbe\u5df2\u77e5\u7684\u5e8f\u5217\u4e3a a_1,...,a_{2n} a_1,...,a_{2n} \uff0c\u6211\u4eec\u53ef\u4ee5\u4ee4 S_1=(a_1,...,a_n) S_1=(a_1,...,a_n) S_2=(a_2,...,a_{n+1}) S_2=(a_2,...,a_{n+1}) .... S_{n+1}=(a_{n+1},...,a_{2n}) S_{n+1}=(a_{n+1},...,a_{2n}) \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6784\u9020\u77e9\u9635 X=(S_1,...,S_n) X=(S_1,...,S_n) \uff0c\u90a3\u4e48 S_{n+1}=(c_n,...,c_1)X S_{n+1}=(c_n,...,c_1)X \u6240\u4ee5 (c_n,...,c_1)=S_{n+1}X^{-1} (c_n,...,c_1)=S_{n+1}X^{-1} \u8fdb\u800c\u6211\u4eec\u4e5f\u5c31\u77e5\u9053\u4e86 LFSR \u7684\u53cd\u9988\u8868\u8fbe\u5f0f\uff0c\u8fdb\u800c\u6211\u4eec\u5c31\u53ef\u4ee5\u63a8\u51fa\u521d\u59cb\u5316\u79cd\u5b50\u3002","title":"B-M \u7b97\u6cd5"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#2018-streamgame1","text":"\u7b80\u5355\u770b\u4e00\u4e0b\u9898\u76ee from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 25 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) R = int ( flag [ 5 : - 1 ], 2 ) mask = 0b1010011000100011100 f = open ( \"key\" , \"ab\" ) for i in range ( 12 ): tmp = 0 for j in range ( 8 ): ( R , out ) = lfsr ( R , mask ) tmp = ( tmp << 1 ) ^ out f . write ( chr ( tmp )) f . close () \u53ef\u4ee5\u53d1\u73b0\uff0cflag \u7684\u957f\u5ea6\u4e3a25-5-1=19\uff0c\u6240\u4ee5\u53ef\u4ee5\u66b4\u529b\u679a\u4e3e\u3002\u7ed3\u679c \u279c 2018 -\u5f3a\u7f51\u676f-streamgame1 git: ( master ) \u2717 python exp.py 12 0b1110101100001101011 \u56e0\u6b64 flag \u4e3a flag{1110101100001101011}\u3002","title":"2018 \u5f3a\u7f51\u676f streamgame1"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#2018-ciscn-oldstreamgame","text":"\u7b80\u5355\u770b\u4e00\u4e0b\u9898\u76ee flag = \"flag{xxxxxxxxxxxxxxxx}\" assert flag.startswith ( \"flag{\" ) assert flag.endswith ( \"}\" ) assert len ( flag )== 14 def lfsr ( R,mask ) : output = ( R << 1) & 0xffffffff i=(R&mask)&0xffffffff lastbit=0 while i!=0: lastbit^=(i&1 ) i = i>>1 output^ = lastbit return ( output,lastbit ) R = int ( flag [ 5 :-1 ] ,16 ) mask = 0b10100100000010000000100010010100 f = open ( \"key\" , \"w\" ) for i in range ( 100 ) : tmp = 0 for j in range ( 8 ) : ( R,out )= lfsr ( R,mask ) tmp =( tmp << 1 ) ^out f.write ( chr ( tmp )) f.close () \u7a0b\u5e8f\u5f88\u7b80\u5355\uff0c\u4ecd\u7136\u662f\u4e00\u4e2a LFSR\uff0c\u4f46\u662f\u521d\u6001\u662f 32 \u6bd4\u7279\u4f4d\uff0c\u5f53\u7136\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u9009\u62e9\u7206\u7834\uff0c\u4f46\u662f\u8fd9\u91cc\u4e0d\u9009\u62e9\u7206\u7834\u3002 \u8fd9\u91cc\u7ed9\u51fa\u4e24\u79cd\u505a\u6cd5\u3002 \u7b2c\u4e00\u79cd\u505a\u6cd5\uff0c\u7a0b\u5e8f\u8f93\u51fa\u7684\u7b2c 32 \u4e2a\u6bd4\u7279\u662f\u7531\u7a0b\u5e8f\u8f93\u51fa\u7684\u524d 31 \u4e2a\u6bd4\u7279\u548c\u521d\u59cb\u79cd\u5b50\u7684\u7b2c 1 \u4e2a\u6bd4\u7279\u6765\u51b3\u5b9a\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\u521d\u59cb\u79cd\u5b50\u7684\u7b2c\u4e00\u4e2a\u6bd4\u7279\uff0c\u8fdb\u800c\u53ef\u4ee5\u77e5\u9053\u521d\u59cb\u79cd\u5b50\u7684\u7b2c 2 \u4e2a\u6bd4\u7279\uff0c\u4f9d\u6b21\u7c7b\u63a8\u3002\u4ee3\u7801\u5982\u4e0b mask = 0b10100100000010000000100010010100 b = '' N = 32 with open ( 'key' , 'rb' ) as f : b = f . read () key = '' for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): key += str ( t >> j & 1 ) idx = 0 ans = \"\" key = key [ 31 ] + key [: 32 ] while idx < 32 : tmp = 0 for i in range ( 32 ): if mask >> i & 1 : tmp ^= int ( key [ 31 - i ]) ans = str ( tmp ) + ans idx += 1 key = key [ 31 ] + str ( tmp ) + key [ 1 : 31 ] num = int ( ans , 2 ) print hex ( num ) \u8fd0\u884c \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 python exp1.py 0x926201d7 \u7b2c\u4e8c\u79cd\u505a\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4e00\u4e0b\u77e9\u9635\u8f6c\u6362\u7684\u8fc7\u7a0b\uff0c\u5982\u679c\u8fdb\u884c\u4e86 32 \u6b21\u7ebf\u6027\u53d8\u6362\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5f97\u5230\u8f93\u51fa\u6d41\u524d 32 \u4e2a\u6bd4\u7279\u3002\u800c\u5176\u5b9e\uff0c\u6211\u4eec\u53ea\u9700\u8981\u524d 32 \u4e2a\u6bd4\u7279\u5c31\u53ef\u4ee5\u6062\u590d\u521d\u59cb\u72b6\u6001\u4e86\u3002 mask = 0b10100100000010000000100010010100 N = 32 F = GF ( 2 ) b = '' with open ( 'key' , 'rb' ) as f : b = f . read () R = [ vector ( F , N ) for i in range ( N )] for i in range ( N ): R [ i ][ N - 1 ] = mask >> ( 31 - i ) & 1 for i in range ( N - 1 ): R [ i + 1 ][ i ] = 1 M = Matrix ( F , R ) M = M ^ N vec = vector ( F , N ) row = 0 for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): vec [ row ] = t >> j & 1 row += 1 print rank ( M ) num = int ( '' . join ( map ( str , list ( M . solve_left ( vec )))), 2 ) print hex ( num ) \u8fd0\u884c\u811a\u672c \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 sage exp.sage 32 0x926201d7 \u4ece\u800c flag \u4e3a flag{926201d7}\u3002 \u8fd8\u6709\u4e00\u79cd\u505a\u6cd5\u662f TokyoWesterns \u7684\uff0c\u53ef\u4ee5\u53c2\u8003\u5bf9\u5e94\u7684\u6587\u4ef6\u5939\u7684\u6587\u4ef6\u3002","title":"2018 CISCN \u521d\u8d5b oldstreamgame"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#_5","text":"","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr-zh/#_6","text":"\u5bc6\u7801\u5b66\u8bb2\u4e49\uff0c\u674e\u8d85\uff0c\u5c48\u9f99\u6c5f\u7f16\u8457","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/","text":"EN | ZH Linear Feedback Shift Register - LFSR \u00b6 Introduction \u00b6 The feedback function of the linear feedback shift register is generally as follows a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} Where c_j c_j is in a finite field F_q F_q . Since the linear space is a linear transformation, we can know that this linear transformation is \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] Furthermore, we can find the characteristic polynomial as $ f (x) = x ^ n- sum limit_ {i = 1} ^ {n} c_ix ^ {in} $ At the same time, we define its reciprocal polynomial as \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} We also call the reciprocal polynomial as the joint polynomial of the linear feedback shift register. Here are some theorems that we need to remember. Interesting can be derived by ourselves. Characteristic Polynomial and Generator \u00b6 Knowing the characteristic polynomial of an n-level linear feedback shift register, then the corresponding generation function of the sequence is A(x)=\\frac{p(x)}{\\overline f(x)} A(x)=\\frac{p(x)}{\\overline f(x)} Where p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }) p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }) . It can be seen that p(x) is completely determined by the initial state and the coefficient of the feedback function. Sequence cycle and generation function \u00b6 The period of the sequence is the period of the denominator of the resulting true fraction of the function. For n-level linear feedback shift registers, the longest period is 2^{n-1} 2^{n-1} (excluding all zeros). The sequence that reaches the longest period is generally referred to as the m sequence. Special nature \u00b6 The two sequences are accumulated to give a new sequence whose period is the sum of the periods of the two sequences. The sequence is an n-level m sequence if and only if the minimal polynomial of the sequence is n primitive polynomials. BM algorithm \u00b6 In general, we can consider LFSR from two perspectives. Key generation angle. Generally, we want to use a LFSR with as low a level as possible to generate a sequence with a large period and good randomness. Cryptographic analysis, given a sequence a of length n, how to construct a LFSR with as few stages as possible to generate it. In fact, this is the source of the BM algorithm. In general, we define the linear complexity of a sequence as follows If s is an all-zero sequence, the linear complexity is zero. If no LFSR can generate s, the linear complexity is infinite. Otherwise, the linear complexity of s is the minimum level of LFSR that generates L(s). The requirements of the BM algorithm we need to know the sequence of length 2n. Complexity Time complexity: O(n^2) sub-bit operation Space complexity: O(n) bits. Details about the BM algorithm, added later, are currently in the learning process. But in fact, if we know the sequence of length 2n, we can also get a stupid way to get the original sequence. Let's assume that the known sequence is a_1,...,a_{2n} a_1,...,a_{2n} , we can make S_1=(a_1,...,a_n) S_1=(a_1,...,a_n) S_2=(a_2,...,a_{n+1}) S_2=(a_2,...,a_{n+1}) .... S_{n+1}=(a_{n+1},...,a_{2n}) S_{n+1}=(a_{n+1},...,a_{2n}) Then we can construct the matrix X=(S_1,...,S_n) X=(S_1,...,S_n) , then S_{n+1}=(c_n,...,c_1)X S_{n+1}=(c_n,...,c_1)X and so (c_n,...,c_1)=S_{n+1}X^{-1} (c_n,...,c_1)=S_{n+1}X^{-1} Then we also know the feedback expression of the LFSR, and then we can introduce the initialization seed. 2018 \u5f3a\u7f51\u676fstreamgame1 \u00b6 Simply look at the topic from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 25 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) R = int ( flag [ 5 : - 1 ], 2 ) mask = 0b1010011000100011100 f = open ( \"key\" , \"ab\" ) for i in range ( 12 ): tmp = 0 for j in range ( 8 ): ( R , out ) = lfsr ( R , mask ) tmp = ( tmp << 1 ) ^ out f . write ( chr ( tmp )) f . close () It can be found that the length of the flag is 25-5-1=19, so it can be violently enumerated. result \u279c 2018 -Strong Net Cup-streamgame1 git: ( master ) \u2717 python exp.py 12 0b1110101100001101011 Therefore flag is flag{1110101100001101011}. 2018 CISCN preliminary match oldstreamgame \u00b6 Simply look at the topic flag = \"flag{xxxxxxxxxxxxxxxx}\" assert flag.startswith ( \"flag{\" ) assert flag.endswith ( \"}\" ) assert len ( flag )== 14 def lfsr ( R,mask ) : output = ( R << 1) & 0xffffffff i=(R&mask)&0xffffffff lastbit=0 while i!=0: lastbit^=(i&1 ) i = i>>1 output^ = lastbit return ( output,lastbit ) R = int ( flag [ 5 :-1 ] ,16 ) mask = 0b10100100000010000000100010010100 f = open ( \"key\" , \"w\" ) for i in range ( 100 ) : tmp = 0 for j in range ( 8 ) : ( R,out )= lfsr ( R,mask ) tmp =( tmp << 1 ) ^out f.write ( chr ( tmp )) f.close () The program is very simple, it is still an LFSR, but the initial state is 32 bits. Of course, we can also choose to blast, but here we do not choose blasting. Here are two approaches. In the first method, the 32th bit of the program output is determined by the first 31 bits of the program output and the first bit of the initial seed, so we can know the first bit of the initial seed, and then we can know the initial seed. The second bit, and so on. code show as below mask = 0b10100100000010000000100010010100 b = '' N = 32 with open ( 'key' , 'rb' ) as f : b = f . read () key = '' for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): key += str ( t >> j & 1 ) idx = 0 ans = & quot ; & quot ; key = key [ 31 ] + key [: 32 ] while idx < 32 : tmp = 0 for i in range ( 32 ): if mask >> i & 1 : tmp ^= int ( key [ 31 - i ]) ans = str ( tmp ) + years idx += 1 key = key [ 31 ] + str ( tmp ) + key [ 1 : 31 ] Surely = int ( ans , 2 ) Print Hex ( whether ) run \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 python exp1.py 0x926201d7 In the second approach, we can consider the process of matrix conversion. If 32 linear transformations are performed, the first 32 bits of the output stream can be obtained. In fact, we only need the first 32 bits to restore the initial state. mask = 0b10100100000010000000100010010100 N = 32 F = GF ( 2 ) b = '' with open ( 'key' , 'rb' ) as f : b = f . read () R = [ vector ( F , N ) for i in range ( N )] for i in range ( N ): R [ i ][ N - 1 ] = mask >> ( 31 - i ) & 1 for i in range ( N - 1 ): R [ i + 1 ][ i ] = 1 M = Matrix ( F , R ) M = M ^ N vec = vector ( F , N ) row = 0 for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): vec [ row ] = t >> j & 1 row += 1 print rank ( M ) num = int ( '' . join ( map ( str , list ( M . solve_left ( vec )))), 2 ) Print Hex ( whether ) Running script \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 sage exp.sage 32 0x926201d7 Thus flag is flag{926201d7}. Another way is for TokyoWesterns, you can refer to the corresponding folder file. topic \u00b6 references \u00b6 Cryptography handouts, edited by Li Chao, Qu Longjiang","title":"\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#linear-feedback-shift-register-lfsr","text":"","title":"Linear Feedback Shift Register - LFSR"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#introduction","text":"The feedback function of the linear feedback shift register is generally as follows a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} a_{i+n}=\\sum\\limits_{j=1}^{n}c_ja_{i+n-j} Where c_j c_j is in a finite field F_q F_q . Since the linear space is a linear transformation, we can know that this linear transformation is \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} 0 & 0 & \\cdots & 0 & c_n \\\\ 1 & 0 & \\cdots & 0 & c_{n-1} \\\\ 0 & 1 & \\cdots & 0 & c_{n-2}\\\\\\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & c_1 \\\\ \\end{matrix} \\right] Furthermore, we can find the characteristic polynomial as $ f (x) = x ^ n- sum limit_ {i = 1} ^ {n} c_ix ^ {in} $ At the same time, we define its reciprocal polynomial as \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} \\overline f(x)=x^nf(\\frac{1}{x})=1-\\sum\\limits_{i=1}^{n}c_ix^{i} We also call the reciprocal polynomial as the joint polynomial of the linear feedback shift register. Here are some theorems that we need to remember. Interesting can be derived by ourselves.","title":"Introduction"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#characteristic-polynomial-and-generator","text":"Knowing the characteristic polynomial of an n-level linear feedback shift register, then the corresponding generation function of the sequence is A(x)=\\frac{p(x)}{\\overline f(x)} A(x)=\\frac{p(x)}{\\overline f(x)} Where p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }) p(x)=\\sum\\limits_{i=1}^{n}(c_{ni}x^{ni}\\sum\\limits_{j=1}^{i}a_jx^{j-1 }) . It can be seen that p(x) is completely determined by the initial state and the coefficient of the feedback function.","title":"Characteristic Polynomial and Generator"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#sequence-cycle-and-generation-function","text":"The period of the sequence is the period of the denominator of the resulting true fraction of the function. For n-level linear feedback shift registers, the longest period is 2^{n-1} 2^{n-1} (excluding all zeros). The sequence that reaches the longest period is generally referred to as the m sequence.","title":"Sequence cycle and generation function"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#special-nature","text":"The two sequences are accumulated to give a new sequence whose period is the sum of the periods of the two sequences. The sequence is an n-level m sequence if and only if the minimal polynomial of the sequence is n primitive polynomials.","title":"Special nature"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#bm-algorithm","text":"In general, we can consider LFSR from two perspectives. Key generation angle. Generally, we want to use a LFSR with as low a level as possible to generate a sequence with a large period and good randomness. Cryptographic analysis, given a sequence a of length n, how to construct a LFSR with as few stages as possible to generate it. In fact, this is the source of the BM algorithm. In general, we define the linear complexity of a sequence as follows If s is an all-zero sequence, the linear complexity is zero. If no LFSR can generate s, the linear complexity is infinite. Otherwise, the linear complexity of s is the minimum level of LFSR that generates L(s). The requirements of the BM algorithm we need to know the sequence of length 2n. Complexity Time complexity: O(n^2) sub-bit operation Space complexity: O(n) bits. Details about the BM algorithm, added later, are currently in the learning process. But in fact, if we know the sequence of length 2n, we can also get a stupid way to get the original sequence. Let's assume that the known sequence is a_1,...,a_{2n} a_1,...,a_{2n} , we can make S_1=(a_1,...,a_n) S_1=(a_1,...,a_n) S_2=(a_2,...,a_{n+1}) S_2=(a_2,...,a_{n+1}) .... S_{n+1}=(a_{n+1},...,a_{2n}) S_{n+1}=(a_{n+1},...,a_{2n}) Then we can construct the matrix X=(S_1,...,S_n) X=(S_1,...,S_n) , then S_{n+1}=(c_n,...,c_1)X S_{n+1}=(c_n,...,c_1)X and so (c_n,...,c_1)=S_{n+1}X^{-1} (c_n,...,c_1)=S_{n+1}X^{-1} Then we also know the feedback expression of the LFSR, and then we can introduce the initialization seed.","title":"BM algorithm"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#2018-streamgame1","text":"Simply look at the topic from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 25 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) R = int ( flag [ 5 : - 1 ], 2 ) mask = 0b1010011000100011100 f = open ( \"key\" , \"ab\" ) for i in range ( 12 ): tmp = 0 for j in range ( 8 ): ( R , out ) = lfsr ( R , mask ) tmp = ( tmp << 1 ) ^ out f . write ( chr ( tmp )) f . close () It can be found that the length of the flag is 25-5-1=19, so it can be violently enumerated. result \u279c 2018 -Strong Net Cup-streamgame1 git: ( master ) \u2717 python exp.py 12 0b1110101100001101011 Therefore flag is flag{1110101100001101011}.","title":"2018 \u5f3a\u7f51\u676fstreamgame1"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#2018-ciscn-preliminary-match-oldstreamgame","text":"Simply look at the topic flag = \"flag{xxxxxxxxxxxxxxxx}\" assert flag.startswith ( \"flag{\" ) assert flag.endswith ( \"}\" ) assert len ( flag )== 14 def lfsr ( R,mask ) : output = ( R << 1) & 0xffffffff i=(R&mask)&0xffffffff lastbit=0 while i!=0: lastbit^=(i&1 ) i = i>>1 output^ = lastbit return ( output,lastbit ) R = int ( flag [ 5 :-1 ] ,16 ) mask = 0b10100100000010000000100010010100 f = open ( \"key\" , \"w\" ) for i in range ( 100 ) : tmp = 0 for j in range ( 8 ) : ( R,out )= lfsr ( R,mask ) tmp =( tmp << 1 ) ^out f.write ( chr ( tmp )) f.close () The program is very simple, it is still an LFSR, but the initial state is 32 bits. Of course, we can also choose to blast, but here we do not choose blasting. Here are two approaches. In the first method, the 32th bit of the program output is determined by the first 31 bits of the program output and the first bit of the initial seed, so we can know the first bit of the initial seed, and then we can know the initial seed. The second bit, and so on. code show as below mask = 0b10100100000010000000100010010100 b = '' N = 32 with open ( 'key' , 'rb' ) as f : b = f . read () key = '' for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): key += str ( t >> j & 1 ) idx = 0 ans = & quot ; & quot ; key = key [ 31 ] + key [: 32 ] while idx < 32 : tmp = 0 for i in range ( 32 ): if mask >> i & 1 : tmp ^= int ( key [ 31 - i ]) ans = str ( tmp ) + years idx += 1 key = key [ 31 ] + str ( tmp ) + key [ 1 : 31 ] Surely = int ( ans , 2 ) Print Hex ( whether ) run \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 python exp1.py 0x926201d7 In the second approach, we can consider the process of matrix conversion. If 32 linear transformations are performed, the first 32 bits of the output stream can be obtained. In fact, we only need the first 32 bits to restore the initial state. mask = 0b10100100000010000000100010010100 N = 32 F = GF ( 2 ) b = '' with open ( 'key' , 'rb' ) as f : b = f . read () R = [ vector ( F , N ) for i in range ( N )] for i in range ( N ): R [ i ][ N - 1 ] = mask >> ( 31 - i ) & 1 for i in range ( N - 1 ): R [ i + 1 ][ i ] = 1 M = Matrix ( F , R ) M = M ^ N vec = vector ( F , N ) row = 0 for i in range ( N / 8 ): t = ord ( b [ i ]) for j in xrange ( 7 , - 1 , - 1 ): vec [ row ] = t >> j & 1 row += 1 print rank ( M ) num = int ( '' . join ( map ( str , list ( M . solve_left ( vec )))), 2 ) Print Hex ( whether ) Running script \u279c 2018 -CISCN-start-oldstreamgame git: ( master ) \u2717 sage exp.sage 32 0x926201d7 Thus flag is flag{926201d7}. Another way is for TokyoWesterns, you can refer to the corresponding folder file.","title":"2018 CISCN preliminary match oldstreamgame"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#topic","text":"","title":"topic"},{"location":"crypto/ctf-wiki/streamcipher/fsr/lfsr/#references","text":"Cryptography handouts, edited by Li Chao, Qu Longjiang","title":"references"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/","text":"EN | ZH \u975e\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668 \u00b6 \u4ecb\u7ecd \u00b6 \u4e3a\u4e86\u4f7f\u5f97\u5bc6\u94a5\u6d41\u8f93\u51fa\u7684\u5e8f\u5217\u5c3d\u53ef\u80fd\u590d\u6742\uff0c\u4f1a\u4f7f\u7528\u975e\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff0c\u5e38\u89c1\u7684\u6709\u4e09\u79cd \u975e\u7ebf\u6027\u7ec4\u5408\u751f\u6210\u5668\uff0c\u5bf9\u591a\u4e2a LFSR \u7684\u8f93\u51fa\u4f7f\u7528\u4e00\u4e2a\u975e\u7ebf\u6027\u7ec4\u5408\u51fd\u6570 \u975e\u7ebf\u6027\u6ee4\u6ce2\u751f\u6210\u5668\uff0c\u5bf9\u4e00\u4e2a LFSR \u7684\u5185\u5bb9\u4f7f\u7528\u4e00\u4e2a\u975e\u7ebf\u6027\u7ec4\u5408\u51fd\u6570 \u949f\u63a7\u751f\u6210\u5668\uff0c\u4f7f\u7528\u4e00\u4e2a\uff08\u6216\u591a\u4e2a\uff09LFSR \u7684\u8f93\u51fa\u6765\u63a7\u5236\u53e6\u4e00\u4e2a\uff08\u6216\u591a\u4e2a\uff09LFSR \u7684\u65f6\u949f \u975e\u7ebf\u6027\u7ec4\u5408\u751f\u6210\u5668 \u00b6 \u7b80\u4ecb \u00b6 \u7ec4\u5408\u751f\u6210\u5668\u4e00\u822c\u5982\u4e0b\u56fe\u6240\u793a\u3002 Geffe \u00b6 \u8fd9\u91cc\u6211\u4eec\u4ee5 Geffe \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002Geffe \u5305\u542b 3 \u4e2a\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff0c\u975e\u7ebf\u6027\u7ec4\u5408\u51fd\u6570\u4e3a F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 2018 \u5f3a\u7f51\u676f streamgame3 \u00b6 \u7b80\u5355\u770b\u4e00\u4e0b\u9898\u76ee from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 24 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW ,( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1 = int ( flag [ 5 : 11 ], 16 ) R2 = int ( flag [ 11 : 17 ], 16 ) R3 = int ( flag [ 17 : 23 ], 16 ) assert len ( bin ( R1 )[ 2 :]) == 17 assert len ( bin ( R2 )[ 2 :]) == 19 assert len ( bin ( R3 )[ 2 :]) == 21 R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 for fi in range ( 1024 ): print fi tmp1mb = \"\" for i in range ( 1024 ): tmp1kb = \"\" for j in range ( 1024 ): tmp = 0 for k in range ( 8 ): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) tmp = ( tmp << 1 ) ^ out tmp1kb += chr ( tmp ) tmp1mb += tmp1kb f = open ( \"./output/\" + str ( fi ), \"ab\" ) f . write ( tmp1mb ) f . close () \u53ef\u4ee5\u770b\u51fa\uff0c\u8be5\u7a0b\u5e8f\u4e0e Geffe \u751f\u6210\u5668\u975e\u5e38\u7c7b\u4f3c\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u76f8\u5173\u653b\u51fb\u65b9\u6cd5\u8fdb\u884c\u653b\u51fb\uff0c\u6211\u4eec\u53ef\u4ee5\u7edf\u8ba1\u4e00\u4e0b\u5728\u4e09\u4e2a LFSR \u8f93\u51fa\u4e0d\u540c\u7684\u60c5\u51b5\u4e0b\uff0c\u6700\u540e\u7c7b Geffe \u751f\u6210\u5668\u7684\u8f93\u51fa\uff0c\u5982\u4e0b x_1 x_1 x_2 x_2 x_3 x_3 F(x_1,x_2,x_3) F(x_1,x_2,x_3) 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 1 \u53ef\u4ee5\u53d1\u73b0 Geffe \u7684\u8f93\u51fa\u4e0e x_1 x_1 \u76f8\u540c\u7684\u6982\u7387\u4e3a 0.75 Geffe \u7684\u8f93\u51fa\u4e0e x_2 x_2 \u76f8\u540c\u7684\u6982\u7387\u4e3a 0.5 Geffe \u7684\u8f93\u51fa\u4e0e x_3 x_3 \u76f8\u540c\u7684\u6982\u7387\u4e3a 0.75 \u8fd9\u8bf4\u660e\u8f93\u51fa\u4e0e\u7b2c\u4e00\u4e2a\u548c\u7b2c\u4e09\u4e2a\u7684\u5173\u8054\u6027\u975e\u5e38\u5927\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u66b4\u529b\u53bb\u679a\u4e3e\u7b2c\u4e00\u4e2a\u548c\u7b2c\u4e09\u4e2a LFSR \u7684\u8f93\u51fa\u5224\u65ad\u5176\u4e0e \u7c7b Geffe \u7684\u8f93\u51fa\u76f8\u7b49\u7684\u4e2a\u6570\uff0c\u5982\u679c\u5927\u7ea6\u5728 75% \u7684\u8bdd\uff0c\u5c31\u53ef\u4ee5\u8ba4\u4e3a\u662f\u6b63\u786e\u7684\u3002\u7b2c\u4e8c\u4e2a\u5c31\u76f4\u63a5\u66b4\u529b\u679a\u4e3e\u4e86\u3002 \u811a\u672c\u5982\u4e0b #for x1 in range(2): # for x2 in range(2): # for x3 in range(2): # print x1,x2,x3,(x1*x2)^((x2^1)*x3) #n = [17,19,21] #cycle = 1 #for i in n: # cycle = cycle*(pow(2,i)-1) #print cycle def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW , ( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 n3 = 21 n2 = 19 n1 = 17 def guess ( beg , end , num , mask ): ansn = range ( beg , end ) data = open ( './output/0' ) . read ( num ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) now = 0 res = 0 for i in ansn : r = i cnt = 0 for j in range ( num * 8 ): r , lastbit = lfsr ( r , mask ) lastbit = str ( lastbit ) cnt += ( lastbit == data [ j ]) if cnt > now : now = cnt res = i print now , res return res def bruteforce2 ( x , z ): data = open ( './output/0' ) . read ( 50 ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) for y in range ( pow ( 2 , n2 - 1 ), pow ( 2 , n2 )): R1 , R2 , R3 = x , y , z flag = True for i in range ( len ( data )): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) if str ( out ) != data [ i ]: flag = False break if y % 10000 == 0 : print 'now: ' , x , y , z if flag : print 'ans: ' , hex ( x )[ 2 :], hex ( y )[ 2 :], hex ( z )[ 2 :] break R1 = guess ( pow ( 2 , n1 - 1 ), pow ( 2 , n1 ), 40 , R1_mask ) print R1 R3 = guess ( pow ( 2 , n3 - 1 ), pow ( 2 , n3 ), 40 , R3_mask ) print R3 R1 = 113099 R3 = 1487603 bruteforce2 ( R1 , R3 ) \u8fd0\u884c\u7ed3\u679c\u5982\u4e0b \u279c 2018 -CISCN-start-streamgame3 git: ( master ) \u2717 python exp.py 161 65536 172 65538 189 65545 203 65661 210 109191 242 113099 113099 157 1048576 165 1048578 183 1048580 184 1049136 186 1049436 187 1049964 189 1050869 190 1051389 192 1051836 194 1053573 195 1055799 203 1060961 205 1195773 212 1226461 213 1317459 219 1481465 239 1487603 1487603 now: 113099 270000 1487603 now: 113099 280000 1487603 now: 113099 290000 1487603 now: 113099 300000 1487603 now: 113099 310000 1487603 now: 113099 320000 1487603 now: 113099 330000 1487603 now: 113099 340000 1487603 now: 113099 350000 1487603 now: 113099 360000 1487603 ans: 1b9cb 5979c 16b2f3 \u4ece\u800c flag \u4e3a flag{01b9cb05979c16b2f3}\u3002 \u9898\u76ee \u00b6 2017 WHCTF Bornpig 2018 Google CTF 2018 Betterzip \u53c2\u8003 \u00b6 https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/chapter3.pdf http://data.at.preempted.net/INDEX/articles/Correlation_Attacks_Geffe.pdf","title":"Nfsr zh"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/#_1","text":"","title":"\u975e\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/#_2","text":"\u4e3a\u4e86\u4f7f\u5f97\u5bc6\u94a5\u6d41\u8f93\u51fa\u7684\u5e8f\u5217\u5c3d\u53ef\u80fd\u590d\u6742\uff0c\u4f1a\u4f7f\u7528\u975e\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff0c\u5e38\u89c1\u7684\u6709\u4e09\u79cd \u975e\u7ebf\u6027\u7ec4\u5408\u751f\u6210\u5668\uff0c\u5bf9\u591a\u4e2a LFSR \u7684\u8f93\u51fa\u4f7f\u7528\u4e00\u4e2a\u975e\u7ebf\u6027\u7ec4\u5408\u51fd\u6570 \u975e\u7ebf\u6027\u6ee4\u6ce2\u751f\u6210\u5668\uff0c\u5bf9\u4e00\u4e2a LFSR \u7684\u5185\u5bb9\u4f7f\u7528\u4e00\u4e2a\u975e\u7ebf\u6027\u7ec4\u5408\u51fd\u6570 \u949f\u63a7\u751f\u6210\u5668\uff0c\u4f7f\u7528\u4e00\u4e2a\uff08\u6216\u591a\u4e2a\uff09LFSR \u7684\u8f93\u51fa\u6765\u63a7\u5236\u53e6\u4e00\u4e2a\uff08\u6216\u591a\u4e2a\uff09LFSR \u7684\u65f6\u949f","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/#_3","text":"","title":"\u975e\u7ebf\u6027\u7ec4\u5408\u751f\u6210\u5668"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/#_4","text":"\u7ec4\u5408\u751f\u6210\u5668\u4e00\u822c\u5982\u4e0b\u56fe\u6240\u793a\u3002","title":"\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/#geffe","text":"\u8fd9\u91cc\u6211\u4eec\u4ee5 Geffe \u4e3a\u4f8b\u8fdb\u884c\u4ecb\u7ecd\u3002Geffe \u5305\u542b 3 \u4e2a\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668\uff0c\u975e\u7ebf\u6027\u7ec4\u5408\u51fd\u6570\u4e3a F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3","title":"Geffe"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/#2018-streamgame3","text":"\u7b80\u5355\u770b\u4e00\u4e0b\u9898\u76ee from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 24 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW ,( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1 = int ( flag [ 5 : 11 ], 16 ) R2 = int ( flag [ 11 : 17 ], 16 ) R3 = int ( flag [ 17 : 23 ], 16 ) assert len ( bin ( R1 )[ 2 :]) == 17 assert len ( bin ( R2 )[ 2 :]) == 19 assert len ( bin ( R3 )[ 2 :]) == 21 R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 for fi in range ( 1024 ): print fi tmp1mb = \"\" for i in range ( 1024 ): tmp1kb = \"\" for j in range ( 1024 ): tmp = 0 for k in range ( 8 ): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) tmp = ( tmp << 1 ) ^ out tmp1kb += chr ( tmp ) tmp1mb += tmp1kb f = open ( \"./output/\" + str ( fi ), \"ab\" ) f . write ( tmp1mb ) f . close () \u53ef\u4ee5\u770b\u51fa\uff0c\u8be5\u7a0b\u5e8f\u4e0e Geffe \u751f\u6210\u5668\u975e\u5e38\u7c7b\u4f3c\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u76f8\u5173\u653b\u51fb\u65b9\u6cd5\u8fdb\u884c\u653b\u51fb\uff0c\u6211\u4eec\u53ef\u4ee5\u7edf\u8ba1\u4e00\u4e0b\u5728\u4e09\u4e2a LFSR \u8f93\u51fa\u4e0d\u540c\u7684\u60c5\u51b5\u4e0b\uff0c\u6700\u540e\u7c7b Geffe \u751f\u6210\u5668\u7684\u8f93\u51fa\uff0c\u5982\u4e0b x_1 x_1 x_2 x_2 x_3 x_3 F(x_1,x_2,x_3) F(x_1,x_2,x_3) 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 1 1 1 0 1 1 1 1 1 \u53ef\u4ee5\u53d1\u73b0 Geffe \u7684\u8f93\u51fa\u4e0e x_1 x_1 \u76f8\u540c\u7684\u6982\u7387\u4e3a 0.75 Geffe \u7684\u8f93\u51fa\u4e0e x_2 x_2 \u76f8\u540c\u7684\u6982\u7387\u4e3a 0.5 Geffe \u7684\u8f93\u51fa\u4e0e x_3 x_3 \u76f8\u540c\u7684\u6982\u7387\u4e3a 0.75 \u8fd9\u8bf4\u660e\u8f93\u51fa\u4e0e\u7b2c\u4e00\u4e2a\u548c\u7b2c\u4e09\u4e2a\u7684\u5173\u8054\u6027\u975e\u5e38\u5927\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u66b4\u529b\u53bb\u679a\u4e3e\u7b2c\u4e00\u4e2a\u548c\u7b2c\u4e09\u4e2a LFSR \u7684\u8f93\u51fa\u5224\u65ad\u5176\u4e0e \u7c7b Geffe \u7684\u8f93\u51fa\u76f8\u7b49\u7684\u4e2a\u6570\uff0c\u5982\u679c\u5927\u7ea6\u5728 75% \u7684\u8bdd\uff0c\u5c31\u53ef\u4ee5\u8ba4\u4e3a\u662f\u6b63\u786e\u7684\u3002\u7b2c\u4e8c\u4e2a\u5c31\u76f4\u63a5\u66b4\u529b\u679a\u4e3e\u4e86\u3002 \u811a\u672c\u5982\u4e0b #for x1 in range(2): # for x2 in range(2): # for x3 in range(2): # print x1,x2,x3,(x1*x2)^((x2^1)*x3) #n = [17,19,21] #cycle = 1 #for i in n: # cycle = cycle*(pow(2,i)-1) #print cycle def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW , ( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 n3 = 21 n2 = 19 n1 = 17 def guess ( beg , end , num , mask ): ansn = range ( beg , end ) data = open ( './output/0' ) . read ( num ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) now = 0 res = 0 for i in ansn : r = i cnt = 0 for j in range ( num * 8 ): r , lastbit = lfsr ( r , mask ) lastbit = str ( lastbit ) cnt += ( lastbit == data [ j ]) if cnt > now : now = cnt res = i print now , res return res def bruteforce2 ( x , z ): data = open ( './output/0' ) . read ( 50 ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) for y in range ( pow ( 2 , n2 - 1 ), pow ( 2 , n2 )): R1 , R2 , R3 = x , y , z flag = True for i in range ( len ( data )): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) if str ( out ) != data [ i ]: flag = False break if y % 10000 == 0 : print 'now: ' , x , y , z if flag : print 'ans: ' , hex ( x )[ 2 :], hex ( y )[ 2 :], hex ( z )[ 2 :] break R1 = guess ( pow ( 2 , n1 - 1 ), pow ( 2 , n1 ), 40 , R1_mask ) print R1 R3 = guess ( pow ( 2 , n3 - 1 ), pow ( 2 , n3 ), 40 , R3_mask ) print R3 R1 = 113099 R3 = 1487603 bruteforce2 ( R1 , R3 ) \u8fd0\u884c\u7ed3\u679c\u5982\u4e0b \u279c 2018 -CISCN-start-streamgame3 git: ( master ) \u2717 python exp.py 161 65536 172 65538 189 65545 203 65661 210 109191 242 113099 113099 157 1048576 165 1048578 183 1048580 184 1049136 186 1049436 187 1049964 189 1050869 190 1051389 192 1051836 194 1053573 195 1055799 203 1060961 205 1195773 212 1226461 213 1317459 219 1481465 239 1487603 1487603 now: 113099 270000 1487603 now: 113099 280000 1487603 now: 113099 290000 1487603 now: 113099 300000 1487603 now: 113099 310000 1487603 now: 113099 320000 1487603 now: 113099 330000 1487603 now: 113099 340000 1487603 now: 113099 350000 1487603 now: 113099 360000 1487603 ans: 1b9cb 5979c 16b2f3 \u4ece\u800c flag \u4e3a flag{01b9cb05979c16b2f3}\u3002","title":"2018 \u5f3a\u7f51\u676f streamgame3"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/#_5","text":"2017 WHCTF Bornpig 2018 Google CTF 2018 Betterzip","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr-zh/#_6","text":"https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/chapter3.pdf http://data.at.preempted.net/INDEX/articles/Correlation_Attacks_Geffe.pdf","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/","text":"EN | ZH \u975e\u53cd\u9988 feedback shift register \u00b6 Introduction \u00b6 In order to make the sequence of key stream output as complex as possible, a nonlinear feedback shift register is used. There are three common types. Nonlinear combination generator that uses a nonlinear combination function for the output of multiple LFSRs Nonlinear filter generator that uses a nonlinear combination function for the contents of an LFSR Clock generator that uses the output of one (or more) LFSRs to control the clock of another (or multiple) LFSRs Nonlinear Combination Generator \u00b6 Introduction \u00b6 The combination generator is generally shown below. Geffe \u00b6 Here we take Geffe as an example. Geffe contains 3 linear feedback shift registers, and the nonlinear combination function is F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 2018 Strong Net Cup streamgame3 \u00b6 Simply look at the topic from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 24 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW ,( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1 = int ( flag [ 5 : 11 ], 16 ) R2 = int ( flag [ 11 : 17 ], 16 ) R3 = int ( flag [ 17 : 23 ], 16 ) assert len ( bin ( R1 ) [ 2 :]) == 17 assert len ( bin ( R2 ) [ 2 :]) == 19 assert len ( bin ( R3 )[ 2 :]) == 21 R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 for fi in range ( 1024 ): print fi tmp1mb = & quot ; & quot ; for i in range ( 1024 ): tmp1kb = & quot ; & quot ; for j in range ( 1024 ): tmp = 0 for k in range ( 8 ): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) tmp = ( tmp << 1 ) ^ out tmp1kb += chr ( tmp ) tmp1mb + = tmp1kb f = open ( \"./output/\" + str ( fi ), \"ab\" ) f . write ( tmp1mb ) f . close () It can be seen that the program is very similar to the Geffe generator. Here we use the related attack method to attack. We can count the output of the last class Geffe generator when the three LFSR outputs are different, as follows. | x_1 x_1 | x_2 x_2 | x_3 x_3 | F(x_1,x_2,x_3) F(x_1,x_2,x_3) | | ----- | ----- | ----- | ---------------- | | 0 | 0 | 0 | 0 | | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 0 | | 0 | 1 | 1 | 0 | | 1 | 0 | 0 | 0 | | 1 | 0 | 1 | 1 | | 1 | 1 | 0 | 1 | | 1 | 1 | 1 | 1 | it can be discovered Geffe's output has the same probability as x_1 x_1 0.75 Geffe's output has the same probability of x_2 x_2 as 0.5 Geffe's output has the same probability of x_3 x_3 as 0.75 This shows that the output is very relevant to the first and third. Therefore, we can violently enumerate the output of the first and third LFSRs to determine the number equal to the output of Geffe-like, and if it is about 75%, it can be considered correct. The second is a direct violent enumeration. The script is as follows #for x1 in range(2): # for x2 in range(2): # for x3 in range(2): # print x1,x2,x3,(x1*x2)^((x2^1)*x3) #n = [17,19,21] #cycle = 1 #for i in n: # cycle = cycle*(pow(2,i)-1) #print cycle def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW , ( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 n3 = 21 n2 = 19 n1 = 17 def guess ( beg , end , num , mask ): ansn = range ( beg , end ) data = open ( './output/0' ) . read ( num ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) now = 0 true = 0 for i in ansn : r = i cnt = 0 for j in range ( num * 8 ): r , lastbit = lfsr ( r , mask ) lastbit = str ( lastbit ) cnt += ( lastbit == data [ j ]) if cnt > now : now = cnt res = i print now , res return res def bruteforce2 ( x , z ): data = open ( './output/0' ) . read ( 50 ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) for y in range ( pow ( 2 , n2 - 1 ), pow ( 2 , n2 )): R1 , R2 , R3 = x , y , z flag = True for i in range ( len ( data )): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) if str ( out ) != data [ i ]: flag = False break if y % 10000 == 0 : print 'now: ' , x , y , z if flag : print 'ans: ' , hex ( x )[ 2 :], hex ( y )[ 2 :], hex ( z )[ 2 :] break R1 = guess ( pow ( 2 , n1 - 1 ), pow ( 2 , n1 ), 40 , R1_mask ) print R1 R3 = guess ( pow ( 2 , n3 - 1 ), pow ( 2 , n3 ), 40 , R3_mask ) print R3 R1 = 113099 R3 = 1487603 bruteforce2 ( R1 , R3 ) The results are as follows \u279c 2018 -CISCN-start-streamgame3 git: ( master ) \u2717 python exp.py 161 65536 172 65538 189 65545 203 65661 210 109191 242 113099 113099 157 1048576 165 1048578 183 1048580 184 1049136 186 1049436 187 1049964 189 1050869 190 1051389 192 1051836 194 1053573 195 1055799 203 1060961 205 1195773 212 1226461 213 1317459 219 1481465 239 1487603 1487603 now: 113099 270000 1487603 now: 113099 280000 1487603 now: 113099 290000 1487603 now: 113099 300000 1487603 now: 113099 310000 1487603 now: 113099 320000 1487603 now: 113099 330000 1487603 now: 113099 340000 1487603 now: 113099 350000 1487603 now: 113099 360000 1487603 years old: 1b9cb 5979c 16b2f3 Thus flag is flag{01b9cb05979c16b2f3}. topic \u00b6 2017 WHCTF Bornpig 2018 Google CTF 2018 Betterzip Reference \u00b6 https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/chapter3.pdf http://data.at.preempted.net/INDEX/articles/Correlation_Attacks_Geffe.pdf","title":"\u975e\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/#feedback-shift-register","text":"","title":"\u975e\u53cd\u9988 feedback shift register"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/#introduction","text":"In order to make the sequence of key stream output as complex as possible, a nonlinear feedback shift register is used. There are three common types. Nonlinear combination generator that uses a nonlinear combination function for the output of multiple LFSRs Nonlinear filter generator that uses a nonlinear combination function for the contents of an LFSR Clock generator that uses the output of one (or more) LFSRs to control the clock of another (or multiple) LFSRs","title":"Introduction"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/#nonlinear-combination-generator","text":"","title":"Nonlinear Combination Generator"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/#introduction_1","text":"The combination generator is generally shown below.","title":"Introduction"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/#geffe","text":"Here we take Geffe as an example. Geffe contains 3 linear feedback shift registers, and the nonlinear combination function is F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3 F(x_1,x_2,x_3)=(x_1 \\and x_2) \\oplus (\\urcorner x_1 \\and x_3)=(x_1 \\and x_2) \\oplus ( x_1 \\and x_3)\\oplus x_3","title":"Geffe"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/#2018-strong-net-cup-streamgame3","text":"Simply look at the topic from flag import flag assert flag . startswith ( \"flag{\" ) assert flag . endswith ( \"}\" ) assert len ( flag ) == 24 def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW ,( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1 = int ( flag [ 5 : 11 ], 16 ) R2 = int ( flag [ 11 : 17 ], 16 ) R3 = int ( flag [ 17 : 23 ], 16 ) assert len ( bin ( R1 ) [ 2 :]) == 17 assert len ( bin ( R2 ) [ 2 :]) == 19 assert len ( bin ( R3 )[ 2 :]) == 21 R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 for fi in range ( 1024 ): print fi tmp1mb = & quot ; & quot ; for i in range ( 1024 ): tmp1kb = & quot ; & quot ; for j in range ( 1024 ): tmp = 0 for k in range ( 8 ): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) tmp = ( tmp << 1 ) ^ out tmp1kb += chr ( tmp ) tmp1mb + = tmp1kb f = open ( \"./output/\" + str ( fi ), \"ab\" ) f . write ( tmp1mb ) f . close () It can be seen that the program is very similar to the Geffe generator. Here we use the related attack method to attack. We can count the output of the last class Geffe generator when the three LFSR outputs are different, as follows. | x_1 x_1 | x_2 x_2 | x_3 x_3 | F(x_1,x_2,x_3) F(x_1,x_2,x_3) | | ----- | ----- | ----- | ---------------- | | 0 | 0 | 0 | 0 | | 0 | 0 | 1 | 1 | | 0 | 1 | 0 | 0 | | 0 | 1 | 1 | 0 | | 1 | 0 | 0 | 0 | | 1 | 0 | 1 | 1 | | 1 | 1 | 0 | 1 | | 1 | 1 | 1 | 1 | it can be discovered Geffe's output has the same probability as x_1 x_1 0.75 Geffe's output has the same probability of x_2 x_2 as 0.5 Geffe's output has the same probability of x_3 x_3 as 0.75 This shows that the output is very relevant to the first and third. Therefore, we can violently enumerate the output of the first and third LFSRs to determine the number equal to the output of Geffe-like, and if it is about 75%, it can be considered correct. The second is a direct violent enumeration. The script is as follows #for x1 in range(2): # for x2 in range(2): # for x3 in range(2): # print x1,x2,x3,(x1*x2)^((x2^1)*x3) #n = [17,19,21] #cycle = 1 #for i in n: # cycle = cycle*(pow(2,i)-1) #print cycle def lfsr ( R , mask ): output = ( R << 1 ) & 0xffffff i = ( R & mask ) & 0xffffff lastbit = 0 while i != 0 : lastbit ^= ( i & 1 ) i = i >> 1 output ^= lastbit return ( output , lastbit ) def single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ): ( R1_NEW , x1 ) = lfsr ( R1 , R1_mask ) ( R2_NEW , x2 ) = lfsr ( R2 , R2_mask ) ( R3_NEW , x3 ) = lfsr ( R3 , R3_mask ) return ( R1_NEW , R2_NEW , R3_NEW , ( x1 * x2 ) ^ (( x2 ^ 1 ) * x3 )) R1_mask = 0x10020 R2_mask = 0x4100c R3_mask = 0x100002 n3 = 21 n2 = 19 n1 = 17 def guess ( beg , end , num , mask ): ansn = range ( beg , end ) data = open ( './output/0' ) . read ( num ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) now = 0 true = 0 for i in ansn : r = i cnt = 0 for j in range ( num * 8 ): r , lastbit = lfsr ( r , mask ) lastbit = str ( lastbit ) cnt += ( lastbit == data [ j ]) if cnt > now : now = cnt res = i print now , res return res def bruteforce2 ( x , z ): data = open ( './output/0' ) . read ( 50 ) data = '' . join ( bin ( 256 + ord ( c ))[ 3 :] for c in data ) for y in range ( pow ( 2 , n2 - 1 ), pow ( 2 , n2 )): R1 , R2 , R3 = x , y , z flag = True for i in range ( len ( data )): ( R1 , R2 , R3 , out ) = single_round ( R1 , R1_mask , R2 , R2_mask , R3 , R3_mask ) if str ( out ) != data [ i ]: flag = False break if y % 10000 == 0 : print 'now: ' , x , y , z if flag : print 'ans: ' , hex ( x )[ 2 :], hex ( y )[ 2 :], hex ( z )[ 2 :] break R1 = guess ( pow ( 2 , n1 - 1 ), pow ( 2 , n1 ), 40 , R1_mask ) print R1 R3 = guess ( pow ( 2 , n3 - 1 ), pow ( 2 , n3 ), 40 , R3_mask ) print R3 R1 = 113099 R3 = 1487603 bruteforce2 ( R1 , R3 ) The results are as follows \u279c 2018 -CISCN-start-streamgame3 git: ( master ) \u2717 python exp.py 161 65536 172 65538 189 65545 203 65661 210 109191 242 113099 113099 157 1048576 165 1048578 183 1048580 184 1049136 186 1049436 187 1049964 189 1050869 190 1051389 192 1051836 194 1053573 195 1055799 203 1060961 205 1195773 212 1226461 213 1317459 219 1481465 239 1487603 1487603 now: 113099 270000 1487603 now: 113099 280000 1487603 now: 113099 290000 1487603 now: 113099 300000 1487603 now: 113099 310000 1487603 now: 113099 320000 1487603 now: 113099 330000 1487603 now: 113099 340000 1487603 now: 113099 350000 1487603 now: 113099 360000 1487603 years old: 1b9cb 5979c 16b2f3 Thus flag is flag{01b9cb05979c16b2f3}.","title":"2018 Strong Net Cup streamgame3"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/#topic","text":"2017 WHCTF Bornpig 2018 Google CTF 2018 Betterzip","title":"topic"},{"location":"crypto/ctf-wiki/streamcipher/fsr/nfsr/#reference","text":"https://www.rocq.inria.fr/secret/Anne.Canteaut/MPRI/chapter3.pdf http://data.at.preempted.net/INDEX/articles/Correlation_Attacks_Geffe.pdf","title":"Reference"},{"location":"crypto/ctf-wiki/streamcipher/lcg/challenge-zh/","text":"EN | ZH \u9898\u76ee \u00b6 2016 Google CTF woodman \u00b6 \u7a0b\u5e8f\u7684\u5927\u6982\u610f\u601d\u5c31\u662f\u4e00\u4e2a\u731c\u6570\u6e38\u620f\uff0c\u5982\u679c\u8fde\u7eed\u731c\u4e2d\u82e5\u5e72\u6b21\uff0c\u5c31\u7b97\u4f1a\u62ff\u5230 flag\uff0c\u80cc\u540e\u7684\u751f\u6210\u76f8\u5e94\u6570\u7684\u6838\u5fc3\u4ee3\u7801\u5982\u4e0b class SecurePrng ( object ): def __init__ ( self ): # generate seed with 64 bits of entropy self . p = 4646704883 L self . x = random . randint ( 0 , self . p ) self . y = random . randint ( 0 , self . p ) def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) \u8fd9\u91cc\u6211\u4eec\u663e\u7136\uff0c\u6211\u4eec\u731c\u51fa\u524d\u4e24\u8f6e\u8fd8\u662f\u6bd4\u8f83\u5bb9\u6613\u7684\uff0c\u6bd5\u7adf\u6982\u7387\u4e5f\u6709 0.25\u3002\u8fd9\u91cc\u5f53\u6211\u4eec\u731c\u51fa\u524d\u4e24\u8f6e\u540e\uff0c\u4f7f\u7528 Z3 \u6765\u6c42\u89e3\u51fa\u521d\u59cb\u7684 x \u548c y\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u987a\u5229\u7684\u731c\u51fa\u5269\u4e0b\u7684\u503c\u4e86\u3002 \u5177\u4f53\u7684\u811a\u672c\u5982\u4e0b\uff0c\u7136\u800c Z3 \u5728\u89e3\u51b3\u8fd9\u6837\u7684\u95ee\u9898\u65f6\u4f3c\u4e4e\u662f\u6709\u95ee\u9898\u7684\u3002\u3002\u3002 \u8fd9\u91cc\u6211\u4eec\u8003\u8651\u53e6\u5916\u4e00\u79cd\u65b9\u6cd5\uff0c \u4f9d\u6b21\u4ece\u4f4e\u6bd4\u7279\u4f4d\u679a\u4e3e\u5230\u9ad8\u6bd4\u7279\u4f4d\u83b7\u53d6 x \u7684\u503c \uff0c\u4e4b\u6240\u4ee5\u80fd\u591f\u8fd9\u6837\u505a\uff0c\u662f\u4f9d\u8d56\u4e8e\u8fd9\u6837\u7684\u89c2\u5bdf a + b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u4ee5\u53ca\u66f4\u4f4e\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002 \u56e0\u4e3a\u7b2c i \u6bd4\u7279\u4f4d\u8fdb\u884c\u8fd0\u7b97\u65f6\uff0c\u53ea\u6709\u53ef\u80fd\u6536\u5230\u4f4e\u6bd4\u7279\u4f4d\u7684\u8fdb\u4f4d\u6570\u503c\u3002 a - b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u4ee5\u53ca\u66f4\u4f4e\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002 \u56e0\u4e3a\u7b2c i \u6bd4\u7279\u4f4d\u8fdb\u884c\u8fd0\u7b97\u65f6\uff0c\u53ea\u6709\u53ef\u80fd\u5411\u4f4e\u6bd4\u7279\u4f4d\u7684\u501f\u4f4d\u3002 a * b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u4ee5\u53ca\u66f4\u4f4e\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002\u56e0\u4e3a\u8fd9\u53ef\u4ee5\u89c6\u4f5c\u591a\u6b21\u52a0\u6cd5\u3002 a % b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u4ee5\u53ca\u66f4\u4f4e\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002\u56e0\u4e3a\u8fd9\u53ef\u89c6\u4e3a\u591a\u6b21\u8fdb\u884c\u51cf\u6cd5\u3002 a ^ b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002\u8fd9\u4e00\u70b9\u662f\u663e\u800c\u6613\u89c1\u7684\u3002 \u6ce8\uff1a\u4e2a\u4eba\u611f\u89c9\u8fd9\u4e2a\u6280\u5de7\u975e\u5e38\u6709\u7528\u3002 \u6b64\u5916\uff0c\u6211\u4eec\u4e0d\u96be\u5f97\u77e5 p \u7684\u6bd4\u7279\u4f4d\u4e3a 33 \u6bd4\u7279\u4f4d\u3002\u5177\u4f53\u5229\u7528\u601d\u8def\u5982\u4e0b \u9996\u5148\u83b7\u53d6\u4e24\u6b21\u731c\u5230\u7684\u503c\uff0c\u8fd9\u4e2a\u6982\u7387\u6709 0.25\u3002 \u4f9d\u6b21\u4ece\u4f4e\u6bd4\u7279\u4f4d\u5230\u9ad8\u6bd4\u7279\u4f4d\u4f9d\u6b21\u679a\u4e3e \u7b2c\u4e00\u6b21\u8fed\u4ee3\u540e\u7684 x \u7684\u76f8\u5e94\u6bd4\u7279\u4f4d \u3002 \u6839\u636e\u81ea\u5df1\u679a\u4e3e\u7684\u503c\u5206\u522b\u8ba1\u7b97\u51fa\u7b2c\u4e8c\u6b21\u7684\u503c\uff0c\u53ea\u6709\u5f53\u5bf9\u5e94\u6bd4\u7279\u4f4d\u6b63\u786e\uff0c\u53ef\u4ee5\u5c06\u5176\u52a0\u5165\u5019\u9009\u6b63\u786e\u503c\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u91cc\u7531\u4e8e\u53d6\u6a21\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u679a\u4e3e\u5230\u5e95\u51cf\u4e86\u591a\u5c11\u6b21\u3002 \u6b64\u5916\uff0c\u5728\u6700\u7ec8\u5224\u65ad\u65f6\uff0c\u4ecd\u7136\u9700\u8981\u786e\u4fdd\u5bf9\u5e94\u7684\u503c\u6ee1\u8db3\u4e00\u5b9a\u8981\u6c42\uff0c\u56e0\u4e3a\u4e4b\u524d\u5bf9\u51cf\u4e86\u591a\u5c11\u6b21\u8fdb\u884c\u4e86\u679a\u4e3e\u3002 \u5177\u4f53\u5229\u7528\u4ee3\u7801\u5982\u4e0b import os import random from itertools import product class SecurePrng ( object ): def __init__ ( self , x =- 1 , y =- 1 ): # generate seed with 64 bits of entropy self . p = 4646704883 L # 33bit if x == - 1 : self . x = random . randint ( 0 , self . p ) else : self . x = x if y == - 1 : self . y = random . randint ( 0 , self . p ) else : self . y = y def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) def getbiti ( num , idx ): return bin ( num )[ - idx - 1 :] def main (): sp = SecurePrng () targetx = sp . x targety = sp . y print \"we would like to get x \" , targetx print \"we would like to get y \" , targety # suppose we have already guess two number guess1 = sp . next () guess2 = sp . next () p = 4646704883 # newx = tmpx*2+3-kx*p for kx , ky in product ( range ( 3 ), range ( 4 )): candidate = [[ 0 ]] # only 33 bit for i in range ( 33 ): #print 'idx ', i new_candidate = [] for old , bit in product ( candidate , range ( 2 )): #print old, bit oldx = old [ 0 ] #oldy = old[1] tmpx = oldx | (( bit & 1 ) << i ) #tmpy = oldy | ((bit / 2) << i) tmpy = tmpx ^ guess1 newx = tmpx * 2 + 3 - kx * p + ( 1 << 40 ) newy = tmpy * 3 + 9 - ky * p + ( 1 << 40 ) tmp1 = newx ^ newy #print \"tmpx: \", bin(tmpx) #print \"targetx: \", bin(targetx) #print \"calculate: \", bin(tmp1 + (1 << 40)) #print \"target guess2: \", bin(guess1 + (1 << 40)) if getbiti ( guess2 + ( 1 << 40 ), i ) == getbiti ( tmp1 + ( 1 << 40 ), i ): if [ tmpx ] not in new_candidate : #print \"got one\" #print bin(tmpx) #print bin(targetx) #print bin(tmpy) new_candidate . append ([ tmpx ]) candidate = new_candidate #print len(candidate) #print candidate print \"candidate x for kx: \" , kx , \" ky \" , ky for item in candidate : tmpx = candidate [ 0 ][ 0 ] tmpy = tmpx ^ guess1 if tmpx >= p or tmpx >= p : continue mysp = SecurePrng ( tmpx , tmpy ) tmp1 = mysp . next () if tmp1 != guess2 : continue print tmpx , tmpy print ( targetx * 2 + 3 ) % p , ( targety * 3 + 9 ) % p if __name__ == \"__main__\" : main ()","title":"Challenge zh"},{"location":"crypto/ctf-wiki/streamcipher/lcg/challenge-zh/#_1","text":"","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/streamcipher/lcg/challenge-zh/#2016-google-ctf-woodman","text":"\u7a0b\u5e8f\u7684\u5927\u6982\u610f\u601d\u5c31\u662f\u4e00\u4e2a\u731c\u6570\u6e38\u620f\uff0c\u5982\u679c\u8fde\u7eed\u731c\u4e2d\u82e5\u5e72\u6b21\uff0c\u5c31\u7b97\u4f1a\u62ff\u5230 flag\uff0c\u80cc\u540e\u7684\u751f\u6210\u76f8\u5e94\u6570\u7684\u6838\u5fc3\u4ee3\u7801\u5982\u4e0b class SecurePrng ( object ): def __init__ ( self ): # generate seed with 64 bits of entropy self . p = 4646704883 L self . x = random . randint ( 0 , self . p ) self . y = random . randint ( 0 , self . p ) def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) \u8fd9\u91cc\u6211\u4eec\u663e\u7136\uff0c\u6211\u4eec\u731c\u51fa\u524d\u4e24\u8f6e\u8fd8\u662f\u6bd4\u8f83\u5bb9\u6613\u7684\uff0c\u6bd5\u7adf\u6982\u7387\u4e5f\u6709 0.25\u3002\u8fd9\u91cc\u5f53\u6211\u4eec\u731c\u51fa\u524d\u4e24\u8f6e\u540e\uff0c\u4f7f\u7528 Z3 \u6765\u6c42\u89e3\u51fa\u521d\u59cb\u7684 x \u548c y\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u987a\u5229\u7684\u731c\u51fa\u5269\u4e0b\u7684\u503c\u4e86\u3002 \u5177\u4f53\u7684\u811a\u672c\u5982\u4e0b\uff0c\u7136\u800c Z3 \u5728\u89e3\u51b3\u8fd9\u6837\u7684\u95ee\u9898\u65f6\u4f3c\u4e4e\u662f\u6709\u95ee\u9898\u7684\u3002\u3002\u3002 \u8fd9\u91cc\u6211\u4eec\u8003\u8651\u53e6\u5916\u4e00\u79cd\u65b9\u6cd5\uff0c \u4f9d\u6b21\u4ece\u4f4e\u6bd4\u7279\u4f4d\u679a\u4e3e\u5230\u9ad8\u6bd4\u7279\u4f4d\u83b7\u53d6 x \u7684\u503c \uff0c\u4e4b\u6240\u4ee5\u80fd\u591f\u8fd9\u6837\u505a\uff0c\u662f\u4f9d\u8d56\u4e8e\u8fd9\u6837\u7684\u89c2\u5bdf a + b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u4ee5\u53ca\u66f4\u4f4e\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002 \u56e0\u4e3a\u7b2c i \u6bd4\u7279\u4f4d\u8fdb\u884c\u8fd0\u7b97\u65f6\uff0c\u53ea\u6709\u53ef\u80fd\u6536\u5230\u4f4e\u6bd4\u7279\u4f4d\u7684\u8fdb\u4f4d\u6570\u503c\u3002 a - b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u4ee5\u53ca\u66f4\u4f4e\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002 \u56e0\u4e3a\u7b2c i \u6bd4\u7279\u4f4d\u8fdb\u884c\u8fd0\u7b97\u65f6\uff0c\u53ea\u6709\u53ef\u80fd\u5411\u4f4e\u6bd4\u7279\u4f4d\u7684\u501f\u4f4d\u3002 a * b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u4ee5\u53ca\u66f4\u4f4e\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002\u56e0\u4e3a\u8fd9\u53ef\u4ee5\u89c6\u4f5c\u591a\u6b21\u52a0\u6cd5\u3002 a % b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u4ee5\u53ca\u66f4\u4f4e\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002\u56e0\u4e3a\u8fd9\u53ef\u89c6\u4e3a\u591a\u6b21\u8fdb\u884c\u51cf\u6cd5\u3002 a ^ b = c\uff0cc \u7684\u7b2c i \u6bd4\u7279\u4f4d\u7684\u503c\u53ea\u53d7 a \u548c b \u8be5\u6bd4\u7279\u4f4d\u7684\u5f71\u54cd\u3002\u8fd9\u4e00\u70b9\u662f\u663e\u800c\u6613\u89c1\u7684\u3002 \u6ce8\uff1a\u4e2a\u4eba\u611f\u89c9\u8fd9\u4e2a\u6280\u5de7\u975e\u5e38\u6709\u7528\u3002 \u6b64\u5916\uff0c\u6211\u4eec\u4e0d\u96be\u5f97\u77e5 p \u7684\u6bd4\u7279\u4f4d\u4e3a 33 \u6bd4\u7279\u4f4d\u3002\u5177\u4f53\u5229\u7528\u601d\u8def\u5982\u4e0b \u9996\u5148\u83b7\u53d6\u4e24\u6b21\u731c\u5230\u7684\u503c\uff0c\u8fd9\u4e2a\u6982\u7387\u6709 0.25\u3002 \u4f9d\u6b21\u4ece\u4f4e\u6bd4\u7279\u4f4d\u5230\u9ad8\u6bd4\u7279\u4f4d\u4f9d\u6b21\u679a\u4e3e \u7b2c\u4e00\u6b21\u8fed\u4ee3\u540e\u7684 x \u7684\u76f8\u5e94\u6bd4\u7279\u4f4d \u3002 \u6839\u636e\u81ea\u5df1\u679a\u4e3e\u7684\u503c\u5206\u522b\u8ba1\u7b97\u51fa\u7b2c\u4e8c\u6b21\u7684\u503c\uff0c\u53ea\u6709\u5f53\u5bf9\u5e94\u6bd4\u7279\u4f4d\u6b63\u786e\uff0c\u53ef\u4ee5\u5c06\u5176\u52a0\u5165\u5019\u9009\u6b63\u786e\u503c\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u91cc\u7531\u4e8e\u53d6\u6a21\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u679a\u4e3e\u5230\u5e95\u51cf\u4e86\u591a\u5c11\u6b21\u3002 \u6b64\u5916\uff0c\u5728\u6700\u7ec8\u5224\u65ad\u65f6\uff0c\u4ecd\u7136\u9700\u8981\u786e\u4fdd\u5bf9\u5e94\u7684\u503c\u6ee1\u8db3\u4e00\u5b9a\u8981\u6c42\uff0c\u56e0\u4e3a\u4e4b\u524d\u5bf9\u51cf\u4e86\u591a\u5c11\u6b21\u8fdb\u884c\u4e86\u679a\u4e3e\u3002 \u5177\u4f53\u5229\u7528\u4ee3\u7801\u5982\u4e0b import os import random from itertools import product class SecurePrng ( object ): def __init__ ( self , x =- 1 , y =- 1 ): # generate seed with 64 bits of entropy self . p = 4646704883 L # 33bit if x == - 1 : self . x = random . randint ( 0 , self . p ) else : self . x = x if y == - 1 : self . y = random . randint ( 0 , self . p ) else : self . y = y def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) def getbiti ( num , idx ): return bin ( num )[ - idx - 1 :] def main (): sp = SecurePrng () targetx = sp . x targety = sp . y print \"we would like to get x \" , targetx print \"we would like to get y \" , targety # suppose we have already guess two number guess1 = sp . next () guess2 = sp . next () p = 4646704883 # newx = tmpx*2+3-kx*p for kx , ky in product ( range ( 3 ), range ( 4 )): candidate = [[ 0 ]] # only 33 bit for i in range ( 33 ): #print 'idx ', i new_candidate = [] for old , bit in product ( candidate , range ( 2 )): #print old, bit oldx = old [ 0 ] #oldy = old[1] tmpx = oldx | (( bit & 1 ) << i ) #tmpy = oldy | ((bit / 2) << i) tmpy = tmpx ^ guess1 newx = tmpx * 2 + 3 - kx * p + ( 1 << 40 ) newy = tmpy * 3 + 9 - ky * p + ( 1 << 40 ) tmp1 = newx ^ newy #print \"tmpx: \", bin(tmpx) #print \"targetx: \", bin(targetx) #print \"calculate: \", bin(tmp1 + (1 << 40)) #print \"target guess2: \", bin(guess1 + (1 << 40)) if getbiti ( guess2 + ( 1 << 40 ), i ) == getbiti ( tmp1 + ( 1 << 40 ), i ): if [ tmpx ] not in new_candidate : #print \"got one\" #print bin(tmpx) #print bin(targetx) #print bin(tmpy) new_candidate . append ([ tmpx ]) candidate = new_candidate #print len(candidate) #print candidate print \"candidate x for kx: \" , kx , \" ky \" , ky for item in candidate : tmpx = candidate [ 0 ][ 0 ] tmpy = tmpx ^ guess1 if tmpx >= p or tmpx >= p : continue mysp = SecurePrng ( tmpx , tmpy ) tmp1 = mysp . next () if tmp1 != guess2 : continue print tmpx , tmpy print ( targetx * 2 + 3 ) % p , ( targety * 3 + 9 ) % p if __name__ == \"__main__\" : main ()","title":"2016 Google CTF woodman"},{"location":"crypto/ctf-wiki/streamcipher/lcg/challenge/","text":"EN | ZH \u9898 \u00b6 2016 Google CTF woodman \u00b6 The approximate meaning of the program is a guessing game. If you guess a number of times in a row, even if you get the flag, the core code behind the corresponding number is as follows: class SecurePrng ( object ): def __init__ ( self ): # generate seed with 64 bits of entropy self . p = 4646704883 L self . x = random . randint ( 0 , self . p ) self . y = random . randint ( 0 , self . p ) def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) Here we obviously, we guessed that the first two rounds are still relatively easy, after all, the probability is also 0.25. Here, after we guessed the first two rounds, we used Z3 to solve the initial x and y, then we can easily guess the remaining values. The specific script is as follows, but Z3 seems to be problematic when solving such problems. . . Here we consider another method, ** sequentially extracting the value of x from the low-bit enumeration to the high-bit bit. The reason for this is that it depends on such observation. a + b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because the i-th bit is operated, only the carry value of the low bit may be received. a - b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because the i-th bit is operated, there is only a possible borrow from the low bit. a * b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple additions. a % b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple subtractions. a ^ b = c, the value of the ith bit of c is only affected by the bits a and b. This is obvious. Note: Personally feel this technique is very useful. In addition, it is not difficult to know that the bit of p is 33 bits. The specific use ideas are as follows First get the value you guessed twice, this probability is 0.25. In turn, enumerate the corresponding bits of x after the first iteration from the low bit to the high bit. Calculate the second value according to the value of the enumeration. Only when the corresponding bit is correct, you can add it to the candidate correct value. It should be noted that due to the modulo, we need to reduce the number of enumerations in the end. In addition, in the final judgment, it is still necessary to ensure that the corresponding value meets certain requirements, because the number of reductions has been enumerated before. The specific use code is as follows import import random from itertools import product class SecurePrng ( object ): def __init__ ( self , x =- 1 , y =- 1 ): # generate seed with 64 bits of entropy self . p = 4646704883 L # 33bit if x == - 1 : self . x = random . randint ( 0 , self . p ) else : self . x = x if y == - 1 : self . y = random . randint ( 0 , self . p ) else : self . y = and def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) def getbiti ( num , idx ): return bin ( num )[ - idx - 1 :] def main (): sp = SecurePrng () targetx = sp . x targety = sp . y print \"we would like to get x \" , targetx print \"we would like to get y \" , targety # suppose we have already guess two number guess1 = sp . next () guess2 = sp . next () p = 4646704883 # newx = tmpx*2+3-kx*p for kx , ky in product ( range ( 3 ), range ( 4 )): candidate = [[ 0 ]] # only 33 bit for i in range ( 33 ): #print 'idx ', i new_candidate = [] for old , bit in product ( candidate , range ( 2 )): #print old, bit oldx = old [ 0 ] #oldy = old[1] tmpx = oldx | (( bit & 1 ) << i ) #tmpy = oldy | ((bit / 2) << i) tmpy = tmpx ^ guess1 newx = tmpx * 2 + 3 - kx * p + ( 1 << 40 ) newy = tmpy * 3 + 9 - ky * p + ( 1 & lt ; & lt ; 40 ) tmp1 = newx ^ newy #print \"tmpx: \", bin(tmpx) #print \"targetx: \", bin(targetx) #print \"calculate: \", bin(tmp1 + (1 << 40)) #print \"target guess2: \", bin(guess1 + (1 << 40)) if getbiti ( guess2 + ( 1 << 40 ), i ) == getbiti ( tmp1 + ( 1 & lt ; & lt ; 40 ), i ): if [ tmpx ] not in new_candidate : #print \"got one\" #print bin(tmpx) #print bin(targetx) #print bin(tmpy) new_candidate . append ([ tmpx ]) candidate = new_candidate #print len (candidate) #print candidate print \"candidate x for kx: \" , kx , \" ky \" , ky for item in candidate : tmpx = candidate [ 0 ][ 0 ] tmpy = tmpx ^ guess1 if tmpx >= p or tmpx >= p : continue mysp = SecurePrng ( tmpx , tmpy ) tmp1 = mysp . next () if tmp1 != guess2 : continue print tmpx , tmpy print ( targetx * 2 + 3 ) % p , ( targety * 3 + 9 ) % p if __name__ == \"__main__\" : main ()","title":"\u4f8b\u9898"},{"location":"crypto/ctf-wiki/streamcipher/lcg/challenge/#_1","text":"","title":"\u9898"},{"location":"crypto/ctf-wiki/streamcipher/lcg/challenge/#2016-google-ctf-woodman","text":"The approximate meaning of the program is a guessing game. If you guess a number of times in a row, even if you get the flag, the core code behind the corresponding number is as follows: class SecurePrng ( object ): def __init__ ( self ): # generate seed with 64 bits of entropy self . p = 4646704883 L self . x = random . randint ( 0 , self . p ) self . y = random . randint ( 0 , self . p ) def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) Here we obviously, we guessed that the first two rounds are still relatively easy, after all, the probability is also 0.25. Here, after we guessed the first two rounds, we used Z3 to solve the initial x and y, then we can easily guess the remaining values. The specific script is as follows, but Z3 seems to be problematic when solving such problems. . . Here we consider another method, ** sequentially extracting the value of x from the low-bit enumeration to the high-bit bit. The reason for this is that it depends on such observation. a + b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because the i-th bit is operated, only the carry value of the low bit may be received. a - b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because the i-th bit is operated, there is only a possible borrow from the low bit. a * b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple additions. a % b = c, the value of the ith bit of c is only affected by the a and b bits and lower bits. Because this can be seen as multiple subtractions. a ^ b = c, the value of the ith bit of c is only affected by the bits a and b. This is obvious. Note: Personally feel this technique is very useful. In addition, it is not difficult to know that the bit of p is 33 bits. The specific use ideas are as follows First get the value you guessed twice, this probability is 0.25. In turn, enumerate the corresponding bits of x after the first iteration from the low bit to the high bit. Calculate the second value according to the value of the enumeration. Only when the corresponding bit is correct, you can add it to the candidate correct value. It should be noted that due to the modulo, we need to reduce the number of enumerations in the end. In addition, in the final judgment, it is still necessary to ensure that the corresponding value meets certain requirements, because the number of reductions has been enumerated before. The specific use code is as follows import import random from itertools import product class SecurePrng ( object ): def __init__ ( self , x =- 1 , y =- 1 ): # generate seed with 64 bits of entropy self . p = 4646704883 L # 33bit if x == - 1 : self . x = random . randint ( 0 , self . p ) else : self . x = x if y == - 1 : self . y = random . randint ( 0 , self . p ) else : self . y = and def next ( self ): self . x = ( 2 * self . x + 3 ) % self . p self . y = ( 3 * self . y + 9 ) % self . p return ( self . x ^ self . y ) def getbiti ( num , idx ): return bin ( num )[ - idx - 1 :] def main (): sp = SecurePrng () targetx = sp . x targety = sp . y print \"we would like to get x \" , targetx print \"we would like to get y \" , targety # suppose we have already guess two number guess1 = sp . next () guess2 = sp . next () p = 4646704883 # newx = tmpx*2+3-kx*p for kx , ky in product ( range ( 3 ), range ( 4 )): candidate = [[ 0 ]] # only 33 bit for i in range ( 33 ): #print 'idx ', i new_candidate = [] for old , bit in product ( candidate , range ( 2 )): #print old, bit oldx = old [ 0 ] #oldy = old[1] tmpx = oldx | (( bit & 1 ) << i ) #tmpy = oldy | ((bit / 2) << i) tmpy = tmpx ^ guess1 newx = tmpx * 2 + 3 - kx * p + ( 1 << 40 ) newy = tmpy * 3 + 9 - ky * p + ( 1 & lt ; & lt ; 40 ) tmp1 = newx ^ newy #print \"tmpx: \", bin(tmpx) #print \"targetx: \", bin(targetx) #print \"calculate: \", bin(tmp1 + (1 << 40)) #print \"target guess2: \", bin(guess1 + (1 << 40)) if getbiti ( guess2 + ( 1 << 40 ), i ) == getbiti ( tmp1 + ( 1 & lt ; & lt ; 40 ), i ): if [ tmpx ] not in new_candidate : #print \"got one\" #print bin(tmpx) #print bin(targetx) #print bin(tmpy) new_candidate . append ([ tmpx ]) candidate = new_candidate #print len (candidate) #print candidate print \"candidate x for kx: \" , kx , \" ky \" , ky for item in candidate : tmpx = candidate [ 0 ][ 0 ] tmpy = tmpx ^ guess1 if tmpx >= p or tmpx >= p : continue mysp = SecurePrng ( tmpx , tmpy ) tmp1 = mysp . next () if tmp1 != guess2 : continue print tmpx , tmpy print ( targetx * 2 + 3 ) % p , ( targety * 3 + 9 ) % p if __name__ == \"__main__\" : main ()","title":"2016 Google CTF woodman"},{"location":"crypto/ctf-wiki/streamcipher/lcg/intro-zh/","text":"EN | ZH \u7ebf\u6027\u540c\u4f59\u751f\u6210\u5668 \u00b6 \u5f85\u8865\u5145\u3002","title":"Intro zh"},{"location":"crypto/ctf-wiki/streamcipher/lcg/intro-zh/#_1","text":"\u5f85\u8865\u5145\u3002","title":"\u7ebf\u6027\u540c\u4f59\u751f\u6210\u5668"},{"location":"crypto/ctf-wiki/streamcipher/lcg/intro/","text":"EN | ZH Linear Congruence Generator \u00b6 To be added.","title":"\u7b80\u4ecb"},{"location":"crypto/ctf-wiki/streamcipher/lcg/intro/#linear-congruence-generator","text":"To be added.","title":"Linear Congruence Generator"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng-zh/","text":"EN | ZH \u5bc6\u7801\u5b89\u5168\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668 \u00b6 \u4ecb\u7ecd \u00b6 \u5bc6\u7801\u5b66\u5b89\u5168\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\uff08cryptographically secure pseudo-random number generator\uff0cCSPRNG\uff09\uff0c\u4e5f\u79f0\u4e3a\u5bc6\u7801\u5b66\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\uff08cryptographic pseudo-random number generator\uff0cCPRNG)\uff0c\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u3002\u5b83\u9700\u8981\u6ee1\u8db3\u6ee1\u8db3\u4e00\u4e9b\u5fc5\u8981\u7684\u7279\u6027\uff0c\u4ee5\u4fbf\u4e8e\u9002\u5408\u4e8e\u5bc6\u7801\u5b66\u5e94\u7528\u3002 \u5bc6\u7801\u5b66\u7684\u5f88\u591a\u65b9\u9762\u90fd\u9700\u8981\u968f\u673a\u6570 \u5bc6\u94a5\u751f\u6210 \u751f\u6210\u521d\u59cb\u5316\u5411\u91cf\uff0cIV\uff0c\u7528\u4e8e\u5206\u7ec4\u5bc6\u7801\u7684 CBC\uff0cCFB\uff0cOFB \u6a21\u5f0f nounce\uff0c\u7528\u4e8e\u9632\u6b62\u91cd\u653e\u653b\u51fb\u4ee5\u53ca\u5206\u7ec4\u5bc6\u7801\u7684 CTR \u6a21\u5f0f\u7b49\u3001 one-time pads \u67d0\u4e9b\u7b7e\u540d\u65b9\u6848\u4e2d\u7684\u76d0\uff0c\u5982 ECDSA \uff0c RSASSA-PSS \u9700\u6c42 \u00b6 \u6beb\u65e0\u7591\u95ee\uff0c\u5bc6\u7801\u5b66\u5b89\u5168\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u7684\u8981\u6c42\u80af\u5b9a\u6bd4\u4e00\u822c\u7684\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u8981\u9ad8\u3002\u4e00\u822c\u800c\u8a00\uff0cCSPRNG \u7684\u8981\u6c42\u53ef\u4ee5\u5206\u4e3a\u4e24\u7c7b \u901a\u8fc7\u7edf\u8ba1\u968f\u673a\u6027\u6d4b\u8bd5\u3002CSPRNG \u5fc5\u987b\u901a\u8fc7 next-bit test \uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u77e5\u9053\u4e86\u4e00\u4e2a\u5e8f\u5217\u7684\u524d k \u4e2a\u6bd4\u7279\uff0c\u653b\u51fb\u8005\u4e0d\u53ef\u80fd\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u5185\u4ee5\u5927\u4e8e 50% \u7684\u6982\u7387\u9884\u6d4b\u51fa\u6765\u4e0b\u4e00\u4e2a\u6bd4\u7279\u4f4d\u3002\u8fd9\u91cc\u7279\u522b\u63d0\u53ca\u4e00\u70b9\uff0c\u59da\u671f\u667a\u66fe\u5728 1982 \u5e74\u8bc1\u660e\uff0c\u5982\u679c\u4e00\u4e2a\u751f\u6210\u5668\u53ef\u4ee5\u901a\u8fc7 next-bit test \uff0c\u90a3\u4e48\u5b83\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6240\u6709\u5176\u4ed6\u7684\u591a\u9879\u5f0f\u65f6\u95f4\u7edf\u8ba1\u6d4b\u8bd5\u3002 \u5fc5\u987b\u80fd\u591f\u62b5\u6297\u8db3\u591f\u5f3a\u7684\u653b\u51fb\uff0c\u6bd4\u5982\u5f53\u751f\u6210\u5668\u7684\u90e8\u5206\u521d\u59cb\u72b6\u6001\u6216\u8005\u8fd0\u884c\u65f6\u7684\u72b6\u6001\u88ab\u653b\u51fb\u8005\u83b7\u77e5\u65f6\uff0c\u653b\u51fb\u8005\u4ecd\u7136\u4e0d\u80fd\u591f\u83b7\u53d6\u6cc4\u6f0f\u72b6\u6001\u4e4b\u524d\u7684\u751f\u6210\u7684\u968f\u673a\u6570\u3002 \u5206\u7c7b \u00b6 \u5c31\u76ee\u524d\u800c\u770b\uff0c CSPRNG \u7684\u8bbe\u8ba1\u53ef\u4ee5\u5206\u4e3a\u4ee5\u4e0b\u4e09\u7c7b \u57fa\u4e8e\u5bc6\u7801\u5b66\u7b97\u6cd5\uff0c\u5982\u5bc6\u6587\u6216\u8005\u54c8\u5e0c\u503c\u3002 \u57fa\u4e8e\u6570\u5b66\u96be\u9898 \u67d0\u4e9b\u7279\u6b8a\u76ee\u7684\u7684\u8bbe\u8ba1 \u53c2\u8003\u6587\u732e \u00b6 https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator","title":"Csprng zh"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng-zh/#_1","text":"","title":"\u5bc6\u7801\u5b89\u5168\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng-zh/#_2","text":"\u5bc6\u7801\u5b66\u5b89\u5168\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\uff08cryptographically secure pseudo-random number generator\uff0cCSPRNG\uff09\uff0c\u4e5f\u79f0\u4e3a\u5bc6\u7801\u5b66\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\uff08cryptographic pseudo-random number generator\uff0cCPRNG)\uff0c\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u3002\u5b83\u9700\u8981\u6ee1\u8db3\u6ee1\u8db3\u4e00\u4e9b\u5fc5\u8981\u7684\u7279\u6027\uff0c\u4ee5\u4fbf\u4e8e\u9002\u5408\u4e8e\u5bc6\u7801\u5b66\u5e94\u7528\u3002 \u5bc6\u7801\u5b66\u7684\u5f88\u591a\u65b9\u9762\u90fd\u9700\u8981\u968f\u673a\u6570 \u5bc6\u94a5\u751f\u6210 \u751f\u6210\u521d\u59cb\u5316\u5411\u91cf\uff0cIV\uff0c\u7528\u4e8e\u5206\u7ec4\u5bc6\u7801\u7684 CBC\uff0cCFB\uff0cOFB \u6a21\u5f0f nounce\uff0c\u7528\u4e8e\u9632\u6b62\u91cd\u653e\u653b\u51fb\u4ee5\u53ca\u5206\u7ec4\u5bc6\u7801\u7684 CTR \u6a21\u5f0f\u7b49\u3001 one-time pads \u67d0\u4e9b\u7b7e\u540d\u65b9\u6848\u4e2d\u7684\u76d0\uff0c\u5982 ECDSA \uff0c RSASSA-PSS","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng-zh/#_3","text":"\u6beb\u65e0\u7591\u95ee\uff0c\u5bc6\u7801\u5b66\u5b89\u5168\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u7684\u8981\u6c42\u80af\u5b9a\u6bd4\u4e00\u822c\u7684\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u8981\u9ad8\u3002\u4e00\u822c\u800c\u8a00\uff0cCSPRNG \u7684\u8981\u6c42\u53ef\u4ee5\u5206\u4e3a\u4e24\u7c7b \u901a\u8fc7\u7edf\u8ba1\u968f\u673a\u6027\u6d4b\u8bd5\u3002CSPRNG \u5fc5\u987b\u901a\u8fc7 next-bit test \uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u77e5\u9053\u4e86\u4e00\u4e2a\u5e8f\u5217\u7684\u524d k \u4e2a\u6bd4\u7279\uff0c\u653b\u51fb\u8005\u4e0d\u53ef\u80fd\u5728\u591a\u9879\u5f0f\u65f6\u95f4\u5185\u4ee5\u5927\u4e8e 50% \u7684\u6982\u7387\u9884\u6d4b\u51fa\u6765\u4e0b\u4e00\u4e2a\u6bd4\u7279\u4f4d\u3002\u8fd9\u91cc\u7279\u522b\u63d0\u53ca\u4e00\u70b9\uff0c\u59da\u671f\u667a\u66fe\u5728 1982 \u5e74\u8bc1\u660e\uff0c\u5982\u679c\u4e00\u4e2a\u751f\u6210\u5668\u53ef\u4ee5\u901a\u8fc7 next-bit test \uff0c\u90a3\u4e48\u5b83\u4e5f\u53ef\u4ee5\u901a\u8fc7\u6240\u6709\u5176\u4ed6\u7684\u591a\u9879\u5f0f\u65f6\u95f4\u7edf\u8ba1\u6d4b\u8bd5\u3002 \u5fc5\u987b\u80fd\u591f\u62b5\u6297\u8db3\u591f\u5f3a\u7684\u653b\u51fb\uff0c\u6bd4\u5982\u5f53\u751f\u6210\u5668\u7684\u90e8\u5206\u521d\u59cb\u72b6\u6001\u6216\u8005\u8fd0\u884c\u65f6\u7684\u72b6\u6001\u88ab\u653b\u51fb\u8005\u83b7\u77e5\u65f6\uff0c\u653b\u51fb\u8005\u4ecd\u7136\u4e0d\u80fd\u591f\u83b7\u53d6\u6cc4\u6f0f\u72b6\u6001\u4e4b\u524d\u7684\u751f\u6210\u7684\u968f\u673a\u6570\u3002","title":"\u9700\u6c42"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng-zh/#_4","text":"\u5c31\u76ee\u524d\u800c\u770b\uff0c CSPRNG \u7684\u8bbe\u8ba1\u53ef\u4ee5\u5206\u4e3a\u4ee5\u4e0b\u4e09\u7c7b \u57fa\u4e8e\u5bc6\u7801\u5b66\u7b97\u6cd5\uff0c\u5982\u5bc6\u6587\u6216\u8005\u54c8\u5e0c\u503c\u3002 \u57fa\u4e8e\u6570\u5b66\u96be\u9898 \u67d0\u4e9b\u7279\u6b8a\u76ee\u7684\u7684\u8bbe\u8ba1","title":"\u5206\u7c7b"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng-zh/#_5","text":"https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng/","text":"EN | ZH \u5bc6\u7801\u5b89\u5168 pseudo-random number generator \u00b6 Introduction \u00b6 The cryptographically secure pseudo-random number generator (CSPRNG), also known as the cryptographic pseudo-random number generator (CPRNG), is a special pseudo-random number generation. Device. It needs to meet some of the necessary features to be suitable for cryptographic applications. Many aspects of cryptography require random numbers Key generation Generate initialization vector, IV, CBC, CFB, OFB mode for grouping passwords nounce, used to prevent replay attacks and CTR mode of block ciphers, etc. one-time pads Salt in some signature schemes, such as [ECDSA] ( https://en.wikipedia.org/wiki/ECDSA ), [RSASSA-PSS] ( https://en.wikipedia.org/w/index.php ?title=RSASSA-PSS&action=edit&redlink=1) demand \u00b6 There is no doubt that the requirements for cryptographically secure pseudo-random number generators are certainly higher than for general pseudo-random number generators. In general, CSPRNG requirements can be divided into two categories. Pass the statistical randomness test. CSPRNG must pass [next-bit test] ( https://en.wikipedia.org/wiki/Next-bit_test ), that is, knowing the first k bits of a sequence, it is impossible for an attacker to A probability greater than 50% predicts the next bit. One point mentioned here is that Yao Zhizhi proved in 1982 that if a generator can pass [next-bit test] ( https://en.wikipedia.org/wiki/Next-bit_test ), then it can also pass all other Polynomial time statistics test. Must be able to resist strong enough attacks, such as when the initial state of the generator or the state of the runtime is known to the attacker, the attacker is still unable to obtain the generated random number before the leak state. Categories \u00b6 As far as the current situation is concerned, the design of CSPRNG can be divided into the following three categories. Based on cryptographic algorithms such as ciphertext or hash values. Based on math problems Some special purpose designs references \u00b6 https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator","title":"\u5bc6\u7801\u5b66\u5b89\u5168\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng/#pseudo-random-number-generator","text":"","title":"\u5bc6\u7801\u5b89\u5168 pseudo-random number generator"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng/#introduction","text":"The cryptographically secure pseudo-random number generator (CSPRNG), also known as the cryptographic pseudo-random number generator (CPRNG), is a special pseudo-random number generation. Device. It needs to meet some of the necessary features to be suitable for cryptographic applications. Many aspects of cryptography require random numbers Key generation Generate initialization vector, IV, CBC, CFB, OFB mode for grouping passwords nounce, used to prevent replay attacks and CTR mode of block ciphers, etc. one-time pads Salt in some signature schemes, such as [ECDSA] ( https://en.wikipedia.org/wiki/ECDSA ), [RSASSA-PSS] ( https://en.wikipedia.org/w/index.php ?title=RSASSA-PSS&action=edit&redlink=1)","title":"Introduction"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng/#demand","text":"There is no doubt that the requirements for cryptographically secure pseudo-random number generators are certainly higher than for general pseudo-random number generators. In general, CSPRNG requirements can be divided into two categories. Pass the statistical randomness test. CSPRNG must pass [next-bit test] ( https://en.wikipedia.org/wiki/Next-bit_test ), that is, knowing the first k bits of a sequence, it is impossible for an attacker to A probability greater than 50% predicts the next bit. One point mentioned here is that Yao Zhizhi proved in 1982 that if a generator can pass [next-bit test] ( https://en.wikipedia.org/wiki/Next-bit_test ), then it can also pass all other Polynomial time statistics test. Must be able to resist strong enough attacks, such as when the initial state of the generator or the state of the runtime is known to the attacker, the attacker is still unable to obtain the generated random number before the leak state.","title":"demand"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng/#categories","text":"As far as the current situation is concerned, the design of CSPRNG can be divided into the following three categories. Based on cryptographic algorithms such as ciphertext or hash values. Based on math problems Some special purpose designs","title":"Categories"},{"location":"crypto/ctf-wiki/streamcipher/prng/csprng/#references","text":"https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator","title":"references"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/","text":"EN | ZH \u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u4ecb\u7ecd \u00b6 \u6982\u8ff0 \u00b6 \u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\uff08pseudorandom number generator\uff0cPRNG\uff09\uff0c\u53c8\u79f0\u4e3a\u786e\u5b9a\u6027\u968f\u673a\u4f4d\u751f\u6210\u5668\uff08deterministic random bit generator\uff0cDRBG\uff09\uff0c\u662f\u7528\u6765\u751f\u6210 \u63a5\u8fd1\u4e8e\u7edd\u5bf9\u968f\u673a\u6570\u5e8f\u5217\u7684\u6570\u5b57\u5e8f\u5217 \u7684\u7b97\u6cd5\u3002\u4e00\u822c\u6765\u8bf4\uff0cPRNG \u4f1a\u4f9d\u8d56\u4e8e\u4e00\u4e2a\u521d\u59cb\u503c\uff0c\u4e5f\u79f0\u4e3a\u79cd\u5b50\uff0c\u6765\u751f\u6210\u5bf9\u5e94\u7684\u4f2a\u968f\u673a\u6570\u5e8f\u5217\u3002\u53ea\u8981\u79cd\u5b50\u786e\u5b9a\u4e86\uff0cPRNG \u6240\u751f\u6210\u7684\u968f\u673a\u6570\u5c31\u662f\u5b8c\u5168\u786e\u5b9a\u7684\uff0c\u56e0\u6b64\u5176\u751f\u6210\u7684\u968f\u673a\u6570\u5e8f\u5217\u5e76\u4e0d\u662f\u771f\u6b63\u968f\u673a\u7684\u3002 \u5c31\u76ee\u524d\u800c\u8a00\uff0cPRNG \u5728\u4f17\u591a\u5e94\u7528\u90fd\u53d1\u6325\u7740\u91cd\u8981\u7684\u4f5c\u7528\uff0c\u6bd4\u5982\u6a21\u62df\uff08\u8499\u7279\u5361\u6d1b\u65b9\u6cd5\uff09\uff0c\u7535\u5b50\u7ade\u6280\uff0c\u5bc6\u7801\u5e94\u7528\u3002 \u968f\u673a\u6027\u7684\u4e25\u683c\u6027 \u00b6 \u968f\u673a\u6027\uff1a\u968f\u673a\u6570\u5e94\u8be5\u4e0d\u5b58\u5728\u7edf\u8ba1\u5b66\u504f\u5dee\uff0c\u662f\u5b8c\u5168\u6742\u4e71\u7684\u6570\u5217\u3002 \u4e0d\u53ef\u9884\u6d4b\u6027\uff1a\u4e0d\u80fd\u4ece\u8fc7\u53bb\u7684\u5e8f\u5217\u63a8\u6d4b\u51fa\u4e0b\u4e00\u4e2a\u51fa\u73b0\u7684\u6570\u3002 \u4e0d\u53ef\u91cd\u73b0\u6027\uff1a\u9664\u975e\u6570\u5217\u4fdd\u5b58\u4e0b\u6765\uff0c\u5426\u5219\u4e0d\u80fd\u91cd\u73b0\u76f8\u540c\u7684\u6570\u5217\u3002 \u8fd9\u4e09\u4e2a\u6027\u8d28\u7684\u4e25\u683c\u6027\u4f9d\u6b21\u9012\u589e\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u968f\u673a\u6570\u53ef\u4ee5\u5206\u4e3a\u4e09\u7c7b \u7c7b\u522b \u968f\u673a\u6027 \u4e0d\u53ef\u9884\u6d4b\u6027 \u4e0d\u53ef\u91cd\u73b0\u6027 \u5f31\u4f2a\u968f\u673a\u6570 \u2705 \u274c \u274c \u5f3a\u4f2a\u968f\u673a\u6570 \u2705 \u2705 \u274c \u771f\u968f\u673a\u6570 \u2705 \u2705 \u2705 \u4e00\u822c\u6765\u8bf4\uff0c\u5bc6\u7801\u5b66\u4e2d\u4f7f\u7528\u7684\u968f\u673a\u6570\u662f\u7b2c\u4e8c\u79cd\u3002 \u5468\u671f \u00b6 \u6b63\u5982\u6211\u4eec\u4e4b\u524d\u6240\u8bf4\uff0c\u4e00\u65e6 PRNG \u6240\u4f9d\u8d56\u7684\u79cd\u5b50\u786e\u5b9a\u4e86\uff0c\u90a3\u4e48 PRNG \u751f\u6210\u7684\u968f\u673a\u6570\u5e8f\u5217\u57fa\u672c\u4e5f\u5c31\u786e\u5b9a\u4e86\u3002\u8fd9\u91cc\u5b9a\u4e49 PRNG \u7684\u5468\u671f\u5982\u4e0b\uff1a\u5bf9\u4e8e\u4e00\u4e2a PRNG \u7684 \u6240\u6709\u53ef\u80fd\u8d77\u59cb\u72b6\u6001 \uff0c\u4e0d\u91cd\u590d\u5e8f\u5217\u7684\u6700\u957f\u957f\u5ea6\u3002\u663e\u7136\uff0c\u5bf9\u4e8e\u4e00\u4e2a PRNG \u6765\u8bf4\uff0c\u5176\u5468\u671f\u4e0d\u4f1a\u5927\u4e8e\u5176\u6240\u6709\u53ef\u80fd\u7684\u72b6\u6001\u3002\u4f46\u662f\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5e76\u4e0d\u662f\u5f53\u6211\u4eec\u9047\u5230\u91cd\u590d\u7684\u8f93\u51fa\u65f6\uff0c\u5c31\u53ef\u4ee5\u8ba4\u4e3a\u662f PRNG \u7684\u5468\u671f\uff0c\u56e0\u4e3a PRNG \u7684\u72b6\u6001\u4e00\u822c\u90fd\u662f\u5927\u4e8e\u8f93\u51fa\u7684\u4f4d\u6570\u7684\u3002 \u8bc4\u4ef7\u6807\u51c6 \u00b6 \u53c2\u89c1\u7ef4\u57fa\u767e\u79d1\uff0c https://en.wikipedia.org/wiki/Pseudorandom_number_generator \u3002 \u5206\u7c7b \u00b6 \u76ee\u524d\u901a\u7528\u7684\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u4e3b\u8981\u6709 \u7ebf\u6027\u540c\u4f59\u751f\u6210\u5668\uff0cLCG \u7ebf\u6027\u56de\u5f52\u53d1\u751f\u5668 Mersenne Twister xorshift generators WELL family of generators Linear feedback shift register\uff0cLFSR\uff0c\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668 \u95ee\u9898 \u00b6 \u901a\u5e38\u6765\u8bf4\uff0c\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u53ef\u80fd\u4f1a\u6709\u4ee5\u4e0b\u95ee\u9898 \u5728\u67d0\u4e9b\u79cd\u5b50\u7684\u60c5\u51b5\u4e0b\uff0c\u5176\u751f\u6210\u7684\u968f\u673a\u6570\u5e8f\u5217\u7684\u5468\u671f\u4f1a\u6bd4\u8f83\u5c0f\u3002 \u751f\u6210\u5927\u6570\u65f6\uff0c\u5206\u914d\u7684\u4e0d\u5747\u5300\u3002 \u8fde\u7eed\u503c\u4e4b\u95f4\u5173\u8054\u5bc6\u5207\uff0c\u77e5\u9053\u540e\u7eed\u503c\uff0c\u53ef\u4ee5\u77e5\u9053\u4e4b\u524d\u7684\u503c\u3002 \u8f93\u51fa\u5e8f\u5217\u7684\u503c\u7684\u5927\u5c0f\u5f88\u4e0d\u5747\u5300\u3002 \u53c2\u8003 \u00b6 https://en.wikipedia.org/wiki/Pseudorandom_number_generator","title":"Intro zh"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/#_1","text":"","title":"\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/#_2","text":"\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\uff08pseudorandom number generator\uff0cPRNG\uff09\uff0c\u53c8\u79f0\u4e3a\u786e\u5b9a\u6027\u968f\u673a\u4f4d\u751f\u6210\u5668\uff08deterministic random bit generator\uff0cDRBG\uff09\uff0c\u662f\u7528\u6765\u751f\u6210 \u63a5\u8fd1\u4e8e\u7edd\u5bf9\u968f\u673a\u6570\u5e8f\u5217\u7684\u6570\u5b57\u5e8f\u5217 \u7684\u7b97\u6cd5\u3002\u4e00\u822c\u6765\u8bf4\uff0cPRNG \u4f1a\u4f9d\u8d56\u4e8e\u4e00\u4e2a\u521d\u59cb\u503c\uff0c\u4e5f\u79f0\u4e3a\u79cd\u5b50\uff0c\u6765\u751f\u6210\u5bf9\u5e94\u7684\u4f2a\u968f\u673a\u6570\u5e8f\u5217\u3002\u53ea\u8981\u79cd\u5b50\u786e\u5b9a\u4e86\uff0cPRNG \u6240\u751f\u6210\u7684\u968f\u673a\u6570\u5c31\u662f\u5b8c\u5168\u786e\u5b9a\u7684\uff0c\u56e0\u6b64\u5176\u751f\u6210\u7684\u968f\u673a\u6570\u5e8f\u5217\u5e76\u4e0d\u662f\u771f\u6b63\u968f\u673a\u7684\u3002 \u5c31\u76ee\u524d\u800c\u8a00\uff0cPRNG \u5728\u4f17\u591a\u5e94\u7528\u90fd\u53d1\u6325\u7740\u91cd\u8981\u7684\u4f5c\u7528\uff0c\u6bd4\u5982\u6a21\u62df\uff08\u8499\u7279\u5361\u6d1b\u65b9\u6cd5\uff09\uff0c\u7535\u5b50\u7ade\u6280\uff0c\u5bc6\u7801\u5e94\u7528\u3002","title":"\u6982\u8ff0"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/#_3","text":"\u968f\u673a\u6027\uff1a\u968f\u673a\u6570\u5e94\u8be5\u4e0d\u5b58\u5728\u7edf\u8ba1\u5b66\u504f\u5dee\uff0c\u662f\u5b8c\u5168\u6742\u4e71\u7684\u6570\u5217\u3002 \u4e0d\u53ef\u9884\u6d4b\u6027\uff1a\u4e0d\u80fd\u4ece\u8fc7\u53bb\u7684\u5e8f\u5217\u63a8\u6d4b\u51fa\u4e0b\u4e00\u4e2a\u51fa\u73b0\u7684\u6570\u3002 \u4e0d\u53ef\u91cd\u73b0\u6027\uff1a\u9664\u975e\u6570\u5217\u4fdd\u5b58\u4e0b\u6765\uff0c\u5426\u5219\u4e0d\u80fd\u91cd\u73b0\u76f8\u540c\u7684\u6570\u5217\u3002 \u8fd9\u4e09\u4e2a\u6027\u8d28\u7684\u4e25\u683c\u6027\u4f9d\u6b21\u9012\u589e\u3002 \u4e00\u822c\u6765\u8bf4\uff0c\u968f\u673a\u6570\u53ef\u4ee5\u5206\u4e3a\u4e09\u7c7b \u7c7b\u522b \u968f\u673a\u6027 \u4e0d\u53ef\u9884\u6d4b\u6027 \u4e0d\u53ef\u91cd\u73b0\u6027 \u5f31\u4f2a\u968f\u673a\u6570 \u2705 \u274c \u274c \u5f3a\u4f2a\u968f\u673a\u6570 \u2705 \u2705 \u274c \u771f\u968f\u673a\u6570 \u2705 \u2705 \u2705 \u4e00\u822c\u6765\u8bf4\uff0c\u5bc6\u7801\u5b66\u4e2d\u4f7f\u7528\u7684\u968f\u673a\u6570\u662f\u7b2c\u4e8c\u79cd\u3002","title":"\u968f\u673a\u6027\u7684\u4e25\u683c\u6027"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/#_4","text":"\u6b63\u5982\u6211\u4eec\u4e4b\u524d\u6240\u8bf4\uff0c\u4e00\u65e6 PRNG \u6240\u4f9d\u8d56\u7684\u79cd\u5b50\u786e\u5b9a\u4e86\uff0c\u90a3\u4e48 PRNG \u751f\u6210\u7684\u968f\u673a\u6570\u5e8f\u5217\u57fa\u672c\u4e5f\u5c31\u786e\u5b9a\u4e86\u3002\u8fd9\u91cc\u5b9a\u4e49 PRNG \u7684\u5468\u671f\u5982\u4e0b\uff1a\u5bf9\u4e8e\u4e00\u4e2a PRNG \u7684 \u6240\u6709\u53ef\u80fd\u8d77\u59cb\u72b6\u6001 \uff0c\u4e0d\u91cd\u590d\u5e8f\u5217\u7684\u6700\u957f\u957f\u5ea6\u3002\u663e\u7136\uff0c\u5bf9\u4e8e\u4e00\u4e2a PRNG \u6765\u8bf4\uff0c\u5176\u5468\u671f\u4e0d\u4f1a\u5927\u4e8e\u5176\u6240\u6709\u53ef\u80fd\u7684\u72b6\u6001\u3002\u4f46\u662f\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5e76\u4e0d\u662f\u5f53\u6211\u4eec\u9047\u5230\u91cd\u590d\u7684\u8f93\u51fa\u65f6\uff0c\u5c31\u53ef\u4ee5\u8ba4\u4e3a\u662f PRNG \u7684\u5468\u671f\uff0c\u56e0\u4e3a PRNG \u7684\u72b6\u6001\u4e00\u822c\u90fd\u662f\u5927\u4e8e\u8f93\u51fa\u7684\u4f4d\u6570\u7684\u3002","title":"\u5468\u671f"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/#_5","text":"\u53c2\u89c1\u7ef4\u57fa\u767e\u79d1\uff0c https://en.wikipedia.org/wiki/Pseudorandom_number_generator \u3002","title":"\u8bc4\u4ef7\u6807\u51c6"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/#_6","text":"\u76ee\u524d\u901a\u7528\u7684\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u4e3b\u8981\u6709 \u7ebf\u6027\u540c\u4f59\u751f\u6210\u5668\uff0cLCG \u7ebf\u6027\u56de\u5f52\u53d1\u751f\u5668 Mersenne Twister xorshift generators WELL family of generators Linear feedback shift register\uff0cLFSR\uff0c\u7ebf\u6027\u53cd\u9988\u79fb\u4f4d\u5bc4\u5b58\u5668","title":"\u5206\u7c7b"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/#_7","text":"\u901a\u5e38\u6765\u8bf4\uff0c\u4f2a\u968f\u673a\u6570\u751f\u6210\u5668\u53ef\u80fd\u4f1a\u6709\u4ee5\u4e0b\u95ee\u9898 \u5728\u67d0\u4e9b\u79cd\u5b50\u7684\u60c5\u51b5\u4e0b\uff0c\u5176\u751f\u6210\u7684\u968f\u673a\u6570\u5e8f\u5217\u7684\u5468\u671f\u4f1a\u6bd4\u8f83\u5c0f\u3002 \u751f\u6210\u5927\u6570\u65f6\uff0c\u5206\u914d\u7684\u4e0d\u5747\u5300\u3002 \u8fde\u7eed\u503c\u4e4b\u95f4\u5173\u8054\u5bc6\u5207\uff0c\u77e5\u9053\u540e\u7eed\u503c\uff0c\u53ef\u4ee5\u77e5\u9053\u4e4b\u524d\u7684\u503c\u3002 \u8f93\u51fa\u5e8f\u5217\u7684\u503c\u7684\u5927\u5c0f\u5f88\u4e0d\u5747\u5300\u3002","title":"\u95ee\u9898"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro-zh/#_8","text":"https://en.wikipedia.org/wiki/Pseudorandom_number_generator","title":"\u53c2\u8003"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/","text":"EN | ZH pseudo random number generator introduction \u00b6 Overview \u00b6 A pseudorandom number generator (PRNG), also known as a deterministic random bit generator (DRBG), is an algorithm used to generate a digital sequence** close to an absolute random number sequence. . In general, a PRNG relies on an initial value, also called a seed, to generate a corresponding pseudo-random number sequence. As long as the seed is determined, the random number generated by the PRNG is completely determined, so the sequence of random numbers it generates is not truly random. For now, PRNG plays an important role in many applications, such as simulation (Monte Carlo method), e-sports, and password applications. Randomness of rigor \u00b6 Randomness: Random numbers should be free of statistical bias and are completely messy series. Unpredictability: The next occurrence cannot be inferred from the past sequence. Non-reproducibility: The same sequence cannot be reproduced unless the sequence is saved. The stringency of these three properties increases in turn. In general, random numbers can be divided into three categories. Category Randomness Unpredictability Non-reproducibility | Weak pseudo-random number | \u2705 | \u274c | \u274c | | Strong pseudo-random number | \u2705 | \u2705 | \u274c | | Real random number | \u2705 | \u2705 | \u2705 | In general, the random number used in cryptography is the second. Cycle \u00b6 As we said before, once the seed that the PRNG depends on is determined, the sequence of random numbers generated by the PRNG is basically determined. The period in which the PRNG is defined here is as follows: For all possible starting states of a PRNG**, the longest length of the sequence is not repeated. Obviously, for a PRNG, its period will not be greater than all its possible states. However, it should be noted that not when we encounter repeated output, we can consider it to be the period of the PRNG, because the state of the PRNG is generally greater than the number of bits of the output. evaluation standard \u00b6 See Wikipedia, https://en.wikipedia.org/wiki/Pseudorandom_number_generator . Categories \u00b6 Currently, the common pseudo-random number generator mainly has Linear Congruence Generator, LCG Linear regression generator [Mersenne Twister] ( https://en.wikipedia.org/wiki/Mersenne_Twister ) xorshift generators WELL family of generators Linear feedback shift register, LFSR, linear feedback shift register problem \u00b6 In general, pseudo-random number generators may have the following problems In the case of some seeds, the period of the generated random number sequence will be smaller. Uneven distribution when generating large numbers. The continuous values are closely related, and the subsequent values are known, and the previous values can be known. The value of the output sequence is very uneven. Reference \u00b6 https://en.wikipedia.org/wiki/Pseudorandom_number_generator","title":"\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/#pseudo-random-number-generator-introduction","text":"","title":"pseudo random number generator introduction"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/#overview","text":"A pseudorandom number generator (PRNG), also known as a deterministic random bit generator (DRBG), is an algorithm used to generate a digital sequence** close to an absolute random number sequence. . In general, a PRNG relies on an initial value, also called a seed, to generate a corresponding pseudo-random number sequence. As long as the seed is determined, the random number generated by the PRNG is completely determined, so the sequence of random numbers it generates is not truly random. For now, PRNG plays an important role in many applications, such as simulation (Monte Carlo method), e-sports, and password applications.","title":"Overview"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/#randomness-of-rigor","text":"Randomness: Random numbers should be free of statistical bias and are completely messy series. Unpredictability: The next occurrence cannot be inferred from the past sequence. Non-reproducibility: The same sequence cannot be reproduced unless the sequence is saved. The stringency of these three properties increases in turn. In general, random numbers can be divided into three categories. Category Randomness Unpredictability Non-reproducibility | Weak pseudo-random number | \u2705 | \u274c | \u274c | | Strong pseudo-random number | \u2705 | \u2705 | \u274c | | Real random number | \u2705 | \u2705 | \u2705 | In general, the random number used in cryptography is the second.","title":"Randomness of rigor"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/#cycle","text":"As we said before, once the seed that the PRNG depends on is determined, the sequence of random numbers generated by the PRNG is basically determined. The period in which the PRNG is defined here is as follows: For all possible starting states of a PRNG**, the longest length of the sequence is not repeated. Obviously, for a PRNG, its period will not be greater than all its possible states. However, it should be noted that not when we encounter repeated output, we can consider it to be the period of the PRNG, because the state of the PRNG is generally greater than the number of bits of the output.","title":"Cycle"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/#evaluation-standard","text":"See Wikipedia, https://en.wikipedia.org/wiki/Pseudorandom_number_generator .","title":"evaluation standard"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/#categories","text":"Currently, the common pseudo-random number generator mainly has Linear Congruence Generator, LCG Linear regression generator [Mersenne Twister] ( https://en.wikipedia.org/wiki/Mersenne_Twister ) xorshift generators WELL family of generators Linear feedback shift register, LFSR, linear feedback shift register","title":"Categories"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/#problem","text":"In general, pseudo-random number generators may have the following problems In the case of some seeds, the period of the generated random number sequence will be smaller. Uneven distribution when generating large numbers. The continuous values are closely related, and the subsequent values are known, and the previous values can be known. The value of the output sequence is very uneven.","title":"problem"},{"location":"crypto/ctf-wiki/streamcipher/prng/intro/#reference","text":"https://en.wikipedia.org/wiki/Pseudorandom_number_generator","title":"Reference"},{"location":"crypto/ctf-wiki/streamcipher/prng/problem-zh/","text":"EN | ZH \u9898\u76ee \u00b6 2017 Tokyo Westerns CTF 3 rd Backpacker's Problem \u00b6 \u9898\u76ee\u4e2d\u7ed9\u4e86\u4e00\u4e2a cpp \u6587\u4ef6\uff0c\u5927\u6982\u610f\u601d\u5982\u4e0b Given the integers a_1, a_2, ..., a_N, your task is to find a subsequence b of a where b_1 + b_2 + ... + b_K = 0. Input Format: N a_1 a_2 ... a_N Answer Format: K b_1 b_2 ... b_K Example Input: 4 -8 -2 3 5 Example Answer: 3 -8 3 5 \u5373\u662f\u4e00\u4e2a\u80cc\u5305\u95ee\u9898\u3002\u5176\u4e2d\uff0c\u5728\u672c\u9898\u4e2d\uff0c\u6211\u4eec\u9700\u8981\u89e3\u51b3 20 \u4e2a\u8fd9\u6837\u7684\u80cc\u5305\u95ee\u9898\uff0c\u80cc\u5305\u5927\u5c0f\u4f9d\u6b21\u662f 1 * 10~20 * 10\u3002\u800c\u5b50\u96c6\u6c42\u548c\u7684\u80cc\u5305\u95ee\u9898\u662f\u4e00\u4e2a NPC \u95ee\u9898\uff0c\u95ee\u9898\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u968f\u7740\u968f\u7740\u80cc\u5305\u5927\u5c0f\u800c\u6307\u6570\u589e\u957f\u3002\u8fd9\u91cc\u80cc\u5305\u7684\u5927\u5c0f\u6700\u5927\u662f200\uff0c\u663e\u7136\u4e0d\u53ef\u80fd\u4f7f\u7528\u66b4\u529b\u7834\u89e3\u7684\u65b9\u5f0f\u3002 \u5f85\u5b8c\u6210 \u53c2\u8003\u6587\u732e \u00b6 https://github.com/r00ta/myWriteUps/tree/master/GoogleCTF/woodman http://mslc.ctf.su/wp/google-ctf-woodman-crypto-100/","title":"Problem zh"},{"location":"crypto/ctf-wiki/streamcipher/prng/problem-zh/#_1","text":"","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/streamcipher/prng/problem-zh/#2017-tokyo-westerns-ctf-3rd-backpackers-problem","text":"\u9898\u76ee\u4e2d\u7ed9\u4e86\u4e00\u4e2a cpp \u6587\u4ef6\uff0c\u5927\u6982\u610f\u601d\u5982\u4e0b Given the integers a_1, a_2, ..., a_N, your task is to find a subsequence b of a where b_1 + b_2 + ... + b_K = 0. Input Format: N a_1 a_2 ... a_N Answer Format: K b_1 b_2 ... b_K Example Input: 4 -8 -2 3 5 Example Answer: 3 -8 3 5 \u5373\u662f\u4e00\u4e2a\u80cc\u5305\u95ee\u9898\u3002\u5176\u4e2d\uff0c\u5728\u672c\u9898\u4e2d\uff0c\u6211\u4eec\u9700\u8981\u89e3\u51b3 20 \u4e2a\u8fd9\u6837\u7684\u80cc\u5305\u95ee\u9898\uff0c\u80cc\u5305\u5927\u5c0f\u4f9d\u6b21\u662f 1 * 10~20 * 10\u3002\u800c\u5b50\u96c6\u6c42\u548c\u7684\u80cc\u5305\u95ee\u9898\u662f\u4e00\u4e2a NPC \u95ee\u9898\uff0c\u95ee\u9898\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u968f\u7740\u968f\u7740\u80cc\u5305\u5927\u5c0f\u800c\u6307\u6570\u589e\u957f\u3002\u8fd9\u91cc\u80cc\u5305\u7684\u5927\u5c0f\u6700\u5927\u662f200\uff0c\u663e\u7136\u4e0d\u53ef\u80fd\u4f7f\u7528\u66b4\u529b\u7834\u89e3\u7684\u65b9\u5f0f\u3002 \u5f85\u5b8c\u6210","title":"2017 Tokyo Westerns CTF 3rd Backpacker's Problem"},{"location":"crypto/ctf-wiki/streamcipher/prng/problem-zh/#_2","text":"https://github.com/r00ta/myWriteUps/tree/master/GoogleCTF/woodman http://mslc.ctf.su/wp/google-ctf-woodman-crypto-100/","title":"\u53c2\u8003\u6587\u732e"},{"location":"crypto/ctf-wiki/streamcipher/prng/problem/","text":"EN | ZH \u9898 \u00b6 2017 Tokyo Westerns CTF 3 rd Backpacker's Problem \u00b6 A cpp file is given in the title, which probably means the following Given the integers a_1, a_2, ..., a_N, your task is to find a subsequence b of a where b_1 + b_2 + ... + b_K = 0. Input Format: N a_1 a_2 ... a_N Answer Format: K b_1 b_2 ... b_K Example Input: 4 -8 -2 3 5 Example Answer: 3 -8 3 5 It is a backpack problem. Among them, in this question, we need to solve 20 such backpack problems, the size of the backpack is 1 * 10 ~ 20 * 10 in order. The backpack problem of subset summation is an NPC problem, and the time complexity of the problem increases exponentially with the size of the backpack. The size of the backpack here is at most 200, and it is obviously impossible to use brute force. To be completed references \u00b6 https://github.com/r00ta/myWriteUps/tree/master/GoogleCTF/woodman http://mslc.ctf.su/wp/google-ctf-woodman-crypto-100/","title":"\u9898\u76ee"},{"location":"crypto/ctf-wiki/streamcipher/prng/problem/#_1","text":"","title":"\u9898"},{"location":"crypto/ctf-wiki/streamcipher/prng/problem/#2017-tokyo-westerns-ctf-3rd-backpackers-problem","text":"A cpp file is given in the title, which probably means the following Given the integers a_1, a_2, ..., a_N, your task is to find a subsequence b of a where b_1 + b_2 + ... + b_K = 0. Input Format: N a_1 a_2 ... a_N Answer Format: K b_1 b_2 ... b_K Example Input: 4 -8 -2 3 5 Example Answer: 3 -8 3 5 It is a backpack problem. Among them, in this question, we need to solve 20 such backpack problems, the size of the backpack is 1 * 10 ~ 20 * 10 in order. The backpack problem of subset summation is an NPC problem, and the time complexity of the problem increases exponentially with the size of the backpack. The size of the backpack here is at most 200, and it is obviously impossible to use brute force. To be completed","title":"2017 Tokyo Westerns CTF 3rd Backpacker's Problem"},{"location":"crypto/ctf-wiki/streamcipher/prng/problem/#references","text":"https://github.com/r00ta/myWriteUps/tree/master/GoogleCTF/woodman http://mslc.ctf.su/wp/google-ctf-woodman-crypto-100/","title":"references"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4-zh/","text":"EN | ZH RC4 \u00b6 \u57fa\u672c\u4ecb\u7ecd \u00b6 RSA \u7531 Ron Rivest \u8bbe\u8ba1\uff0c\u6700\u521d\u96b6\u5c5e\u4e8e RSA \u5b89\u5168\u516c\u53f8\uff0c\u662f\u4e00\u4e2a\u4e13\u5229\u5bc6\u7801\u4ea7\u54c1\u3002\u5b83\u662f\u9762\u5411\u5b57\u8282\u7684\u6d41\u5bc6\u7801\uff0c\u5bc6\u94a5\u957f\u5ea6\u53ef\u53d8\uff0c\u975e\u5e38\u7b80\u5355\uff0c\u4f46\u4e5f\u5f88\u6709\u6548\u679c\u3002RC4 \u7b97\u6cd5\u5e7f\u6cdb\u5e94\u7528\u4e8e SSL/TLS \u534f\u8bae\u548c WEP/WPA \u534f\u8bae\u3002 \u57fa\u672c\u6d41\u7a0b \u00b6 RC4 \u4e3b\u8981\u5305\u542b\u4e09\u4e2a\u6d41\u7a0b \u521d\u59cb\u5316 S \u548c T \u6570\u7ec4\u3002 \u521d\u59cb\u5316\u7f6e\u6362 S\u3002 \u751f\u6210\u5bc6\u94a5\u6d41\u3002 \u521d\u59cb\u5316 S \u548c T \u6570\u7ec4 \u00b6 \u521d\u59cb\u5316 S \u548c T \u7684\u4ee3\u7801\u5982\u4e0b for i = 0 to 255 do S [ i ] = i T [ i ] = K [ i mod keylen ]) \u521d\u59cb\u5316\u7f6e\u6362 S \u00b6 j = 0 for i = 0 to 255 do j = ( j + S [ i ] + T [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) \u751f\u6210\u6d41\u5bc6\u94a5 \u00b6 i = j = 0 for each message byte b i = ( i + 1 ) ( mod 256 ) j = ( j + S [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) t = ( S [ i ] + S [ j ]) ( mod 256 ) print S [ t ] \u6211\u4eec\u4e00\u822c\u79f0\u524d\u4e24\u90e8\u5206\u4e3a KSA \uff0c\u6700\u540e\u4e00\u90e8\u5206\u662f PRGA\u3002 \u653b\u51fb\u65b9\u6cd5 \u00b6 \u5f85\u8865\u5145\u3002","title":"Rc4 zh"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4-zh/#rc4","text":"","title":"RC4"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4-zh/#_1","text":"RSA \u7531 Ron Rivest \u8bbe\u8ba1\uff0c\u6700\u521d\u96b6\u5c5e\u4e8e RSA \u5b89\u5168\u516c\u53f8\uff0c\u662f\u4e00\u4e2a\u4e13\u5229\u5bc6\u7801\u4ea7\u54c1\u3002\u5b83\u662f\u9762\u5411\u5b57\u8282\u7684\u6d41\u5bc6\u7801\uff0c\u5bc6\u94a5\u957f\u5ea6\u53ef\u53d8\uff0c\u975e\u5e38\u7b80\u5355\uff0c\u4f46\u4e5f\u5f88\u6709\u6548\u679c\u3002RC4 \u7b97\u6cd5\u5e7f\u6cdb\u5e94\u7528\u4e8e SSL/TLS \u534f\u8bae\u548c WEP/WPA \u534f\u8bae\u3002","title":"\u57fa\u672c\u4ecb\u7ecd"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4-zh/#_2","text":"RC4 \u4e3b\u8981\u5305\u542b\u4e09\u4e2a\u6d41\u7a0b \u521d\u59cb\u5316 S \u548c T \u6570\u7ec4\u3002 \u521d\u59cb\u5316\u7f6e\u6362 S\u3002 \u751f\u6210\u5bc6\u94a5\u6d41\u3002","title":"\u57fa\u672c\u6d41\u7a0b"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4-zh/#s-t","text":"\u521d\u59cb\u5316 S \u548c T \u7684\u4ee3\u7801\u5982\u4e0b for i = 0 to 255 do S [ i ] = i T [ i ] = K [ i mod keylen ])","title":"\u521d\u59cb\u5316 S \u548c T \u6570\u7ec4"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4-zh/#s","text":"j = 0 for i = 0 to 255 do j = ( j + S [ i ] + T [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ])","title":"\u521d\u59cb\u5316\u7f6e\u6362 S"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4-zh/#_3","text":"i = j = 0 for each message byte b i = ( i + 1 ) ( mod 256 ) j = ( j + S [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) t = ( S [ i ] + S [ j ]) ( mod 256 ) print S [ t ] \u6211\u4eec\u4e00\u822c\u79f0\u524d\u4e24\u90e8\u5206\u4e3a KSA \uff0c\u6700\u540e\u4e00\u90e8\u5206\u662f PRGA\u3002","title":"\u751f\u6210\u6d41\u5bc6\u94a5"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4-zh/#_4","text":"\u5f85\u8865\u5145\u3002","title":"\u653b\u51fb\u65b9\u6cd5"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4/","text":"EN | ZH RC4 \u00b6 basic introduction \u00b6 Designed by Ron Rivest, RSA was originally part of RSA Security and is a patented cryptographic product. It is a byte-oriented stream cipher with a variable key length that is very simple, but it works. The RC4 algorithm is widely used in the SSL/TLS protocol and the WEP/WPA protocol. Basic Process \u00b6 RC4 mainly consists of three processes Initialize the S and T arrays. Initialize the replacement S. Generate a key stream. Initializing S and T arrays \u00b6 The code to initialize S and T is as follows for i = 0 to 255 do S [ i ] = i T [ i ] = K [ i mod keylen ]) Initialization replacement S \u00b6 j = 0 for i = 0 to 255 do j = ( j + S [ i ] + T [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) Generating a stream key \u00b6 i = j = 0 for each message byte b i = ( i + 1 ) ( toward 256 ) j = ( j + S [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) t = ( S [ i ] + S [ j ]) ( mod 256 ) print S [ t ] We generally refer to the first two parts as KSA and the last part to PRGA. Attack method \u00b6 To be added.","title":"RC4"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4/#rc4","text":"","title":"RC4"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4/#basic-introduction","text":"Designed by Ron Rivest, RSA was originally part of RSA Security and is a patented cryptographic product. It is a byte-oriented stream cipher with a variable key length that is very simple, but it works. The RC4 algorithm is widely used in the SSL/TLS protocol and the WEP/WPA protocol.","title":"basic introduction"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4/#basic-process","text":"RC4 mainly consists of three processes Initialize the S and T arrays. Initialize the replacement S. Generate a key stream.","title":"Basic Process"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4/#initializing-s-and-t-arrays","text":"The code to initialize S and T is as follows for i = 0 to 255 do S [ i ] = i T [ i ] = K [ i mod keylen ])","title":"Initializing S and T arrays"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4/#initialization-replacement-s","text":"j = 0 for i = 0 to 255 do j = ( j + S [ i ] + T [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ])","title":"Initialization replacement S"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4/#generating-a-stream-key","text":"i = j = 0 for each message byte b i = ( i + 1 ) ( toward 256 ) j = ( j + S [ i ]) ( mod 256 ) swap ( S [ i ], S [ j ]) t = ( S [ i ] + S [ j ]) ( mod 256 ) print S [ t ] We generally refer to the first two parts as KSA and the last part to PRGA.","title":"Generating a stream key"},{"location":"crypto/ctf-wiki/streamcipher/special/rc4/#attack-method","text":"To be added.","title":"Attack method"}]}