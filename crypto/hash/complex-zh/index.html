<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>Complex zh - 西山下,闻溪语,书心境</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Complex zh";
    var mkdocs_page_input_path = "crypto/hash/complex-zh.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> 西山下,闻溪语,书心境</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../..">Index</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Crypto</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../introduction/">密码学简介</a>
                </li>
                <li class="">
                    
    <span class="caption-text">基础数学知识</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../basic/introduction/">简介</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">古典密码</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../classical/introduction/">古典密码简介</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../classical/monoalphabetic/">单表代换加密</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../classical/polyalphabetic/">多表代换加密</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../classical/others/">其他类型加密</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../classical/summary/">总结</a>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">流密码</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../streamcipher/intro/">介绍</a>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">伪随机数生成器</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/prng/intro/">介绍</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/prng/csprng/">密码学安全伪随机数生成器</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/prng/problem/">题目</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">线性同余生成器</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/lcg/intro/">简介</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/lcg/challenge/">例题</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">反馈移位寄存器</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/fsr/intro/">介绍</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/fsr/lfsr/">线性反馈移位寄存器</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/fsr/nfsr/">非线性反馈移位寄存器</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">特殊流密码</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../streamcipher/special/rc4/">RC4</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">块加密</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../blockcipher/introduction/">块加密简介</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../blockcipher/arx-operations/">ARX</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../blockcipher/des/">DES</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../blockcipher/idea/">IDEA</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../blockcipher/aes.md">AES</a>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../blockcipher/simon-speck/">Simon and Speck</a>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">分组模式</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/introduction/">介绍</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/padding/">填充方式</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/ecb/">ECB</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/cbc/">CBC</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/pcbc/">PCBC</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/cfb/">CFB</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/ofb/">OFB</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/ctr/">CTR</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../blockcipher/mode/padding-oracle-attack/">Padding Oracle Attack</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="">
                    
    <span class="caption-text">非对称加密</span>
    <ul class="subnav">
                <li class="toctree-l3">
                    
    <a class="" href="../../asymmetric/introduction/">非对称加密简介</a>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">RSA</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_theory/">RSA 基本介绍</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_module_attack/">模数相关攻击</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_e_attack/">公钥指数相关攻击</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_d_attack/">私钥 d 相关攻击</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_coppersmith_attack.md">Coppersmith 相关攻击</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_chosen_plain_cipher/">选择明密文攻击</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_side_channel/">侧信道攻击</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_pkcs_attack/">Bleichenbacher 攻击</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/rsa/rsa_complex/">综合</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <a class="" href="../../asymmetric/knapsack/knapsack/">背包加密</a>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">离散对数相关</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/discrete-log/discrete-log/">离散对数</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/discrete-log/elgamal/">Elgamal</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/discrete-log/ecc/">ECC</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">格密码</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/lattice/overview/">格概述</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/lattice/introduction/">格介绍</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/lattice/lattice-reduction/">格基规约算法</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../asymmetric/lattice/cvp/">CVP</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">哈希函数</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../introduction/">哈希函数简介</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../md5/">MD5</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../sha1/">SHA1</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../fnv/">FNV</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../attack/">Hash Attack</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../complex/">综合</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">数字签名</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../signature/introduction/">数字签名简介</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../signature/rsa/">RSA 数字签名</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../signature/elgamal.md">ElGamal 数字签名</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../signature/dsa/">DSA 数字签名</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3">
                    
    <span class="caption-text">攻击思想总结</span>
    <ul class="subnav">
                <li class="toctree-l4">
                    
    <a class="" href="../../attack-summary/attack-mode/">简介</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../attack-summary/meet-in-the-middle/">中间相遇攻击</a>
                </li>
                <li class="toctree-l4">
                    
    <a class="" href="../../attack-summary/bit-attack/">比特攻击</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../../about/">About</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">西山下,闻溪语,书心境</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
    
    <li>Complex zh</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p><a href="../complex/">EN</a> | <a href="./">ZH</a></p>
<h1 id="_1">综合题目</h1>
<h2 id="2017-34c3-software_update">2017 34c3 Software_update</h2>
<p>可以看出，程序的大概意思是上传一个 zip 压缩包，然后对 signed_data 目录下的文件进行签名验证。其中，最后验证的手法是大概是将每一个文件进行 sha256 哈希，然后<strong>异或</strong>起来作为输入传递给 rsa 进行签名。如果通过验证的话，就会执行对应的 pre-copy.py 和 post-copy.py 文件。</p>
<p>很自然的想法是我们修改 pre-copy.py 或者 post-copy.py 文件，使其可以读取 flag，然后再次绕过签名即可。主要有两种思路</p>
<ol>
<li>根据给定的公钥文件获取对应的私钥，进而再修改文件后伪造签名，然后大概看了看公钥文件几乎不可破，所以这一点，基本上可以放弃。</li>
<li>修改对应文件后，利用<strong>异或的特性使得其哈希值仍然与原来相同</strong>，从而绕过签名检测。即使得 signed_data 目录下包含多个文件，使得这些文件的哈希值最后异或起来可以抵消修改 pre-copy.py 或者 post-copy.py文件所造成的哈希值的不同。</li>
</ol>
<p>这里，我们选择第二种方法，这里我们选择修改 pre-copy.py 文件，具体思路如下</p>
<ol>
<li>计算 pre-copy.py 的原 hash 值。</li>
<li>修改 pre-copy.py 文件，使其可以读取 flag。与此同时，计算新的 hash 值。将两者异或，求得异或差值 delta。</li>
<li>寻找一系列的文件，使其 hash 值异或起来正好为 delta。</li>
</ol>
<p>关键的步骤在于第三步，而其实这个文件可以看做是一个线性组合的问题，即寻找若干个 256 维01向量使其异或值为 delta。而 
$$
(F={0,1},F^{256},\oplus ,\cdot)
$$
是一个 256 维的向量空间。如果我们可以求得该向量空间的一个基，那么我们就可以求得该空间中任意指定值的所需要的向量。</p>
<p>我们可以使用 sage 来辅助我们求，如下</p>
<pre><code class="python"># generage the base of &lt;{0,1},F^256,xor,*&gt;
def gen_gf2_256_base():
    v = VectorSpace(GF(2), 256)
    tmphash = compute_file_hash(&quot;0.py&quot;, &quot;&quot;)
    tmphash_bin = hash2bin(tmphash)
    base = [tmphash_bin]
    filelist = ['0.py']
    print base
    s = v.subspace(base)
    dim = s.dimension()
    cnt = 1
    while dim != 256:
        tmpfile = str(cnt) + &quot;.py&quot;
        tmphash = compute_file_hash(tmpfile, &quot;&quot;)
        tmphash_bin = hash2bin(tmphash)
        old_dim = dim
        s = v.subspace(base + [tmphash_bin])
        dim = s.dimension()
        if dim &gt; old_dim:
            base += [tmphash_bin]
            filelist.append(tmpfile)
            print(&quot;dimension &quot; + str(s.dimension()))
        cnt += 1
        print(cnt)
    m = matrix(GF(2), 256, 256, base)
    m = m.transpose()
    return m, filelist
</code></pre>

<p>关于更加详细的解答，请参考 <code>exp.py</code>。</p>
<p>这里我修改 pre-copy 多输出  <code>!!!!come here!!!!</code> 字眼，如下</p>
<pre><code class="shell">➜  software_update git:(master) python3 installer.py now.zip
Preparing to copy data...
!!!!come here!!!!
Software update installed successfully.
</code></pre>

<p>参考文献</p>
<ul>
<li>https://sectt.github.io/writeups/34C3CTF/crypto_182_software_update/Readme</li>
<li>https://github.com/OOTS/34c3ctf/blob/master/software_update/solution/exploit.py</li>
</ul>
<h2 id="2019-36c3-sav-ls-l-aas">2019 36c3 SaV-ls-l-aaS</h2>
<p>这个题的分类是 Crypto&amp;Web，捋一下流程：</p>
<p>60601端口开着一个Web服务，题目描述给了连接方法：</p>
<pre><code class="bash">url='http://78.47.240.226:60601' &amp;&amp; ip=$(curl -s &quot;$url/ip&quot;) &amp;&amp; sig=$(curl -s -d &quot;cmd=ls -l&amp;ip=$ip&quot; &quot;$url/sign&quot;) &amp;&amp; curl --data-urlencode &quot;signature=$sig&quot; &quot;$url/exec&quot;
</code></pre>

<p>可以看到，先是访问 <code>/ip</code> 得到 ip，再向 <code>/sign</code> post 过去 ip 和我们要执行的命令，得到签名，最后向 <code>/exec</code> post signature 来执行命令。我们执行这一行可以发现回显了<code>ls -l</code>执行的结果，发现有个 flag.txt。</p>
<p>看源码，Web 服务是由 go 起的：</p>
<pre><code class="go">package main

import (
    &quot;bytes&quot;
    &quot;crypto/sha1&quot;
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
    &quot;time&quot;
)

func main() {
    m := http.NewServeMux()

    m.HandleFunc(&quot;/ip&quot;, func(w http.ResponseWriter, r *http.Request) {
        ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil {
            return
        }
        fmt.Fprint(w, ip)
    })

    m.HandleFunc(&quot;/sign&quot;, func(w http.ResponseWriter, r *http.Request) {
        ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil {
            return
        }
        remoteAddr := net.ParseIP(ip)
        if remoteAddr == nil {
            return
        }

        ip = r.PostFormValue(&quot;ip&quot;)
        signIP := net.ParseIP(ip)
        if signIP == nil || !signIP.Equal(remoteAddr) {
            fmt.Fprintln(w, &quot;lol, not ip :&gt;&quot;)
            return
        }

        cmd := r.PostFormValue(&quot;cmd&quot;)
        if cmd != &quot;ls -l&quot; {
            fmt.Fprintln(w, &quot;lol, nope :&gt;&quot;)
            return
        }

        msg := ip + &quot;|&quot; + cmd
        digest := sha1.Sum([]byte(msg))

        b := new(bytes.Buffer)
        err = json.NewEncoder(b).Encode(string(digest[:]))
        if err != nil {
            return
        }

        resp, err := http.Post(&quot;http://127.0.0.1/index.php?action=sign&quot;, &quot;application/json; charset=utf-8&quot;, b)
        if err != nil || resp.StatusCode != 200 {
            fmt.Fprintln(w, &quot;oops, hsm is down&quot;)
            return
        }

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil {
            fmt.Fprintln(w, &quot;oops, hsm is bodyless?&quot;)
            return
        }

        var signature string
        err = json.Unmarshal(body, &amp;signature)
        if err != nil {
            fmt.Fprintln(w, &quot;oops, hsm is jsonless?&quot;)
            return
        }

        fmt.Fprint(w, signature+msg)
    })

    m.HandleFunc(&quot;/exec&quot;, func(w http.ResponseWriter, r *http.Request) {
        ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil {
            return
        }
        remoteAddr := net.ParseIP(ip)
        if remoteAddr == nil {
            return
        }

        signature := r.PostFormValue(&quot;signature&quot;)
        digest := sha1.Sum([]byte(signature[172:]))

        b := new(bytes.Buffer)
        err = json.NewEncoder(b).Encode(signature[:172] + string(digest[:]))
        if err != nil {
            fmt.Fprintln(w, &quot;oops, json encode&quot;)
            return
        }

        resp, err := http.Post(&quot;http://127.0.0.1/index.php?action=verify&quot;, &quot;application/json; charset=utf-8&quot;, b)
        if err != nil || resp.StatusCode != 200 {
            fmt.Fprintln(w, &quot;oops, hsm is down?&quot;)
            return
        }

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil {
            fmt.Fprintln(w, &quot;oops, hsm is bodyless?&quot;)
            return
        }

        var valid bool
        err = json.Unmarshal(body, &amp;valid)
        if err != nil {
            fmt.Fprintln(w, &quot;oops, json unmarshal&quot;)
            return
        }

        if valid {
            t := strings.Split(signature[172:], &quot;|&quot;)
            if len(t) != 2 {
                fmt.Fprintln(w, &quot;oops, split&quot;)
            }

            signIP := net.ParseIP(t[0])
            if signIP == nil || !signIP.Equal(remoteAddr) {
                fmt.Fprintln(w, &quot;lol, not ip :&gt;&quot;)
                return
            }

            conn, err := net.DialTimeout(&quot;tcp&quot;, &quot;127.0.0.1:1024&quot;, 1*time.Second)
            if err != nil {
                fmt.Fprintln(w, &quot;oops, dial&quot;)
                return
            }
            fmt.Fprintf(conn, t[1]+&quot;\n&quot;)
            conn.(*net.TCPConn).CloseWrite()
            io.Copy(w, conn)
        }
    })

    s := &amp;http.Server{
        Addr:           &quot;:60601&quot;,
        Handler:        m,
        ReadTimeout:    5 * time.Second,
        WriteTimeout:   5 * time.Second,
        MaxHeaderBytes: 1 &lt;&lt; 20,
    }
    log.Fatal(s.ListenAndServe())
}

</code></pre>

<p>代码很容易看，限制了 cmd 只能是<code>ls -l</code>，其余不给签名，看样子我们是要伪造其他命令的签名来读flag，这里注意到签名和验签的过程是传给本地起的一个 php 来完成的，看一下这部分源码：</p>
<pre><code class="php">&lt;?php
define('ALGO', 'md5WithRSAEncryption');
$d = json_decode(file_get_contents('php://input'), JSON_THROW_ON_ERROR);

if ($_GET['action'] === 'sign'){
    $pkeyid = openssl_pkey_get_private(&quot;file:///var/www/private_key.pem&quot;);
    openssl_sign($d, $signature, $pkeyid, ALGO);
    echo json_encode(base64_encode($signature));
    openssl_free_key($pkeyid);
}
elseif ($_GET['action'] === 'verify') {
    $pkeyid = openssl_pkey_get_public(&quot;file:///var/www/public_key.pem&quot;);
    echo json_encode(openssl_verify(substr($d, 172), base64_decode(substr($d,0, 172)), $pkeyid, ALGO) === 1);
    openssl_free_key($pkeyid);
}

</code></pre>

<p>采用的是<code>md5WithRSAEncryption</code>的方式签名，本地试了一下，是把我们传入的 <code>$d</code> md5 后转为hex，填充到<code>0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff003020300c06082a864886f70d020505000410</code>后面，组成数字然后用RSA签名。</p>
<p>看样子整个逻辑找不到一点问题，用的都是标准库，基本无法攻击。有个思路是通过代理更换 ip，可以拿到两个 ip|ls -l 的签名，这样我们就拥有了两组 RSA 的 m 和 c，因为题目给了 dockerfile 给了生成公私钥的方法，使用 openssl 默认生成，e为65537，那么我们可以通过求公因数的方式来求出 n。</p>
<p>在得到两组签名后，我们要得到 RSA 的m，就是填充后的数，所以按照代码逻辑，在 go 里面先是 sha1:</p>
<pre><code class="go">msg := ip + &quot;|&quot; + cmd
digest := sha1.Sum([]byte(msg))

b := new(bytes.Buffer)
err = json.NewEncoder(b).Encode(string(digest[:]))
</code></pre>

<p>再 php 里的 md5，得到两组 m 和 c，但是总是求不出公因数 n，怀疑求的 m 不对。看代码发现 go 里把 sha1的结果用 json 编码，然后传到 php里 json 解码。这部分非常可疑，为何要用 json 编码（用 hex 传过去它不香么），本地搭一下环境跟一下。（题目给了dockerfile）</p>
<p>起个docker，改一下 index.php，加一个<code>var_dump($d);</code>，再改一下 go，返回一下 php 的结果：</p>
<pre><code class="go">fmt.Fprintln(w,string(body))
</code></pre>

<p>现在让程序签名，返回结果：</p>
<pre><code>string(38) &quot;   ��.���?-�KC��@�&quot;
&quot;K4FEmxz4yuTsjDAbRZQmHJ+MBiCSGaOnpZTLbThXpCkDYe3siAIPfihX6ppjN2Tz6XqOr4tF\/u1\/+ccfhj8NNLIL+2hknyDXbosmMBV8mEGYsMqQHAE0f+3OhDWlzN5RnteSMYNZbTipFErB8ZOWCiXmynWxsqJhyaN9J6\/\/h6I=&quot;
oops, hsm is jsonless?
</code></pre>

<p>$d 竟然是长度为 38 的字符串，看来果然是这里编码有问题，我们需要看一下每个步骤的结果，先看一下 go 里 json编码后的 sha1 结果是什么：</p>
<pre><code class="go">package main

import (
    &quot;bytes&quot;
    &quot;crypto/sha1&quot;
    &quot;encoding/json&quot;
    &quot;fmt&quot;
)
func main() {
    msg := &quot;172.17.0.1|ls -l&quot;
    digest := sha1.Sum([]byte(msg))

    b := new(bytes.Buffer)
    json.NewEncoder(b).Encode(string(digest[:]))
    fmt.Print(string(b.Bytes()));
}
</code></pre>

<p>运行一下：</p>
<pre><code>&quot;\u000e\t\u001d\ufffd\u0012\ufffd.\ufffd\ufffd\ufffd?-\ufffdKC\ufffd\u0005\ufffd@\ufffd&quot;
</code></pre>

<p>和正常的sha1的结果来比较一下：</p>
<pre><code class="bash">Python 2.7.16 (default, Sep  2 2019, 11:59:44)
[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.46.4)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; &quot;\u000e\t\u001d\ufffd\u0012\ufffd.\ufffd\ufffd\ufffd?-\ufffdKC\ufffd\u0005\ufffd@\ufffd&quot;
'\\u000e\t\\u001d\\ufffd\\u0012\\ufffd.\\ufffd\\ufffd\\ufffd?-\\ufffdKC\\ufffd\\u0005\\ufffd@\\ufffd'
&gt;&gt;&gt; from hashlib import *
&gt;&gt;&gt; sha1('172.17.0.1|ls -l').digest()
'\x0e\t\x1d\xbd\x12\x90.\xca\xf0\xd9?-\x98KC\xeb\x05\xa1@\xd1'
</code></pre>

<p>由于 go 的 json 编码，很多不可见字符都被转为了 <code>U+fffd</code>，丢失了很多信息。</p>
<p>再经过 php 接口的接收，我们来看一下结果：</p>
<pre><code class="php">$d = json_decode(file_get_contents('php://input'), JSON_THROW_ON_ERROR);
var_dump(file_get_contents('php://input'));
var_dump($d);
var_dump(bin2hex($d));
</code></pre>

<p>结果：</p>
<pre><code>string(89) &quot;&quot;\u000e\t\u001d\ufffd\u0012\ufffd.\ufffd\ufffd\ufffd?-\ufffdKC\ufffd\u0005\ufffd@\ufffd&quot;
&quot;
string(38) &quot;   ��.���?-�KC��@�&quot;
string(76) &quot;0e091defbfbd12efbfbd2eefbfbdefbfbdefbfbd3f2defbfbd4b43efbfbd05efbfbd40efbfbd&quot;
&quot;K4FEmxz4yuTsjDAbRZQmHJ+MBiCSGaOnpZTLbThXpCkDYe3siAIPfihX6ppjN2Tz6XqOr4tF\/u1\/+ccfhj8NNLIL+2hknyDXbosmMBV8mEGYsMqQHAE0f+3OhDWlzN5RnteSMYNZbTipFErB8ZOWCiXmynWxsqJhyaN9J6\/\/h6I=&quot;
oops, hsm is jsonless?

</code></pre>

<p><code>U+fffd</code>变成了<code>\xef\xbf\xbd</code>。所以由于 go 的 json 编码问题，丢失了很多信息，造成了 md5 前的数据有很多相同字符。当时做题时往下并没有细想，得到 n 后总是想构造出任意命令的签名，也很疑惑如果构造出岂不是这种签名就不安全了？其实是无法得到的。</p>
<p>正解是 go 的这种问题 ，为碰撞创造了条件。我们可以碰撞出在这种编码情况下与 <code>ls -l</code>有相同结果的<code>cat *</code> 此类命令。但是问题是我们需要非常大量 ip 来提供碰撞的数据。</p>
<p>可以发现，go 取 ip 的时候，是先用<code>net.ParseIP</code>解析了 ip，我们在 ip 每个数字前面加 0 ，解析后还是原来的 ip 结果，每个数字最多添加 256 个 0，四个数字就已经产生了 <code>2^32</code>种不同的组合，足以碰撞出 <code>ls -l</code>与 <code>cat *</code>之间的冲突。</p>
<p>官方题解的 c++ 碰撞脚本我本地编译的有点问题，加了一些引入的头文件：</p>
<pre><code class="c++">// g++ -std=c++17 -march=native -O3 -lcrypto -lpthread gewalt.cpp -o gewalt

#include &lt;cassert&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;random&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
#include &lt;mutex&gt;
#include &lt;array&gt;
#include &lt;openssl/sha.h&gt;

const unsigned num_threads = std::thread::hardware_concurrency();



static std::string hash(std::string const&amp; s)
{
    SHA_CTX ctx;
    if (!SHA1_Init(&amp;ctx)) throw;
    if (!SHA1_Update(&amp;ctx, s.data(), s.length())) throw;
    std::string d(SHA_DIGEST_LENGTH, 0);
    if (!SHA1_Final((uint8_t *) &amp;d[0], &amp;ctx)) throw;
    return d;
}

static std::u32string kapot(std::string const&amp; s)
{
    std::u32string r(s.size(), 0);
    size_t o = 0;

    for (size_t i = 0; i &lt; s.length(); ) {

        auto T = [](uint8_t c) {
            return (c &lt; 0x80)         ? 1   /* ASCII */
                 : (c &amp; 0xc0) == 0x80 ? 0   /* continuation */
                 : (c &amp; 0xe0) == 0xc0 ? 2   /* 2-byte chunk */
                 : (c &amp; 0xf0) == 0xe0 ? 3   /* 3-byte chunk */
                 : (c &amp; 0xf8) == 0xf0 ? 4   /* 4-byte chunk */
                 : -1;
        };

        uint32_t c = s[i++];
        auto cont = [&amp;]() { c = (c &lt;&lt; 6) | (s[i++] &amp; 0x3f); };

        switch (T(c)) {

        case -1:
        case  0:
        invalid: c = 0xfffd; /* fall through */

        case  1:
        valid:   r[o++] = c; break;

        case  2:
                 if (c &amp;= 0x1f, i+0 &gt;= s.size() || T(s[i+0]))
                     goto invalid;
                 goto one;

        case  3:
                 if (c &amp;= 0x1f, i+1 &gt;= s.size() || T(s[i+0]) || T(s[i+1]))
                     goto invalid;
                 goto two;

        case  4:
                 if (c &amp;= 0x1f, i+2 &gt;= s.size() || T(s[i+0]) || T(s[i+1]) || T(s[i+2]))
                     goto invalid;
                 cont();
        two:     cont();
        one:     cont();
                 goto valid;

        }

    }

    r.resize(o);

    return r;
}

std::atomic&lt;uint64_t&gt; hcount = 0, kcount = 0;
typedef std::unordered_map&lt;std::u32string, std::string&gt; tab_t;
tab_t tab0, tab1;
std::mutex mtx;

std::array&lt;uint8_t,4&gt; ip;
std::string cmd0, cmd1;

class stuffer_t
{
    private:
        std::array&lt;size_t,4&gt; cnts;
        size_t step;
        std::string cmd;
    public:
        stuffer_t(size_t t, size_t s, std::string c) : cnts{t}, step(s), cmd(c) {}
        std::string operator()()
        {
            //XXX this is by far not the most efficient way of doing this, but yeah
            if (++cnts[3] &gt;= cnts[0]) {
                cnts[3] = 0;
                if (++cnts[2] &gt;= cnts[0]) {
                    cnts[2] = 0;
                    if (++cnts[1] &gt;= cnts[0]) {
                        cnts[1] = 0;
                        cnts[0] += step;
                    }
                }
            }
            std::stringstream o;
            for (size_t i = 0; i &lt; 4; ++i)
                o &lt;&lt; (i ? &quot;.&quot; : &quot;&quot;)
                  &lt;&lt; std::string(cnts[i], '0')
                  &lt;&lt; (unsigned) ip[i];
            o &lt;&lt; &quot;|&quot; &lt;&lt; cmd;
            return o.str();
        }
};

void go(size_t tid)
{
    //XXX tid stuff is a hack, but YOLO

    bool one = tid &amp; 1;

    stuffer_t next(tid &gt;&gt; 1, (num_threads + 1) &gt;&gt; 1, one ? cmd1 : cmd0);

    tab_t&amp; mytab = one ? tab1 : tab0;
    tab_t&amp; thtab = one ? tab0 : tab1;

    uint64_t myhcount = 0, mykcount = 0;

    while (1) {

        std::string r = next();

        {

            ++myhcount;

            auto h = hash(r);
            if ((h.size()+3)/4 &lt; (size_t) std::count_if(h.begin(), h.end(),
                                            [](unsigned char c) { return c &lt; 0x80; }))
                continue;

            ++mykcount;

            auto k = kapot(h);
            if (k.size() &gt; 3 + (size_t) std::count(k.begin(), k.end(), 0xfffd))
                continue;

            std::lock_guard&lt;std::mutex&gt; lck(mtx);

            hcount += myhcount, myhcount = 0;
            kcount += mykcount, mykcount = 0;

            if (thtab.find(k) != thtab.end()) {

                mytab[k] = r;

                std::cerr &lt;&lt; &quot;\r\x1b[K&quot;
                          &lt;&lt; &quot;\x1b[32m&quot;;
                std::cout &lt;&lt; tab0[k] &lt;&lt; std::endl
                          &lt;&lt; tab1[k] &lt;&lt; std::endl;
                std::cerr &lt;&lt; &quot;\x1b[0m&quot;;

                std::cerr &lt;&lt; std::hex;
                bool first = true;
                for (uint32_t c: k)
                    std::cerr &lt;&lt; (first ? first = false, &quot;&quot; : &quot; &quot;) &lt;&lt; c;
                std::cerr &lt;&lt; std::endl;

                std::cerr &lt;&lt; std::dec &lt;&lt; &quot;hash count:  \x1b[35m&quot; &lt;&lt; hcount &lt;&lt; &quot;\x1b[0m&quot;;
                {
                    std::stringstream s;
                    s &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; log(hcount|1)/log(2);
                    std::cerr &lt;&lt; &quot; (2^\x1b[35m&quot; &lt;&lt; std::setw(5) &lt;&lt; s.str() &lt;&lt; &quot;\x1b[0m&quot; &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
                }
                std::cerr &lt;&lt; &quot;kapot count: &quot; &lt;&lt; &quot;\x1b[35m&quot; &lt;&lt; kcount &lt;&lt; &quot;\x1b[0m&quot;;
                {
                    std::stringstream s;
                    s &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; log(kcount|1)/log(2);
                    std::cerr &lt;&lt; &quot; (2^\x1b[35m&quot; &lt;&lt; std::setw(5) &lt;&lt; s.str() &lt;&lt; &quot;\x1b[0m)&quot; &lt;&lt; std::endl;
                }
                std::cerr &lt;&lt; &quot;table sizes: \x1b[35m&quot;
                          &lt;&lt; tab0.size() &lt;&lt; &quot;\x1b[0m \x1b[35m&quot;
                          &lt;&lt; tab1.size() &lt;&lt; &quot;\x1b[0m&quot; &lt;&lt; std::endl;

                exit(0);

            }

            if (mytab.size() &lt; (1 &lt;&lt; 20))
                mytab[k] = r;

        }

        hcount += myhcount;
        kcount += mykcount;

    }
}

void status()
{
    while (1) {

        {
            std::lock_guard&lt;std::mutex&gt; lck(mtx);

            std::cerr &lt;&lt; &quot;\r\x1b[K&quot;;
            std::cerr &lt;&lt; &quot;hash count: \x1b[35m&quot; &lt;&lt; std::setw(12) &lt;&lt; hcount &lt;&lt; &quot;\x1b[0m &quot;;
            {
                std::stringstream s;
                s &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; log(hcount|1)/log(2);
                std::cerr &lt;&lt; &quot;(2^\x1b[35m&quot; &lt;&lt; std::setw(5) &lt;&lt; s.str() &lt;&lt; &quot;\x1b[0m) | &quot;;
            }
            std::cerr &lt;&lt; &quot;kapot count: \x1b[35m&quot; &lt;&lt; std::setw(12) &lt;&lt; kcount &lt;&lt; &quot;\x1b[0m &quot;;
            {
                std::stringstream s;
                s &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; log(kcount|1)/log(2);
                std::cerr &lt;&lt; &quot;(2^\x1b[35m&quot; &lt;&lt; std::setw(5) &lt;&lt; s.str() &lt;&lt; &quot;\x1b[0m) | &quot;;
            }
            std::cerr &lt;&lt; &quot;tables: \x1b[35m&quot;
                      &lt;&lt; std::setw(9) &lt;&lt; tab0.size() &lt;&lt; &quot; &quot;
                      &lt;&lt; std::setw(9) &lt;&lt; tab1.size() &lt;&lt; &quot;\x1b[0m &quot;
                      &lt;&lt; std::flush;
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

int main(int argc, char **argv)
{

    if (argc &lt; 2) {
        std::cerr &lt;&lt; &quot;\x1b[31mneed IPv4 in argv[1]\x1b[0m&quot; &lt;&lt; std::endl;
        exit(1);
    }
    {
        std::stringstream ss(argv[1]);
        for (auto&amp; v: ip) {
            std::string s;
            std::getline(ss, s, '.');
            int n = std::atoi(s.c_str());
            if (n &lt; std::numeric_limits&lt;uint8_t&gt;::min() || n &gt; std::numeric_limits&lt;uint8_t&gt;::max())
                goto bad_ip;
            v = n;
        }
        if (!ss) {
bad_ip:
            std::cerr &lt;&lt; &quot;\x1b[31mbad IPv4 given?\x1b[0m&quot; &lt;&lt; std::endl;
            exit(2);
        }
    }


    if (argc &lt; 4) {
        std::cerr &lt;&lt; &quot;\x1b[31mneed commands in argv[2] and argv[3]\x1b[0m&quot; &lt;&lt; std::endl;
        exit(2);
    }
    cmd0 = argv[2];
    cmd1 = argv[3];


    std::thread status_thread(status);
    std::vector&lt;std::thread&gt; ts;
    for (unsigned i = 0; i &lt; num_threads; ++i)
        ts.push_back(std::thread(go, i));
    for (auto&amp; t: ts)
        t.join();

}


</code></pre>

<p>编译可能会找不到 <code>lcrypto</code>，编译命令加上 lcrypto 路径（我本地是 /usr/local/opt/openssl/lib）</p>
<pre><code class="bash">g++ -std=c++17 -march=native -O3 -lcrypto -lpthread gewalt.cpp -o gewalt -L/usr/local/opt/openssl/lib
</code></pre>

<p>与 go 交互的脚本：</p>
<pre><code class="python">#!/usr/bin/env python3
import sys, requests, subprocess

benign_cmd = 'ls -l'
exploit_cmd = 'cat *'

ip, port = sys.argv[1], sys.argv[2]
url = 'http://{}:{}'.format(ip, port)

my_ip = requests.get(url + '/ip').text
print('[+] IP: ' + my_ip)

o = subprocess.check_output(['./gewalt', my_ip, benign_cmd, exploit_cmd])
print('[+] gewalt:' + o.decode())

payload = {}
for l in o.decode().splitlines():
    ip, cmd = l.split('|')
    payload['benign' if cmd == benign_cmd else 'pwn'] = ip, cmd

print(payload)

sig  = requests.post(url + '/sign', data={'ip': payload['benign'][0], 'cmd': payload['benign'][1]}).text
print('[+] sig: ' + sig)

r = requests.post(url + '/exec', data={'signature': sig[:172] + payload['pwn'][0]  + '|' + payload['pwn'][1]})
print(r.text)
</code></pre>

<pre><code class="bash"> ⚙  SaV-ls-l-aaS  python solve.py 127.0.0.1 60601
[+] IP: 172.17.0.1
fffd fffd fffd fffd fffd fffd 55 fffd fffd fffd fffd c fffd fffd fffd fffd fffd fffd fffd fffd
hash count:  168104875 (2^27.32)
kapot count: 3477222 (2^21.73)
table sizes: 8745 8856
[+] gewalt:00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001|ls -l
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.17.000000000000000000000000.0000000000000000000000000000000000000001|cat *

{'pwn': (u'00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.17.000000000000000000000000.0000000000000000000000000000000000000001', u'cat *'), 'benign': (u'00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', u'ls -l')}
[+] sig: ODxSukwtu4rHICBpzT23WGD7DCJNawhA0DUN/tcyv1AgwNmS8OPUnO5FnBBDgiaVx5OTYd4OjH8LVbKiXUBUBuFx1OHDgKBKG5umkKMLt+350SlgMWY5qWny9tPIU3I+X0A9FcADCBCi6f0PkXfc0CSCZXuFu9rAKnVGsbmaUwY=00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000172.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000017.000000000000000000000000000000000000000000000000000000000000000000000000000000000.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001|ls -l
hxp{FLAG}
</code></pre>

<p>参考：</p>
<ul>
<li>https://ctftime.org/writeup/17966</li>
</ul>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js" defer></script>
      <script src="https://cdnjs.loli.net/ajax/libs/pangu/3.3.0/pangu.min.js" defer></script>
      <script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
      <script src="../../../search/main.js" defer></script>

</body>
</html>
